<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.thebetterkong.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="为了提高自己算法能力，从今天起，这篇 Blog 持续更新，预计在 35 天后完成所有题目的一刷，立下 flag 保证每日更新两题！主要用 Java 完成，偶尔为了练习 Python 也会穿插一些 Python 算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指 offer 67题">
<meta property="og:url" content="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/index.html">
<meta property="og:site_name" content="TheBetterKong">
<meta property="og:description" content="为了提高自己算法能力，从今天起，这篇 Blog 持续更新，预计在 35 天后完成所有题目的一刷，立下 flag 保证每日更新两题！主要用 Java 完成，偶尔为了练习 Python 也会穿插一些 Python 算法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/header.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/search-two-dimensional-array.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/Spaces-Replace.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/Rebuild-Binary-Tree.jpeg">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/Print-matrix-clockwise.jpeg">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/UglyNumber.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/TwoNumberSum.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/ProductArray.png">
<meta property="og:image" content="http://www.thebetterkong.cn/2020/04/05/_images/Algorithm/Finger-offer67/BinaryTreeNextNode.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/Cutshengzi.png">
<meta property="article:published_time" content="2020-04-05T06:58:23.000Z">
<meta property="article:modified_time" content="2020-08-14T09:28:51.176Z">
<meta property="article:author" content="TheBetterKong">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.thebetterkong.cn/blog/Finger-offer67/header.png">

<link rel="canonical" href="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>剑指 offer 67题 | TheBetterKong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TheBetterKong" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TheBetterKong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">自律即自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheBetterKong">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheBetterKong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剑指 offer 67题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-05 14:58:23" itemprop="dateCreated datePublished" datetime="2020-04-05T14:58:23+08:00">2020-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-14 17:28:51" itemprop="dateModified" datetime="2020-08-14T17:28:51+08:00">2020-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStructure-Algorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructure & Algorithm</span></a>
                </span>
            </span>

          
            <span id="/2020/04/05/DataStructure-Algorithm/Finger-offer67/" class="post-meta-item leancloud_visitors" data-flag-title="剑指 offer 67题" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/05/DataStructure-Algorithm/Finger-offer67/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/05/DataStructure-Algorithm/Finger-offer67/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div align="center"> <img src="http://img.thebetterkong.cn/blog/Finger-offer67/header.png" width="100%" alt="header.png" /> </div>     

<p>为了提高自己算法能力，从今天起，这篇 Blog 持续更新，预计在 35 天后完成所有题目的一刷，立下 flag 保证每日更新两题！主要用 <code>Java</code> 完成，偶尔为了练习 <code>Python</code> 也会穿插一些 <code>Python</code> 算法。</p>
<a id="more"></a> 
<hr>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code> <code>数组</code></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在目标二维数组中，找目标数。很显然，这是一个典型的寻找问题，题目给出了数组元素的一个递增关系，那么很明显，我们就不能直接把整个数组都遍历一遍，那样实在是太笨了。     </p>
<p>所以，现在问题的关键就是在于：制定一种遍历策略，保证当目标 <code>target &gt; a[i][j]</code> 或 <code>target &lt; a[i][j]</code> 时，算法只有一种遍历方向，并且不会出现漏找的情况。   </p>
<p>下面，研究一下这个二维数组：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/search-two-dimensional-array.png" alt="二维数组">      </p>
<blockquote>
<p>不难发现，任意画一条从上到下再从左往右的折线箭头（①、②、③），该箭头所穿过的数组元素都满足递增的顺序，而数组便是由许许多多这种所谓的箭头构成。<br>数组左上角元素最小，右下角元素最大；   </p>
</blockquote>
<p>基于上述发现，一个大致的思路就已经出来了：</p>
<ul>
<li>初始时，选择数组最左下角的元素参与比较</li>
<li>若 <code>target &gt; a[i][j]</code>，下一个选取 <code>a[i][j+1]</code> 与 <code>target</code> 比较；</li>
<li>若 <code>target &lt; a[i][j]</code>，下一个选取 <code>a[i+1][j]</code> 与 <code>target</code> 比较；</li>
</ul>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>Java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[row][col])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">                    col++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    row--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于<code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row = len(array)<span class="number">-1</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span> <span class="keyword">and</span> col &lt; len(array[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                row = row - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col = col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价"><a href="#算法评价" class="headerlink" title="算法评价"></a>算法评价</h2><ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>最坏情况下的时间复杂度： <code>2n</code></li>
</ul>
<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个函数，将一个字符串中的每个 <code>空格</code> 替换成 <code>“%20”</code>。<br>例如：当字符串为： <code>We Are Happy.</code> ，则经过替换之后的字符串为： <code>We%20Are%20Happy.</code>     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点：<code>字符串</code></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，如果不考虑额外的空间开销，最简单的思路就是：</p>
<ol>
<li>开辟一个新的字符串数组，然后对原字符串数组从头到尾进行遍历；</li>
<li>字符如果不是空格就复制到新字符串中，如果是空格就不复制，并且在新字符串中插入%20；</li>
<li>循环进行，直至遍历完原字符串；</li>
</ol>
<p>那问题就来了：<code>『能不能在不开辟新的内存空间的情况下，完成此操作呢？』</code>   </p>
<ul>
<li>当然可以，我们可以直接遍历字符串，假设在索引 <code>i</code> 处遇到 <code>空格</code>，就将位于 <code>i</code> 位置后的所有字符后移两位，然后将 <code>%</code>、<code>2</code>、<code>0</code>，插入到 <code>i</code>、<code>i+1</code>、<code>i+2</code> 这三个位置即可，然后，再从第 <code>i+2</code> 出开始遍历，直至字符串遍历完毕。   </li>
<li>因为后移操作也需要进行循环遍历，所以此算法的时间复杂度无疑是很高的，为 <code>O(n^2)</code>。    </li>
</ul>
<p>那还有没有更加高效的方法，让时间复杂度变为 <code>O(n)</code> 呢？   </p>
<ul>
<li>上面的思路，带来过高的时间开销的原因是：<code>每次遍历到空格时，都需要再次循环移动字符串字符</code>。如果能解决这个问题，我们的时间复杂度就能变成 <code>O(n)</code> 了。</li>
<li>转换一下思考方向：如果我们能知道，各个字符需要往后移动的位数，那么，我们就可以通过一次从后往前的循环遍历，直接将所有字符移动到位了！</li>
</ul>
<p>为了实现上面的想法，我们将替换前后的字符串拿出来对比一下：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Spaces-Replace.png" alt="替换空格">       </p>
<blockquote>
<p><code>Happy</code> 整体向后移动四个单位；<code>Are</code> 整体向后移动两个单位；<code>We</code> 没变；<br>也就是说，每遇到一个空格，后面的字符就需要多移动两个单位；<br>关键的问题也就是：需要我们确定各个字符前的空格总数。</p>
</blockquote>
<p>规律找到了，我们算法的思路也就知道了：</p>
<ul>
<li>第一次遍历，确定字符串中的空格数量，并用 <code>count</code> 记录；</li>
<li>第二次 『<strong>从后往前</strong>』 遍历：<ul>
<li>不是空格就往后移动 <code>2 x count</code> 个单位；</li>
<li>是空格，<code>count - 1</code>，并且将 <code>%</code>、<code>2</code>、<code>0</code>，插入到当前 <code>i+2*count-2</code>、<code>i+2*count-1</code>、<code>i+2*count</code> 这三个位置；然后继续从 <code>i-1</code> 处遍历；</li>
<li>直至整个字符遍历完毕。（Ps：结束条件可改为 『count==0』 ，这样可以进一步提高性能。</li>
</ul>
</li>
</ul>
<h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>Java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldlength = str.length(); </span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(newlength);<span class="comment">//扩大str的长度,防止下标越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = oldlength-<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; count&gt;<span class="number">0</span>;i--)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count, <span class="string">'0'</span>);</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count-<span class="number">1</span>, <span class="string">'2'</span>);</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count-<span class="number">2</span>, <span class="string">'%'</span>);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count, str.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>Python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        changed = s.replace(<span class="string">" "</span>,<span class="string">"%20"</span>)</span><br><span class="line">        <span class="keyword">return</span> changed</span><br></pre></td></tr></table></figure></p>
<p>语法知识点：</p>
<ul>
<li><code>python</code>：字符串有replace方法，直接替换即可；</li>
<li><code>java</code>：<ul>
<li>也有 <code>replace</code>、<code>replaceALL</code> 等方法，但是这里为了表达算法思路，就没有直接使用；</li>
<li>字符串按位置索引需要用：<code>CharAt</code></li>
<li>字符串按位置赋值需要用：<code>setCharAt</code></li>
<li>字符串取出某字符位置：<code>indexOf</code></li>
<li>要注意，字符串长度 <code>setLength</code>，防止下标越界</li>
</ul>
</li>
</ul>
<h2 id="算法评价-1"><a href="#算法评价-1" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度： <code>O(n)</code></p>
<hr>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个 <code>ArrayList</code>。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题，第一反应就是利用 <code>栈</code> 来实现，直接将其顺序入栈，然后出栈，就能很轻松的实现 <code>反顺序</code>，但是这种方法带来的问题就是：栈的引入，带来了额外的空间开销；     </p>
<p>这个时候，我就想：直接将链表元素存入数组，然后将数组进行一下反转。<br>数组反转时，大致有三种思路：</p>
<ol>
<li>使用工具类： <code>Collections.reverse(ArrayList)</code> 将数组进行反转;</li>
<li>新建一个 <code>arrayList</code>，新数组的头等于原数组的尾；<ul>
<li>这种方法和基于堆栈的方法比较起来，没有什么优势，而且个人认为此更加麻烦；</li>
</ul>
</li>
</ol>
<p>上面使用工具类的方法，相对来说最为简单，但是问题就是，这个工具类的内部实现是怎样的？它在内部实现的时候是否也像其他方法一样，开辟了新的内存空间，带着这个问题，我查看了它的内部实现源代码『<code>摘自于jdk 1.8.0_181</code>』，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverses the order of the elements in the specified list.&lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method runs in linear time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  list the list whose elements are to be reversed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the specified list or</span></span><br><span class="line"><span class="comment">     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">                swap(list, i, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// instead of using a raw type here, it's possible to capture</span></span><br><span class="line">            <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">            <span class="comment">// private method</span></span><br><span class="line">            ListIterator fwd = list.listIterator();</span><br><span class="line">            ListIterator rev = list.listIterator(size);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">                Object tmp = fwd.next();</span><br><span class="line">                fwd.set(rev.previous());</span><br><span class="line">                rev.set(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Swaps the elements at the specified positions in the specified list.</span></span><br><span class="line"><span class="comment">     * (If the specified positions are equal, invoking this method leaves</span></span><br><span class="line"><span class="comment">     * the list unchanged.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list The list in which to swap elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index of one element to be swapped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j the index of the other element to be swapped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException if either &lt;tt&gt;i&lt;/tt&gt; or &lt;tt&gt;j&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is out of range (i &amp;lt; 0 || i &amp;gt;= list.size()</span></span><br><span class="line"><span class="comment">     *         || j &amp;lt; 0 || j &amp;gt;= list.size()).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instead of using a raw type here, it's possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="keyword">final</span> List l = list;</span><br><span class="line">        l.set(i, l.set(j, l.get(i)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，它分为了两种情况来实现：    </p>
<ol>
<li>『集合大小小于 REVERSE_THRESHOLD』或者『支持随机访问』：直接使用 <code>swap函数</code> 实现，注意：<mark>这里 <code>swap函数</code> 的具体实现也非常值得我们深挖；</mark></li>
<li>采用两个迭代器，一个从前往后，一个从后往前，实现数组元素的交换</li>
</ol>
</blockquote>
<p>所以可以看到，使用 <code>Collections.reverse(ArrayList)</code> 方法的这个思路更加简单，而且，在空间效率上也不会比『开辟新栈的方法』差。所以，这里我更加推荐这种方法实现。</p>
<h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：  </p>
<ol>
<li><p>堆栈实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Collections.reverse(ArrayList)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>基于 <code>python</code>：   </p>
<ul>
<li>python可直接用insert方法实现<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        array = []</span><br><span class="line">        node = listNode</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            array.insert(<span class="number">0</span>, node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="算法评价-2"><a href="#算法评价-2" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度为：<code>O(n)</code><br>空间复杂度为：<code>3n</code>，此参数仅供参考，还不够准确</p>
<hr>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。    </p>
<p>例如：输入前序遍历序列 $\{1,2,4,7,3,5,6,8\}$ 和中序遍历序列 $\{4,7,2,1,5,3,8,6\}$，则重建二叉树并返回。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一道十分基础的和 <code>树</code> 有关的题，在学习的时候，我们就知道树的遍历一般都是用递归实现的，本题自然也不例外。     </p>
<p>其实只需要将平常解这种题的过程用算法描述出来即可。<br>![例子][<img src="http://img.thebetterkong.cn/blog/Finger-offer67/Rebuild-Binary-Tree.jpeg" alt="mark">]</p>
<h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存数组长度，也是递归调用的出口</span></span><br><span class="line">        <span class="keyword">int</span> length = pre.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在中序遍历中，找根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重构左右子树的前序和中序遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> [] left_pre = <span class="keyword">new</span> <span class="keyword">int</span> [mid];</span><br><span class="line">        <span class="keyword">int</span> [] left_in = <span class="keyword">new</span> <span class="keyword">int</span> [mid];</span><br><span class="line">        <span class="keyword">int</span> [] right_pre = <span class="keyword">new</span> <span class="keyword">int</span> [length-<span class="number">1</span>-mid];</span><br><span class="line">        <span class="keyword">int</span> [] right_in = <span class="keyword">new</span> <span class="keyword">int</span> [length-<span class="number">1</span>-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mid;i++)&#123;</span><br><span class="line">            left_pre[i] = pre[i+<span class="number">1</span>];</span><br><span class="line">            left_in[i] = in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            right_pre[i-mid-<span class="number">1</span>] = pre[i];</span><br><span class="line">            right_in[i-mid-<span class="number">1</span>] = in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        head.left = reConstructBinaryTree(left_pre,left_in);</span><br><span class="line">        head.right = reConstructBinaryTree(right_pre,right_in);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        mid = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:mid+<span class="number">1</span>], tin[:mid])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[mid + <span class="number">1</span>:], tin[mid + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-3"><a href="#算法评价-3" class="headerlink" title="算法评价"></a>算法评价</h2><p>基于递归的算法，不管是在时间复杂度还是空间复杂度上都是很高的；     </p>
<p>后续，二刷时，考虑下非递归实现。目前感觉，即使是采用非递归算法，其时间复杂度和空间复杂度也应该是比较高的。</p>
<hr>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> 和 <code>栈</code></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先得认清 <code>栈</code> 和 <code>队列</code> 的特点：</p>
<ul>
<li>栈：先进后出</li>
<li>队列：先进先出</li>
</ul>
<p>利用栈实现队列，需要两个栈（一个负责入队，一个负责出队）：</p>
<ul>
<li>入队操作：将元素压入栈 1</li>
<li>出队操作：将栈 1 的元素出栈并依次压入栈 2，这样栈 1 的栈底也就成了栈 2 的栈顶，再对栈 2 出栈即可。</li>
</ul>
<p>Note：出队的逻辑，在将栈 1 的元素倒入栈 2 之前，一定要先保证栈 2 空。</p>
<h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>『数组的旋转』：把一个数组最开始的若干个元素搬到数组的末尾；    </p>
<p>现要求：输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。   </p>
<p>例如：数组 $\{3,4,5,1,2\}$ 为 $\{1,2,3,4,5\}$ 的一个旋转，该数组的最小值为 1。    </p>
<p>注意：给出的所有元素都大于 0，若数组大小为 0，请返回 0。    </p>
<p>时间限制：C/C++ 3秒，其他语言6秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code></p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一思路：直接从头往后遍历数组，如果出现 <code>array[i]&gt;array[i+1]</code>，那么 <code>array[i+1]</code> 一定就是最小元素，如果一直遍历结束也没出现这种结果，那么最小元素就是 <code>array[0]</code>；   </p>
<ul>
<li>该思路，时间复杂性为 <code>O(n)</code>；最坏情况下，需要将整个数组遍历一次，效率比较低。所以，下面探讨采用 <code>二分查找</code> 的方法来实现该算法，将时间复杂度降为：$O(log_2n)$</li>
</ul>
<p>二分查找思路：类似普通二分法，但是需要注意的是：当 <code>mid==high</code> 时，例如 $(1,1,1,1,1,1)$，此时是无法判断最小元素是在 $[low,mid]$ 还是 $[mid,high]$ 区间的，此时需要再从头至尾逐个查找，但发生这种情况概率还是较低的。对算法效率影响不大。</p>
<h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>思路一：    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路二：   </p>
<p>基于<code>java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = lenth-<span class="number">1</span>,mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high -<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;<span class="comment">//array[mid]可能就是最小元素，比较时，不能直接将其剔除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        lenth = len(rotateArray)</span><br><span class="line">        high = lenth - <span class="number">1</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        mid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt; rotateArray[high]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] == rotateArray[high]:</span><br><span class="line">                high = high - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[low]</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-4"><a href="#算法评价-4" class="headerlink" title="算法评价"></a>算法评价</h2><p>见解题思路部分；</p>
<hr>
<h1 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。（n&lt;=39）</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p><code>斐波那契数列</code>：$0、1、1、2、3、5、8、13、21、34…$     </p>
<p>从斐波那契数列的定义来看，我们就知道容易用递归实现，其递归算法：</p>
<ul>
<li>当 $n&gt;2$ 时：$Fibonacci（n）=Fibonacci（n-1）+ Fibonacci（n-2）$</li>
</ul>
<p>但是递归对程序员来说，修养要求极高，容易出现：无穷递归、栈溢出等各种问题，安全性也比较难把握，所以我们应该尽量避免递归的使用。<br>有关递归的效率问题，具体参考：『<a href="http://www.nowamagic.net/librarys/veda/detail/2321" target="_blank" rel="noopener">漫谈递归：递归的效率问题</a>』     </p>
<p>接下来的算法主要采用循环实现；</p>
<h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p><a id="FibonacciSequence"></a></p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            c=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = []</span><br><span class="line">            c.append(<span class="number">1</span>)</span><br><span class="line">            c.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">                c.append(c[i<span class="number">-1</span>]+c[i<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> c[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="跳台阶问题"><a href="#跳台阶问题" class="headerlink" title="跳台阶问题"></a>跳台阶问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题需要转换思路，直接分析比较麻烦，尝试分析其数列关系：</p>
<ul>
<li>要想知道跳到 n 级台阶多少种跳法，那么包含两种情况：① 从 n-1 级台阶跳一级到 n 级；② 从 n-2 级台阶跳 2 级到 n 级台阶。这样，递归关系就出来了；</li>
</ul>
<p>得到递归关系：</p>
<ul>
<li>$f（n）=f（n−1）+f（n−2）$，说白了，也就是斐波拉契数列；</li>
</ul>
<h2 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h2><p>参考：『<a href="#FibonacciSequence">斐波拉契数列</a>』</p>
<hr>
<h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>贪心</code></p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>青蛙可以跳任意级数的台阶，所以类似上一题那种找递归关系的办法在这里肯定是行不通了。那么，既然局部分析已经失效，那就再换个思路，从总体上分析：     </p>
<p>青蛙从初始 0 处开始，任意跳，最终落到位置 n 处。这时候，建立一个模型：</p>
<ul>
<li>首先，将步长定为 1，再将青蛙每次的落脚点作为集合中的一个元素，这样就能得到 <code>集合 a[n]</code>；</li>
<li>然后，青蛙的步长为任意值，此时集合 $a[n]$ 中的 n 个元素都有 $0/1$ 两种取值（0：青蛙没在该位置停留；1：青蛙又在该位置停留）；</li>
<li>青蛙最终停在位置 n 处，那么 $a[n]=1$；</li>
</ul>
<p>有了这个模型后，问题就转换成：<code>集合 a[n]</code> 中的前 n-1 个元素一共有多少种不同的取值情况，答案也就是：$2^{n-1}$；</p>
<h2 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target;i++)&#123;</span><br><span class="line">            b=a*<span class="number">2</span>;</span><br><span class="line">            a=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">2</span>,number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 $2<em>1$ 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 $2</em>1$ 的小矩形无重叠地覆盖一个 $2*n$ 的大矩形，总共有多少种方法？    </p>
<p>比如：n=3 时，$2*3$ 的矩形块有3种覆盖方法：   </p>
<ul>
<li>三竖；</li>
<li>一竖两横；</li>
<li>两横一竖；</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样是一个找递推关系的题：    </p>
<ul>
<li>首先，假设我们已知：$2*n$ 的矩形有 $f(n)$ 种覆盖方式；</li>
<li>使用 $2*1$ 的矩形去填充，也就是需要找： $f(n)、f(n+1)、f(n+2)$ 这三者的关系；</li>
</ul>
<p>从 $f(n+1)$ 到 $f(n+2)$ 只有一种填充方式：    </p>
<ul>
<li>在原基础上竖着往后加入一个小矩形；    </li>
</ul>
<p>从 $f(n)$ 到 $f(n+2)$，且不经过 $f(n+1)$ 的结构，也只有一种填充方式：    </p>
<ul>
<li>在原基础上横着并入两个小矩形；</li>
</ul>
<p>于是，递推关系就是：$f(n+2)=f(n+1)+f(n)$，同样也是斐波拉契数列；</p>
<h2 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h2><p>参考：『<a href="#FibonacciSequence">斐波拉契数列</a>』，注意一下数列项的对于关系；</p>
<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code>、<code>补码反码原码</code></p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们都知道，求一个正整数二进制中 1 的个数很简单，只需要不断除 2，余 1 时，count+1 就可以了。但是本题主要难点就在于输入的整数可能为负，而负数在计算机中采用补码表示，其 1 的个数计算起来就比较麻烦，咋眼一看，很让人没有头绪。    </p>
<p>上面说到的，正整数处理方法的核心就在于移位：</p>
<ol>
<li>而负数的补码在右移时，最高位填 1，这就会影响我们计算 1 的结果。<ul>
<li>当然了，你也可以说我把移位的次数保留下来最后再减掉就好了，这种思路我也尝试过，真正实现起来比较复杂，有兴趣可以再试一下。</li>
</ul>
</li>
<li>既然补码右移麻烦，那就考虑左移。在最高上与 1 计数，然后不断左移。<ul>
<li>我们知道，一个 int 类型的变量在计算机里是 32 位，那么最高位为 1 的数应该就是：$-2^{31}$，这个数具体是多少，我是不会算了，真要实现就得调 math 里的 pow 方法，所以，我还是把这个思路放弃了。</li>
</ul>
</li>
</ol>
<p>好了，两种处理数的办法都行不通，看来对数本身进行处理是不太可能了，那就另辟蹊径，把用来进行与操作的 flag 进行移位：</p>
<ul>
<li>初始时，<code>flag = 1</code>（二进制表示：0000 0000 0000 0000 0000 0000 0000 0001）；</li>
<li><code>n &amp; flag</code>，就能知道 n 最低位是否为 1；</li>
<li>flag 左移 1 位，<code>flag=flag&lt;&lt;1</code>（二进制表示：0000 0000 0000 0000 0000 0000 0000 0010），再 <code>n &amp; flag</code>，就能知道 n 倒数第二位是否为 1；</li>
<li>循环下去，直至 flag 32 次左移后，1 溢出，<code>flag = 0</code>；</li>
<li>注意：<code>n &amp; flag</code> 是否需要 <code>count++</code> 的判别标准是 <code>(n &amp; flag)!=0</code>，原因仔细琢磨一下就知道了。</li>
</ul>
<h2 id="算法描述-10"><a href="#算法描述-10" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag)!=<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> bin(n).count(<span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><br>还可以更简单，表达：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        nbin = bin(n &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">        <span class="keyword">return</span> nbin.count(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-5"><a href="#算法评价-5" class="headerlink" title="算法评价"></a>算法评价</h2><p>上面的思路中，我们知道不管数字 n 中 1 的个数为多少，我们都需要循环 32 次，有时候会造成大量的浪费；    </p>
<p>发现了网上广为流传的一个更加巧妙的思路：   </p>
<ul>
<li>先一个简单的例子，整数 12 的二进制表示为：1100，将其减一变为 1011，将得到的结果和原数进行按位与，得到 1000。</li>
<li>这样就可以发现一个<mark>规律</mark>：把一个整数减去 1 之后再和原来的整数做按位与，得到的结果相当于是把整数的二进制表示中最右边的一个 1 变成 0 。</li>
</ul>
<p>按照这个规律进行遍历，则函数的循环次数为二进制中一的个数次。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!= <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的exponent 次方。<br>保证：base 和 exponent 不同时为 0；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数学</code></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>求浮点数的整数次方，无非就是要分情况讨论：</p>
<ol>
<li>base=0，exponent=0，抛出异常；<ol>
<li>base=0，exponent != 0，返回0；</li>
<li>base != 0：<ol>
<li>exponent为正，直接求$base^{exponent}$；</li>
<li>exponent为负，先求,$base^{-exponent}$，再求$\frac{1}{base^{-exponent}}$；</li>
<li>exponent=0，直接返回1；</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>特别关注一下这里的<mark>快速幂算法</mark>；</p>
<h2 id="算法描述-11"><a href="#算法描述-11" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//用来标记最后返回情况</span></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Invalid input!"</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//快速幂算法：</span></span><br><span class="line">            <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                flag = -<span class="number">1</span>;</span><br><span class="line">                exponent = -exponent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(exponent != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                    ans *= base;</span><br><span class="line">                base *= base;<span class="comment">// 翻倍</span></span><br><span class="line">                exponent&gt;&gt;=<span class="number">1</span>;<span class="comment">// 右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag&gt;=<span class="number">0</span>?ans:(<span class="number">1</span>/ans);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"Invalid input!"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">                flag = <span class="number">-1</span>;</span><br><span class="line">                exponent = -exponent;</span><br><span class="line">            <span class="keyword">while</span> exponent != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (exponent &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    ans *= base</span><br><span class="line">                base *= base</span><br><span class="line">                exponent&gt;&gt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans <span class="keyword">if</span> flag&gt;=<span class="number">0</span> <span class="keyword">else</span> (<span class="number">1</span>/ans)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="调整数组顺序使奇数位于偶数前"><a href="#调整数组顺序使奇数位于偶数前" class="headerlink" title="调整数组顺序使奇数位于偶数前"></a>调整数组顺序使奇数位于偶数前</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>典型的 <code>数组排序</code> 问题。    </p>
<p>第一种思路：新开辟一个数组，第一次遍历，把所有的奇数按顺序放入新数组；第二次遍历，把所有的偶数放入新数组。但是这样，带来了额外的空间开销，这在排序算法里是十分低效的，这里不再具体描述。    </p>
<p>第二种思路：利用常见的排序算法，插入排序、冒泡排序等，这里我选用冒泡排序；</p>
<h2 id="算法描述-12"><a href="#算法描述-12" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i]%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>]%<span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        odd = collections.deque()</span><br><span class="line">        x = len(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            <span class="keyword">if</span> array[x-i<span class="number">-1</span>]%<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                odd.appendleft(array[x-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> array[i]%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                odd.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> list(odd)</span><br></pre></td></tr></table></figure><br>主要是为了，学习 python 里，<code>collections.deque()</code>；</p>
<h2 id="算法评价-6"><a href="#算法评价-6" class="headerlink" title="算法评价"></a>算法评价</h2><p>上述，冒泡排序算法的时间复杂度为：$O(n^2)$    </p>
<p>但是对于上述冒泡排序算法，还可以进行进一步的改进：往第一层循环里插入旗标，一旦发现某次循环不再进行元素交换，就直接终止算法，这样，使该算法在最好情况下的时间复杂度变为：$O(n)$     </p>
<p>具体 <code>java</code> 算法描述：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray(<span class="keyword">int</span> [] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//旗标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i]%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>]%<span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> array;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我有一个疑问：从循环次数的角度上来看，算法在最好情况下的时间复杂度下降了一个级别。但是，从编译器的角度来看，新变量的引入、循环赋值、以及每次循环都得进行的条件判断，又带来新的开销，这在性能上会不会出现得不偿失的情况？</p>
<hr>
<h1 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p><a id="LastKthNode"></a></p>
<p>链表的特点是只能从头到尾进行遍历，而现在要求的是输出链表的倒数第 k 个结点，所以我们迫切需要知道的就是链表的 length 了；    </p>
<p>一个简单的思路自然就是，先遍历一遍链表并记录结点数，这样就知道了链表 length，下次再遍历链表至第 length-k+1 个结点即可。<br>这种方法，两次遍历链表，两次循环，每次循环带来的时间复杂度都是 $O(n)$；<br>那进一步改进，考虑将循环减为一次。     </p>
<p>结合上面的思路，将两次循环合并：在链表遍历时定义两个指针。</p>
<ul>
<li>指针 1 从头至尾遍历，也就相当于length；</li>
<li>指针 2 在指针 1 遍历到第 k 个节点时，再跟着一起遍历；</li>
<li>这样，在指针 1 遍历至链表末尾时，刚好指针 2 所指向的结点就是链表的倒数第 k 个结点了。</li>
</ul>
<h2 id="算法描述-13"><a href="#算法描述-13" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fir = <span class="keyword">null</span>;</span><br><span class="line">        ListNode las = <span class="keyword">null</span>;</span><br><span class="line">        fir = head;</span><br><span class="line">        las = head;</span><br><span class="line">        <span class="keyword">int</span> a=k;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fir!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fir = fir.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                las = las.next;</span><br><span class="line">            &#125;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> las;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p2=head</span><br><span class="line">        p1=head</span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> p2.next!=<span class="literal">None</span>:</span><br><span class="line">                p2=p2.next</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p2.next!=<span class="literal">None</span>:</span><br><span class="line">            p1=p1.next</span><br><span class="line">            p2=p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-7"><a href="#算法评价-7" class="headerlink" title="算法评价"></a>算法评价</h2><p>见解题思路部分；</p>
<hr>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题是链表里一个十分常见的操作，想要将链表反向，最重要的就是捋清各个指针的相互关系，循环实现每个结点的反转。具体的关系，直接参考代码，画图过一遍就能很清楚了。</p>
<h2 id="算法描述-14"><a href="#算法描述-14" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = head.next;</span><br><span class="line">            head.next = p1;</span><br><span class="line">            p1 = head;</span><br><span class="line">            head = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        p1 = <span class="literal">None</span></span><br><span class="line">        p2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            p2 = pHead.next</span><br><span class="line">            pHead.next = p1</span><br><span class="line">            p1 = pHead</span><br><span class="line">            pHead = p2</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-8"><a href="#算法评价-8" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度为：$O(n)$</p>
<hr>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题也是链表中十分常见的操作，我最开始想的是，合并的时候，直接把 List2 向List1 上合并，以此来节省再次开辟新链表的内存空间。<br>具体思路：先找到 List1 和 List2 的较小者，假设为 List1，然后循环遍历 List2，将 List2 的各个节点插入到 List1 中的合适位置。    </p>
<p>但是会存在一些问题：</p>
<ol>
<li>初始时，并不能确定 List1 和 List2 的大小关系，需要分情况讨论；</li>
<li>上述的想法中对 List2 的每个节点，都需要遍历 List1 来找合适位置，本身来说比较麻烦，而且算法在最坏情况下的时间复杂度$n*（n-1）$，太高。</li>
</ol>
<p>所以，我还是用最原始的方法，合并到一个新链表。以空间换时间。</p>
<h2 id="算法描述-15"><a href="#算法描述-15" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;<span class="comment">//合并链表的头指针</span></span><br><span class="line">        ListNode p = <span class="keyword">null</span>; <span class="comment">//合并链表过程中的中间指针</span></span><br><span class="line">        <span class="comment">//初始化合并链表的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            list = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        p = list;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                p.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">                p = p.next;<span class="comment">//p指针始终指向合并链表的链尾，向尾部插入节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//某一个链表合并完后，直接将另一个链表的剩余部分，链接到合并链表的链尾</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        Head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = Head</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &gt;= pHead2.val:</span><br><span class="line">                Head.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Head.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next       </span><br><span class="line">            Head = Head.next</span><br><span class="line">        <span class="keyword">if</span> pHead1:</span><br><span class="line">            Head.next = pHead1</span><br><span class="line">        <span class="keyword">elif</span> pHead2:</span><br><span class="line">            Head.next = pHead2</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure><br>下面是我参考的别人的代码，对比两个代码，思路基本相同，但是我认为，下面的更加巧妙，它的条件判断语句更少，可以好好领会一下。</p>
<h2 id="算法评价-9"><a href="#算法评价-9" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。<br>ps：我们约定空树不是任意一个树的子结构。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>二叉树</code></p>
<h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><p>又涉及到树的遍历，说实话，每次看到看到树相关的操作，莫名就有些抵触，因为太需要花脑细胞去分析递归关系了。<br>抵触归抵触，题目还得做。   </p>
<p>首先，弄清题目所谓的『子结构』:两个层次的含义，即要求每个结点的值相等，也要求树的结构相同；    </p>
<p>程序返回值，肯定就是 <code>false or true</code>，那就用一个标志 <code>flag</code> 表示。再然后就是，递归呗！关键问题：怎么递？分情况讨论；   </p>
<ol>
<li>比较两个树的根节点，若 <code>root1.val == root2.val</code>，再比较 <code>root1</code> 和 <code>root2</code> 的左右子树结构是否相同。<ul>
<li>这里就又有一个问题了，这里描述的操作和我们原函数不同，就需要再考虑编写一个递归函数：</li>
<li>递归比较：<code>root1.left.val == root2.left.val ?</code> 以及 <code>root1.right.val == root2.right.val ?</code>，只要有一次不等于就 <code>return false</code>；如果一直递归下去，tree1 先遍历完，<code>return false</code>，tree2 先遍历完，<code>return false</code>；</li>
</ul>
</li>
<li>若 <code>root1.val != root2.val</code>，接下来就递归的找：<code>root1</code> 的左子树是否包含 <code>root2</code> 以及 <code>root1</code> 的右子树是否包含 <code>root2</code>；</li>
</ol>
<p>思路捋清楚了，接下来，代码更加直观的描述；</p>
<h2 id="算法描述-16"><a href="#算法描述-16" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                flag = rootTree1EqualTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">rootTree1EqualTree2</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意下面这两个条件判断递归出口的顺序</span></span><br><span class="line">        <span class="comment">//特殊情况：有可能tree1和tree2同时遍历完毕，node1=node2=null，此时应该返回true；</span></span><br><span class="line">        <span class="comment">//因此要优先考虑node2；</span></span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1.val != node2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootTree1EqualTree2(node1.left,node2.left) &amp;&amp; rootTree1EqualTree2(node1.right,node2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_subtree</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(A.left,B.left) <span class="keyword">and</span> self.is_subtree(A.right, B.right)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>Ps：源二叉树的镜像：将二叉树的所有结点的左右子结点交换得到的二叉树；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>算得上是树里面十分常见的操作了，主要思路就是循环递归交换左右子树。    </p>
<p>以这题为例子，实现一下树里面一些操作的非递归实现，主要利用 <code>栈</code> 和 <code>队列</code>；</p>
<h2 id="算法描述-17"><a href="#算法描述-17" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：递归算法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//结点交换</span></span><br><span class="line">        TreeNode p = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = p;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>java</code>，非递归算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span> || p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = p.left;</span><br><span class="line">                p.left = p.right;</span><br><span class="line">                p.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root!=<span class="literal">None</span>:</span><br><span class="line">            root.left,root.right=root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字；<br>例如：</p>
<ul>
<li>如果输入如下 $4 \times 4$ 矩阵：<ul>
<li>$[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]$；</li>
</ul>
</li>
<li>则依次打印出数字： <ul>
<li>$1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10$。</li>
</ul>
</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题目，很明显就是画图找规律，既然如此，上图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Print-matrix-clockwise.jpeg" alt="顺时针打印矩阵"></p>
<p>规律：</p>
<ol>
<li>circle 由 row 和 col 的较小者决定，为：<code>circle = (row&lt;col?row:col)/2</code>；</li>
<li>当 row 和 col 的较小者为偶数时，按一层层的 circle 遍历完矩阵即可；</li>
<li>当 row 和 col 的较小者为奇数时，按一层层的 circle 遍历完矩阵后，矩阵中间会残留有小行或者小列（由矩阵的形状决定）没有遍历到的情况；</li>
</ol>
<h2 id="算法描述-18"><a href="#算法描述-18" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() ;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length; <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length; <span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> circle = (row&lt;col?row:col)/<span class="number">2</span>; <span class="comment">//圈数</span></span><br><span class="line">        <span class="comment">//处理所有的外圈情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circle;i++)&#123;</span><br><span class="line">            <span class="comment">//从左向右打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;col-i;j++)</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//从上往下打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;row-i;k++)</span><br><span class="line">                result.add(matrix[k][col-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="comment">//从右向左的每行数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=col-i-<span class="number">2</span>;m&gt;=i;m--)</span><br><span class="line">                result.add(matrix[row-i-<span class="number">1</span>][m]);</span><br><span class="line">            <span class="comment">//从下往上的每一列数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=row-i-<span class="number">2</span>;n&gt;i;n--)</span><br><span class="line">                result.add(matrix[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行列的较小者为偶数，则不会存在需特殊处理的情况</span></span><br><span class="line">        <span class="keyword">if</span>((row&lt;col?row:col)%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//处理竖矩阵</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(row &gt; col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=circle;i&lt;row-circle;i++)</span><br><span class="line">                result.add(matrix[i][circle]);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=circle;i&lt;col-circle;i++)</span><br><span class="line">                result.add(matrix[circle][i]);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        res=[]</span><br><span class="line">        row=len(matrix)</span><br><span class="line">        col=len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> row==<span class="number">1</span> <span class="keyword">and</span> col==<span class="number">1</span>:</span><br><span class="line">            res=[matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange((min(col,row)+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">            [res.append(matrix[k][i]) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k,col-k)]</span><br><span class="line">            [res.append(matrix[j][col<span class="number">-1</span>-k]) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k,row-k) <span class="keyword">if</span> matrix[j][col<span class="number">-1</span>-k] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">            [res.append(matrix[row<span class="number">-1</span>-k][m]) <span class="keyword">for</span> m <span class="keyword">in</span> xrange(col<span class="number">-1</span>-k,k<span class="number">-1</span>,<span class="number">-1</span>) <span class="keyword">if</span> matrix[row<span class="number">-1</span>-k][m] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">            [res.append(matrix[n][k]) <span class="keyword">for</span> n <span class="keyword">in</span> xrange(row<span class="number">-1</span>-k,k<span class="number">-1</span>,<span class="number">-1</span>) <span class="keyword">if</span> matrix[n][k] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 $O(1)$）。    </p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用 pop() 或者 min() 或者 top() 方法。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code></p>
<h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义一个动态数组 minlist，随时保存当前栈中的最小值，并用一个变量 min 记录当前最小值（其实，动态数组的最后一个元素就是最小值）。</p>
<ul>
<li>每次 <code>push</code> 时，比当前元素小，就将该值加入 minlist 末尾，并更新 min；<ul>
<li>注意：初始化，以及重复压入相同最小值至 minlist 的情况；</li>
</ul>
</li>
<li>每次 <code>pop</code> 时，直接考虑 pop 的元素值是否是当前最小值，“是”：更新；“否”：不用更新；</li>
</ul>
<h2 id="算法描述-19"><a href="#算法描述-19" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    ArrayList&lt;Integer&gt; minlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minlist.isEmpty())&#123;</span><br><span class="line">            min = node;</span><br><span class="line">            minlist.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node &lt;= min)&#123;</span><br><span class="line">            min = node;</span><br><span class="line">            minlist.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lenth = minlist.size();</span><br><span class="line">        k = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(k == min)&#123;</span><br><span class="line">            min = minlist.get(lenth-<span class="number">2</span>);</span><br><span class="line">            minlist.remove(lenth-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-10"><a href="#算法评价-10" class="headerlink" title="算法评价"></a>算法评价</h2><p>尽量避免循环的使用，从 <code>pop</code> 和 <code>push</code> 操作入手，保证时间复杂性在 $O(1)$ 级别。</p>
<hr>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出序列。假设压入栈的所有数字均不相等。（注意：这两个序列的长度是相等的）<br>例如：</p>
<ul>
<li>序列 $\{1,2,3,4,5\}$ 是某栈的压入顺序；</li>
<li>序列 $\{4,5,3,2,1\}$ 是该压栈序列对应的一个弹出序列；</li>
<li>但 $\{4,3,5,1,2\}$ 就不可能是该压栈序列的弹出序列。</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code></p>
<h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据某入栈序列判断出栈序列，关键就是分析给出的出栈序列中，每个元素出栈时的位置，只要其所有元素的出栈位置合法（所谓合法：就是看是否满足栈的先进后出特点），那么该出栈序列就是一个合法的出栈序列；    </p>
<p>举个例子：</p>
<ul>
<li>给定入栈序列 <code>pushA = {1,2,3,4,5}</code>，判断序列 <code>popA = {4,5,3,2,1}</code> 是否合法：</li>
<li>第一个出栈元素是：4，那么我们就检查是在什么时候出栈的这个 4。<ul>
<li>遍历 pushA 并入栈（保留状态）；</li>
<li>比较栈顶元素值，直到栈顶为 4 时，即说明该位置为 4 出栈时刻；</li>
</ul>
</li>
<li>第二个出栈元素是：5<ul>
<li>首先比较当前栈顶元素是否为5，是：找到，并出栈5；否，继续遍历 pushA，寻找合适时刻；</li>
</ul>
</li>
<li>循环下去…</li>
<li>如果 popA 所有元素都能在合法时刻出栈，最终栈会为空；</li>
</ul>
<p>基于上述思路，将其归纳一下：就是遍历 pushA 依次入栈，在此期间，不停地将栈顶元素和 popA 元素比较（找到，就出栈，找不到就继续遍历 pushA 并入栈），最终，pushA 遍历完毕时，如果 popA 序列合法，栈应该为空。</p>
<h2 id="算法描述-20"><a href="#算法描述-20" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span> || pushA.length != popA.length) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//保存状态的辅助栈</span></span><br><span class="line">        <span class="keyword">int</span> lenth = pushA.length;</span><br><span class="line">        <span class="keyword">int</span> pA = <span class="number">0</span>; <span class="comment">//索引 popA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="comment">//比较 popA 的过程</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[pA])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                pA++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> 和 <code>树</code></p>
<h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题说白了就是二叉树的广度优先遍历。这里做一个扩展：</p>
<ul>
<li>广度优先遍历：利用队列实现</li>
<li>深度优先遍历：利用栈实现</li>
</ul>
<h2 id="算法描述-21"><a href="#算法描述-21" class="headerlink" title="算法描述"></a>算法描述</h2><p><strong>广度优先遍历：</strong>    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">//利用队列遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>深度优先遍历：</strong>    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">depthOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="comment">//利用栈遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。<br>假设输入的数组的任意两个数字都互不相同。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code> 和 <code>树</code></p>
<h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先介绍几种树：</p>
<ul>
<li>满二叉树：除叶结点外，所有结点的左右子结点都存在；</li>
<li>完全二叉树：若二叉树的深度为 h，除第 h 层外，其它 1～h-1 层构成一个满二叉树，并且第 h 层所有的结点都连续集中在最左边；</li>
<li>平衡二叉树：空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树也都是平衡树；</li>
<li>二叉搜索树：空树或者二叉树的所有结点，该结点比它的左子结点大，比它的右子结点小；</li>
</ul>
<p>回到题目，判断二叉搜索树的后序遍历，那么寻找二叉搜索树后序遍历序列的规律，可以发现该序列一定满足如下形式：</p>
<ul>
<li><code>[(根节点左子树的后序遍历序列，且该序列中所有元素均小于根节点)，(根节点右子树的后序遍历序列，且该序列中所有元素均大于根节点)，(根节点)]</code></li>
</ul>
<p>然后，基于上述形式，不断的递归判断序列的各个部分是否也满足上述形式即可。</p>
<h2 id="算法描述-22"><a href="#算法描述-22" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> IsSquenceOfBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt;= start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找跟结点的左子树</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &gt; sequence[end]) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根结点的右子树的结点应该都比根节点大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j] &lt; sequence[end]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断根节点的左右子树是否构成二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> IsSquenceOfBST(sequence, start, i-<span class="number">1</span>) &amp;&amp; IsSquenceOfBST(sequence, i, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>网上还有一个十分巧妙的非递归算法，该算法的原理其实和递归算法完全相同：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = sequence.size();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==size)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从最后一个结点循环遍历</span></span><br><span class="line">        <span class="keyword">while</span>(--size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//二叉搜索树后序遍历，对于数组中每个元素来说，都可以将该元素前的数组分为两部分：第一部分所有元素都比它大，第二部分所有元素都比它小；</span></span><br><span class="line">            <span class="keyword">while</span>(sequence[i++]&lt;sequence[size]);</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++]&gt;sequence[size]);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(i&lt;size)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>路径：定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>注意: 在返回值的 list 中，数组长度大的数组靠前。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用递归遍历的思路，无非就是在深度优先遍历的基础上，加上每次遍历到叶结点时，判断一下路径和与目标是否相等；     </p>
<p>递归思路：</p>
<ul>
<li>从根节点出发，设置好递归出口；</li>
<li>递归调用：<ul>
<li>FindPath(root.left, target-root.val);</li>
<li>FindPath(root.right, target-root.val);</li>
</ul>
</li>
</ul>
<h2 id="算法描述-23"><a href="#算法描述-23" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：      </p>
<p>以下提供的是一种非递归实现方式，该方式基于二叉树的『非递归深度优先遍历算法』实现，但是有个缺陷：在查找失败回退时，需要查找某结点的父结点。算法的复杂度比较高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//用来存储各条路径</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> result;&#125;</span><br><span class="line">        <span class="comment">//用来存储某条路径的节点</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储当前的累加值</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二叉树深度优先遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            sum = sum + node.val;</span><br><span class="line">            res.add(node);</span><br><span class="line">            <span class="comment">//遍历到了叶结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span> &amp;&amp; node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(res));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//不是目标路径，开始回退</span></span><br><span class="line">                    TreeNode next = stack.peek();</span><br><span class="line">                    TreeNode fathernext = getfather(root,next);</span><br><span class="line">                    <span class="keyword">int</span> size = res.size()</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res.get(i) == fathernext.val)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            sum = sum - res.get(i);</span><br><span class="line">                            res.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非叶结点，继续</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常规解法，递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//初始化声明</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//保存当前总和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        path(root,target,result,res,sum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result, ArrayList&lt;Integer&gt; res,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">//遍历到叶结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">                res.add(root.val);</span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(res));</span><br><span class="line">                <span class="comment">//查找完毕，回退一下，不影响后面子结点的查找</span></span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        path(root.left,target,result,res,sum);</span><br><span class="line">        path(root.right,target,result,res,sum);</span><br><span class="line">        <span class="comment">//遍历到了叶子结点，路径上结点值的和不是目标，也需要回退一次</span></span><br><span class="line">        res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。<br>注意：输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空；      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，想先谈一下深拷贝和浅拷贝：</p>
<ul>
<li>深拷贝：<ul>
<li>会拷贝所有的属性，并拷贝属性指向的动态分配的内存；</li>
<li>当对象和它所引用的对象一起拷贝时即发生深拷贝；</li>
<li>深拷贝相比于浅拷贝速度较慢并且花销较大；</li>
</ul>
</li>
<li>浅拷贝：<ul>
<li>按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝；</li>
<li>如果属性是基本类型，拷贝的就是基本类型的值；</li>
<li>如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象；</li>
</ul>
</li>
</ul>
<p>回到此题，题目想要我们做的就是一个深拷贝例子。回想一下在最初接触到链表时，一定也接触过链表的拷贝问题，此题就是在此基础上最了改进，给每个结点加入了一个复杂的 random 指针，如果理解了普通链表的复制过程，那么此题也就只是在原基础上多复制一下链表结点的一个指针罢了。     </p>
<p>两种思路：</p>
<ol>
<li>利用 hashmap 构造出，新旧链表的节点映射关系。通过两次循环，一次新建链表结点；第二次，赋值新链表结点的 next 和 random 指针，使链表结点构成链；</li>
<li>采用类似普通链表复制时的『复制拆分』策略：<ul>
<li>遍历链表，复制每个结点，如：复制结点 A 得到 A1，将结点 A1 插到结点 A 后面；</li>
<li>重新遍历链表，复制老结点的随机指针给新结点，如：A1.random = A.random.next;</li>
<li>拆分链表，将链表拆分为原链表和复制后的链表；</li>
</ul>
</li>
</ol>
<h2 id="算法描述-24"><a href="#算法描述-24" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：     </p>
<p>思路一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode p1 = pHead;<span class="comment">//在hashmap中新建结点时，第一次循环遍历原链表的指针</span></span><br><span class="line">        RandomListNode p2 = pHead;<span class="comment">//修改hashmap中新结点的next和random时，第二次循环遍历原链表的指针</span></span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过原链表，在hashmap中建立新链表的每个结点，并构造出了新旧链表的映射关系</span></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(p1,<span class="keyword">new</span> RandomListNode(p1.label));</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给新链表各结点的next和random赋值</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(p2).next = map.get(p2.next);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(p2).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(p2).random = map.get(p2.random);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制原链表的结点，并将复制得到的新节点插入到原结点后；</span></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode currentnext = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = currentnext;</span><br><span class="line">            currentNode = currentnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新遍历链表，复制原结点的random；</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//currentNode.next.random，新链表结点的random指针</span></span><br><span class="line">            <span class="keyword">if</span>(currentNode.random == <span class="keyword">null</span>)</span><br><span class="line">                currentNode.next.random = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                currentNode.next.random = currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;<span class="comment">//跨度为2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分链表出复制的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code> <code>树</code></p>
<h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题最常见的思路就是中序遍历二叉搜索树，然后用一个动态数组保存遍历结果，之后再通过该动态数组来修改二叉树的指针。这种方法需要新开辟内存空间，且也需要完整遍历二叉树，显然不是最佳方式。     </p>
<p>再之后，看到树，自然而然的就想到了递归算法，这个递归过程想起来也不算难，但是真的让我烧了不少脑细胞（里面的坑比较多），大致思路：</p>
<ul>
<li>先初始化一个链表的头尾指针为 null；</li>
<li>递归生成当前 root 结点的树，使之成为双向链表：<ul>
<li>将其左子树生成为双向链表，并更新 head 和 end 指针；</li>
<li>将当前 root 结点插入到双向链表，并更新 end 指针；</li>
<li>在现在的链表的基础上，继续生成其右子树的双向链表；</li>
</ul>
</li>
</ul>
<p>我们知道，递归算法效率很低，这里又想到树里面常用的队列和栈，于是提出第三种基于栈的算法实现，其主要原理和思路二的递归算法一样。（分析这个思路更加有利于递归算法的理解）     </p>
<h2 id="算法描述-25"><a href="#算法描述-25" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：     </p>
<p>思路一：基于 ArrayList 的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrderTraverse1(pRootOfTree, list);</span><br><span class="line">        <span class="keyword">return</span> Convertlist(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历，将树的节点排好序，保存在 ArrayList 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode pRootOfTree, ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderTraverse1(pRootOfTree.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(pRootOfTree);</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderTraverse1(pRootOfTree.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历list，修改指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convertlist</span><span class="params">(ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            list.get(i).right = list.get(i + <span class="number">1</span>);</span><br><span class="line">            list.get(i + <span class="number">1</span>).left = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路二：递归实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode end = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        ConvertSub(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>)&#123;    <span class="comment">//相当于初始链表为空，初始化链表</span></span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//将当前根节点加入到链表</span></span><br><span class="line">            end.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = end;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路三：基于栈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode end = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将根节点在内其所有左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出栈顶，相当于在树中回退出父节点</span></span><br><span class="line">            pRootOfTree = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;   <span class="comment">//链表初始化</span></span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                end = pRootOfTree;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//将当前节点插入链表</span></span><br><span class="line">                end.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = end;</span><br><span class="line">                end = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找其右子节点</span></span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-11"><a href="#算法评价-11" class="headerlink" title="算法评价"></a>算法评价</h2><p>这个题真的是烧了我不少的脑细胞，一开始想到用递归实现，可是递归的逻辑捋了半天也没捋明白，后来看了不少大神的算法，将其总结。<br>最后想说的，涉及树的算法，还是 <code>栈</code> 牛逼！</p>
<hr>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。<br>例如：输入字符串 $abc$，则打印出由字符 $a,b,c$ 所能排列出来的所有字符串 $abc, acb, bac, bca, cab 和 cba$。      </p>
<p>输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code> <code>动态规划</code> <code>递归</code></p>
<h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设求：$fun(a,b,c)$</p>
<ul>
<li>求：$a \times fun(b,c)$，$b \times fun(a,c)$，$c \times fun(a,b)$</li>
<li>$fun(b,c)=b \times fun(c)+c \times fun(b)$</li>
<li>$fun(c)=\{c\}$</li>
</ul>
<p>采用递归的思想：</p>
<ul>
<li>循环提取字符串的字符，作为新字符串的首字符，递归排序新字符串除首字符外的子字符串，然后合并出结果，最后对结果进行排序；</li>
</ul>
<p>有几个关键点：</p>
<ol>
<li>避免重复操作；</li>
<li>每次递归得到结果后，记得恢复字符串为原始状态；</li>
<li>最终的排序不要忘了；</li>
</ol>
<h2 id="算法描述-26"><a href="#算法描述-26" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder strbuilder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//用来存放所有排序结果</span></span><br><span class="line">        result = PermutationSub(strbuilder);</span><br><span class="line">        Collections.sort(result);  <span class="comment">//按字典顺序排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">PermutationSub</span><span class="params">(StringBuilder str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//用来存放所有排序结果</span></span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//递归处理：循环将字符串中的字符都提到最前面来进行递归</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="comment">//和字符开头字符相同的字符，交换后是同一种排列，因此这里不做处理</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || str.charAt(i) != str.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="comment">//开始交换</span></span><br><span class="line">                    swap(str,<span class="number">0</span>,i);</span><br><span class="line">                    <span class="comment">//递归给出，str除首字符外其他字符的排序情况</span></span><br><span class="line">                    ArrayList&lt;String&gt; subresult = PermutationSub(<span class="keyword">new</span> StringBuilder(str.substring(<span class="number">1</span>)));</span><br><span class="line">                    <span class="comment">//将子结果与首字符合并后，加入result</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;subresult.size();j++)</span><br><span class="line">                        result.add(str.substring(<span class="number">0</span>,<span class="number">1</span>)+subresult.get(j));</span><br><span class="line">                    <span class="comment">//完成后，回到原始状态</span></span><br><span class="line">                    swap(str,i,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于字符交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(StringBuilder str, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str.charAt(b);</span><br><span class="line">        str.setCharAt(b, str.charAt(a));</span><br><span class="line">        str.setCharAt(a, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-12"><a href="#算法评价-12" class="headerlink" title="算法评价"></a>算法评价</h2><p>本题采用递归实现，每层递归都输出一个排列结果，没有造成额外的时间浪费；<br>每次提出字符串首字符，然后给出剩余字符串的排序结果，再与字符串的首字符合并，时间复杂度较高： $time(n)=n \times (time(n-1)+(n-1)+time(排序))$，为$O(n!)$</p>
<hr>
<h1 id="数组中出现次数超过一半的数组"><a href="#数组中出现次数超过一半的数组" class="headerlink" title="数组中出现次数超过一半的数组"></a>数组中出现次数超过一半的数组</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如：输入一个长度为 9 的数组 $\{1,2,3,2,2,2,5,4,2\}$。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用『数量削减』方式寻找数组中出现次数最多的元素：</p>
<ul>
<li>具体思路：假象一块区域（该区域只允许相同的数存在），然后循环遍历数组，将数组元素加到该区域，如果「加入数」与「区域内数」相同，则「区域内该数」的数量加一，否则数量减一，当区域内没有数存在时，更换区域内的数值为「加入数」。</li>
</ul>
<p>利用上述方法，找到数组中出现次数最多的元素后，再判断该数出现的次数是否超过数组长度一半。</p>
<h2 id="算法描述-27"><a href="#算法描述-27" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找数组中出现次数最多的元素</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123; <span class="comment">//区域内没有了数</span></span><br><span class="line">                current = array[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i] == current)</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到数组中出现次数最多的元素为 current，判断其出现次数是否超过数组长度一半</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == current)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; (array.length/<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-13"><a href="#算法评价-13" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 n 个整数，找出其中最小的 K 个数。<br>例如：输入 $4,5,1,6,2,7,3,8$ 这 8 个数字，则最小的 4 个数字是 $1,2,3,4$    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code> <code>高级算法</code></p>
<h2 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h2><p>说白了，本题主要就是考查的各种排序算法，这里我选择时间复杂度为：$O(nlogn)$ 的快速排序算法。</p>
<h2 id="算法描述-28"><a href="#算法描述-28" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最小的k个数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; kminlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> lenth = input.length; <span class="comment">//数组长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k&gt;lenth || k==<span class="number">0</span> || lenth==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> kminlist;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对input进行快排</span></span><br><span class="line">        sort(input,<span class="number">0</span>,lenth-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将低位的k个数放入kminlist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            kminlist.add(input[i]);</span><br><span class="line">        <span class="keyword">return</span> kminlist;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, index;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        index = a[i]; <span class="comment">// 用子表的第一个记录做基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= index)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                a[i++] = a[j];<span class="comment">// 用比基准小的记录替换低位记录</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="comment">// 用比基准大的记录替换高位记录</span></span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = index;<span class="comment">// 将基准数值替换回 a[i]</span></span><br><span class="line">        sort(a, low, i - <span class="number">1</span>); <span class="comment">// 对低子表进行递归排序</span></span><br><span class="line">        sort(a, i + <span class="number">1</span>, hight); <span class="comment">// 对高子表进行递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>在古老的一维模式识别中，常常需要计算连续子向量的最大和，当向量全为正数的时候，问题很好解决。<br>但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？<br>例如：$\{6,-3,-2,7,-15,1,2,2\}$，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。<br>给一个数组，返回它的最大连续子序列的和。(子向量的长度至少是1)       </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题是一个简单的动态规划问题，并且只有保存值，不用保存路径：</p>
<ul>
<li>imax 为某处位置的最大连续子序列和：<ul>
<li>$imax = max(imax+array[i],array[i])$</li>
</ul>
</li>
<li>result：取最大的 imax；</li>
</ul>
<h2 id="算法描述-29"><a href="#算法描述-29" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];  <span class="comment">//当前最大连续子序列和</span></span><br><span class="line">        <span class="keyword">int</span> imax = array[<span class="number">0</span>];     <span class="comment">//包含了array[i]的最大连续子序列和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            imax = Math.max(imax+array[i], array[i]);</span><br><span class="line">            result = Math.max(imax, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="从-1-到-n-的整数中-1-出现的次数"><a href="#从-1-到-n-的整数中-1-出现的次数" class="headerlink" title="从 1 到 n 的整数中 1 出现的次数"></a>从 1 到 n 的整数中 1 出现的次数</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出任意非负整数区间中 1 出现的次数；<br>例如：$[1,13]$ 中包含 1 的数字有：$\{1,10,11,12,13\}$；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code> <code>数学</code></p>
<h2 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h2><p>谈到这个题目，真是困扰了我很长一段时间，最开始解题失误，我以为是求 1 到 n 位的整数中，「1」出现的次数，我也不知道我怎么会想成这样，既然都想了，也与本题思考方式大同小异，这里先把这个思路记录一下：</p>
<ul>
<li>首先，一位数，即：0 ~ 9<ul>
<li>没啥好说的，「1」出现了 1 次；</li>
</ul>
</li>
<li>两位数，即：0 ~ 99，分为两部分：0 ~ 9 ，10 ~ 99<ul>
<li>第一部分也就是刚刚计算的，我们用 $c_1$ 表示；</li>
<li>首位为 1 的数，$[10,11,…,19]$，「1」出现了 $10+c_1$ 次；</li>
<li>其余数中，有 1 出现的：$[21,31,…,91]$，「1」出现了 $8 \times c_1$ 次；</li>
<li>合计：<mark>$c_2=c_1+10+c_1+8 \times c_1=10+10 \times c_1$</mark></li>
</ul>
</li>
<li>三位数，即：0 ~ 999，同样分为两部分：0 ~ 99 ，100 ~ 999<ul>
<li>第一部分也就是刚刚计算的，我们用 $C_2$ 表示；</li>
<li>首位为 1 的数，$[100,101,…,199]$，「1」出现了 $100+c_2$ 次；</li>
<li>其余数，即：$[201,…,299,300,…,399,…,999]$，「1」出现了 $8 \times c_2$ 次；</li>
<li>合计：<mark>$c_3=c_2+100+c_2+8 \times c_2=100+10 \times c_2$</mark></li>
</ul>
</li>
<li>继续采用同样的思路分析：<ul>
<li>k 位数时，合计：<mark>$c_k=10^{k-1}+10 \times c_{k-1}$</mark></li>
</ul>
</li>
<li>现在递推关系式出来了，用递归实现？那当然是不存在的，高中数学，求数列通项公式（两边同时除以 $10^{k-1}$ 就可以了，最后求得：<mark>$c_n=10^{n-1} \times n$</mark></li>
</ul>
<p>好了，上面的思路虽然不是解决本题的，但是仔细分析和本题的关系也是十分紧密的，这里我实在是在这题上耽误了太多时间，这次就直接引用网上一个分析过程：</p>
<blockquote>
<p>个位：</p>
<ul>
<li>每 10 个数一轮回，每个轮回中，个位上出现一次 1；</li>
<li>对于任意整数，其最后不足一个轮回的部分，我们称为「露出」。这里，如果最后这个露出来的部分小于 1，则不可能出现 1;</li>
<li>归纳，个位上 1 出现的个数为：<code>(n/10)*1 + (n%10 != 0 ? 1:0)</code></li>
</ul>
<p>十位：</p>
<ul>
<li>十位数上出现 1 的情况是 10-19，每 100 个数为一轮回，每轮回 1 出现 10 次；</li>
<li>露出部分：<code>k = n%100</code><ul>
<li>如果露出来的数大于 19，那么直接算 10 个 1，因为 10-19 肯定会出现；</li>
<li>如果小于 10，那么肯定不会出现十位数的 1；</li>
<li>如果在 10-19 之间的，计算结果为：k-10+1（k为露出部分的数字）；</li>
</ul>
</li>
<li>归纳：<code>(n/100)*10 + (if(k&gt;19) 10 else if(k&lt;10) 0 else k-10+1)</code></li>
</ul>
<p>百位：<code>k = n%1000</code></p>
<ul>
<li>十位数上出现 1 的情况是 100-199，每一千个数一轮回，每轮回 1 出现 100 次；</li>
<li>露出部分：<ul>
<li>若：k &gt; 199，则有 100 个百位 1；</li>
<li>若：100 &lt;= k &lt;= 199，则有 k-100+1 个百位 1；</li>
<li>否则，露出部分 1；</li>
</ul>
</li>
<li>归纳：<code>(n/1000)*100 + (if(k&gt;199) 100 else if(k&lt;100) 0 else k-100+1)</code></li>
</ul>
<p>最终归纳：</p>
<ul>
<li>设 i 为所计算的位数（i=1：计算个位，i=10：计算十位），<code>k = n%(i*10)</code></li>
<li><strong><code>count(i) = (n/(i*10))*i + (if(k &gt; i*2-1) i else if (k &lt; i) 0 else k-i+1)</code></strong></li>
<li>将后半部分的条件判断再改变一下写法：</li>
<li><code>min( max( (n mod (i*10))−i+1 , 0), i)</code></li>
</ul>
</blockquote>
<h2 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>)&#123;</span><br><span class="line">             <span class="keyword">long</span> diviver = i * <span class="number">10</span>;          </span><br><span class="line">             count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + <span class="number">1</span>, <span class="number">0</span>), i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如：输入数组 ${3,32,321}$，则打印出这三个数字能排成的最小数字为 321323。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一个类似数组排序的问题，但是，排序的规则不再是数组里每个元素的大小，而是需要某种规则，使得最后连接而成的数字最小；    </p>
<p>最简单的思路：把数组所有可能的组合情况都记录到一个新数组，然后对新数组进行排序，求最小。也就是我们常说的暴力破解，这种方式时间复杂度有多高不言而喻，所以，我们需要一种新的思路。     </p>
<p>递归的思想就来了，既然要求数组 a 中的最小组合情况，我们可以把先求数组前 n-1 个元素的最小组合情况，然后与 a[n] 归并。递归？再 pass 掉；</p>
<p>其实，就像一开始说的，问题关键在于找数组排序规则。那么假设：如果我们找两元素 a1、a2 的排序，有两种拼接方式 a1+a2 或 a2+a1。若 a1+a2 &gt; a2+a1，则排序为 {a1，a2}，否则为 {a2，a1}；那么，基于这个规则，对数组进行排序即可解决问题，这里采用选择排序策略；</p>
<h2 id="算法描述-30"><a href="#算法描述-30" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//选择排序策略</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numbers.length; j++)&#123;</span><br><span class="line">                <span class="comment">//将int型数组转换为字符串拼接，再转换成int型</span></span><br><span class="line">                <span class="keyword">int</span> sum1 = Integer.valueOf(numbers[i]+<span class="string">""</span>+numbers[j]);</span><br><span class="line">                <span class="keyword">int</span> sum2 = Integer.valueOf(numbers[j]+<span class="string">""</span>+numbers[i]);</span><br><span class="line">                <span class="comment">//排序规则</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 &gt; sum2)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[j];</span><br><span class="line">                    numbers[j] = numbers[i];</span><br><span class="line">                    numbers[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序后的数组，拼接位字符串</span></span><br><span class="line">        String result = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            result = result + numbers[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）；<br>例如：6、8 都是丑数，但 14 不是，因为它包含质因子 7；<br>习惯上我们把 1 当做是第一个丑数；<br>求按从小到大的顺序的第N个丑数。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>穷举</code></p>
<h2 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，我们将丑数的定义抽象为数学公式就是 $m=2^x \times 3^y \times 5^z$；<br>所以，任意一个丑数本质上都是在它的前面数的基础上乘 2/3/5 所得到的，我们将这个过程手工模拟一遍来找规律：</p>
<ul>
<li>首先，假定一个 list 用来存放按从小到大顺序排列的丑数，初始时，里面包含第一个丑数 1；</li>
<li>接下来将求： $1 \times2$，$1 \times 3$，$1 \times 5$，在里面找最小的数为 2，将 2 存入队列，list=[1,2]；</li>
<li>然后就是求：$2 \times2$，$2 \times 3$，$2 \times 5$，接下来就是从：$1 \times 3$，$1 \times 5$，$2 \times2$，$2 \times 3$，$2 \times 5$，里面找最小数，但是这里 $2 \times 3$，$2 \times 5$ 很显然是要大于 $1 \times 3$，$1 \times 5$ 的，因此就是从：$1 \times 3$，$1 \times 5$，$2 \times2$ 里面找最小值。</li>
<li>发现规律没有？</li>
</ul>
<p>这么说可能还不够明显，画张图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/UglyNumber.png" alt="丑数">     </p>
<p>从图中，我们可以看出，假想有三个队列，分别代表 x2，x3，x4 的队列，队列中第一个元素被选中加入到 list 后，就将该元素出列，并把选中的元素 x2，x3，x4 并加入到相应的队列中去。这样实现起来，很清晰，可是，新引入的三个队列，造成了很大的空间浪费。   </p>
<p>再继续观察这个图，我们真正意义用到的永远只有三个数（x2，x3，x4 三个队列的队头），所以后面的元素根本用不上，引入队列的目的无非就是记录一下，当前进行到什么位置了。再观察其结构，既然是要记录位置，那我们直接在 list 上引入三个变量记录位置信息就可以了。</p>
<h2 id="算法描述-31"><a href="#算法描述-31" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>,index3=<span class="number">0</span>,index5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &lt; index)&#123;</span><br><span class="line">            <span class="keyword">int</span> m2=list.get(index2)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m3=list.get(index3)*<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> m5=list.get(index5)*<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">int</span> min=Math.min(m2,Math.min(m3,m5));</span><br><span class="line">            list.add(min);</span><br><span class="line">            <span class="keyword">if</span>(min == m2) index2++;</span><br><span class="line">            <span class="keyword">if</span>(min == m3) index3++;</span><br><span class="line">            <span class="keyword">if</span>(min == m5) index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个字符串（0 &lt;= 字符串长度 &lt;= 10000，全部由字母组成）中找到第一个只出现一次的字符，并返回它的位置,，如果没有则返回 -1（需要区分大小写）。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h2><p>一眼看去，就想到了 hashmap，先遍历整个字符串，将每种字符的情况以 [“字符首次出现位置”,”字符出现次数”] 的形式存入 hashmap。然后再次遍历 hashmap，直到找出出现次数为 1 的字符，并返回。   </p>
<p>强迫症，总觉得引入 hashmap 带来了额外的空间开销，是否还有其它解法，二刷的时候在仔细研究一下。</p>
<h2 id="算法描述-32"><a href="#算法描述-32" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length() == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.keySet().contains(str.charAt(i)))</span><br><span class="line">                map.put(str.charAt(i),<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(str.charAt(i),map.get(str.charAt(i))+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s.count(s[i]) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 P。并将 P 对 1000000007 取模的结果输出。即输出：P%1000000007</p>
<ul>
<li>输入描述：<ul>
<li>题目保证输入的数组中没有相同的数字；</li>
<li>数据范围：<ul>
<li>对于 %50 的数据，size&lt;=10^4</li>
<li>对于 %75 的数据，size&lt;=10^5</li>
<li>对于 %100 的数据，size&lt;=2*10^5</li>
</ul>
</li>
</ul>
</li>
<li>例如：<ul>
<li>输入：1,2,3,4,5,6,7,0</li>
<li>输出：7</li>
</ul>
</li>
</ul>
<p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h2><p>求逆序对的数目，说白了就是在数组排序时，需要交换的元素次数。想到了「冒泡排序」，然后按照冒泡排序思路写了个算法去测试，结果报超时异常了，看来 $O(n^2)$ 的复杂度太高了。     </p>
<figure class="highlight java"><figcaption><span>[冒泡排序]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是想着改用其他排序算法，先考虑了「快排」，但是我们知道快排加速的基本原理就是减少比较和交换次数，那既然这样，利用快排找逆序对势必会少于真正逆序对的数目；</p>
<p>那又不想开辟过多的内存空间，唯一能想到的就是「归并排序」了。在归并排序的归并操作时，遇到交换就计数。</p>
<h2 id="算法描述-33"><a href="#算法描述-33" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并排序递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(array, start, mid);</span><br><span class="line">        MergeSort(array, mid+<span class="number">1</span>, end);</span><br><span class="line">        Merge(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = start; <span class="comment">//代表第一个子序列头</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//第二个子序列头</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j]) <span class="comment">//第一个子序列元素小，不构成逆序对</span></span><br><span class="line">                temp[k++] = array[i++]; <span class="comment">//注意这个写法：先有temp[k]=array[i]，然后k++，i++</span></span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//array[i]&gt;array[j]，由于子序列已经是排好序，则array[i，mid]都会与array[j]构成逆序对</span></span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">                count = (count + (mid-i+<span class="number">1</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end)</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;k; l++)&#123;</span><br><span class="line">            array[start+l] = temp[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。<br>注意：因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的；     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个链表的第一个公共结点，像不像找两个数组第一个相同的元素？<br>暴力解答：套用两层循环逐个遍历，时间复杂度 $O(n^2)$；</p>
<p>想其他更优办法：</p>
<ul>
<li>首先，必须想到的一点是：两个链表存在公共结点，而每个结点又只有一个后续结点，那么，从该公共结点开始，后续的所有结点都是被两个链表公用的；</li>
<li>例如：<ul>
<li>链表 1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; <strong>5 -&gt; 6 -&gt; 7 -&gt; null</strong></li>
<li>链表 2：8 -&gt; 9 -&gt; <strong>5 -&gt; 6 -&gt; 7 -&gt; null</strong></li>
<li>公共结点为：5</li>
<li>链表 1 长度：4+3</li>
<li>链表 2 长度：2+3</li>
</ul>
</li>
</ul>
<p>发现没有，如果有某种办法，能将两个链表从尾向头遍历，那么就是找最后一个不相同的结点，当然了，这种方法是不可能的。<br>但是，有没有联想到我们之前做过的一个题：『<a href="#LastKthNode">链表中倒数第k个结点</a>』，当时就是通过两个指针“绕”，解决的。那么这里，是不是也可以这么绕？</p>
<ul>
<li>我们观察，链表 1 比链表 2 长 2，那么让链表 1 先遍历两个结点，链表再开始和链表 1 同时遍历，那么只要它们有公共结点，就一定能找到；</li>
<li>现在问题就是，怎么知道链表长度差？这里就需要绕一下了<ul>
<li>同样思路，先用两指针同时遍历链表，某个指针先遍历到链表（短的那个）末尾，然后将其换成头指针，换成哪个链表的头指针呢？<ul>
<li>如果换成短链表自己的头指针，那链表 2 比链表 1 领先，这肯定不是我们想要的；</li>
</ul>
</li>
<li>所以就换成长链表的头指针，然后再继续同时遍历，长链表的指针遍历的末尾，再换成短链表的头指针，OK，长度差就合理构造出来了；</li>
<li>有点绕，可以自己画图模拟一下，关系就能出来了。</li>
</ul>
</li>
</ul>
<h2 id="算法描述-34"><a href="#算法描述-34" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1 = (p1==<span class="keyword">null</span> ? pHead2 : p1.next);</span><br><span class="line">            p2 = (p2==<span class="keyword">null</span> ? pHead1 : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题主要分为两部分：</p>
<ol>
<li>在排序数组中找到这个数字；</li>
<li>统计这个数字出现的次数；</li>
</ol>
<p>问题还是相对简单的，关键在于降低时间复杂度，选用时间复杂度为：$O(logn)$ 的折半查找；</p>
<h2 id="算法描述-35"><a href="#算法描述-35" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(array.length==<span class="number">0</span> || k&lt;array[<span class="number">0</span>] || k&gt;array[array.length-<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; k)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; k)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到后进一步统计数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i&lt;array.length &amp;&amp; array[i]==k; i++)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; array[i]==k; i--)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注： java 中自带的二叉搜索函数：<code>binatySearch</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来源：https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2?answerType=1&amp;f=discussion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(array, k);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i &lt; array.length &amp;&amp; array[i]==k;i++)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i]==k;i--)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p><a id="cengcishuchuerchashu"></a></p>
<h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一种简单思路，就是递归实现；   </p>
<p>第二种：非递归实现。   </p>
<ul>
<li>我们知道，求树的深度，其实就相当于对二叉树进行层次遍历，然后求层次遍历所经过的层数；</li>
<li>在广度优先的非递归算法中，我们采用的是队列实现：<ul>
<li>初始：先将根节点入队；</li>
<li>队头取出元素，然后将其左右孩子节点入队；</li>
<li>循环进行，直至队列为空；</li>
</ul>
</li>
<li>任意一棵二叉树广度优先遍历的结果，就是将二叉树每层的节点，从根节点开始，一层一层的存入数组中，所以，如果能知道二叉树每层的节点数，这个问题就很好解决了；</li>
<li>回到广度优先遍历算法的实现过程，其实每次「将其左右孩子节点入队」入的就是下一层结点，我们只需要将这个操作的次数记录下来，就能知道下一层的节点数了；</li>
<li>大致思路是这样，但是还有一些细节上的问题，详情见代码；</li>
</ul>
<h2 id="算法描述-36"><a href="#算法描述-36" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<p>递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">return</span> Math.max( <span class="number">1</span>+TreeDepth(root.left), <span class="number">1</span>+TreeDepth(root.right) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录每层的节点个数</span></span><br><span class="line">        <span class="comment">//遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            num = queue.size();<span class="comment">//每层结点出队完毕后，记录下一层结点的个数</span></span><br><span class="line">            <span class="comment">//每层的节点逐个出队，并将其左右孩子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            high++; <span class="comment">//遍历完了二叉树的一层，记录+1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h2><p>「平衡二叉树」：空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树也都是平衡树；</p>
<p>直接递归求各个节点的高度，只要发现某个结点的左孩子与右孩子高度差大于 1，就返回 false；</p>
<h2 id="算法描述-37"><a href="#算法描述-37" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getHigh(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getHigh(root.left);;</span><br><span class="line">        <span class="keyword">int</span> right = getHigh(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> right &gt; left ? right+<span class="number">1</span>:left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题，第一思路就是 HashMap，第一次遍历数组：将数组的各数字及其出现的次数存入 hashmap，第二次遍历 hashmap，返回出现次数为 1 的数字；</p>
<p>思路二：</p>
<blockquote>
<p><strong>异或</strong>，对数组的所有元素进行异或处理，那么数组中出现两次的数都会被清除掉，最终只剩下只出现一次的两个数的异或结果。<br>但是这里，就有个问题，我知道了 A B 异或的结果，但是我要求的是 A 和 B 的值：    </p>
<ul>
<li>知道了 A、B 异或的结果，这个结果的二进制中的 1，表现的是 A 和 B 的不同的位。</li>
<li>我们就取第一个 1 所在的位数，假设是第 3 位，接着把原数组分成两组，分组标准是第 3 位是否为 1。<ul>
<li>一组：包含数字 A，另一组：包含数字 B<ul>
<li>这两个数组中，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。</li>
</ul>
</li>
<li>然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="算法描述-38"><a href="#算法描述-38" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：   </p>
<p>思路一：hashmap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))</span><br><span class="line">                map.put(array[i],<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                map.put(array[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth &amp;&amp; count&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    num1[<span class="number">0</span>] = array[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    num2[<span class="number">0</span>] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路二：异或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">2</span>)&#123;</span><br><span class="line">            num1[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">            num2[<span class="number">0</span>] = array[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A B 异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> bitResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            bitResult ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A 异或 B 结果中第一个 1 的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = findFirst1(bitResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="comment">//分为两组异或</span></span><br><span class="line">            <span class="keyword">if</span>(isBit1(array[i], index))&#123;</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst1</span><span class="params">(<span class="keyword">int</span> bitResult)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((bitResult &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; index &lt; <span class="number">32</span>)&#123;</span><br><span class="line">            bitResult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照 index 的位是否为 1，将原数组分组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((target &gt;&gt; index) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="和位-S-的连续正数序列"><a href="#和位-S-的连续正数序列" class="headerlink" title="和位 S 的连续正数序列"></a>和位 S 的连续正数序列</h1><h2 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h2><p>小明很喜欢数学，有一天他在做数学作业时，要求计算出 9~16 的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100(至少包括两个数)。没多久，他就得到另一组连续正数和为 100 的序列:18,19,20,21,22。现在把问题交给你，你能不能也很快的找出所有和为S的连续正数序列? Good Luck!    </p>
<p>输出描述:<br>输出所有和为 S 的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>穷举</code></p>
<h2 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题的知识点是「穷举」，那自然就知道思路是啥了，一个一个列举呗！<br>那问题关键就是怎样穷举，来保证一个不漏。<br>在看输出描述，要求序列内按从小至大的顺序，序列间按开始数字从小到大，很显然，本题的穷举也就自然应该分为两层循环：</p>
<ol>
<li>找所有序列：<ul>
<li><code>for(int i=0; i&lt;s; i++)</code></li>
</ul>
</li>
<li>找满足条件的序列:<ul>
<li><code>for(int j=i+1; j&lt;s; k++)</code></li>
</ul>
</li>
</ol>
<p>把它们合并起来看，像不像一个大小可变的「窗口」，要在整个数轴上滑动，找到所有和为 s 的窗口！     </p>
<p>窗口，就需要定义一个窗口左右边界，左边界就是上面循环中的 <code>i</code>，右边界就是上面循环中的 <code>j</code>；利用滑动窗口的思想，接下来就好办了，详情见代码。</p>
<h2 id="算法描述-39"><a href="#算法描述-39" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//开始滑</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            <span class="comment">//当前窗口内数字总和，等差数列求和</span></span><br><span class="line">            <span class="keyword">int</span> val = (left+right)*(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到满足条件的窗口</span></span><br><span class="line">            <span class="keyword">if</span>(val == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，扩大窗口，右边界右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; sum)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，当前窗口不再可能满足条件，滑动窗口到新的位置寻找，左边界右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="和为-s-的两个数字"><a href="#和为-s-的两个数字" class="headerlink" title="和为 s 的两个数字"></a>和为 s 的两个数字</h1><h2 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。      </p>
<p>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数学</code></p>
<h2 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h2><p>求递增数组中和为 s 的两个数，也是一个穷举问题，这里有两种穷举思路：从数组同一侧进行、从数组两端进行，但是题目要求输出两个数的乘积最小的，那自然就是从数组两端进行了，因为“相差越远乘积越小”；<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/TwoNumberSum.png" alt="TowNumberSum"></p>
<ul>
<li>若 <code>left + right == sum</code>，找到；</li>
<li>若 <code>left + right &gt; sum</code>，<code>right--</code>，right 右边的数据都过大而不可能满足条件；</li>
<li>若 <code>left + right &lt; sum</code>，<code>left++</code>，left 左边的数都过小不可能满足条件；</li>
</ul>
<h2 id="算法描述-40"><a href="#算法描述-40" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = lenth-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right] == sum)&#123;</span><br><span class="line">                list.add(array[left]);</span><br><span class="line">                list.add(array[right]);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right] &gt; sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-14"><a href="#算法评价-14" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。<br>例如，字符序列 <code>S=”abcXYZdef”</code>，要求输出循环左移 3 位后的结果，即 <code>“XYZdefabc”</code>。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题很简单，主要就是字符串的操作，先将原字符串分为两个字字符串，然后再将它们拼接在一起，但是需要注意的是，要考虑 <code>n&gt;length</code> 的情况。</p>
<h2 id="算法描述-41"><a href="#算法描述-41" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = str.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || lenth==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        n = n % lenth;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n) + str.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是 “I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用两个栈实现，首先将整个句子全部反转（栈1）实现，但是我们知道，这样虽然将每个字句的顺序调整对了，但是字句里面的字符也被反转了，所以这个时候，再以空格为单位利用（栈2），将所有的子句再反转会来即可。    </p>
<p>也可以直接用StringBuffer.reverse（）实现，但是注意一下：</p>
<ul>
<li>String 没有 reverse（）用法；</li>
<li>StringBuffer.reverse（）返回的是 String；</li>
</ul>
<h2 id="算法描述-42"><a href="#算法描述-42" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)  <span class="keyword">return</span> str;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(); <span class="comment">//存放结果</span></span><br><span class="line">        Stack&lt;String&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//用来反转句子</span></span><br><span class="line">        Stack&lt;String&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//反转子字符串</span></span><br><span class="line">        <span class="keyword">int</span> lenth = str.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始时，将整个句子入栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)</span><br><span class="line">            stack1.push(String.valueOf(str.charAt(i)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出栈，开始反转</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不是空格，往新栈捣鼓，</span></span><br><span class="line">            <span class="keyword">if</span>(!stack1.peek().trim().isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遇到空格，清空栈2，完成子字符串反转</span></span><br><span class="line">                <span class="keyword">while</span>(!stack2.isEmpty())</span><br><span class="line">                    result.append(stack2.pop());</span><br><span class="line">                result.append(stack1.pop());<span class="comment">//把stack1里面的空格加进来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty())</span><br><span class="line">            result = result.append(stack2.pop());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为了写这个算法，有几个注意点：</p>
<ol>
<li>java 里的 stack 是没有 char 类型的，所以得将 char 类型用  <code>String.valueof()</code> 方法转换为字符串再进行处理；</li>
<li>判断字符串是否为空：<ul>
<li><code>String str1 = null;</code> 类型为空，表示这个字符串不指向任何的东西，如果这时候你调用它的方法，那么就会出现空指针异常；</li>
<li><code>String str2 = &quot;&quot;;</code> 表示它指向一个长度为 0 的字符串，这时候调用它的方法是安全的；</li>
<li>正确的写法是 <code>if(str1==null||str1.equals(&quot;&quot;)){...}</code> ，所以在判断字符串是否为空时，先判断是不是对象，如果是，再判断是不是空字符串 }</li>
</ul>
</li>
<li>在第 18 行处，直接写 <code>stack1.peek() != &quot; &quot;</code>，即使栈顶为空格，它也会一直返回 <code>true</code>：<ul>
<li>空格可以直接输入，例如：System.out.println(“ “)；</li>
<li>而如果用 String 表示那些符号的话，空格应该是 <code>\t</code>； </li>
</ul>
</li>
</ol>
<hr>
<h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><h2 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h2><p>LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王(一副牌原本是 54 张^_^)…他随机从中抽出了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！<br>“红心 A，黑桃 3，小王，大王，方片 5”，“Oh My God!” 不是顺子…..LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作 1，J 为 11，Q 为 12，K 为 13。上面的 5 张牌就可以变成 “1,2,3,4,5” (大小王分别看作 2 和 4)，“So Lucky!”。LL 决定去买体育彩票啦。<br>现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何，如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见，你可以认为大小王是 0。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题题目看着贼麻烦，属实让人头大。但是，仔细分析一下，就可以发现其实思路很简单，要检索手上的五张牌能否组成顺子，研究一下顺子的特点就能发现：“顺子最大值与最小值的差为 4”，那么是不是满足这个就行了呢？     </p>
<p>由于题目引入了大小王，将其定为 0，并且可以替代为任意数字，所以说这里组成顺子应该满足：“顺子最大值与最小值的差小于 5”，另外，肯定得保证顺子无对子出现（每个数字只出现一次）。   </p>
<p>归纳起来：</p>
<ol>
<li>max - min &lt; 5；//注意，min 不包括 0 </li>
<li>除 0 外没有重复的数字(牌)；</li>
<li>数组长度为 5 （五张牌）；</li>
</ol>
<h2 id="算法描述-43"><a href="#算法描述-43" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = numbers.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>]; <span class="comment">//统计出现的元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)&#123;</span><br><span class="line">            count[numbers[i]] = count[numbers[i]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] !=<span class="number">0</span> &amp;&amp; count[numbers[i]]&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt; max) max = numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; min &amp;&amp; numbers[i] != <span class="number">0</span>) min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="圆圈中最后剩下的数"><a href="#圆圈中最后剩下的数" class="headerlink" title="圆圈中最后剩下的数"></a>圆圈中最后剩下的数</h1><h2 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h2><p>每年六一儿童节，牛客都会准备一些小礼物去看望孤儿院的小朋友，今年亦是如此。HF 作为牛客的资深元老，自然也准备了一些小游戏。其中，有个游戏是这样的：首先，让小朋友们围成一个大圈。然后，他随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数，….，这样下去….，直到剩下最后一个小朋友，可以不用表演，并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下，哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 n-1 )<br>如果没有小朋友，请返回 -1；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code> <code>数学</code></p>
<h2 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h2><p>最简单粗暴的方法，就是用数组来模拟圆进行相关操作；然后，我比较懒，总觉得这种题肯定有某种数学规律，就画了数组，手动模拟了一下，发现这个过程是存在一个递推规律的：</p>
<ul>
<li>首先，我们初始所求为 <code>find(n,m)</code>，在进行一轮后，将 <code>(m-1)%n</code> 这个人出列，剩下的就是 <code>find(n-1,m)</code> 问题；</li>
<li>那么，就是将这两个关系式连接起来，问题的关键就是其序号的变化情况。<ul>
<li>原先，一个孩子出列后的序号为：<code>0,1,2,...,(m-1)%n,(m-1)%n+1,...,n-1</code>，为表述方便取 <code>k=m%n</code>，此时，新的一轮开始；</li>
<li>先将上述序号重排为 x：$k,k+1,…,n-1,0,1,…,k-3,k-2$，然后重新编号为 y：$0,1,2,…,n-3,n-2$；</li>
</ul>
</li>
<li>就能找到新编号 y 和旧编号 x 的关联：<code>x=(y+k) % n</code>；</li>
<li>现在递推关系就出来了：<code>f(n)=(f(n-1)+m) % n</code>，然后将其描述为非递归算法即可；</li>
</ul>
<h2 id="算法描述-44"><a href="#算法描述-44" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">            s=(s+m)%i;</span><br><span class="line">       <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>数组模拟圆的方法（weizier）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLastNumber</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>,step = <span class="number">0</span>, count = n;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;   <span class="comment">//跳出循环时将最后一个元素也设置为了-1</span></span><br><span class="line">            i++;          <span class="comment">//指向上一个被删除对象的下一个元素。</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n) i=<span class="number">0</span>;  <span class="comment">//模拟环。</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] == -<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//跳过被删除的对象。</span></span><br><span class="line">            step++;                     <span class="comment">//记录已走过的。</span></span><br><span class="line">            <span class="keyword">if</span>(step==m) &#123;               <span class="comment">//找到待删除的对象。</span></span><br><span class="line">                array[i]=-<span class="number">1</span>;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//返回跳出循环时的i,即最后一个被设置为-1的元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="求-1-2-…-n"><a href="#求-1-2-…-n" class="headerlink" title="求 1+2+…+n"></a>求 1+2+…+n</h1><h2 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h2><p>求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code></p>
<h2 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h2><p>相信大家都知道，这种数列就是所谓的高斯求和，求和公式为：$\frac{(n+1)\times n}{2}$，这里在拓展一下等差数列的求和公式：$\frac{(a_1+a_n)\times n}{2}$。    </p>
<p>可能本题的难点就是不让你用乘除法吧，那上面公式变形一下：$\frac{n+n^2}{2}$，现在，乘法运算改为指数运算，除法运算改为移位运算即可。</p>
<h2 id="算法描述-45"><a href="#算法描述-45" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n + (<span class="keyword">int</span>)Math.pow(n,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：<code>Math.pow()</code> 方法返回的是一个 <code>double</code> 类型的值，需要做一下强制转换；   </p>
<p>后来看了题解，发现有个很有意思的做法，叫 “<strong>短路求值</strong>”：</p>
<blockquote>
<p>来源：<a href="https://www.nowcoder.com/profile/248824047" target="_blank" rel="noopener">Iron欣</a></p>
<ul>
<li>expr1 &amp;&amp; expr2，若 expr=0，expr2 将不会进行求值，整个逻辑表达式的值已经确定为 0</li>
<li>expr1 || expr2，若 expr=1，expr2 将不会进行求值，整个逻辑表达式的值已经确定为 1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n;</span><br><span class="line">            <span class="keyword">boolean</span> ans = (n&gt;<span class="number">0</span>)&amp;&amp;((sum+=Sum(n-<span class="number">1</span>))&gt;<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<hr>
<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点：<code>进制转化</code></p>
<h2 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h2><p>做体系结构的人看到这个题目对会有一种亲切感，说白了，就是要你实现一个加法器；<br>在加法器的实现过程中，我们知道应该分为两部分：①进位（通过与运算求）；②输出（通过异或运算求）；但是，在微结构中，我们可以直接对二进制数的每个位进行操作，而在 JAVA 中肯定就不行了。那就是需要找个办法来模拟这个过程：</p>
<ul>
<li>首先，我们知道，没有进位的加法很容易实现：<code>num1^num2</code>，但是这肯定不够还得加上数的进位部分才行；</li>
<li>某一位是否产生进位，是通过与门实现的，并且这一位产生的进位是加到高一位去的。所以，数的进位求法：<code>(num1&amp;num2)&lt;&lt;1</code></li>
<li>接下来，就是再将原值与进位相加，但是这个过程又可能有新进位运算产生，那么就需要继续递归调用上面的过程，直至没有新的进位产生，递归算法就出来了；    </li>
</ul>
<p>这里可能有人会有疑问，上述思想，递归算法结束的条件是不再有新的进位产生，即：<code>(num1&amp;num2)&lt;&lt;1 == 0</code>，那么这个运算最后一定会为 0 吗？    </p>
<ul>
<li>答案是肯定的，其实，只需要手动模拟一下，下一次的进位求解公式为；<code>((num1^num2)&amp;((num1&amp;num2)&lt;&lt;1))&lt;&lt;1</code>，只需要看 <code>(num1^num2)&amp;((num1&amp;num2)&lt;&lt;1)</code> 这个部分，发现没有，右边的数始终要比左边的数多一个左移操作，也就是说最低位始终添 0，与操作后，新的进位值最低位始终为 0。下一轮迭代时，这个 0 被左移移位，并且又在最低位产生一个 0，如此反复下去，进位值最终肯定会变为 0。</li>
</ul>
<h2 id="算法描述-46"><a href="#算法描述-46" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：   </p>
<p>递归实现，只需要一行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num2 != <span class="number">0</span> ? Add(num1^num2,(num1&amp;num2)&lt;&lt;<span class="number">1</span>):num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本着能不递归就不递归的原则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = num1^num2;</span><br><span class="line">            carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><h2 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数；<br>数值为 0 或者字符串不是一个合法的数值则返回 0；   </p>
<p>输入描述:</p>
<ul>
<li>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:</li>
<li>如果是合法的数值表达则返回该数字，否则返回0</li>
</ul>
<p>示例：</p>
<blockquote>
<p>输入：</p>
<ul>
<li>+2147483647</li>
<li>1a33</li>
</ul>
<p>输出：</p>
<ul>
<li>2147483647</li>
<li>0</li>
</ul>
</blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题看着的时候，属实有点头大感觉没啥思绪，特别是看到这个输入输出示例，更懵了，所以，这题一点一点来怼吧。    </p>
<p>首先，涉及字符串和整数的转换，那么必须知道的就是所对应的常见的 $128(0,2^7-1)$ 个「<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;fromid=99077&amp;fromtitle=ascii%E7%A0%81" target="_blank" rel="noopener">ASCII</a>」码，其中比较常见的几个：</p>
<ul>
<li>数字 ‘0-9’：对应 ASCII 码 ‘48-57’；</li>
<li>大写字母 ‘A-Z’：对应 ASCII 码 ‘65-90’；</li>
<li>小写字母 ‘a-z’：对应 ASCII 码 ‘97-122’； </li>
<li>空字符 NULL：对应 ASCII 码为 0；</li>
<li>在上述中间穿插各种特殊符号，具体讲上面的百度百科链接；</li>
</ul>
<p>然后，看了这题的题解，恍然大悟，其实就是要把这个按「字符串类型存的整数」转换成「整数类型存储」，瞬间觉得自己的理解能力属实有点差了。希望下次再看到这题的时候不会这么懵了…</p>
<p>注意一下，int 类型一共 32 位，在转换时需要做溢出判断：</p>
<ul>
<li><code>int MIN_VALUE = 0x80000000;</code>，int 类型数的最小值：$-2^31 = -2147483648$；</li>
<li><code>int MAX_VALUE = 0x7fffffff;</code>，int 类型数的最大值：$2^31-1 = 2147483647$;</li>
</ul>
<h2 id="算法描述-47"><a href="#算法描述-47" class="headerlink" title="算法描述"></a>算法描述</h2><p>『<a href="https://www.nowcoder.com/profile/236738700" target="_blank" rel="noopener">来源牛客网：pmzcc</a>』    </p>
<p><strong>解法 1</strong>：捕捉异常（有些钻空子嫌疑，但是很好用）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       Integer res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             res = <span class="keyword">new</span> Integer(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法 2</strong>：正则表达式判断格式 + 结果溢出判断，<strong>效率低，很慢</strong></p>
<ul>
<li>不符合规则就返回 0；符合规则，得出结果后判断是否溢出；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// \d代表[0-9] 但是要写成\\d才行。</span></span><br><span class="line">        <span class="keyword">if</span>(!str.matches(<span class="string">"[+,-]?\\d+"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//long类型，避免溢出。不能用int</span></span><br><span class="line">        <span class="comment">//按十进制数原理开始转换</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            res += Math.pow(<span class="number">10</span>,len-<span class="number">1</span>-i)*(str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (str.charAt(<span class="number">0</span>) == <span class="string">'-'</span> ? -res : res);</span><br><span class="line">        <span class="comment">//溢出就返回0，用long类型的res来比较，</span></span><br><span class="line">        <span class="comment">//如果定义为int res,那再比较就没有意义了，int范围为[-2147483648,2147483647]</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE || res&lt;Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法 3</strong>：最优解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str.trim())) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断数字的正负性</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] == <span class="string">'+'</span> || arr[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始转换</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;arr.length )&#123;</span><br><span class="line">            <span class="keyword">if</span>(isNum(arr[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = arr[i] - <span class="string">'0'</span>; <span class="comment">//当前位置字符对应的整数值，将 ASCII 类似的数字，转换成 int类型的数字</span></span><br><span class="line">                <span class="comment">//正数的溢出判断，实际上只有在最后一个迭代时才进行了比较，最大正数的末尾为7</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; (res &gt; Integer.MAX_VALUE/<span class="number">10</span> || res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; cur &gt;<span class="number">7</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//负数的溢出判断，负数的最大末位为8</span></span><br><span class="line">                <span class="keyword">if</span>(flag == -<span class="number">1</span> &amp;&amp; (res &gt; Integer.MAX_VALUE/<span class="number">10</span> || res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; cur &gt;<span class="number">8</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始转换</span></span><br><span class="line">                res = res*<span class="number">10</span> +cur;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不是数字</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符在 ascii 中对应的是否为数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c&gt;=<span class="string">'0'</span>&amp;&amp; c&lt;=<span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以，其实不用去记 ASCII 码的；</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>java 中字符串与整数装换的常用函数：</p>
<ol>
<li>String 转换成 int 类型：<ul>
<li><code>int i = Integer.parseInt([String]);</code><ul>
<li>//直接使用静态方法，不会产生多余的对象，但会抛出异常</li>
</ul>
</li>
<li><code>int i = Integer.valueOf(my_str).intValue();</code><ul>
<li>//<code>Integer.valueOf(s)</code> 相当于 <code>new Integer(Integer.parseInt(my_str))</code>，也会抛异常，但会多产生一个对象</li>
</ul>
</li>
<li>举例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = Integer.parseInt(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = Integer.valueOf(str).intValue();</span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>int 类型转换成 String 类：<ul>
<li>通过 <code>Integer.toString(i)</code> 方法转换：利用 <code>String s = Integer.toString(i);</code></li>
<li>通过 <code>String.valueOf(i)</code> 方法转换为字符串：利用 <code>String s = String.valueOf(i);//直接使用String类的静态方法，只产生一个对象</code></li>
<li>通过 ‘+’ 链接，将整型强制转换一下字符串：利用 <code>String s = &quot;&quot; + i;//会产生两个String对象</code></li>
</ul>
</li>
</ol>
<p>『<a href="https://blog.csdn.net/yangxingpa/article/details/79900732" target="_blank" rel="noopener">来源链接</a>』</p>
<hr>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="问题描述-13"><a href="#问题描述-13" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个长度为 n 的数组里的所有数字都在  0 到 n-1 的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中任意一个重复的数字。    </p>
<p>例如：如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路一：先排序，查找相邻位置；     </p>
<p>思路二：hashmap 存次数；   </p>
<p>思路三：对数组做标记</p>
<ul>
<li>我们知道，比较重复最常见的思路就是，存访问过的数据值进行比较，但是这样势必引入新的空间开销；</li>
<li>同样是采用做标志的方法，本题汇总规定了数组的所有元素数值不超过 n，这就给了我们很好的做标志方法；</li>
<li>每次访问一个值，我们就将其 +n，这样下次再访问这个位置时，只要是重复出现了，就会发现其值 &gt;n；</li>
</ul>
<h2 id="算法描述-48"><a href="#算法描述-48" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//开始打标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="comment">//位置被标记过</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= length)&#123;</span><br><span class="line">                numbers[i] = numbers[i]-length; <span class="comment">//回到原始值去访问相应位置</span></span><br><span class="line">                <span class="comment">//因为先做了-length的操作，避免自己访问自己的情况时把标记减掉了</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == i)&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断 numbers[i] 做索引访问对应的位置（那个位置被访问过话，那个位置的值就大于length），也就间接说明数组里有相同的元素</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[numbers[i]] &gt;= length) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[numbers[i]] = numbers[numbers[i]] + length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><h2 id="问题描述-14"><a href="#问题描述-14" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组 $A[0,1,…,n-1]$，请构建一个数组 $B[0,1,…,n-1]$，其中 B 中的元素 $B[i]=A[0] \ast A[1] \ast … \ast A[i-1] \ast A[i+1] \ast … \ast A[n-1]$。<br>不能使用除法。<br>注意：规定 $B[0] = A[1] \ast A[2] \ast … \ast A[n-1]$，$B[n-1] = A[0] \ast A[1] \ast … \ast A[n-2]$;     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h2><p>见到这题时，一开始，我想着先求 A[i] 的各个叠乘值，这样就能得到：</p>
<ul>
<li>A[0];</li>
<li>A[0] * A[1];</li>
<li>A[0] <em> A[1] </em> A[2];</li>
<li>……</li>
<li>A[0] <em> A[1] </em> A[2] <em> … </em> A[n-1];</li>
</ul>
<p>然后，再将题目所求的 B[i] 表示出来：</p>
<ul>
<li>B[0]   =   1  <em> A[1] </em> A[2] <em> … </em> A[n-1]</li>
<li>B[1]   = A[0] <em>   1  </em> A[2] <em> … </em> A[n-1]</li>
<li>B[2]   = A[0] <em> A[1] </em>   1  <em> … </em> A[n-1]</li>
<li>……</li>
<li>B[n-1] = A[0] <em> A[1] </em> A[2] <em> … </em> 1</li>
</ul>
<p>对比一下，我们只需要再将 A[i] 倒过来再求一次叠乘值：</p>
<ul>
<li>A[n-1]</li>
<li>A[n-1] * A[n-2]</li>
<li>……</li>
<li>A[n-1] <em> A[n-2] </em> A[n-3] <em> … </em> A[1];</li>
<li>A[n-1] <em> A[n-2] </em> A[n-3] <em> … </em> A[1] * A[0];</li>
</ul>
<p>接下来观察上面三个矩阵就知道，只需要将第 1 个和第 3 个合适的项乘到一起就能求得 B[i]；   </p>
<p>画个图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/ProductArray.png" alt="ProductArray"><br>这样更加直观了，是不是好像也不用重新来定义两个新的数组，直接在 B[i] 上操作也可以，见代码。</p>
<h2 id="算法描述-49"><a href="#算法描述-49" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            mul = mul*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*mul;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><h2 id="问题描述-15"><a href="#问题描述-15" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数用来匹配包括 <code>.</code> 和 <code>*</code> 的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含 0 次）；<br>在本题中，匹配是指字符串的所有字符匹配整个模式；<br>例如，字符串 <code>aaa</code> 与模式 <code>a.a</code> 和 <code>ab*ac*a</code> 匹配，但是与 <code>aa.a</code> 和 <code>ab*a</code> 均不匹配；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题主要是分类讨论，不要出现漏算的情况。    </p>
<p>就不再论述了，看了网上的分析觉得写的很详细，鉴于许多人的题解都出现了一模一样的分析，我也不知道谁是原作者，这里就没加链接了。</p>
<blockquote>
<p>首先，考虑特殊情况：</p>
<ul>
<li>两个字符串都为空，返回 true；</li>
<li>当第一个字符串不空，而第二个字符串空了，返回 false；<ul>
<li>而如果第一个字符串空了，第二个字符串非空，还是可能匹配成功的，比如第二个字符串是 <code>a*a*a*a*</code>，由于 <code>*</code> 之前的元素可以出现 0 次，所以有可能匹配成功；</li>
</ul>
</li>
</ul>
<p>之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。<br>但考虑到 pattern 下一个字符可能是 <code>*</code>， 这里我们分两种情况讨论：pattern 下一个字符为 <code>*</code> 或不为 <code>*</code>：</p>
<ul>
<li>pattern 下一个字符不为 <code>*</code>：<ul>
<li>这种情况比较简单，直接匹配当前字符。</li>
<li>如果匹配成功，继续匹配下一个；如果匹配失败，直接返回 false。</li>
<li>注意这里的“匹配成功”，除了两个字符相同的情况外，还有一种情况，就是 pattern 的当前字符为 <code>.</code>，同时 str 的当前字符不为 ‘\0’；</li>
</ul>
</li>
<li>pattern 下一个字符为 <code>*</code> 时，稍微复杂一些，因为 <code>*</code> 可以代表 0 个或多个。<ul>
<li>当 <code>*</code> 匹配 0 个字符时，str 当前字符不变，pattern 当前字符后移两位，跳过这个 <code>*</code> 符号；</li>
<li>当 <code>*</code> 匹配 1 个或多个时，str 当前字符移向下一个，pattern 当前字符不变。<ul>
<li>这里匹配 1 个或多个可以看成一种情况，因为：当匹配一个时，由于 str 移到了下一个字符，而 pattern 字符不变，就回到了上边的情况；</li>
<li>当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>本题其实更适合用 C/C++ 写，因为 C/C++ 的指针可以直接进行 +1 操作，相对方便，而 java 不行，虽然可以用 index 来替代，但是随时都需要判断数组溢出的情况。</p>
<h2 id="算法描述-50"><a href="#算法描述-50" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>C++</code> （<a href="https://www.nowcoder.com/profile/2189472" target="_blank" rel="noopener">来源：跪求offer养家糊口</a>）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//if the next character in pattern is not '*'</span></span><br><span class="line">        <span class="keyword">if</span> (*(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the next character is '*'</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>) || match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>java</code>（基于上述思路修改）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchhelp(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchhelp</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span> (i == str.length &amp;&amp; j == pattern.length) <span class="comment">// 字符串和模式串都为空</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == pattern.length)<span class="comment">// 模式串为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next character in pattern is '*'</span></span><br><span class="line">        <span class="comment">//时时刻刻都要保证 i&lt;str.length，j&lt;pattern.length 否则越界</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (j+<span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[j+<span class="number">1</span>] == <span class="string">'*'</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j]))</span><br><span class="line">                <span class="keyword">return</span> matchhelp(str, i, pattern, j+<span class="number">2</span>) || matchhelp(str, i+<span class="number">1</span>, pattern, j);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> matchhelp(str, i, pattern, j+<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//if the next character is not '*'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j]))</span><br><span class="line">                 <span class="keyword">return</span> matchhelp(str, i + <span class="number">1</span>, pattern, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。<br>例如，字符串 <code>+100</code>,<code>5e2</code>,<code>-123</code>,<code>3.1416</code> 和 <code>-1E-16</code> 都表示数值。但是 <code>12e</code>,<code>1a3.14</code>,<code>1.2.3</code>,<code>+-5</code> 和 <code>12e+4.3</code> 都不是。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单明了的办法，就是正则表达式：<br><code>[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?</code></p>
<p>其中：</p>
<ul>
<li><code>[+-]?</code>：正负符号是否出现；</li>
<li><code>[0-9]*</code>：数字出现 0 或者任意次；</li>
<li><code>(\\.[0-9]*)?</code>：小数部分，出不出现都可以；</li>
<li><code>([eE][+-]?[0-9]+)?</code>：指数部分，出不出现都可以<ul>
<li><code>[eE]</code>：必须要有指数符号；</li>
<li><code>[+-]?</code>：正负符号出不出现都可以；</li>
<li><code>[0-9]+</code>：数字部分至少出现一次；</li>
</ul>
</li>
</ul>
<h2 id="算法描述-51"><a href="#算法描述-51" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String str1 = String.valueOf(str);</span><br><span class="line">        <span class="keyword">return</span> str1.matches(<span class="string">"[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><h2 id="问题描述-16"><a href="#问题描述-16" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>例如：当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g” 。当从该字符流中读出前六个字符 “google” 时，第一个只出现一次的字符是 “l”。   </p>
<p>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h2><p>在此之前已经遇到过几次关于查找重复的问题了，之前我们基本都是采用 hashmap 来记录元素出现次数，然后比较来判断的。本题当然也可以。    </p>
<p>但是注意到本题判断的是字符流，和之前的数组中元素有点不太，这里是没有索引的（当然了，你也可以按照字符出现的顺序来建立索引，但是这样似乎太占内存空间了）。其实，可以直接用一个数组来存就行了：</p>
<ul>
<li>ASCII 一共 128 个字符，也就是说，字符流中出现的字符可能有 128 种情况；</li>
<li>因此，建立一个 128 大小的数组，利用字符的 ASCII码 的十进制作为数组索引，元素值代表该字符出现的次数；</li>
<li>说白了，就是相当于用数组做了一个 hashmap；</li>
</ul>
<p>现在，解决了出现次数的问题，但是题目还有一个要求就是让我们返回第一个只出现一次的字符，所以相当于还得对这些字符出现的顺序做一个记录，根据这里的规则：先进先出，很容易就想到了队列，那怎样来完成这个逻辑呢：</p>
<ul>
<li>元素首次出现，就入队；</li>
<li>当字符流中出现队头字符，该字符出队，但是这个时候，不能直接返回新的队头（因为，按照前面的逻辑，在字符流字符的判断时，只关心了队头，但是队列中的其他元素可能出现过，所以，这里还需要做一下判断），在数组检查新队头字符出现次数，为 1，则返回；否则，将该队头出队，继续检查新的队头；</li>
</ul>
<h2 id="算法描述-52"><a href="#算法描述-52" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numcount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numcount[ch] == <span class="number">0</span>)</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        numcount[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            res = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (numcount[res] == <span class="number">1</span>) <span class="comment">//判断是否脱单了，没脱单则输出</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span> queue.remove(); <span class="comment">//脱单了就移出队列，它不会再回来了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h1><h2 id="问题描述-17"><a href="#问题描述-17" class="headerlink" title="问题描述"></a>问题描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一眼看到这个题，脑海里只有一个思路：构造辅助存储空间，但是这题要是只有这种解法，自然也就没意思了。       </p>
<p>想了一会也没什么思路，就去看了题解（『<a href="https://leetcode.com/problems/linked-list-cycle-ii/discuss/44774/Java-O(1" target="_blank" rel="noopener">原文链接</a>-space-solution-with-detailed-explanation)』，这里做一个搬运工），捋一遍思路：</p>
<ul>
<li>主打方法：<strong>双指针法</strong><ul>
<li>一快一慢指针。快指针每次跑两个结点，慢指针每次跑一个结点；</li>
<li>如果存在一个圈，最终快指针是能追上慢指针的；</li>
</ul>
</li>
<li>假设一个模型（可以自己画个图）：<ul>
<li>快慢指针相遇的点：p；</li>
<li>环的入口在点：q；</li>
<li>从链表头节点到点 q 距离为 A；</li>
<li>q、p 两点间距离为 B，p、q 两点间距离为 C；</li>
<li>快指针的速度是慢指针的两倍，因此得到关系式：$2 \times (A+B) = A+B+C+B$，因此，求得：$C=A$</li>
</ul>
</li>
<li>找入口节点：<ul>
<li>新建一个另外的指针 slow2，让他从头节点开始走，每次只走下一个；原 slow 指针继续保持原来的走法，和 slow2 同样，每次只走下一个；</li>
<li>由于 $A=C$，在遍历完 A/C 个节点后，这两个指针最终一定会在入口处相遇，返回此时的节点即可；</li>
</ul>
</li>
</ul>
<p>刷题，刷到这，发现凡是涉及链表的操作，都可以将其思路归结如下：</p>
<ol>
<li>链表嘛，自然离不开指针，所以首先来个指针遍历一定不会有错；</li>
<li>因为链表遍历的特点，<strong>走过之后不留痕迹</strong>（遍历过后，是没法回退的），而这往往会成为链表考点。<ul>
<li>最简单粗暴的方法就是开辟新的空间存 “痕迹”；但是这一般不推荐。</li>
</ul>
</li>
<li>存痕迹的方法很多，不能仅仅局限在数组、hashmap 等这种数据结构上，不知道你有没有发现，链表要用到所谓的痕迹，很多时候都只需要用到前面一个或者几个（很少）的节点信息，直接用变量（指针）存就行了；<ul>
<li>常用的思路就是，用一个指针正常遍历，另外定义一个指针按照 “某种规则” 跟着遍历；</li>
<li>常用的 “规则”：从速度差，时间差上去考虑；</li>
</ul>
</li>
</ol>
<h2 id="算法描述-53"><a href="#算法描述-53" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = pHead;</span><br><span class="line">                <span class="keyword">while</span>(slow2 != slow)&#123;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个小思考：我们将快结点的速度定义为慢结点的两倍，那如果是：“三倍”、“四倍”、……呢？算法的时间复杂度会不会更低一些？</p>
<ul>
<li>这个具体怎样规定速度最合适，是需要根据链表结构来确定的，是受环的大小以及链表头结点到环入口长度这两点的影响。</li>
</ul>
<hr>
<h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><h2 id="问题描述-18"><a href="#问题描述-18" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如：链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚刚总结完思路，这里正好用的上：</p>
<ul>
<li>删除链表重复元素，考查的就是链表遍历过程中无法保留历史信息特点；</li>
<li>思路一：构造辅助存储，这里不再阐述；</li>
<li>思路二：构造双指针存历史记录；<ul>
<li>pre：正常遍历指针</li>
<li>cur：遍历重复结点的指针</li>
<li>删除：<code>pre = cur.next</code></li>
<li>关键点：边界处理（仔细查看代码的处理逻辑）</li>
</ul>
</li>
</ul>
<h2 id="算法描述-54"><a href="#算法描述-54" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给链表手工构建一个头结点，用于头结点重复被删除的情况</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        <span class="comment">//初始化指针</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val)&#123; <span class="comment">//遇到重复结点</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val) <span class="comment">//循环使cur指向最后一个重复的结点</span></span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                <span class="comment">// pre 连接新结点</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-15"><a href="#算法评价-15" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<hr>
<h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><h2 id="问题描述-19"><a href="#问题描述-19" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<br>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M 热度指数：290756<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h2><p>中序遍历的下一个结点，所以需要对树进行分类讨论，我本来写了一段，但是感觉绕来绕去，不太清晰，刚好发现了一个十分简洁清晰的版本，这里引入一下（来源：<a href="https://www.nowcoder.com/profile/773262" target="_blank" rel="noopener">小河沟大河沟</a>）。</p>
<p><img src="./image/../../../_images/Algorithm/Finger-offer67/BinaryTreeNextNode.png" alt="BinaryTreeNextNode"></p>
<blockquote>
<p>结合图，我们可发现分成两大类：</p>
<ol>
<li>有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） </li>
<li>没有右子树的，也可以分成两类:<ul>
<li>a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； </li>
<li>b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="算法描述-55"><a href="#算法描述-55" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从右子树找最左边的结点</span></span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无右子树，看父结点</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找当前结点是其父结点的左孩子的结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//回退到了根节点，pNode 就是最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><h2 id="问题描述-20"><a href="#问题描述-20" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h2><p>涉及到树，这里利用递归进行左右子树的比较很容易实现，同样本着能不递归就不递归的原则，利用栈的思想实现。实现起来的主要思路和递归一样，要注意的就是，每次入栈出栈操作都应该保证镜像结点成对同时进行操作。</p>
<h2 id="算法描述-56"><a href="#算法描述-56" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot.left);</span><br><span class="line">        stack.push(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//成对出栈比较镜像结点</span></span><br><span class="line">            TreeNode right = stack.pop();</span><br><span class="line">            TreeNode left = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//不构成镜像</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//左右应保持对称的结点成对进栈</span></span><br><span class="line">            stack.push(left.left);</span><br><span class="line">            stack.push(right.right);</span><br><span class="line">            stack.push(left.right);</span><br><span class="line">            stack.push(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><h2 id="问题描述-21"><a href="#问题描述-21" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code>  <code>树</code></p>
<h2 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先应该联想起来的就是二叉树的广度优先遍历，这两个有着异曲同工之妙。<br>两种办法，一般用队列实现，但是这里会涉及反转，比较麻烦，采用 reverse() 方法效率太低。所以，不如直接采用栈来实现。毕竟，栈和反转、树都是经常关联在一起的。   </p>
<p>本题分析思路：</p>
<ul>
<li>既然是层次遍历，那每次对栈进行进栈出栈都应该是以层为单位来循环的；</li>
<li>涉及到反转，应该是用两个栈以每层为单位来进行两个栈的互相捣鼓；</li>
<li>然后就是分析，怎么捣鼓？画图。</li>
</ul>
<p>本题思路：</p>
<ul>
<li>先把根节点入栈 1；</li>
<li>栈 1 栈顶元素出栈并记录，把根节点的<strong>左右</strong>孩子结点入栈 2；栈 1 空；</li>
<li>栈 2 栈顶元素出栈并记录，注意：因为要反转，这里孩子节点应该是按<strong>右左</strong>的顺序入栈 1，循环，直至栈 2 空，第二层遍历完毕；</li>
<li>循环进行……</li>
</ul>
<h2 id="算法描述-57"><a href="#算法描述-57" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//标记对哪个栈进行操作，就就是我们所谓的奇偶行</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//最终结果</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//没层的遍历结果</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop = s1.pop();</span><br><span class="line">                    res.add(pop.val);</span><br><span class="line">                    <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>) s2.add(pop.left);</span><br><span class="line">                    <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>) s2.add(pop.right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res); <span class="comment">//把本层的结果放入结果中</span></span><br><span class="line">                flag = <span class="number">2</span>; <span class="comment">//下一次就是对 s2 操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop = s2.pop();</span><br><span class="line">                    res.add(pop.val);</span><br><span class="line">                    <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>) s1.add(pop.right);</span><br><span class="line">                    <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>) s1.add(pop.left);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res); <span class="comment">//把本层的结果放入结果中</span></span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//下一次就是对 s2 操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><h2 id="问题描述-22"><a href="#问题描述-22" class="headerlink" title="问题描述"></a>问题描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> <code>树</code></p>
<h2 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题和上一题是同一类型的，而且在之前也有讨论过类似的（<a href="#cengcishuchuerchashu">返回到该题</a>），只需要使用个队列，然后用变量记录一下每层的结点数就可以。当然也可以像上一题，在这里用两个队列实现。</p>
<h2 id="算法描述-58"><a href="#算法描述-58" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录每层的节点个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            num = queue.size();<span class="comment">//每层结点出队完毕后，记录下一层结点的个数</span></span><br><span class="line">            <span class="comment">//每层的节点逐个出队，并将其左右孩子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="问题描述-23"><a href="#问题描述-23" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树；</p>
<ul>
<li>二叉树的序列化：<ul>
<li>把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存；</li>
<li>序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</li>
</ul>
</li>
<li>二叉树的反序列化：<ul>
<li>根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树；</li>
</ul>
</li>
</ul>
<p>例如，我们可以把一个只有根节点为 1 的二叉树序列化为 “1,”，然后通过自己的函数来解析回这个二叉树；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> <code>树</code></p>
<h2 id="解题思路-60"><a href="#解题思路-60" class="headerlink" title="解题思路"></a>解题思路</h2><p>关键在于捋清递归的思路；</p>
<h2 id="算法描述-59"><a href="#算法描述-59" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + <span class="string">"!"</span> + Serialize(root.left) + <span class="string">"!"</span> + Serialize(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] s = str.split(<span class="string">"!"</span>); <span class="comment">//将序列化之后的字符串用!分隔符转化为字符串数组</span></span><br><span class="line">        index++; <span class="comment">//索引每次加一</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s[index].equals(<span class="string">"#"</span>)) &#123;  <span class="comment">//不是叶子节点</span></span><br><span class="line">            treeNode = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">            treeNode.left = Deserialize(str);</span><br><span class="line">            treeNode.right = Deserialize(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树的第-k-个节点"><a href="#二叉搜索树的第-k-个节点" class="headerlink" title="二叉搜索树的第 k 个节点"></a>二叉搜索树的第 k 个节点</h1><h2 id="问题描述-24"><a href="#问题描述-24" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一棵二叉搜索树，请找出其中的第 k 小的结点；    </p>
<p>例如：（5，3，7，2，4，6，8）中，按结点数值大小顺序第 3 小结点的值为 4；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code> <code>树</code></p>
<h2 id="解题思路-61"><a href="#解题思路-61" class="headerlink" title="解题思路"></a>解题思路</h2><p>找二叉搜索树的第 k 小节点，相当于需要先对二叉树节点进行排序，才能知道第 k 小的节点是哪个。<br>而二叉搜索树的中序遍历结果，即将二叉搜索树的各个节点从小到大的排列，我们用栈来完成其中序遍历，而栈 pop 的序列就是二叉搜索树从小到大的输出序列。所以，只需要记录栈 pop 的次数，第 k 次 pop 时就是我们要找的数。</p>
<h2 id="算法描述-60"><a href="#算法描述-60" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = pRoot;</span><br><span class="line">        <span class="comment">//利用栈实现中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123; <span class="comment">//只要当前节点不为空就找左孩子</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//当前节点为空，出栈其父节点，然后找右节点</span></span><br><span class="line">                node = stack.pop(); <span class="comment">//出栈的顺序就是中序遍历的结果，也即从小到大的排列</span></span><br><span class="line">                <span class="keyword">if</span>(--k &lt;= <span class="number">0</span>)&#123;  <span class="comment">//计数第 k 小的数</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数据流中的位数"><a href="#数据流中的位数" class="headerlink" title="数据流中的位数"></a>数据流中的位数</h1><h2 id="问题描述-25"><a href="#问题描述-25" class="headerlink" title="问题描述"></a>问题描述</h2><p>如何得到一个数据流中的中位数？</p>
<ul>
<li>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值；</li>
<li>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值；</li>
</ul>
<p>使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code></p>
<h2 id="解题思路-62"><a href="#解题思路-62" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目一开始没明白它具体的意思，不太懂使用 Insert() 方法读取数据流是要干嘛，后来参看题解才知道，Insert() 方法主要是为了让我们能够构建一个数据结构，便于后面求解中位数。       </p>
<p>知道题目意思后，最先想到的思路就是把 Insert() 方法写成类似插入排序的算法，从而构建一个排好序的动态数组，但是这样有个问题就是每次插入的时候可能都需要移动整个数组，时间复杂度太高。    </p>
<p>然后又想到了 Insert() 方法只负责将数据存入数组，在使用 GetMedian() 方法时，就先对数组进行排序，但是这样时间复杂度依旧很高。时间关系，来不及再思考别的方法，等二刷的时候在仔细思考一下，直接参考了题解，用 <code>优先队列 PriorityQueue（堆）</code> 实现。</p>
<h2 id="算法描述-61"><a href="#算法描述-61" class="headerlink" title="算法描述"></a>算法描述</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆，用该堆记录位于中位数后面的部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大顶堆，用该堆记录位于中位数前面的部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="comment">//优先队列中的常用方法有：增加元素，删除栈顶，获得栈顶元素，和队列中的几个函数应该是一样的</span></span><br><span class="line">    <span class="comment">//offer peek poll,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可，所以我们要保证小顶堆中的元素的个数。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><h2 id="问题描述-26"><a href="#问题描述-26" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<br>例如：如果输入数组 <code>{2,3,4,2,6,2,5,1}</code> 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 <code>{4,4,6,6,6,5}</code>；</p>
<ul>
<li>针对数组 <code>{2,3,4,2,6,2,5,1}</code> 的滑动窗口有以下 6 个： </li>
<li><code>{[2,3,4],2,6,2,5,1}</code>，<code>{2,[3,4,2],6,2,5,1}</code>，<code>{2,3,[4,2,6],2,5,1}</code>，<code>{2,3,4,[2,6,2],5,1}</code>，<code>{2,3,4,2,[6,2,5],1}</code>，<code>{2,3,4,2,6,[2,5,1]}</code>；    </li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-63"><a href="#解题思路-63" class="headerlink" title="解题思路"></a>解题思路</h2><p>滑动窗口类型的题目接触的不多，但是我比较习惯直接用指针来遍历数组，对比网上流传的好多采用双端队列或者其他数据结构的，还是感觉用在这里有点杀猪用牛刀。（也是我比较菜，对高级数据结构掌握还不够熟练，等一刷结束，打算把这些数据结构，或者常用算法好好总结一番）</p>
<h2 id="算法描述-62"><a href="#算法描述-62" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span>||size == <span class="number">0</span> ||size&gt;num.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = num[<span class="number">0</span>];<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;  <span class="comment">//记录最大值下标，防止最大值过期</span></span><br><span class="line">        <span class="keyword">int</span> len = num.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size-<span class="number">1</span>;  <span class="comment">//滑动窗口边界</span></span><br><span class="line">        <span class="comment">//开始在数组中滑动窗口</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>((index &gt;= left)&amp;&amp;(index &lt;= right))&#123; <span class="comment">//保证最大值未过期</span></span><br><span class="line">                <span class="keyword">if</span>(max &lt; num[right])&#123;</span><br><span class="line">                    max = num[right];</span><br><span class="line">                    index = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//过期后，重新在窗口内循环遍历，更新最大值</span></span><br><span class="line">                <span class="comment">//初始定在窗口最左边的元素</span></span><br><span class="line">                max = num[left];</span><br><span class="line">                index = left;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i &lt;= right; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;num[i])&#123;</span><br><span class="line">                        max = num[i];</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="问题描述-27"><a href="#问题描述-27" class="headerlink" title="问题描述"></a>问题描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。   </p>
<p>例如：</p>
<script type="math/tex; mode=display">\begin{bmatrix}a & b & c & e\\\\s & f & c & s\\\\a & d & e & e\end{bmatrix}</script><p>矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M 热度指数：342994<br>本题知识点：<code>回溯法</code></p>
<h2 id="解题思路-64"><a href="#解题思路-64" class="headerlink" title="解题思路"></a>解题思路</h2><p>回溯法；</p>
<h2 id="算法描述-63"><a href="#算法描述-63" class="headerlink" title="算法描述"></a>算法描述</h2><p>找到个思路十分清晰的代码（来源：<a href="https://www.nowcoder.com/profile/7711710" target="_blank" rel="noopener">我去个地方啊</a>）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="问题描述-28"><a href="#问题描述-28" class="headerlink" title="问题描述"></a>问题描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0,0) 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的<strong>数位之和</strong>大于 k 的格子。<br>例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code> <code>回溯法</code></p>
<h2 id="解题思路-65"><a href="#解题思路-65" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题和上题是同一类型的题目，采用相同思路；</p>
<h2 id="算法描述-64"><a href="#算法描述-64" class="headerlink" title="算法描述"></a>算法描述</h2><p>这里也参照了同一人的代码，加上注释（来源：<a href="https://www.nowcoder.com/profile/7711710" target="_blank" rel="noopener">我去个地方啊</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];  <span class="comment">//存储某个位置的格子能否到达，避免递归中重复检查某个位置导致死循环</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断，judge(索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，给定的最大数位和，存储该位置能否进入的矩阵)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> threshold,<span class="keyword">boolean</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || flag[i][j]==<span class="keyword">true</span> || getK(i)+getK(j) &gt; threshold)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上述条件的位置就说明可以到达，置标志位</span></span><br><span class="line">        flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//从当前位置递归继续向其余四个方向查找，并因为当前位置可达，总格子数+1</span></span><br><span class="line">        <span class="keyword">return</span> judge(i+<span class="number">1</span>,j,rows,cols,threshold,flag) +</span><br><span class="line">                 judge(i-<span class="number">1</span>,j,rows,cols,threshold,flag) +</span><br><span class="line">                    judge(i,j+<span class="number">1</span>,rows,cols,threshold,flag) +</span><br><span class="line">                        judge(i,j-<span class="number">1</span>,rows,cols,threshold,flag) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求每个位置行坐标和列坐标的数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>((num=num/<span class="number">10</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><h2 id="问题描述-29"><a href="#问题描述-29" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为 $k[0],k[1],…,k[m]$。请问 $k[0] \times k[1] \times…\times k[m]$ 可能的最大乘积是多少？<br>例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 64M，其他语言128M<br>本题知识点： <code>贪心</code></p>
<h2 id="解题思路-66"><a href="#解题思路-66" class="headerlink" title="解题思路"></a>解题思路</h2><p>最后一题了，看到这题，哈哈，想着就充分的利用下自己的数学优势吧！<br>完全数学分析解法，详细分析过程：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Cutshengzi.png" alt="Cutshengzi"></p>
<p>结论：尽量将绳子剪的只有 2 和 3 这两种长度，并且尽量保证 3 的个数更多。</p>
<h2 id="算法描述-65"><a href="#算法描述-65" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> x = target % <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">int</span> y = target / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)  <span class="comment">//刚好能被全部剪成3的长度</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="comment">//全部按照3的长度，最后剩下了一个1，需要把3少算一段，变成两个2长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * <span class="number">2</span> * (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//最后刚好剩一个2长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他解法，基于 <code>python</code>：</p>
<ol>
<li><p>递归解法：</p>
<ul>
<li>我们先定义函数 f(n) 为把绳子剪成若干段之后的各段长度乘积的最大值。在剪第一刀的时候，我们会有 n-1 种可能的选择，也就是说剪出来的第一段绳子的长度可能为 1,2,……n-1。因此就有了递归公式 f(n) = max(f(i)*f(n-i))，其中 0 &lt; i &lt; n 。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###链接：https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion</span></span><br><span class="line"><span class="comment">###来源：牛客网</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>       </span><br><span class="line">    <span class="keyword">return</span> self.cutRopeCore(number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRopeCore</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line">    max_ = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number/<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        max_ = max(self.cutRopeCore(i) * self.cutRopeCore(number - i), max_)</span><br><span class="line">    <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>动态规划：</p>
<ul>
<li>接着上面的递归解法我们可以将其转换成动态规划的写法。由于这是一个从上至下的递归公式，递归会出现很多大量不必要的计算，一个很好的方法就是按照从下而上的顺序计算，即:</li>
<li>我们先得到 f(2),f(3)，再得到 f(4),f(5)，直到 f(n)。</li>
<li>我们可以得知 f(2)=1, f(3)=2<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###链接：https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion</span></span><br><span class="line"><span class="comment">###来源：牛客网</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>       </span><br><span class="line">    <span class="comment">#申请辅助空间</span></span><br><span class="line">    products = [<span class="number">0</span>]*(number+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#定义前几个初始变量的值</span></span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    <span class="comment">#进行动态规划,也就是从下向上的进行求解</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, number+<span class="number">1</span>):</span><br><span class="line">        max_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i/<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            max_ = max(products[j]*products[i-j], max_)</span><br><span class="line">        products[i] = max_</span><br><span class="line"></span><br><span class="line">    max_ = products[number]</span><br><span class="line">    <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>从 2010-04-05 到 2010-05-09 历时三十多天，利用闲暇时间完成了《剑指offer》的一刷，这个过程中明显感觉到自己在一些数据结构和 java 知识点的掌握上有所不足。    </p>
<p>下一阶段，会对这段时间来的刷题进行一波沉淀，准备好好总结算法中的一些数据结构、常用算法和一些解题思路。并再对 java 知识点进行一波查漏补缺。看后面这段时间的课程安排吧，初步打算在两周时间左右完成。    </p>
<p>然后就要进军 LeetCode 了，待 LeetCode 刷完 100 题后，再回来对《剑指offer》进行二刷。这就是目前的计划安排了。    </p>
<div align="center"><span style="background-color:black; color:#FF0000;font-size:24px;"> Let's fight！</span></div>
    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="TheBetterKong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="TheBetterKong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>TheBetterKong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/" title="剑指 offer 67题">http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a>
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/04/Blog-Related/Blog-Establish/" rel="prev" title="Blog 搭建">
      <i class="fa fa-chevron-left"></i> Blog 搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/10/FPGA-technology/FPGA-ClockNetwork/" rel="next" title="FPGA-Clock Network">
      FPGA-Clock Network <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#二维数组中的查找"><span class="nav-number">1.</span> <span class="nav-text">二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路"><span class="nav-number">1.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述"><span class="nav-number">1.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价"><span class="nav-number">1.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#替换空格"><span class="nav-number">2.</span> <span class="nav-text">替换空格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-1"><span class="nav-number">2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-1"><span class="nav-number">2.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-1"><span class="nav-number">2.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-1"><span class="nav-number">2.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从尾到头打印链表"><span class="nav-number">3.</span> <span class="nav-text">从尾到头打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-2"><span class="nav-number">3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-2"><span class="nav-number">3.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-2"><span class="nav-number">3.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-2"><span class="nav-number">3.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重建二叉树"><span class="nav-number">4.</span> <span class="nav-text">重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-3"><span class="nav-number">4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-3"><span class="nav-number">4.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-3"><span class="nav-number">4.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-3"><span class="nav-number">4.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用两个栈实现队列"><span class="nav-number">5.</span> <span class="nav-text">用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-4"><span class="nav-number">5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-4"><span class="nav-number">5.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-4"><span class="nav-number">5.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#旋转数组的最小数字"><span class="nav-number">6.</span> <span class="nav-text">旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-5"><span class="nav-number">6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-5"><span class="nav-number">6.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-5"><span class="nav-number">6.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-4"><span class="nav-number">6.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#斐波拉契数列"><span class="nav-number">7.</span> <span class="nav-text">斐波拉契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述"><span class="nav-number">7.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-6"><span class="nav-number">7.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-6"><span class="nav-number">7.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跳台阶问题"><span class="nav-number">8.</span> <span class="nav-text">跳台阶问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-1"><span class="nav-number">8.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-7"><span class="nav-number">8.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-7"><span class="nav-number">8.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变态跳台阶"><span class="nav-number">9.</span> <span class="nav-text">变态跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-6"><span class="nav-number">9.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-8"><span class="nav-number">9.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-8"><span class="nav-number">9.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#矩形覆盖"><span class="nav-number">10.</span> <span class="nav-text">矩形覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-7"><span class="nav-number">10.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-9"><span class="nav-number">10.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-9"><span class="nav-number">10.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二进制中1的个数"><span class="nav-number">11.</span> <span class="nav-text">二进制中1的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-8"><span class="nav-number">11.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-10"><span class="nav-number">11.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-10"><span class="nav-number">11.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-5"><span class="nav-number">11.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数值的整数次方"><span class="nav-number">12.</span> <span class="nav-text">数值的整数次方</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-9"><span class="nav-number">12.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-11"><span class="nav-number">12.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-11"><span class="nav-number">12.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#调整数组顺序使奇数位于偶数前"><span class="nav-number">13.</span> <span class="nav-text">调整数组顺序使奇数位于偶数前</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-2"><span class="nav-number">13.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-12"><span class="nav-number">13.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-12"><span class="nav-number">13.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-6"><span class="nav-number">13.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表中倒数第k个结点"><span class="nav-number">14.</span> <span class="nav-text">链表中倒数第k个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-10"><span class="nav-number">14.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-13"><span class="nav-number">14.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-13"><span class="nav-number">14.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-7"><span class="nav-number">14.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#反转链表"><span class="nav-number">15.</span> <span class="nav-text">反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-11"><span class="nav-number">15.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-14"><span class="nav-number">15.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-14"><span class="nav-number">15.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-8"><span class="nav-number">15.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合并两个排序的链表"><span class="nav-number">16.</span> <span class="nav-text">合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-12"><span class="nav-number">16.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-15"><span class="nav-number">16.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-15"><span class="nav-number">16.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-9"><span class="nav-number">16.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树的子结构"><span class="nav-number">17.</span> <span class="nav-text">树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-13"><span class="nav-number">17.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-16"><span class="nav-number">17.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-16"><span class="nav-number">17.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的镜像"><span class="nav-number">18.</span> <span class="nav-text">二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-14"><span class="nav-number">18.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-17"><span class="nav-number">18.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-17"><span class="nav-number">18.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#顺时针打印矩阵"><span class="nav-number">19.</span> <span class="nav-text">顺时针打印矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-15"><span class="nav-number">19.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-18"><span class="nav-number">19.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-18"><span class="nav-number">19.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包含-min-函数的栈"><span class="nav-number">20.</span> <span class="nav-text">包含 min 函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-16"><span class="nav-number">20.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-19"><span class="nav-number">20.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-19"><span class="nav-number">20.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-10"><span class="nav-number">20.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈的压入、弹出序列"><span class="nav-number">21.</span> <span class="nav-text">栈的压入、弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-17"><span class="nav-number">21.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-20"><span class="nav-number">21.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-20"><span class="nav-number">21.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从上往下打印二叉树"><span class="nav-number">22.</span> <span class="nav-text">从上往下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-18"><span class="nav-number">22.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-21"><span class="nav-number">22.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-21"><span class="nav-number">22.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉搜索树的后序遍历序列"><span class="nav-number">23.</span> <span class="nav-text">二叉搜索树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-19"><span class="nav-number">23.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-22"><span class="nav-number">23.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-22"><span class="nav-number">23.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树中和为某一值的路径"><span class="nav-number">24.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-20"><span class="nav-number">24.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-23"><span class="nav-number">24.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-23"><span class="nav-number">24.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复杂链表的复制"><span class="nav-number">25.</span> <span class="nav-text">复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-21"><span class="nav-number">25.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-24"><span class="nav-number">25.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-24"><span class="nav-number">25.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉搜索树与双向链表"><span class="nav-number">26.</span> <span class="nav-text">二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-22"><span class="nav-number">26.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-25"><span class="nav-number">26.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-25"><span class="nav-number">26.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-11"><span class="nav-number">26.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串的排列"><span class="nav-number">27.</span> <span class="nav-text">字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-23"><span class="nav-number">27.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-26"><span class="nav-number">27.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-26"><span class="nav-number">27.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-12"><span class="nav-number">27.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组中出现次数超过一半的数组"><span class="nav-number">28.</span> <span class="nav-text">数组中出现次数超过一半的数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-24"><span class="nav-number">28.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-27"><span class="nav-number">28.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-27"><span class="nav-number">28.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-13"><span class="nav-number">28.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最小的k个数"><span class="nav-number">29.</span> <span class="nav-text">最小的k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-25"><span class="nav-number">29.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-28"><span class="nav-number">29.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-28"><span class="nav-number">29.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连续子数组的最大和"><span class="nav-number">30.</span> <span class="nav-text">连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-26"><span class="nav-number">30.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-29"><span class="nav-number">30.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-29"><span class="nav-number">30.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从-1-到-n-的整数中-1-出现的次数"><span class="nav-number">31.</span> <span class="nav-text">从 1 到 n 的整数中 1 出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-27"><span class="nav-number">31.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-30"><span class="nav-number">31.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码描述"><span class="nav-number">31.3.</span> <span class="nav-text">代码描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#把数组排成最小的数"><span class="nav-number">32.</span> <span class="nav-text">把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-28"><span class="nav-number">32.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-31"><span class="nav-number">32.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-30"><span class="nav-number">32.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#丑数"><span class="nav-number">33.</span> <span class="nav-text">丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-29"><span class="nav-number">33.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-32"><span class="nav-number">33.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-31"><span class="nav-number">33.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一个只出现一次的字符"><span class="nav-number">34.</span> <span class="nav-text">第一个只出现一次的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-3"><span class="nav-number">34.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-33"><span class="nav-number">34.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-32"><span class="nav-number">34.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组中的逆序对"><span class="nav-number">35.</span> <span class="nav-text">数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-4"><span class="nav-number">35.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-34"><span class="nav-number">35.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-33"><span class="nav-number">35.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两个链表的第一个公共结点"><span class="nav-number">36.</span> <span class="nav-text">两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-30"><span class="nav-number">36.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-35"><span class="nav-number">36.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-34"><span class="nav-number">36.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数字在排序数组中出现的次数"><span class="nav-number">37.</span> <span class="nav-text">数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-31"><span class="nav-number">37.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-36"><span class="nav-number">37.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-35"><span class="nav-number">37.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的深度"><span class="nav-number">38.</span> <span class="nav-text">二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-5"><span class="nav-number">38.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-37"><span class="nav-number">38.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-36"><span class="nav-number">38.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">39.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-32"><span class="nav-number">39.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-38"><span class="nav-number">39.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-37"><span class="nav-number">39.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组中只出现一次的数字"><span class="nav-number">40.</span> <span class="nav-text">数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-33"><span class="nav-number">40.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-39"><span class="nav-number">40.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-38"><span class="nav-number">40.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#和位-S-的连续正数序列"><span class="nav-number">41.</span> <span class="nav-text">和位 S 的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-6"><span class="nav-number">41.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-40"><span class="nav-number">41.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-39"><span class="nav-number">41.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#和为-s-的两个数字"><span class="nav-number">42.</span> <span class="nav-text">和为 s 的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-7"><span class="nav-number">42.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-41"><span class="nav-number">42.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-40"><span class="nav-number">42.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-14"><span class="nav-number">42.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#左旋转字符串"><span class="nav-number">43.</span> <span class="nav-text">左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-34"><span class="nav-number">43.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-42"><span class="nav-number">43.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-41"><span class="nav-number">43.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#翻转单词顺序列"><span class="nav-number">44.</span> <span class="nav-text">翻转单词顺序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-35"><span class="nav-number">44.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-43"><span class="nav-number">44.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-42"><span class="nav-number">44.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#扑克牌顺子"><span class="nav-number">45.</span> <span class="nav-text">扑克牌顺子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-8"><span class="nav-number">45.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-44"><span class="nav-number">45.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-43"><span class="nav-number">45.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#圆圈中最后剩下的数"><span class="nav-number">46.</span> <span class="nav-text">圆圈中最后剩下的数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-9"><span class="nav-number">46.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-45"><span class="nav-number">46.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-44"><span class="nav-number">46.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#求-1-2-…-n"><span class="nav-number">47.</span> <span class="nav-text">求 1+2+…+n</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-10"><span class="nav-number">47.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-46"><span class="nav-number">47.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-45"><span class="nav-number">47.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不用加减乘除做加法"><span class="nav-number">48.</span> <span class="nav-text">不用加减乘除做加法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-11"><span class="nav-number">48.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-47"><span class="nav-number">48.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-46"><span class="nav-number">48.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#把字符串转换成整数"><span class="nav-number">49.</span> <span class="nav-text">把字符串转换成整数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-12"><span class="nav-number">49.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-48"><span class="nav-number">49.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-47"><span class="nav-number">49.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">49.4.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组中重复的数字"><span class="nav-number">50.</span> <span class="nav-text">数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-13"><span class="nav-number">50.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-49"><span class="nav-number">50.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-48"><span class="nav-number">50.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构建乘积数组"><span class="nav-number">51.</span> <span class="nav-text">构建乘积数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-14"><span class="nav-number">51.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-50"><span class="nav-number">51.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-49"><span class="nav-number">51.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正则表达式匹配"><span class="nav-number">52.</span> <span class="nav-text">正则表达式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-15"><span class="nav-number">52.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-51"><span class="nav-number">52.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-50"><span class="nav-number">52.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#表示数值的字符串"><span class="nav-number">53.</span> <span class="nav-text">表示数值的字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目描述-36"><span class="nav-number">53.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-52"><span class="nav-number">53.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-51"><span class="nav-number">53.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符流中第一个不重复的字符"><span class="nav-number">54.</span> <span class="nav-text">字符流中第一个不重复的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-16"><span class="nav-number">54.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-53"><span class="nav-number">54.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-52"><span class="nav-number">54.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表中环的入口节点"><span class="nav-number">55.</span> <span class="nav-text">链表中环的入口节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-17"><span class="nav-number">55.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-54"><span class="nav-number">55.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-53"><span class="nav-number">55.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除链表中重复的结点"><span class="nav-number">56.</span> <span class="nav-text">删除链表中重复的结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-18"><span class="nav-number">56.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-55"><span class="nav-number">56.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-54"><span class="nav-number">56.3.</span> <span class="nav-text">算法描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法评价-15"><span class="nav-number">56.4.</span> <span class="nav-text">算法评价</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉树的下一个结点"><span class="nav-number">57.</span> <span class="nav-text">二叉树的下一个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-19"><span class="nav-number">57.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-56"><span class="nav-number">57.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-55"><span class="nav-number">57.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对称的二叉树"><span class="nav-number">58.</span> <span class="nav-text">对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-20"><span class="nav-number">58.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-57"><span class="nav-number">58.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-56"><span class="nav-number">58.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#按之字形顺序打印二叉树"><span class="nav-number">59.</span> <span class="nav-text">按之字形顺序打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-21"><span class="nav-number">59.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-58"><span class="nav-number">59.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-57"><span class="nav-number">59.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#把二叉树打印成多行"><span class="nav-number">60.</span> <span class="nav-text">把二叉树打印成多行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-22"><span class="nav-number">60.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-59"><span class="nav-number">60.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-58"><span class="nav-number">60.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列化二叉树"><span class="nav-number">61.</span> <span class="nav-text">序列化二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-23"><span class="nav-number">61.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-60"><span class="nav-number">61.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-59"><span class="nav-number">61.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉搜索树的第-k-个节点"><span class="nav-number">62.</span> <span class="nav-text">二叉搜索树的第 k 个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-24"><span class="nav-number">62.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-61"><span class="nav-number">62.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-60"><span class="nav-number">62.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据流中的位数"><span class="nav-number">63.</span> <span class="nav-text">数据流中的位数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-25"><span class="nav-number">63.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-62"><span class="nav-number">63.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-61"><span class="nav-number">63.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#滑动窗口的最大值"><span class="nav-number">64.</span> <span class="nav-text">滑动窗口的最大值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-26"><span class="nav-number">64.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-63"><span class="nav-number">64.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-62"><span class="nav-number">64.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#矩阵中的路径"><span class="nav-number">65.</span> <span class="nav-text">矩阵中的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-27"><span class="nav-number">65.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-64"><span class="nav-number">65.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-63"><span class="nav-number">65.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#机器人的运动范围"><span class="nav-number">66.</span> <span class="nav-text">机器人的运动范围</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-28"><span class="nav-number">66.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-65"><span class="nav-number">66.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-64"><span class="nav-number">66.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#剪绳子"><span class="nav-number">67.</span> <span class="nav-text">剪绳子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#问题描述-29"><span class="nav-number">67.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路-66"><span class="nav-number">67.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述-65"><span class="nav-number">67.3.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#写在最后"><span class="nav-number">68.</span> <span class="nav-text">写在最后</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheBetterKong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheBetterKong</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheBetterKong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheBetterKong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kongxiangfeng@iie.ac.cn" title="E-Mail → mailto:kongxiangfeng@iie.ac.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_44849403" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44849403" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6460669623" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6460669623" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.cugxuan.cn/" title="https:&#x2F;&#x2F;blog.cugxuan.cn&#x2F;" rel="noopener" target="_blank">泫</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://paper.seebug.org/" title="https:&#x2F;&#x2F;paper.seebug.org&#x2F;" rel="noopener" target="_blank">Paper seebug</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.runoob.com/" title="https:&#x2F;&#x2F;www.runoob.com&#x2F;" rel="noopener" target="_blank">菜鸟教程</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wiki.jikexueyuan.com/" title="https:&#x2F;&#x2F;wiki.jikexueyuan.com&#x2F;" rel="noopener" target="_blank">极客学院Wiki</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://man.linuxde.net/" title="https:&#x2F;&#x2F;man.linuxde.net&#x2F;" rel="noopener" target="_blank">Linux大全</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备20005224号 </a>
  </div>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheBetterKong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


<div class="statistics">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  <span id="busuanzi_value_site_uv"></span>
</span>
<span class ="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
  <span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共249.6k字</span>
  <span class ="post-time-divider">|</span>
    <span>运行<span id="showDays"></span></span>
  <script>
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var birthDay = Date.UTC(2020,04,20,18,00,00); // 这里设置建站时间
    setInterval(function() {
      var today = new Date();
      var todayYear = today.getFullYear();
      var todayMonth = today.getMonth()+1;
      var todayDate = today.getDate();
      var todayHour = today.getHours();
      var todayMinute = today.getMinutes();
      var todaySecond = today.getSeconds();
      var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
      var diff = now - birthDay;
      var diffYears = Math.floor(diff/years);
      var diffDays = Math.floor((diff/days)-diffYears*365);
      var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
      var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
      var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+"年"+diffDays+"天"+diffHours+"小时"+diffMinutes+"分钟"+diffSeconds+"秒";
    }, 1000);
  </script>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FzJ2kTqyh92urg7N9KHkL0RA-9Nh9j0Va',
      appKey     : 'aTVY6lFVOvNPNgaDGtgHVoQy',
      placeholder: "期待您的留言！",
      avatar     : '',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
