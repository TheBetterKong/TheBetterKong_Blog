<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">



<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.thebetterkong.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="排序（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法（详解 + java 实现）">
<meta property="og:url" content="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/index.html">
<meta property="og:site_name" content="TheBetterKong">
<meta property="og:description" content="排序（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gInsertSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/2WayInsert.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gShellSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/ShellSort.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBubbleSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gQuickSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gSelectionSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/TreeSelectSort.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/BuildHeap.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/Sink.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gHeapSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gMergeSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gCountingSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBucketSort.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/gRadixSort.gif">
<meta property="article:published_time" content="2020-06-04T06:58:23.000Z">
<meta property="article:modified_time" content="2020-08-14T09:29:12.959Z">
<meta property="article:author" content="TheBetterKong">
<meta property="article:tag" content="java">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png">

<link rel="canonical" href="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>排序算法（详解 + java 实现） | TheBetterKong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TheBetterKong" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TheBetterKong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">自律即自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheBetterKong">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheBetterKong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序算法（详解 + java 实现）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-04 14:58:23" itemprop="dateCreated datePublished" datetime="2020-06-04T14:58:23+08:00">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-14 17:29:12" itemprop="dateModified" datetime="2020-08-14T17:29:12+08:00">2020-08-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStructure-Algorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructure & Algorithm</span></a>
                </span>
            </span>

          
            <span id="/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/" class="post-meta-item leancloud_visitors" data-flag-title="排序算法（详解 + java 实现）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div align="center"> <img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。</p>
<a id="more"></a> 
<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，我们会将排序算法分为两个大类：     </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部排序</td>
<td>（本文主要讨论的）待排序记录存放在计算机随机存储器中进行的排序过程；</td>
</tr>
<tr>
<td>外部排序</td>
<td>待排序记录的数量很大，以至于内存一次不能够容纳全部记录，在排序过程中尚需对外村进行访问的排序过程；</td>
</tr>
</tbody>
</table>
</div>
<p>在排序算法中，为了衡量每一种算法的性能，我们通常会提及如下概念：     </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>稳定排序</td>
<td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序；</td>
</tr>
<tr>
<td>非稳定排序</td>
<td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序；</td>
</tr>
<tr>
<td>原地排序</td>
<td>在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间来进行比较和交换，从而完成排序；</td>
</tr>
<tr>
<td>非原地排序</td>
<td>需要利用额外的数组来辅助排序；</td>
</tr>
</tbody>
</table>
</div>
<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ul>
<li><strong>依据排序原则可分为 5 大类</strong>：插入排序、交换排序、选择排序、归并排序、计数排序</li>
<li><strong>按算法时间分为 3 大类</strong>：简单排序 $O(n^2)$、先进排序 $O(nlogn)$、基数排序 $O(d \cdot n)$</li>
</ul>
<p>接下来介绍的各种排序算法都可以归入上述各个分类；</p>
<h2 id="规律总述"><a href="#规律总述" class="headerlink" title="规律总述"></a>规律总述</h2><p>排序过程中都会进行两种基本操作：</p>
<ol>
<li>比较两个关键字大小；（对大多数排序方法都是必要的）</li>
<li>将记录从一个位置移动到另一个位置；（可通过改变记录的存储方式来避免）</li>
</ol>
<p>待排序记录的 3 种存储方式：    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储方式</th>
<th>记录之间的次序关系</th>
<th>排序实现方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址连续的一组存储单元上（例如：线性表）</td>
<td>由存储位置决定</td>
<td>必须借助记录移动</td>
</tr>
<tr>
<td>（链表排序）静态链表中</td>
<td>指针指示</td>
<td>修改指针即可</td>
</tr>
<tr>
<td>（地址排序）记录本身存储在一组地址连续的存储单元内，同时又设一个指示各个记录存储位置的地址向量</td>
<td></td>
<td>先移动地址向量中记录的“地址”，排序结束后再按地址向量中的值调整记录的存储位置</td>
</tr>
</tbody>
</table>
</div>
<p>本文主要是介绍排序算法的思想，为方便讨论，默认所介绍的排序算法都是基于第一种存储方式，且待排序记录的关键字均为整数；</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>基于 “插入” 操作进行的排序方式；</p>
<h2 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h2><p><strong>基本操作</strong>：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</p>
<ul>
<li>整个过程可以理解为，打扑克牌时，你是怎样来捋扑克牌的顺序的？</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gInsertSort.gif" alt="InsertSort"></p>
<p><strong>缺点</strong>：无序数组排序时，为了插入元素，需要将其余所有元素在插入之前都向右移动一位；</p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的排序算法：直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 开始 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从当前位置向前寻找插入位置</span></span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp)</span><br><span class="line">            k--;</span><br><span class="line">        <span class="comment">//找到要插的位置 k + 1，移动元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &gt; k + <span class="number">1</span>; j--)</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        arr[k+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>稳定排序，原地排序 </li>
</ul>
<h3 id="改进：折半插入"><a href="#改进：折半插入" class="headerlink" title="改进：折半插入"></a>改进：折半插入</h3><p><strong>基本思路</strong>：在直接插入排序的过程中，将 “搜索插入位置” 这一步骤利用 “折半查找实现”   </p>
<p><strong>评价</strong>：不可取，仅仅减少了直接插入排序中关键字间的比较次数，而记录的移动次数不变，时间复杂度仍为：$O(n^2)$。    </p>
<h3 id="改进：2-路插入"><a href="#改进：2-路插入" class="headerlink" title="改进：2-路插入"></a>改进：2-路插入</h3><p><strong>目标</strong>：减少排序过程中移动记录的次数    </p>
<p><strong>具体思路</strong>：</p>
<ul>
<li>假设，待排序数组为 L.r，新设一个同类型的数组 d；</li>
<li><code>d[0] = L.r[0]</code>，并将 <code>d[0]</code> 看做排好序的序列中处于中间位置的记录；</li>
<li>然后，从 <code>L.r[1]</code> 开始，依次插入到 <code>d[0]</code> 之前和之后的已排好序的有序表中</li>
<li>例子：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/2WayInsert.png" alt="2WayInsert"><ul>
<li>first 和 final 是两个指针，分别指向排序过程中得到的有序列表里第一个记录和最后一个记录在 d 中的位置；</li>
</ul>
</li>
</ul>
<p><strong>评价</strong>：不可取，带来了新的空间开销，也只是减少移动记录的次数（不能完全避免），并且如果 <code>L.r[0]</code> 就是待排序列表里最大或最小的元素，则此方法优越性完全失效；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用插入排序，那么在排序过程中就不可避免的需要移动记录，否则，只能改变其存储结构（之前提及的：链式排序、地址排序）。</p>
<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>又称：缩小增量排序</p>
<p><strong>基本思想</strong>：先将整个待排记录序列分割为若干个子序列，对子序列分别进行直接插入排序，待整个序列的记录 “基本有序” 时，再对全体记录进行一次直接插入排序。    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gShellSort.gif" alt="ShellSort"></p>
<p><strong>过程举例</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/ShellSort.png" alt="ShellSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//默认步长为数组长度除以2</span></span><br><span class="line">    <span class="keyword">int</span> step = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        step = step / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//确定分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            <span class="comment">//对分组数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + step; j &lt; arr.length; j = j + step) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="keyword">for</span>( k = j-step; k &gt;= <span class="number">0</span>; k = k-step)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                        arr[k+step] = arr[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k+step] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：与选取的 “增量” 序列函数直接相关，目前为止，没有人能找出最优的 “增量” 序列函数，上述算法中，复杂度为 $O(nlogn)$</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基于 “交换” 操作进行的排序方式；<strong>快排</strong>（Quick Sort）是基于<strong>冒泡排序</strong>（Bubble Sort）的一种改进排序算法。</p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p><strong>基本思想</strong>：第 i 趟冒泡排序，从 <code>L[0]</code> 到 <code>L[n-1-i]</code> 依次比较每个记录与其下一个记录的大小，并在 “逆序” 时交换这两个记录（最终结果是，这 n-i+1 个记录里，最大值被交换到 n-i 的位置）；完成整个排序过程，也就需要有 $k(1\leq k&lt;n)$ 趟，判断结束的条件为：某趟冒泡过程中不出现交换操作。</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBubbleSort.gif" alt="BubbleSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最优的冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j , k;</span><br><span class="line">    <span class="keyword">int</span> flag = a.length; <span class="comment">// flag记录每趟冒泡的尾边界，同时也作为算法结束的标志</span></span><br><span class="line">    <span class="comment">// 用 flag 标记算法是否结束</span></span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)&#123; </span><br><span class="line">        k = flag;   <span class="comment">// k记录某趟遍历的尾边界</span></span><br><span class="line">        flag = <span class="number">0</span>;   <span class="comment">// 只要不发生交换，就不会进行下一趟冒泡，算法结束</span></span><br><span class="line">        <span class="comment">// 冒泡开始：</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="comment">//前面的数字大于后面的数字就交换a[j-1]和a[j]</span></span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">                <span class="comment">// 发生了交换，让flag重新记录新的尾边界</span></span><br><span class="line">                flag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>稳定排序、原地排序</li>
</ul>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p><strong>基本思想</strong>：通过一趟排序将待排记录分割为独立的两部分，其中一部分的关键字均比另一部分的关键字小，再分别对这两部分进行排序，已达到整个序列有序的目的；</p>
<ul>
<li>设定两个指针 low 和 high，初始时指向开头和结尾位置；枢值记录关键字 key，初始为第一个元素值；</li>
<li>先从 high 指示位置向前搜索，找到第一个值小于 key 的记录，和 key 交换位置；</li>
<li>然后从 low 位置起向后搜索，找到第一个值大于 key 的记录，和 key 交换位置；</li>
<li>重复上面两步，直至 low=high；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gQuickSort.gif" alt="QuickSort">  </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low &lt; index -<span class="number">1</span>)</span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>); <span class="comment">//区间左右都是闭包</span></span><br><span class="line">        <span class="keyword">if</span> (high &gt; index + <span class="number">1</span>)</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排的非递归实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//基于栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        stack.push(high);</span><br><span class="line">        stack.push(low);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> index = partition(a, l, h);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h &gt; index + <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(h);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间函数：某一趟快排的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="comment">// 将序列排列至枢纽两端</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从high向前，找第一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[high] &gt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从low向后，找第一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[low] &lt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在枢纽两端的元素位置都确定后，枢纽的位置也就确定了</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">// 返回枢纽位置，进行下一趟排序</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>空间复杂度：$O(logn)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h2><p><strong>主要思路</strong>：每一趟在 $n-i+1\ (i=1,2,…,n-1)$ 个记录中选取关键字最小的记录作为有序序列中第 i 个记录    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gSelectionSort.gif" alt="SelectionSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// 共 n-1 轮选择排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从未排序的[i，n-1]的序列中，选择最小元素</span></span><br><span class="line">        <span class="keyword">int</span> min = i;  <span class="comment">//先默认a[i]是最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span>(a[min] &gt; a[j])  <span class="comment">//找到更小的值，就更新</span></span><br><span class="line">                min = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换，使最小的元素位于a[i]位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[min];</span><br><span class="line">        a[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p><strong>目的</strong>：减少比较的次数</p>
<p><strong>理论基础</strong>：竞标赛比赛机制</p>
<ul>
<li>8 名运动员选出前 3 名，最多只需要 11 场比赛；</li>
<li>第一轮：7 场比赛决出冠军</li>
<li>第二轮：2 场比赛决出亚军</li>
<li>第三轮：2 场比赛决出季军</li>
</ul>
<p><strong>详情</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/TreeSelectSort.png" alt="TreeSelectSort"></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>缺点：所需的辅助空间太大、和最大值进行了多余的比较；</li>
<li>于是，进一步改进为：堆排序算法</li>
</ul>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆</strong>：一个完全二叉树里，每个结点的值都大（小）于其左右孩子（如果存在的话）节点的值，则称这样的二叉树为大（小）顶堆    </p>
<p><strong>堆排特点</strong>：只需要一个记录大小的辅助空间，每个待排序的记录只占有一个存储空间   </p>
<p><strong>基本思想</strong>：</p>
<ul>
<li>初始建堆：<ul>
<li>将序列按层次遍历看成是一个完全二叉树，则最后一个非终端节点是第 $\lfloor n/2 \rfloor$ 个元素；</li>
<li>因此，从第 $\lfloor n/2 \rfloor$ 个元素开始，往前对每个结点，反复 “下沉” 调整：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/BuildHeap.png" alt="BuildHeap"></li>
</ul>
</li>
<li>循环删除，下沉：<ul>
<li>删除堆顶，把删除的元素放在二叉树最后一个位置；</li>
<li>“下沉” 调整；<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/Sink.png" alt="Sink"></li>
</ul>
</li>
</ul>
<p><strong>过程展示</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gHeapSort.gif" alt="HeapSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 堆排序</span></span><br><span class="line"><span class="comment">*  下沉操作，执行删除操作相当于把最后</span></span><br><span class="line"><span class="comment">*  * 一个元素赋给根元素之后，然后对根元素执行下沉操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent 要下沉元素的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="comment">// 从最后一个非终端节点开始，不断往前下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶元素与最后一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// 把打乱的堆进行调整，恢复堆的特性</span></span><br><span class="line">        downAdjust(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆调整：下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时保存要下沉的元素</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">    <span class="comment">//定位左孩子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//开始下沉，需一直下沉至堆底</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子节点比左孩子大，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">// 如果孩子节点小于或等于父节点，则下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父节点进行下沉</span></span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">//更新孩子，继续下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp; <span class="comment">//下沉完毕，完成交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$，时间主要浪费在初始建堆和堆调整时的下沉操作上</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
<li>适用情景：对记录较少的文件并不提倡，但对 n 较大的文件还是很有效的；</li>
</ul>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p><strong>基本思路</strong>：（2-路归并）假设初始序列含有 n 个记录，则可以看成 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 $\lceil \frac{n}{2} \rceil$ 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止；</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gMergeSort.gif" alt="MergeSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序（递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归地对左右两边进行排序</span></span><br><span class="line">        MergeSort(arr, low, mid);</span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序（非递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 1开始分割，与递归不同的是，递归由数组长度一分为二最后到1，</span></span><br><span class="line">    <span class="comment">// 而非递归则是从1开始扩大二倍直到数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;	    </span><br><span class="line">    <span class="keyword">while</span> (arr.length &gt; len) &#123;    </span><br><span class="line">        <span class="comment">// 完全二叉树一层内的遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= arr.length - <span class="number">1</span>; i += len * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> mid = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i + len * <span class="number">2</span> - <span class="number">1</span>;	            </span><br><span class="line">            <span class="comment">// 防止超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; arr.length - <span class="number">1</span>)</span><br><span class="line">                right = arr.length - <span class="number">1</span>;	            </span><br><span class="line">            <span class="comment">// 合并排序相同</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;	        </span><br><span class="line">        <span class="comment">// 下一层</span></span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间函数：merge</span></span><br><span class="line"><span class="comment">// 将两个有序数组合并成一个有序数组；</span></span><br><span class="line"><span class="comment">//    arr[low,mif]表示一个数组，arr[mid+1,high]表示一个数组</span></span><br><span class="line"><span class="comment">// 因为数组有序，合并只要维护几个指针即可；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// temp 数组用于暂存合并的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//左半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="comment">//右半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//合并后数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录由小到大地放进 temp 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">        arr[low + l] = temp[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>空间复杂度：$O(n)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p><strong>适用场景</strong>：最大值和最小值的差值不是不是很大的排序</p>
<p><strong>基本思想</strong>：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gCountingSort.gif" alt="CountingSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中间数组，存放arr里各元素出现的次数</span></span><br><span class="line">    <span class="comment">//为节约内存空间，从0开始编号（0对应min），最后一个元素max-min（对应max）</span></span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mapPos = arr[i] - min;</span><br><span class="line">        help[mapPos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        <span class="comment">//把help某个位置对应的所有值全部输出（重复值）</span></span><br><span class="line">        <span class="keyword">while</span>(help[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++] = i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n+k)$，k 表示临时数组大小</li>
<li>空间复杂度：$O(k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><p><strong>基本思想</strong>：把最大值和最小值之间的数进行瓜分（例如分成 5 个区间，5 个区间对应 5 个桶），然后，把各元素放到对应区间的桶中去，再对每个桶中的数进行排序（可以采用前面提过的排序算法）。之后每个桶里面的数据就是有序的了，最后再进行合并汇总；</p>
<p><strong>适用场景</strong>：数据基本呈均匀分布的情况，这样才能保证各个桶里的数据量基本相同，不至于浪费 “桶” 所带来的时间和空间开销；</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBucketSort.gif" alt="BucketSort"></p>
<p><strong>问题</strong>：桶排序是怎样优化性能的？</p>
<ul>
<li>举个例子：<ul>
<li>我们假设有 100 个待排序的呈均匀分布的数，如果我们直接采用冒泡排序（时间复杂度为 $O(n^2)$），那么我们的时间开销将在 $100^2=10000$ 量级上；</li>
<li>现在，我们采用桶排序，划分出 10 个桶，因为数据呈均匀分布，那么每个桶里也就是 10 个数据，在每个桶里再单独进行冒泡排序，将 10 个桶都排好序的时间开销也就是  $10^2 \times 10=1000$ 量级上，即使算上桶划分、桶合并的时间，也远远低于 10000；</li>
</ul>
</li>
<li>经过这个例子，应该也就基本了解桶排序的优势所在，用普遍的数学公式表示：<ul>
<li>假设有 n 个数据，采用某种排序方式（时间复杂度为$O(n^i)$），这样直接排序的时间开销也就是：$n^i$</li>
<li>现在，我们分为 k 个桶进行桶排序，桶内仍然采用同样的排序算法:<ul>
<li>如果原数据呈均匀分布，那么时间开销也就是：$({\frac{n}{k})}^i \times k + f(k,n)= \frac{n^i}{k^{i-1}} + f(k,n)$，其中，$f(k,n)$ 为划分桶和合并桶的时间开销，它是一个和 k，n 有关的一阶函数，可以暂且忽略不考虑，将时间开销定为：$\frac{n^i}{k^{i-1}}$，对比 $n^i$，优势就很明显了；</li>
<li>那如果数据不呈均匀分布，我们考虑极端的情况，也就是这 n 个数据全部被分到 k 个桶里的同一个，那么现在的时间开销也就是：$n^i + f(k,n)$，对比 $n^i$，也就没了任何优势，并且还带来额外的时间、空间上的开销；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶划分</span></span><br><span class="line">    <span class="comment">// 定义桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>; </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//某个元素所属桶号</span></span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序（排序算法也可以自己定义）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//System.out.println(bucketArr.toString());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把每个桶排序好的数据进行合并汇总放回原数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer t : bucketArr.get(i)) &#123;</span><br><span class="line">            arr[k++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n+k)$，k 表示桶个数</li>
<li>空间复杂度：$O(n+k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>是一种借助多关键字排序的思想（“分配” 和 “收集” 两种操作）对单逻辑关键字进行排序的方法；有两种排序方式：最高位优先（MSD）、最低位优先（LSD）   </p>
<p><strong>基本思想</strong>：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位，最终得到的序列就是一个有序序列；</p>
<ul>
<li>在具体到某一位的排序时，是利用 “桶” 排序来实现的。数据的某一位取值情况为：0-9，需要 10 个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照 0 号桶到 9 号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gRadixSort.gif" alt="RadixSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radioSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值位数num</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每位数值从0-9，10 种取值，创建 10 个桶 </span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从个位数开始，循环，对每一位排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取每个数最后第 i 位是数组</span></span><br><span class="line">            <span class="keyword">int</span> radio = (arr[j] / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放进对应的桶里</span></span><br><span class="line">            bucketList.get(radio).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并放回原数组</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : bucketList.get(j)) &#123;</span><br><span class="line">                arr[k++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出来合并了之后把桶清光数据</span></span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(kn)$，k 表示最大数位数</li>
<li>空间复杂度：$O(n+k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="排序算法对比分析"><a href="#排序算法对比分析" class="headerlink" title="排序算法对比分析"></a>排序算法对比分析</h1><div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最好时间</th>
<th>最坏时间</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(nlogn)$</td>
<td></td>
<td></td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n^2)$</td>
<td>$O(logn)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n^2)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(n \times k)$</td>
<td>$O(n \times k)$</td>
<td>$O(n \times k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
</div>
<p>注意：以上时间复杂度，供参考，有些算法还需要根据具体情况实际分析；</p>
<p><strong>总结</strong>：</p>
<ul>
<li>从平均时间性能上看，快排是最优选择，但是其最坏情况下性能不如堆排和归并排序。对后两者来说，如果 n 较大，选择归并排序更省时，但是比较废空间；</li>
<li>直接插入排序时最简单的排序，当记录数较少，或基本有序时，是最佳选择。因此，它也常和其他排序方式结合使用；</li>
<li>一般来说，排序过程中的 “比较” 在 “相邻的两个记录关键字” 间进行的排序方法是文档的；稳定性由方法本身决定，总能找出反例；如果排序按主关键字进行，那么算法稳定性不重要，但如果按次关键字进行，则需要重点考虑；</li>
<li>因此，排序算法没有好坏之分，要根据实际情况选择最合适的方法；</li>
<li>经研究表明：所有借助于 “比较” 进行排序的算法在最坏情况下能达到的最好的时间复杂度为：$O(nlogn)$</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>『<a href="https://www.cnblogs.com/kubidemanong/p/10404197.html" target="_blank" rel="noopener">十大排序算法，看这篇就够了(附完整代码/动图/优质文章)</a>』</li>
<li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li>
<li>另：文中动图均来源网络，最终出处没能找到，如原作者看到，可联系我加入参考地址</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="TheBetterKong 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="TheBetterKong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>TheBetterKong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/" title="排序算法（详解 + java 实现）">http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/" rel="prev" title="FPGA-CAD Tools：Placement">
      <i class="fa fa-chevron-left"></i> FPGA-CAD Tools：Placement
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/07/Git/GitStart/" rel="next" title="Git 基础入门">
      Git 基础入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前文"><span class="nav-number">1.</span> <span class="nav-text">前文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念解释"><span class="nav-number">1.1.</span> <span class="nav-text">概念解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法分类"><span class="nav-number">1.2.</span> <span class="nav-text">排序算法分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规律总述"><span class="nav-number">1.3.</span> <span class="nav-text">规律总述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#插入排序"><span class="nav-number">2.</span> <span class="nav-text">插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接插入排序（Insertion-Sort）"><span class="nav-number">2.1.</span> <span class="nav-text">直接插入排序（Insertion Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#改进：折半插入"><span class="nav-number">2.1.1.</span> <span class="nav-text">改进：折半插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改进：2-路插入"><span class="nav-number">2.1.2.</span> <span class="nav-text">改进：2-路插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序（Shell-Sort）"><span class="nav-number">2.2.</span> <span class="nav-text">希尔排序（Shell Sort）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#快速排序"><span class="nav-number">3.</span> <span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序（Bubble-Sort）"><span class="nav-number">3.1.</span> <span class="nav-text">冒泡排序（Bubble Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序（Quick-Sort）"><span class="nav-number">3.2.</span> <span class="nav-text">快速排序（Quick Sort）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#选择排序"><span class="nav-number">4.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单选择排序（Selection-Sort）"><span class="nav-number">4.1.</span> <span class="nav-text">简单选择排序（Selection Sort）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树形选择排序"><span class="nav-number">4.1.1.</span> <span class="nav-text">树形选择排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序（Heap-Sort）"><span class="nav-number">4.2.</span> <span class="nav-text">堆排序（Heap Sort）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#归并排序（Merge-Sort）"><span class="nav-number">5.</span> <span class="nav-text">归并排序（Merge Sort）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计数排序（Counting-Sort）"><span class="nav-number">6.</span> <span class="nav-text">计数排序（Counting Sort）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#桶排序（Bucket-Sort）"><span class="nav-number">7.</span> <span class="nav-text">桶排序（Bucket Sort）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基数排序（Radix-Sort）"><span class="nav-number">8.</span> <span class="nav-text">基数排序（Radix Sort）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法对比分析"><span class="nav-number">9.</span> <span class="nav-text">排序算法对比分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheBetterKong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheBetterKong</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TheBetterKong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheBetterKong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kongxiangfeng@iie.ac.cn" title="E-Mail → mailto:kongxiangfeng@iie.ac.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_44849403" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44849403" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6460669623" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6460669623" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.cugxuan.cn/" title="https:&#x2F;&#x2F;blog.cugxuan.cn&#x2F;" rel="noopener" target="_blank">泫</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://paper.seebug.org/" title="https:&#x2F;&#x2F;paper.seebug.org&#x2F;" rel="noopener" target="_blank">Paper seebug</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.runoob.com/" title="https:&#x2F;&#x2F;www.runoob.com&#x2F;" rel="noopener" target="_blank">菜鸟教程</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wiki.jikexueyuan.com/" title="https:&#x2F;&#x2F;wiki.jikexueyuan.com&#x2F;" rel="noopener" target="_blank">极客学院Wiki</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://man.linuxde.net/" title="https:&#x2F;&#x2F;man.linuxde.net&#x2F;" rel="noopener" target="_blank">Linux大全</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备20005224号 </a>
  </div>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheBetterKong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


<div class="statistics">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  <span id="busuanzi_value_site_uv"></span>
</span>
<span class ="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
  <span id="busuanzi_value_site_pv"></span>
</span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共253.8k字</span>
  <span class ="post-time-divider">|</span>
    <span>运行<span id="showDays"></span></span>
  <script>
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var birthDay = Date.UTC(2020,04,20,18,00,00); // 这里设置建站时间
    setInterval(function() {
      var today = new Date();
      var todayYear = today.getFullYear();
      var todayMonth = today.getMonth()+1;
      var todayDate = today.getDate();
      var todayHour = today.getHours();
      var todayMinute = today.getMinutes();
      var todaySecond = today.getSeconds();
      var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
      var diff = now - birthDay;
      var diffYears = Math.floor(diff/years);
      var diffDays = Math.floor((diff/days)-diffYears*365);
      var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
      var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
      var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML=""+diffYears+"年"+diffDays+"天"+diffHours+"小时"+diffMinutes+"分钟"+diffSeconds+"秒";
    }, 1000);
  </script>
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FzJ2kTqyh92urg7N9KHkL0RA-9Nh9j0Va',
      appKey     : 'aTVY6lFVOvNPNgaDGtgHVoQy',
      placeholder: "期待您的留言！",
      avatar     : '',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
