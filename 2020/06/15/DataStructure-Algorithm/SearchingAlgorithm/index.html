<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.thebetterkong.cn","root":"/","images":"/images","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="查找（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。">
<meta property="og:type" content="article">
<meta property="og:title" content="查找算法（详解 + java 实现）">
<meta property="og:url" content="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/index.html">
<meta property="og:site_name" content="TheBetterKong">
<meta property="og:description" content="查找（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DataStructure.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/IndexTable.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BinarySearchTreeEx.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/FibonacciSegmentation.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTBuild.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTDelete.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BadBST.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/AVLExample.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LLRotate.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RRRotate.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LRRotate.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RLRotate.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackSearch.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeInsertSituation.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeDeleteSituation.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-Tree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeInsert.gif">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete1.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete2.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete3.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete4.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B+Tree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/KeyTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DoubleLinkTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/TrieTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/ChainAddressMethod.png">
<meta property="article:published_time" content="2020-06-15T04:53:23.000Z">
<meta property="article:modified_time" content="2021-03-27T10:56:48.239Z">
<meta property="article:author" content="TheBetterKong">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png">


<link rel="canonical" href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>查找算法（详解 + java 实现） | TheBetterKong</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TheBetterKong" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">TheBetterKong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">自律即自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前文"><span class="nav-number">1.</span> <span class="nav-text">前文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找表"><span class="nav-number">1.1.</span> <span class="nav-text">查找表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找算法的分类"><span class="nav-number">1.2.</span> <span class="nav-text">查找算法的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析"><span class="nav-number">1.3.</span> <span class="nav-text">性能分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态线性表查找"><span class="nav-number">2.</span> <span class="nav-text">静态线性表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序查找（Sequential-Search）"><span class="nav-number">2.1.</span> <span class="nav-text">顺序查找（Sequential Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分块查找（Block-Search）"><span class="nav-number">2.1.1.</span> <span class="nav-text">分块查找（Block Search）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#折半查找（Binary-Search）"><span class="nav-number">2.2.</span> <span class="nav-text">折半查找（Binary Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插值查找（Insertion-Search）"><span class="nav-number">2.2.1.</span> <span class="nav-text">插值查找（Insertion Search）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波拉契查找（Fibonacci-Search）"><span class="nav-number">2.2.2.</span> <span class="nav-text">斐波拉契查找（Fibonacci Search）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态树表查找"><span class="nav-number">3.</span> <span class="nav-text">动态树表查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树（Binary-Sort-Tree）"><span class="nav-number">3.1.</span> <span class="nav-text">二叉排序树（Binary Sort Tree）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平衡二叉树（AVL）"><span class="nav-number">3.1.1.</span> <span class="nav-text">平衡二叉树（AVL）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">红黑树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树和-B-树"><span class="nav-number">3.2.</span> <span class="nav-text">B- 树和 B+ 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树"><span class="nav-number">3.2.1.</span> <span class="nav-text">B- 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-树-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">B+ 树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#键树"><span class="nav-number">3.3.</span> <span class="nav-text">键树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希查找（Hash-Search）"><span class="nav-number">4.</span> <span class="nav-text">哈希查找（Hash Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表和哈希函数"><span class="nav-number">4.1.</span> <span class="nav-text">哈希表和哈希函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希函数的构造方法"><span class="nav-number">4.2.</span> <span class="nav-text">哈希函数的构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理冲突的方法"><span class="nav-number">4.3.</span> <span class="nav-text">处理冲突的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希查找分析"><span class="nav-number">4.4.</span> <span class="nav-text">哈希查找分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheBetterKong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheBetterKong</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TheBetterKong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheBetterKong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kongxiangfeng@iie.ac.cn" title="E-Mail → mailto:kongxiangfeng@iie.ac.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_44849403" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44849403" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6460669623" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6460669623" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.cugxuan.cn/" title="https:&#x2F;&#x2F;blog.cugxuan.cn&#x2F;" rel="noopener" target="_blank">泫</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://paper.seebug.org/" title="https:&#x2F;&#x2F;paper.seebug.org&#x2F;" rel="noopener" target="_blank">Paper seebug</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.runoob.com/" title="https:&#x2F;&#x2F;www.runoob.com&#x2F;" rel="noopener" target="_blank">菜鸟教程</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wiki.jikexueyuan.com/" title="https:&#x2F;&#x2F;wiki.jikexueyuan.com&#x2F;" rel="noopener" target="_blank">极客学院Wiki</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://man.linuxde.net/" title="https:&#x2F;&#x2F;man.linuxde.net&#x2F;" rel="noopener" target="_blank">Linux大全</a>
        </li>
    </ul>
  </div>

        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/TheBetterKong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheBetterKong">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheBetterKong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          查找算法（详解 + java 实现）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-15 12:53:23" itemprop="dateCreated datePublished" datetime="2020-06-15T12:53:23+08:00">2020-06-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-27 18:56:48" itemprop="dateModified" datetime="2021-03-27T18:56:48+08:00">2021-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DataStructure-Algorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructure & Algorithm</span></a>
        </span>
    </span>

  
    <span id="/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/" class="post-meta-item leancloud_visitors" data-flag-title="查找算法（详解 + java 实现）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <div align="center"> <img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>查找</strong>（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。</p>
<a id="more"></a> 
<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>查找表是由同一类型的数据元素（或记录）构成的集合。由于 “集合” 中的元素之间存在着完全松散的关系，因此它是一种非常灵便的数据结构。     </p>
<p>针对查找表，常涉及的操作如下：</p>
<ul>
<li>查询某个 “特点的” 数据元素是否在查找表中；</li>
<li>检索某个 “特定的” 数据源是的各种属性；</li>
<li>在查找表中插入或删除一个数据元素；</li>
</ul>
<h2 id="查找算法的分类"><a href="#查找算法的分类" class="headerlink" title="查找算法的分类"></a>查找算法的分类</h2><ul>
<li><strong>静态查找</strong>：对查找表的操作只涉及前两种 “查找” 操作；</li>
<li><strong>动态查找</strong>：在查找的过程中同时会涉及插入和删除操作；</li>
<li><strong>有序查找</strong>：被查找的数据元素必须有序；</li>
<li><strong>无序查找</strong>：被查找的数据元素有序无序均可；</li>
</ul>
<p>下面是常见查找算法的分类情况：</p>
<ol>
<li>静态查找：<ul>
<li>顺序表的查找：顺序查找、分块查找（索引顺序查找）</li>
<li>有序表的查找：折半查找（二分查找）、斐波那契查找、插值查找</li>
</ul>
</li>
<li>动态查找：<ul>
<li>二叉排序树和平衡二叉树查找</li>
<li>B- 树和 B+ 树查找</li>
<li>键树查找</li>
</ul>
</li>
<li>哈希查找：</li>
</ol>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>平均查找长度</strong>（Average Search Length）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度；    </p>
<p>对于含有 n 个记录的表，查找成功时的平均查找长度为：   </p>
<script type="math/tex; mode=display">ASL\ =\ \sum^n_{i=1}\ P_iC_i</script><p>其中：   </p>
<ul>
<li>$P<em>i$ 为查找表中第 i 个记录的概率，且 $\sum^n</em>{i=1}\ P_i=1$；</li>
<li>$C_i$ 为找到表中期关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。它随查找过程不同而不同；</li>
</ul>
<h1 id="静态线性表查找"><a href="#静态线性表查找" class="headerlink" title="静态线性表查找"></a>静态线性表查找</h1><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DataStructure.png" alt="DataStructure"> </p>
<p>线性表中的元素一旦有序，就可以称为有序表；</p>
<h2 id="顺序查找（Sequential-Search）"><a href="#顺序查找（Sequential-Search）" class="headerlink" title="顺序查找（Sequential Search）"></a>顺序查找（Sequential Search）</h2><p>也称线形查找，属于无序查找算法；</p>
<p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；   </p>
<p><strong>基本思想</strong>：从表中开头或结尾元素开始，逐个进行记录的关键字和给定值比较，若某记录的关键字和给定值比较相等，则查找成功；反之，若直至线性表的另一端，都未发现某记录的关键字和给定值比较相等，则查找失败；   </p>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找（Sequential Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：</p>
<ul>
<li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） $ASL = \frac{1}{n \times (1+2+3+…+n)} = \frac{n+1}{2}$;</li>
<li>查找不成功时，需要 $n+1$ 次比较;</li>
<li>时间复杂度为 $O(n)$</li>
</ul>
<h3 id="分块查找（Block-Search）"><a href="#分块查找（Block-Search）" class="headerlink" title="分块查找（Block Search）"></a>分块查找（Block Search）</h3><p>又称：索引顺序查找，是对顺序查找的改进；    </p>
<p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；  </p>
<p><strong>基本思想</strong>：对需要查找的顺序表进行分块，保证 “分块有序”，然后在此基础上进行查找：</p>
<ul>
<li>除待查找表本身外，新建一个 “索引表”：<ul>
<li><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/IndexTable.png" alt="IndexTable"> </li>
<li>上图中，将 18 个记录分为了 3 个子表：$(R<em>1,R_2,…,R_6)$、$(R_7,R_8,…,R</em>{12})$、$(R<em>{13},R</em>{14},…,R_{18})$；</li>
<li>对每个子表（块）建立一个索引项，其包括两个内容：最大关键字（子表内的最大关键字）、指针项（指示该子表的第一个记录在表中的位置）；</li>
<li>索引表按关键字有序，则表要么有序要么分块有序（是指：第二个子表中所有记录的关键字均大于第一个子表中的关键字，依次类推…）</li>
</ul>
</li>
<li>接下来的查找过程分为两部分：<ul>
<li>先确定待查记录所在的块（子表），这里是有序的，可以采用顺序查找或者插入查找算法；</li>
<li>然后在块中顺序查找；</li>
</ul>
</li>
</ul>
<details>
  <summary><b>分块查找 java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找算法</span></span><br><span class="line"><span class="comment">// 只是展示分块查找的思想，具体实现时，需要根据具体情况灵活运用此思想；</span></span><br><span class="line"><span class="comment">// 算法来源：参考 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexItem</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index; <span class="comment">//值比较的索引</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start; <span class="comment">//开始位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;<span class="comment">//块元素长度(非空)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexItem</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... getter and setter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引查找算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexSearch</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem indexItem = <span class="keyword">null</span>; <span class="comment">// 目标子表</span></span><br><span class="line">        <span class="comment">//建立索引规则：</span></span><br><span class="line">        <span class="comment">// 以 100 作为划分，每 100 项一组，子表存储范围分别为：</span></span><br><span class="line">        <span class="comment">//  indexItemList[0]：0-99</span></span><br><span class="line">        <span class="comment">//  indexItemList[1]：100-199</span></span><br><span class="line">        <span class="comment">//  ......</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//遍历索引表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找到索引项</span></span><br><span class="line">            <span class="keyword">if</span>(indexItemList[i].index == index) &#123;</span><br><span class="line">                indexItem = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span>(indexItem == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据索引项，在主表中查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainList[i] == key)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem item = <span class="keyword">null</span>; <span class="comment">// 用来保存查找的子表</span></span><br><span class="line">        <span class="comment">// 按索引规则，映射为索引</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历索引表，找到对应的索引项</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexItemList[i].index == index) &#123;</span><br><span class="line">                item = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引项将值插入到主表中</span></span><br><span class="line">        mainList[item.start + item.length] = key;</span><br><span class="line">        <span class="comment">// 更新索引表长度</span></span><br><span class="line">        indexItemList[i].length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示开始 ********"</span>);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 每10个数换行一次</span></span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示结束 ********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个主表，size=30</span></span><br><span class="line">        <span class="keyword">int</span>[] mainList = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">301</span>, <span class="number">302</span>, <span class="number">303</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照前面所述的索引规则，声明一个索引表</span></span><br><span class="line">        IndexItem[] indexItemList = <span class="keyword">new</span> IndexItem[]&#123;</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"******** 索引查找 ********"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始数据："</span>);</span><br><span class="line">        display(mainList);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">203</span>;</span><br><span class="line">        System.out.println(<span class="string">"元素"</span> + key + <span class="string">"列表中的位置为："</span> + indexSearch(key,indexItemList,mainList) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按规则插入数据并查找</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">106</span>;</span><br><span class="line">        System.out.println(<span class="string">"插入数据："</span> + value);</span><br><span class="line">        <span class="comment">// 如果插入成功，则查找插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (insert(value,indexItemList,mainList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"插入后的主表："</span>);</span><br><span class="line">            display(mainList);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"元素"</span> + value + <span class="string">"在列表中的位置为："</span> + indexSearch(value,indexItemList,mainList));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>       


<p><strong>性能分析</strong>：</p>
<ul>
<li>平均查找长度为：$ASL_{bs}=L_b+L_w$<ul>
<li>$L_b$：为查找索引表确定所在快的平均查找长度；</li>
<li>$L_w$：为在块中查找元素的平均查找长度；</li>
</ul>
</li>
<li>一般，可将长度为 n 的表均匀分为 b 块，每块含有 s 个记录（$b=\lceil n/s \rceil$）；再假定表中每个记录的查找概率相等，则每块查找的概率为 $1/b$，块中每个记录的查找概率为 $1/s$；<ul>
<li><mark>当 $s=\sqrt{n}$ 时，$ASL_{bs}$ 取最小值 $\sqrt{n}+1$；</mark></li>
</ul>
</li>
<li>若用顺序查找确定所在块，则分块查找的平均长度为：<ul>
<li>$ASL<em>{bs}=L_b+L_w=\frac{1}{b}\sum^b</em>{j=1}j+\frac{1}{s}\sum^s_{i=1}i=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}(\frac{n}{s}+s)+1$</li>
</ul>
</li>
<li>若用折半查找确定所在块，则分块查找的平均长度为：<ul>
<li>$ASL_{bs}\approx log_2(\frac{n}{s}+1)+\frac{s}{2}$</li>
</ul>
</li>
</ul>
<h2 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h2><p>也称二分查找，属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li>
</ul>
<p><strong>基本思想</strong>：先确定待查记录所在的范围（区间），然后逐渐缩小范围，直至找到或找不到该记录为止；   </p>
<ul>
<li>维护两个指针 <code>low</code> 和 <code>high</code>，他们指向线性表两端；然后再引入一个指针 <code>mid</code>，指示区间的中间位置；</li>
<li>将给定值 <code>key</code> 和 <code>mid</code> 所指示元素比较：<ul>
<li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li>
<li>若 <code>key &gt; mid</code>，把 <code>low</code> 指向 <code>mid+1</code> 位置，查找区间改为 <code>[ low(mid+1), high ]</code>；</li>
<li>若 <code>key &lt; mid</code>，把 <code>high</code> 指向 <code>mid-1</code> 位置，查找区间改为 <code>[ low, high(mid-1) ]</code>；</li>
</ul>
</li>
<li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找（Binary Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BinarySearchTreeEx.png" alt="BinarySearchTreeEx"><br>假设有如图所示的一棵深度为 h 的满二叉树，用来描述一个长度 $n=2^h-1$ 的有序表的二分查找过程。其中，层次为 h 的结点有 $2^{h-1}$ 个。 并且，假设各个节点的查找概率相等（$P_i=\frac{1}{n}$）。   </p>
<p>则，查找成功时折半查找的平均查找长度为：   </p>
<script type="math/tex; mode=display">
\begin{aligned}
ASL_{bs}&=\sum^n_{i=1}\ P_iC_i=\frac{1}{n}\ \sum^h_{j=1}\ j \cdot 2^{j-1}\\\\
&=\frac{1}{n}(\ \sum^{h-1}_{i=0}2^i+2\sum^{h-2}_{i=0}2^i+...+2^{h-1}\sum^{h-1}_{i=0}2^i\ )\\\\
&=\frac{1}{n}\ [h \cdot 2^h -(2^0+2^1+...+2^{h-1})]=\frac{1}{n}\ [(h-1)2^h+1]\\\\
&= \frac{1}{n}\ [\ (n+1)(log_2(n+1)-1)+1\ ]\\\\
&=\frac{n+1}{n}log_2(n+1)-1
\end{aligned}</script><p>当 n 较大时 (&gt;50)，可以近似为：$ASL_{bs}=log_2(n+1)-1$</p>
<h3 id="插值查找（Insertion-Search）"><a href="#插值查找（Insertion-Search）" class="headerlink" title="插值查找（Insertion Search）"></a>插值查找（Insertion Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li>
<li>需要关键字均匀分布的表；</li>
</ul>
<p><strong>基本思想</strong>：折半查找中，每次都是从中间位置开始，而插值查找就是为了避免这种 “傻瓜” 式的搜索，希望将比例因子改为自适应的，即：根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，进而间接地减少比较次数；</p>
<ul>
<li>新的 mid 求法：$mid=low+\frac{key-a[low]}{a[high]-a[low]}\ast(high-low)$</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertionSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：   </p>
<ul>
<li>查找成功或者失败的时间复杂度均为 $O(log(logn))$；</li>
<li>分布均匀，且表长较大时，平均性能优于折半查找；</li>
</ul>
<h3 id="斐波拉契查找（Fibonacci-Search）"><a href="#斐波拉契查找（Fibonacci-Search）" class="headerlink" title="斐波拉契查找（Fibonacci Search）"></a>斐波拉契查找（Fibonacci Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）； </li>
</ul>
<p><strong>基本思想</strong>：类似二分查找，根据斐波那契序列的特点对有序表进行分割；它要求开始时，表中记录的个数为某个斐波那契数减 1，及 $n=F(k)-1$；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/FibonacciSegmentation.png" alt="FibonacciSegmentation"></p>
<ul>
<li>同样，维护三个指针，初始时，<code>low</code> 和 <code>high</code> 指向线性表两端，将 <code>key</code> 与第 <code>F(k-1)</code> 位置的记录进行比较（即：<code>mid=low+F(k-1)-1</code>）：<ul>
<li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li>
<li>若 <code>key &gt; mid</code>，则更新：<code>low=mid+1,k-=2</code>；查找区间更新为 <code>[mid+1,high]</code>，<code>k-=2</code> 说明新的查找区间内元素个数为：$n-F(k-1)= F(k)-1-F(k-1)=F(k-2)-1$；</li>
<li>若 <code>key &lt; mid</code>，则更新：<code>high=mid-1,k-=1</code>；查找区间更新为 <code>[low,mid-1]</code>，<code>k-=1</code> 说明新的查找区间内元素个数为：$F(k-1)-1$；</li>
</ul>
</li>
<li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>; <span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波拉契查找（Fibonacci Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 斐波那契分割数值的下标</span></span><br><span class="line">    <span class="keyword">int</span> f[] = fib(); <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    <span class="comment">// 计算获取，斐波那契分割数值的下标</span></span><br><span class="line">    <span class="comment">//  f(k) 是大于数组长度的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f[k] 值可能大于 arr 的长度，则构造一个新的数组 temp[]，该方法不足的部分会使用 0 填充</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">// 但是，实际上需求使用 arr 数组最后的数填充 temp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        temp[i] = arr[high];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环进行查找</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//值过小，从左半部分继续</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">//值过大，从右半部分继续</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//查找成功，但是因为前面扩充了数组，则需要确定，返回的是哪个下标</span></span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= arr.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.length-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：</p>
<ul>
<li>平均复杂度为：$O(longn)$，最坏情况下的时间复杂度也是 $O(longn)$；</li>
<li>平均性能优于折半查找，但最坏情况下的性能（虽然仍是 $O(longn)$）却比折半查找差；</li>
<li>另一个优势：分割时只需要进行加减运算；</li>
</ul>
<h1 id="动态树表查找"><a href="#动态树表查找" class="headerlink" title="动态树表查找"></a>动态树表查找</h1><h2 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h2><p><strong>“二叉排序树”</strong>（也称 “二叉查找树” 或者 “二叉搜索树”）：它或者是一棵空树，或者是具有下列性质的二叉树：（左小右大）</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>根据其定义，也就可以看出，二叉排序树具有如下<strong>性质</strong>：</p>
<ul>
<li>中序遍历的结果是一个有序序列；</li>
</ul>
<p><strong>二叉排序树查找算法基本思想</strong>：</p>
<ul>
<li><p><strong>建树</strong>：从一棵空树开始，将被查找序列的数据不断插入树中，生成一棵二叉排序树<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTBuild.png" alt="BSTBuild"></p>
<ul>
<li><strong>插入</strong>：新插入的节点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点；<ul>
<li>若当前的二叉查找树为空，则插入的元素为根节点；</li>
<li>若插入的元素值小于根节点值，则将元素插入到左子树中；</li>
<li>若插入的元素值不小于根节点值，则将元素插入到右子树中；</li>
<li>总结来说就是：首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败；</li>
</ul>
</li>
<li><strong>删除</strong>：分三种情况进行处理：<ol>
<li>p 为叶子节点：直接删除该节点（不会破坏树的整体结构），再修改其父节点的指针（注意分是根节点和不是根节点），如图 a；</li>
<li>p 为单支节点（即只有左子树或右子树）：让 p 的子树与 p 的父亲节点相连，删除 p 即可（也不会破坏树的整体结构）（注意分是根节点和不是根节点），如图 b；</li>
<li>有两个孩子的情况：当前结点与左子树中最大的元素交换，然后删除当前结点。左子树最大的元素至多只有一个左子节点，交换后，删除就可以参考上面两种的情况。另一种方法是，当前结点与右子树中最小的元素交换，然后删除当前结点。如图 c（删除 z 结点）；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTDelete.png" alt="BSTDelete"></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>查找</strong>：树非空时，将给定值与根节点比较，若相等则查找成功；否则，根据给定值与根节点的大小关系，分别在左子树或右子树上继续查找；迭代进行，直至查找成功，或者不再存在左右子树时查找失败；</p>
</li>
</ul>
<details>
  <summary><b>java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树数据结构*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value, TreeNode parent, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这部分是树里面的一些操作，详细可见二叉树的操作*/</span></span><br><span class="line">    <span class="comment">// 求 BST 的最小值，即最左边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 BST 的最大值，即最右边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中中序遍历的某节点的前驱节点，即查找数据值小于该结点的最大结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">preNode</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMax(x.left);</span><br><span class="line">        <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则"x的前驱结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的右儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.left == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中某节点的后继节点.即查找数据值大于该结点的最小结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">postNode</span><span class="params">(TreeNode x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在右孩子，则"x的后继结点"为"以其右孩子为根的子树的最小结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMin(x.right);</span><br><span class="line">        <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则"x的后继结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的查找算法*/</span></span><br><span class="line">    <span class="comment">// 查找值为val的节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">searchRec</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找值为 val 的节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">search</span><span class="params">(TreeNode root ,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点插入算法*/</span></span><br><span class="line">    <span class="comment">//BST 插入节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insertRec</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left,  x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right,  x);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BST 插入节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root = x;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>; <span class="comment">//需要记录父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位插入的位置</span></span><br><span class="line">            p = root; <span class="comment">//记录父节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        x.parent = p;<span class="comment">//定位到合适的叶节点的空白处后，根据和父节点的大小比较插入合适的位置</span></span><br><span class="line">        <span class="keyword">if</span>(x.value &lt; p.value)</span><br><span class="line">            p.left = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; p.value)</span><br><span class="line">            p.right = x;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点删除算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位到需要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//找到了，root指向待删结点，p指向root的父结点</span></span><br><span class="line">                <span class="comment">// 情景一：待删除的是 叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)</span><br><span class="line">                            p.left = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有左孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>)<span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.left;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.left;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有右孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.right;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景三：待删除节点同时拥有左右孩子</span></span><br><span class="line">                <span class="comment">//  方法：得到待删除节点右子树的最小值，该最小值与待删除节点进行“ 值 ”交换，删除该最小值位置处的节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此情况就不需要考虑被删结点是不是根节点了，操作都相同</span></span><br><span class="line">                    TreeNode rMin = root.right; <span class="comment">// 待删除节点的右孩子的最小值(找到的后继节点肯定没有左孩子！！！)</span></span><br><span class="line">                    TreeNode rMinP = root;<span class="comment">// 因为需要删除后继节点位置，所以需要记录父节点</span></span><br><span class="line">                    <span class="keyword">while</span>(rMin.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        rMinP=rMin;</span><br><span class="line">                        rMin = rMin.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> rootVtemp = root.value;<span class="comment">//值交换</span></span><br><span class="line">                    root.value = rMin.value;</span><br><span class="line">                    rMin.value = rootVtemp;</span><br><span class="line">                    <span class="comment">//删除rMin位置的节点，此时此位置的值已是待删节点的值</span></span><br><span class="line">                    <span class="keyword">if</span>(rMinP.left == rMin)</span><br><span class="line">                        rMinP.left = rMin.right;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rMinP.right == rMin) <span class="comment">// 待删结点root的右孩子结点就是其右子树的最小值</span></span><br><span class="line">                        rMinP.right = rMin.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到后删了后就跳出while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的不完全测试模块：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node45 = <span class="keyword">new</span> TreeNode(<span class="number">45</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node24 = <span class="keyword">new</span> TreeNode(<span class="number">24</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node53 = <span class="keyword">new</span> TreeNode(<span class="number">53</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node12 = <span class="keyword">new</span> TreeNode(<span class="number">12</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node37 = <span class="keyword">new</span> TreeNode(<span class="number">37</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node93 = <span class="keyword">new</span> TreeNode(<span class="number">93</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        insert(node45,node24);</span><br><span class="line">        insert(node45,node53);</span><br><span class="line">        insert(node45,node12);</span><br><span class="line">        insert(node45,node37);</span><br><span class="line">        insert(node45,node93);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以写个中序遍历的函数，遍历一遍</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"查找45结果："</span>);</span><br><span class="line">        TreeNode out1 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out1 +<span class="string">":"</span>+ out1.value);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"删除45后，再次查询结果："</span>);</span><br><span class="line">        delete(node45,node45);</span><br><span class="line">        TreeNode out2 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out2);</span><br><span class="line"></span><br><span class="line">        System.out.println(node45.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>性能分析</strong>：</p>
<ul>
<li>含有 n 个节点的二叉排序树的平均查找长度和树的形态有关；</li>
<li>和二分查找一样，插入和查找的时间复杂度均为 $O(logn)$，但是在最坏的情况下仍然会有 $O(n)$ 的时间复杂度；</li>
<li>最坏情况时，树形结构为每层一个结点，这样算法会退化为顺序查找，于是，平衡二叉查找树应运而生；</li>
</ul>
<h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p><strong>来历</strong>：前面介绍，最坏情况下，如果连续插入已经排好序的键到二叉查找树，二叉查找树会变成了一个链表，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BadBST.png" alt="BadBST"><br>这样，相应的查找算法也就退化为了顺序查找，时间复杂度变为了 $O(n)$。而平衡二叉树就是为了避免这种情况。    </p>
<p><strong>平衡二叉树</strong>（Balance Binary Tree，Height-Balance Tree，AVL 树）：它或者是一棵空树，或者具有以下性质：</p>
<ul>
<li>首先，它是一棵二叉查找树；</li>
<li>它的左右子树也构成一棵平衡二叉树；</li>
<li>并且，左右子树的深度之差的绝对值不超过 1；</li>
</ul>
<p>若将二叉树上结点的<strong>平衡因子 BF</strong>（Balance Factor）定义为：该结点的左子树深度减去它的右子树深度，则平衡二叉树上所有结点的 BF 只可能取值为：-1、0、1，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/AVLExample.png" alt="AVLExample">   </p>
<p>在一个平衡二叉树上插入结点，就可能导致失去平衡，此时仅需对最小不平衡子树进行平衡旋转处理即可。现假设由于二叉排序树上插入结点而失去平衡的最小子树根节点指针为 a（即：a 是离插入结点最近，且平衡因子绝对值超过 1 的祖先结点），则<strong>失去平衡后进行调整（旋转） 的规律</strong>可归结为以下四种情况：   </p>
<ul>
<li><strong>LL 型：单向右旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LLRotate.png" alt="LLRotate"><ul>
<li>由于在 A 结点的左子树根节点的左子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如上图；</li>
</ul>
</li>
<li><strong>RR 型：单向左旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RRRotate.png" alt="RRRotate"><ul>
<li>由于在 A 结点的右子树根节点的右子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需进行一次向左的逆时针旋转操作，如上图；</li>
</ul>
</li>
<li><strong>LR 型：双向旋转（先左后右）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LRRotate.png" alt="LRRotate"><ul>
<li>由于在 A 结点的左子树根节点的右子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先左旋转再右旋转），如上图；</li>
</ul>
</li>
<li><strong>RL 型：双向旋转（先右后左）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RLRotate.png" alt="RLRotate"><ul>
<li>由于在 A 结点的右子树根节点的左子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先右旋转再左旋转），如上图；</li>
</ul>
</li>
</ul>
<p>以上旋转操作的正确性容易由 “保持二叉排序树的特性：中序遍历所得关键字序列自小而大有序” 证明。    </p>
<p><strong>插入和删除</strong>：与二叉查找树类似，只是额外加入了平衡操作。下面以插入算法思想来进行分类讨论：</p>
<ul>
<li>若 BBST 为空树，则插入一个数据元素为 e 的新结点作为 BBST 的根节点，树的深度增 1；</li>
<li>若 e == BBST 的根节点，则不进行插入；</li>
<li>若 e &lt; BBST 的根结点，并且 BBST 的左子树中不存和 e 相等的结点，则将 e 插入至 BBST 的左子树上，并且在插入之后的左子树深度增加（+1）时，分别就以下情况进行处理：<ul>
<li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li>
<li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 1，BBST 深度增 1；</li>
<li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：<ul>
<li>若 BBST 的左子树根结点的平衡因子为 1：则需要进行 LL 型（单向右旋）平衡处理，并且在右旋处理之后，将根节点和其右子树根结点的平衡因子改为 0，树的深度不变；</li>
<li>若 BBST 的左子树根结点的平衡因子为 -1：则需进行 LR 型（先左后右）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li>
</ul>
</li>
</ul>
</li>
<li>若 e &gt; BBST 的根结点，并且 BBST 的右子树中不存和 e 相等的结点，则将 e 插入至 BBST 的右子树上，并且在插入之后的右子树深度增加（+1）时，分别就以下情况进行处理：<ul>
<li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li>
<li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 -1，BBST 深度增 1；</li>
<li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：<ul>
<li>若 BBST 的右子树根结点的平衡因子为 -1：则需要进行 RR 型（单向左旋）平衡处理，并且在左旋处理之后，将根节点和其左子树根结点的平衡因子改为 0，树的深度不变；</li>
<li>若 BBST 的右子树根结点的平衡因子为 1：则需进行 RL 型（先右后左）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li>
</ul>
</li>
</ul>
</li>
</ul>
<details>
  <summary><b>java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 具体的实现依赖于前面的 二叉排序树 */</span></span><br><span class="line"><span class="comment">/** 下面给出里面的几个核心函数：BBST 的辅助旋转算法 */</span></span><br><span class="line"><span class="comment">// 其中，bf 是添加在树节点里的成员变量，代表节点的平衡因子（左子树高度-右子树高度）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的左子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.left; <span class="comment">// p 指向 root 的左子树的根结点</span></span><br><span class="line">    root.left = p.right; <span class="comment">// p 的右子树挂载至 root 的左子树</span></span><br><span class="line">    p.right = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的右子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.right; <span class="comment">// p 指向 root 的右子树的根结点</span></span><br><span class="line">    root.right = p.left; <span class="comment">// p 的左子树挂载至 root 的右子树</span></span><br><span class="line">    p.left = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在上述两种基础上，完成平衡二叉树的左右平衡处理</span></span><br><span class="line"><span class="comment">// 左平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode rl = root.left;</span><br><span class="line">    <span class="keyword">switch</span> (rl.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的左孩子的左子树上，做单向右旋处理</span></span><br><span class="line">            root.bf = rl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的左孩子的右子树上，做双旋（先左后右）处理</span></span><br><span class="line">            TreeNode rlr = rl.right;</span><br><span class="line">            <span class="keyword">switch</span> (rlr.bf)&#123; <span class="comment">// 修改 root 及其左孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = -<span class="number">1</span>; rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">0</span>; rl.bf = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rlr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root.left); <span class="comment">// 对 root 的左子树作左旋处理</span></span><br><span class="line">            rRotate(root); <span class="comment">// 对 root 做右旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected value: "</span> + rl.bf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode rr = root.right;</span><br><span class="line">    <span class="keyword">switch</span> (rr.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的右孩子的右子树上，做单向左旋处理</span></span><br><span class="line">            root.bf = rr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的右孩子的左子树上，做双旋（先右后左）处理</span></span><br><span class="line">            TreeNode rrl = rr.left;</span><br><span class="line">            <span class="keyword">switch</span> (rrl.bf)&#123; <span class="comment">// 修改 root 及其右孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = <span class="number">0</span>; rr.bf = -<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">1</span>; rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rrl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root.right); <span class="comment">// 对 root 的左子树作右旋处理</span></span><br><span class="line">            lRotate(root); <span class="comment">// 对 root 做左旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>性能分析</strong>：</p>
<ul>
<li>在平衡二叉树上进行查找的时间复杂度为：$O(logn)$，注意，它一种动态查找算法，在树形维护上的时间复杂度还是相对较高的；</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>对比说明</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
<th>局限性</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVL 树</td>
<td>严格的平衡二叉树，平衡条件必须满足：所有节点的左右子树高度差不超过 1；</td>
<td>① 平衡调整时的旋转操作十分耗时，因此，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多；更多的地方是用追求局部而不是非常严格整体平衡的红黑树;<br>② 也就更适合用于插入与删除次数比较少，但查找多的情况；</td>
<td>windows 对进程地址空间的管理；</td>
</tr>
<tr>
<td>红黑树</td>
<td>弱平衡二叉树，相同的节点情况下，AVL 树的高度低于红黑树；</td>
<td>旋转操作更少，更适用于搜索、插入、删除等操作较多的情况；<br>但相应的，相同情况下其查找次数会略高于 AVL 树；</td>
<td>① 著名的 linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块；<br>② epoll 在内核中的实现，用红黑树管理事件块；<br>③ nginx 中，用红黑树管理 timer 等；<br>④ Java 的 TreeMap 实现；</td>
</tr>
</tbody>
</table>
</div>
<p><strong>红黑树的定义</strong>：</p>
<ul>
<li>每个结点非黑即红；</li>
<li>根结点是黑色；</li>
<li>每个叶子结点都是黑色的空结点（NIL 结点）；</li>
<li>每个红色结点的两个子结点都是黑色;<ul>
<li>可推出：从每个叶子到根的所有路径上不能有两个连续的红色结点；</li>
</ul>
</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；<ul>
<li>可推出：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li>
</ul>
</li>
</ul>
<p>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTree.png" alt="RedBlackTree">     </p>
<p><strong>红黑树总是通过 “旋转” 和 “变色” 达到自平衡</strong>：</p>
<p><strong>红黑树插入</strong>：同样与二叉树类似，也分为两部分：1.查找插入的位置；2.插入后自平衡</p>
<p>查找流程：注意，插入的位置一定是叶子结点<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackSearch.png" alt="RedBlackSearch">      </p>
<p>接下来，就是将待插结点以 “红色” 插入，此时一共有 8 中情景，如下：</p>
<ul>
<li>“红色” 原因：如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡；并且，如果选择红色，在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作，也可以进一步减少平衡操作；   </li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeInsertSituation.png" alt="RedBlackTreeInsertSituation">   </p>
<p><strong>红黑树删除</strong>：同样也分为两部分：1.查找删除的位置；2.删除后自平衡    </p>
<p>查找流程：直接用前述的过程替代，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除目标结点，若目标结点存在子结点，还需找到结点进行替代，之后还得进行自平衡处理；     </p>
<p>结点删除的第一步，找替代结点分为以下 3 种情景：</p>
<ul>
<li>情景 1：若删除结点无子结点，直接删除</li>
<li>情景 2：若删除结点只有一个子结点，用子结点替换删除结点</li>
<li>情景 3：若删除结点有两个子结点，用中序遍历的后继结点（大于删除结点的最小结点，也即：删除结点右子树的最左边的结点）替换删除结点；</li>
</ul>
<p>经过上述替换之后，也就是删除替换结点。这个时候删除替换结点的情景如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeDeleteSituation.png" alt="RedBlackTreeDeleteSituation"></p>
<h2 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B- 树和 B+ 树"></a>B- 树和 B+ 树</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><p>B- 树是一种<strong>平衡的多路查找树</strong>，它<strong>广泛的运用于文件系统（索引）中</strong>；    </p>
<p><strong>定义</strong>：一棵 m 阶的 B- 树，要么为空树，要么为满足下列条件的 m 叉树：</p>
<ul>
<li>树中每个结点至多有 m 棵子树；</li>
<li>若根节点不是叶子结点，则至少有两棵子树；</li>
<li>除根节点之外的所有非终端结点至少有 $\lceil m/2 \rceil$ 棵子树；</li>
<li>所有的非终端节点包含以下信息数据：$(n,A_0,K_1,A_1,K_2,A_2,…,K_n,A_n)$<ul>
<li>$K<em>i\ (i=1,…,n)$ 为关键字，且 $K_i&lt;K</em>{i+1}\ (i=1,…,n-1)$；</li>
<li>$A<em>i\ (i=1,…,n)$ 为指向子树根节点的指针，且指针 $A</em>{i-1}$ 所指子树中所有结点的关键字均小于 $K_i(i=1,…,n)$，$A_n$ 所指子树中所有结点的关键字均大于 $K_n$；</li>
<li>$n\ (\lceil m/2 \rceil-1 \leq n \leq m-1)$  </li>
</ul>
</li>
<li>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的节点，实际上这些结点不存在，指向这些结点的指针为空）；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-Tree.png" alt="B-Tree"></p>
<p><strong>查找</strong>：B- 树的查找过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程；</p>
<ul>
<li><strong>查找性能分析</strong>：B- 树通常存在磁盘上，因此查找操作的主要两步：（1）在 B- 树中找结点（磁盘）；（2）在结点中找关键字（内存）；详细来说，即：在磁盘上找到指针 p 所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找等于 K 的关键字。而磁盘上的查找更耗时，因此，在磁盘上进行查找的次数（即待查找关键字所在结点在 B- 树上的层次树）是觉得 B- 树查找效率的首要因素。<ul>
<li>讨论深度为 l+1 的 m 阶 B- 树所具有的最少结点数：<ul>
<li>B- 数第一层至少 1 个节点；第二次至少 2 个节点；由于除根节点外每个非终端节点至少有 $\lceil m/2 \rceil$ 棵子树，则第三层至少有 $2\lceil m/2 \rceil$ 个节点；……以此类推；第 l+1 层至少有 $2(\lceil m/2 \rceil)^{l-1}$ 个结点；并且，第 l+1 层的结点为叶子结点 ；</li>
</ul>
</li>
<li>若 m 阶 B- 树中具有 N 个关键字，则叶子结点（即查找失败）的结点为 N+1，则有：$N+1 \geq 2 \ast (\lceil m/2 \rceil)^{l-1}$，也即：<script type="math/tex">l \leq log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1</script></li>
<li>也即：在含有 N 个关键字的 B- 树上进行查找时，从根节点到关键字所在结点的路径上设计的结点数不超过：$log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1$</li>
</ul>
</li>
</ul>
<p><strong>插入</strong>：规则：查找，向最底层的结点插入关键字，然后判断当前结点 key 的个数是否小于等于 m-1，如果满足，直接插入即可；如果不满足，“分裂”：按节点的中间的 key 将这个节点分为左右两部分，中间的 key 放到父节点中即可；</p>
<ul>
<li>往一个 4 阶 B- 树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的动图示例：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeInsert.gif" alt="B-TreeInsert"></li>
</ul>
<p><strong>删除</strong>：首先找到该关键字所在的结点，并从中删除之，然后，对需要进行 “合并” 结点的情况进行合并。这时考虑如下几种情况（$m=5，2 \leq n \leq 4$）：</p>
<ul>
<li>删除的是叶子节点的元素，并且如果删除之后，元素数还是大于等于 $\lceil m/2 \rceil -1$，这种情况只要直接删除即可:<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete1.png" alt="B-TreeDelete1"></li>
<li>删除的是叶子节点的元素，并且如果删除之后，元素数不足 $\lceil m/2 \rceil -1$：<ul>
<li>如果，它的兄弟节点的元素大于等于 $\lceil m/2 \rceil$（即：兄弟节点的元素删掉一个后仍符合要求）：将其兄弟结点中的最小（最大）的元素上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移元素的元素下移至双亲结点中；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete2.png" alt="B-TreeDelete2"></li>
<li>如果与被删元素所在的结点相邻的兄弟结点中元素个数均等于 $\lceil m/2 \rceil - 1$：假设该结点有兄弟结点，且其右兄弟结点地址由双亲结点中的指针 $A_i$ 所指，则在删去元素之后，它所在结点中剩余的元素和指针，加上双亲结点中的关键字 $K_i$ 一起合并到 $A_i$ 所指兄弟结点中去（若没有右兄弟结点，则合并至左兄弟结点）。之后，如果因此使双亲结点中的元素个数不足 $\lceil m/2 \rceil-1$，则依次类推左相应处理。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete3.png" alt="B-TreeDelete3"></li>
</ul>
</li>
<li>对于非叶子节点的删除，则需要用后继 key 覆盖要删除的 key，然后在后继 key 所在的位置中删除该后继 key：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete4.png" alt="B-TreeDelete4"><ul>
<li>此时，26 所在的结点不符合要求，需要进行前面说过的向兄弟结点 “借” 的操作；</li>
</ul>
</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是应文件系统所需而出的一种 B- 树的变种；也是 MySQL 的底层数据结构；    </p>
<p><strong>定义</strong>：一棵 m 阶的 B+ 树和 m 阶的 B- 树的差异在于：</p>
<ul>
<li>有 n 棵子树的节点中含有 n 个关键字；</li>
<li>所有的叶子结点包含了全部的关键字信息（及指向这些关键字记录的指针），且叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（的根节点）中的最大（或最小）关键字；</li>
<li>补充：有关结点的元素范围<ul>
<li>非根节点元素范围：$n\ (\lceil m/2 \rceil \leq n \leq m)$</li>
</ul>
</li>
</ul>
<p>好好与 B- 树对比体会，一棵 3 阶的 B+ 树如下所示：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B+Tree.png" alt="B+Tree">  </p>
<ul>
<li>通常，在 B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的节点；   </li>
</ul>
<p><strong>查找</strong>：根据前面所述的两个指针，查找也就可以分为两种方式：</p>
<ol>
<li>从最小关键字起顺序查找；</li>
<li>从根节点开始进行随机查找；<ul>
<li>在 B+ 树上进行这种随机查找，不管查找成功与否，每次查找都是走了一条从根到叶子结点的完整路径；</li>
</ul>
</li>
</ol>
<p><strong>插入</strong>：仅在叶子结点上进行，当结点中的关键字个数大于 m 时，要从中间分裂为两个结点（它们所含关键字个数为：$\lceil \frac{m+1}{2} \rceil$ 和 $\lfloor \frac{m+1}{2} \rfloor$），并且，它们的双亲结点中应同时含有这两个结点的最大关键字。   </p>
<p><strong>删除</strong>：也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端节点中的值可以作为一个 “分界关键字” 继续存在。若因删除而使结点中关键字的个数少于 $\lceil m/2 \rceil$ 时，其和兄弟结点的合并过程和 B- 树类似。</p>
<h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p><strong>定义</strong>：又称数字查找树（Digital Search Tree）。它是一棵高度 $\geq 2$ 的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。    </p>
<p>例如：如下 16 个关键字的集合。{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。逐层划分，组成一棵键树如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/KeyTree.png" alt="KeyTree"></p>
<ul>
<li>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字，叶子结点中的特殊符号 $ 表示字符的结束；</li>
<li>为了插入和查找的方便，会约定键树是一棵有序树，即：同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符 $ 小于任何字符；</li>
</ul>
<p><strong>两种存储结构</strong>：</p>
<ol>
<li>双链树：<ul>
<li>以树的孩子兄弟链表来表示键树，则每个分支结点包括 3 个域：symbol 域（存储关键字的一个字符）、first 域（存储指向第一棵子树根的指针）、next 域（存储指向右兄弟的指针），同时，叶节点的 infoptr 域（存储指向该关键字记录的指针）。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DoubleLinkTree.png" alt="DoubleLinkTree"></li>
</ul>
</li>
<li>Trie 树：<ul>
<li>以树的多重链表表示键树，则树的每个结点中应含有 d 个指针域；</li>
<li>若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个 “叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息；</li>
<li>Trie 树有两种结点：<ul>
<li>分支结点：含有 d 个指针域和一个指示该结点中非空指针域的个数的整数域；<ul>
<li>分支结点中不设数据域，每个分支结点所表示的字符均有其双亲结点中（指向该结点）的指针所在位置决定；</li>
</ul>
</li>
<li>叶子结点：含有关键字域和指向记录的指针域；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/TrieTree.png" alt="TrieTree"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="哈希查找（Hash-Search）"><a href="#哈希查找（Hash-Search）" class="headerlink" title="哈希查找（Hash Search）"></a>哈希查找（Hash Search）</h1><p>前面介绍的各种结构（线性表、树）中，记录在结构中的相对位置时随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录就需要一系列和关键字的比较，也就是常说的基于 “比较” 的查找算法。这样往往比较耗时。    </p>
<h2 id="哈希表和哈希函数"><a href="#哈希表和哈希函数" class="headerlink" title="哈希表和哈希函数"></a>哈希表和哈希函数</h2><p>就是为了解决上述问题而引入的一种 <strong>“以空间换时间”</strong> 的数据结构：</p>
<ul>
<li>它利用哈希函数 $f$ 在记录的存储位置和它的关键字之间建立了一个确定的对应关系 $f$，这样就使得每个关键字和结构中一个唯一的存储位置相对应。按照这种关系记录关键字的表就是哈希表；</li>
<li>在查找时，只要根据这个对应关系 $f$ 找到给定值 $K$ 的像 $f(K)$。若结构中存在关键字和 $K$ 相等的记录，则必定在 $f(K)$ 的存储位置上，由此，不需要进行比较就可以直接取得所查记录。</li>
</ul>
<p><strong>定义</strong>：综上如下描述哈希表：根据给定的哈希函数 $H(key)$ 和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的 “像” 作为记录在表中的存储位置，这种表即为<strong>哈希表</strong>，这一映像过程称为<strong>哈希造表或散列</strong>，所得的存储位置称为<strong>哈希地址或散列地址</strong>。其两大特点就是：</p>
<ul>
<li>映像：哈希函数</li>
<li>冲突：不同的关键字映射到同一地址</li>
</ul>
<h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>首先，“好” 的哈希函数应该具有特点：对于关键字集合中的任一关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为均匀的哈希函数。     </p>
<p><strong>方法一：直接定址法</strong></p>
<ul>
<li>取关键字或关键字的某个线性函数值为哈希地址，即：$H(key)=key$ 或 $H(key)=a \cdot key + b$</li>
</ul>
<p><strong>方法二：数字分析法</strong></p>
<ul>
<li>假设关键字是以 r 为基的数（如：以 10 为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可 “取关键字的若干位” 组成哈希地址；</li>
<li>如：{313、323、333、343、353、363、373、383、393}，可取其第 2 位组成哈希地址；</li>
</ul>
<p><strong>方法三：平方取中法</strong></p>
<ul>
<li>取关键平方后的中间几位为哈希地址。这种方式比较常用；</li>
<li>通常在选哈希函数的时候是不一定知道所有的关键字的，因此取其中那几位也不一定合适，而一个树平方后的中间几位数和数的每一位都相关，由此可使随机分布的关键字得到的哈希地址也是随机的；</li>
</ul>
<p><strong>方法四：折叠法</strong></p>
<ul>
<li>将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后截取这几部分的叠加和（舍去进位）作为哈希地址；</li>
<li>适用于：关键字位数很多，而且关键字中每一位上数字分布大致均匀时；</li>
</ul>
<p><strong>方法五：除留余数法</strong></p>
<ul>
<li>取关键字被某个不大于哈希表表长 m 的数 p 除后所得余数作为哈希地址，即：$H(key)=key\ MOD\ p,\ p \leq m$</li>
<li>这是最简单、也最常用的方法，不仅可以直接对关键字使用 MOD，也可以在折叠、平方取中等运算之后取模；</li>
<li>但是需要注意 p 的选取，否则可能产生较高的冲突；而根据经验，一般选 p 为质数或不包含小于 20 的质因数的合数；</li>
</ul>
<p><strong>方法六：随机数法</strong></p>
<ul>
<li>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即：$H(key)=random(key)$；</li>
<li>通常适用于关键字长度不等时；</li>
</ul>
<p>针对上述提供的方法，实际工作中需要视情况采用。通常考虑的因素有：</p>
<ul>
<li>计算哈希函数所需的时间（包括硬件指令的因素）；</li>
<li>关键字的长度；</li>
<li>哈希表的大小；</li>
<li>关键字的分布情况；</li>
<li>记录的检查频率；</li>
</ul>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>假设哈希表的地址集为 0~(n-1)，冲突就是指有关键字得到的哈希地址为 j （$0 \leq j \leq n-1$） 的位置上已存有记录。那么冲突处理，就是为该关键字重新找的另一个 “空” 的哈希地址。在实际处理时，可能第一次冲突处理得到的地址 $H_1$ 仍旧冲突，则再进行处理得到 $H_2$，再冲突，再处理，…，这样得到了一个地址序列，最后一个地址 $H_k$ 为不发生冲突的地址；</p>
<p><strong>方法一：开放地址法</strong></p>
<ul>
<li>$H_i=(H(key)+d_i)\ MOD\ m,\ i=1,2,…,k\ (k \leq m-1)$</li>
<li>其中，$H(key)$ 为哈希函数；$m$ 为哈希表长；$d_i$ 为增量序列；</li>
<li>根据增量序列的取法，又可以分为如下方法：<ul>
<li>线性探测再散列：$d_i = 1,2,3,…,m-1$<ul>
<li>只要哈希表未填满，最终总能找到一个不发生冲突的地址；</li>
</ul>
</li>
<li>二次探测再散列：$d_i= 1^2,-1^2,2^2,-2^2,…,\pm k^2,\ (k \leq m/2)$<ul>
<li>只有在哈希表长 m 为形如 $4j+3$（j 为整数）的素数时才可能；</li>
</ul>
</li>
<li>伪随机探测再散列：$d_i = 伪随机数序列$<ul>
<li>取决于伪随机数列；</li>
</ul>
</li>
</ul>
</li>
<li>这种处理方式可能带来一个问题：二次聚集（即：原先不发生冲突的地址，却因为之前某个关键字进行了冲突处理，从而又导致了冲突）</li>
</ul>
<p><strong>方法二：再哈希法</strong></p>
<ul>
<li>$H_i=RH_i(key)\ \ i=1,2,…,k$</li>
<li>$RH_i$ 均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生；</li>
<li>这种方法不易产生 “聚集”，但增加了计算时间；</li>
</ul>
<p><strong>方法三：链地址法（拉链法）</strong></p>
<ul>
<li>将所有关键字为同义词的记录存储在同一线性链表中：<ul>
<li>假若某哈希函数产生的哈希地址在区间 [0,m-1] 上，则设立一个指针型变量 Chain ChainHash[m]；其每个分量的初始状态为空指针；</li>
<li>凡哈希地址为 i 的记录都插入到头指针为 ChainHash[i] 的链表中；</li>
<li>在链表中插入的位置可以是表头或表尾，也可以在中间，以保持同义词在同一线性表中按关键字有序；</li>
</ul>
</li>
<li>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/ChainAddressMethod.png" alt="ChainAddressMethod"></li>
</ul>
<p><strong>方法四：建立一个公共溢出区</strong></p>
<ul>
<li>假设哈希函数的值域为 [0,m-1]，则设向量 HashTable[0,m-1] 为基本表，每个分量存放一个记录，另设立向量 OverTable[0..v] 为溢出表；</li>
<li>所有关键字和基本表中关键字为同义的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表；</li>
</ul>
<h2 id="哈希查找分析"><a href="#哈希查找分析" class="headerlink" title="哈希查找分析"></a>哈希查找分析</h2><p><strong>查找过程</strong>：给定 K 值根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找失败；否则，比较关键字，若与给定值相等，则查找成功，否则根据造表时设定的处理冲突函数的方法找 “下一地址”，直至哈希表中某个位置为 “空” 或者表中所填记录的关键字等于给定值时为止；   </p>
<ul>
<li><mark>注意：若要在非链地址处理冲突的哈希表中删除一个记录，则需要在该记录的位置上填入一个特殊的符号，以免找不到在它之后填入的 “同义词” 的记录；</mark></li>
</ul>
<p><strong>性能分析</strong>：因为 “冲突” 使得哈希表的查找过程仍是一个 “比较” 的过程，仍需以平均查找长度作为衡量哈希表的查找效率的度量；</p>
<ul>
<li>查找过程中，比较的次数取决于三个因素：<ul>
<li>哈希函数：一般情况下选取的哈希函数是 “均匀的”，则产生冲突的可能性相同，所以可以不考虑它的影响因素；</li>
<li>冲突处理方法：线性探测再散列容易产生二次聚集，而链地址法，则可以有效避免此情况；</li>
<li>哈希表的装填因子：冲突处理方法相同的哈希表，其平均查找长度就依赖于哈希表的装填因子<ul>
<li>$哈希表的装填因子\ \alpha = \frac{表中填入的记录数}{哈希表长度}$</li>
<li>$\alpha$ 越小，冲突可能性越小；$\alpha$ 越大，冲突可能性越大，则查找过程中比较的次数就越多；</li>
</ul>
</li>
</ul>
</li>
<li>几种冲突处理方法的平均查找长度：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>冲突处理方法</th>
<th>成功时</th>
<th>失败时</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性探测再散列</td>
<td>$S_{nl} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$</td>
<td>$U_{nl} \approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$</td>
</tr>
<tr>
<td>随机探测再散列、二次探测再散列、再哈希</td>
<td>$S_{nr} \approx -\frac{1}{\alpha}ln(1-\alpha)$</td>
<td>$U_{nr} \approx \frac{1}{1-\alpha}$</td>
</tr>
<tr>
<td>链地址法</td>
<td>$S_{nc} \approx 1+\frac{\alpha}{2}$</td>
<td>$U_{nc} \approx \alpha + e^{-\alpha}$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li>
<li>『<a href="https://www.cnblogs.com/magic-sea/p/11391431.html" target="_blank" rel="noopener">賣贾笔的小男孩：分块查找</a>』</li>
<li>『<a href="https://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="noopener">[Data Structure &amp; Algorithm] 七大查找算法</a>』</li>
<li>『<a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">二叉查找树BST——java实现</a>』</li>
<li>『<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a>』</li>
<li>『<a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">面试官问你B树和B+树，就把这篇文章丢给他</a>』</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="TheBetterKong 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="TheBetterKong 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>TheBetterKong
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/" title="查找算法（详解 + java 实现）">http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a>
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/11/FPGA-technology/FPGA-LabExercise/" rel="prev" title="FPGA-Lab Exercise">
                  <i class="fa fa-chevron-left"></i> FPGA-Lab Exercise
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/" rel="next" title="java 数据结构之线性表">
                  java 数据结构之线性表 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备20005224号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheBetterKong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">498k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:33</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


<script color="105,105,105" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"FzJ2kTqyh92urg7N9KHkL0RA-9Nh9j0Va","appKey":"aTVY6lFVOvNPNgaDGtgHVoQy","serverURLs":"https://valine.thebetterkong.cn","placeholder":"Just go go","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":true,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/",
      serverURLs: "https://valine.thebetterkong.cn"
    }));
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
