<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.thebetterkong.cn","root":"/","images":"/images","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="什么是『动态规划』，quora 上有这样一个回答： How should I explain dynamic programming to a 4-year-old ?  writes down 1+1+1+1+1+1+1+1 &#x3D; on a sheet of paper, What’s that equal to ? counting: 8 writes down another 1+ o">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划搭建 “摩天大厦”">
<meta property="og:url" content="http://www.thebetterkong.cn/2021/05/22/DataStructure-Algorithm/DynamicProgramming/index.html">
<meta property="og:site_name" content="TheBetterKong">
<meta property="og:description" content="什么是『动态规划』，quora 上有这样一个回答： How should I explain dynamic programming to a 4-year-old ?  writes down 1+1+1+1+1+1+1+1 &#x3D; on a sheet of paper, What’s that equal to ? counting: 8 writes down another 1+ o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/header.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/stepproblem.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/FibonacciRecTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/FibonacciRecBwTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/CoinsRecTree.png">
<meta property="og:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/FZvsDPvsBFS.png">
<meta property="article:published_time" content="2021-05-22T05:25:42.000Z">
<meta property="article:modified_time" content="2021-06-04T13:14:21.959Z">
<meta property="article:author" content="TheBetterKong">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.thebetterkong.cn/blog/DynamicProgramming/header.png">


<link rel="canonical" href="http://www.thebetterkong.cn/2021/05/22/DataStructure-Algorithm/DynamicProgramming/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>动态规划搭建 “摩天大厦” | TheBetterKong</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="TheBetterKong" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">TheBetterKong</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">自律即自由</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">2.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">2.1.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念引入"><span class="nav-number">2.1.1.</span> <span class="nav-text">概念引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-number">2.1.2.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">2.1.3.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多阶段决策问题"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">多阶段决策问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态规划问题中的术语"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">动态规划问题中的术语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本结构"><span class="nav-number">2.1.4.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用条件"><span class="nav-number">2.1.5.</span> <span class="nav-text">适用条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类"><span class="nav-number">2.2.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局限性"><span class="nav-number">2.3.</span> <span class="nav-text">局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">2.4.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#问题求解框架"><span class="nav-number">3.</span> <span class="nav-text">问题求解框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-1"><span class="nav-number">3.1.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波拉契数列问题"><span class="nav-number">3.1.1.</span> <span class="nav-text">斐波拉契数列问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#凑零钱问题"><span class="nav-number">3.1.2.</span> <span class="nav-text">凑零钱问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典题型"><span class="nav-number">4.</span> <span class="nav-text">经典题型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-vs-贪心问题，分治、BFS"><span class="nav-number">4.1.</span> <span class="nav-text">DP vs. 贪心问题，分治、BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背包类型问题"><span class="nav-number">4.2.</span> <span class="nav-text">背包类型问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1-背包问题"><span class="nav-number">4.2.1.</span> <span class="nav-text">0-1 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子集背包问题"><span class="nav-number">4.2.2.</span> <span class="nav-text">子集背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全背包问题"><span class="nav-number">4.2.3.</span> <span class="nav-text">完全背包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子序列问题"><span class="nav-number">4.3.</span> <span class="nav-text">子序列问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最大子数组：最大子数组和问题"><span class="nav-number">4.3.1.</span> <span class="nav-text">最大子数组：最大子数组和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编辑距离"><span class="nav-number">4.3.2.</span> <span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列-LCS："><span class="nav-number">4.3.3.</span> <span class="nav-text">最长公共子序列 LCS：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长递增子序列-LIS：俄罗斯套娃信封问题"><span class="nav-number">4.3.4.</span> <span class="nav-text">最长递增子序列 LIS：俄罗斯套娃信封问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">4.4.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP-问题"><span class="nav-number">4.4.1.</span> <span class="nav-text">KMP 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式"><span class="nav-number">4.4.2.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stop"><span class="nav-number">4.4.3.</span> <span class="nav-text">stop</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#写在最后"><span class="nav-number">5.</span> <span class="nav-text">写在最后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TheBetterKong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">TheBetterKong</p>
  <div class="site-description" itemprop="description">知行合一</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TheBetterKong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TheBetterKong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kongxiangfeng@iie.ac.cn" title="E-Mail → mailto:kongxiangfeng@iie.ac.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_44849403" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44849403" rel="noopener" target="_blank"><i class="fa fa-copyright fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6460669623" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6460669623" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.huaxiaozhuan.com/" title="http:&#x2F;&#x2F;www.huaxiaozhuan.com&#x2F;" rel="noopener" target="_blank">AI 算法工程师手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.cugxuan.cn/" title="https:&#x2F;&#x2F;blog.cugxuan.cn&#x2F;" rel="noopener" target="_blank">泫</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://paper.seebug.org/" title="https:&#x2F;&#x2F;paper.seebug.org&#x2F;" rel="noopener" target="_blank">Paper seebug</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://man.linuxde.net/" title="https:&#x2F;&#x2F;man.linuxde.net&#x2F;" rel="noopener" target="_blank">Linux 大全</a>
        </li>
    </ul>
  </div>

        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/TheBetterKong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.thebetterkong.cn/2021/05/22/DataStructure-Algorithm/DynamicProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="TheBetterKong">
      <meta itemprop="description" content="知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TheBetterKong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划搭建 “摩天大厦”
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-22 13:25:42" itemprop="dateCreated datePublished" datetime="2021-05-22T13:25:42+08:00">2021-05-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-04 21:14:21" itemprop="dateModified" datetime="2021-06-04T21:14:21+08:00">2021-06-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DataStructure-Algorithm/" itemprop="url" rel="index"><span itemprop="name">DataStructure & Algorithm</span></a>
        </span>
    </span>

  
    <span id="/2021/05/22/DataStructure-Algorithm/DynamicProgramming/" class="post-meta-item leancloud_visitors" data-flag-title="动态规划搭建 “摩天大厦”" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/22/DataStructure-Algorithm/DynamicProgramming/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/22/DataStructure-Algorithm/DynamicProgramming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <div align="center"> <img src="http://img.thebetterkong.cn/blog/DynamicProgramming/header.png" width="100%" alt="header.png" /> </div>

<p>什么是『动态规划』，quora 上有这样一个回答：</p>
<div class="note warning"><p>How should I explain dynamic programming to a 4-year-old ?</p>
<ul>
<li>writes down <code>1+1+1+1+1+1+1+1 =</code> on a sheet of paper, What’s that equal to ?</li>
<li>counting: <code>8</code></li>
<li>writes down another <code>1+</code> on the left, what about that ?</li>
<li>quickly: <code>9</code></li>
<li>how’d you know it was nine so fast ?</li>
<li>you just add <code>1</code> more, so you didn’t need to recount, because you remembered there were eight !</li>
<li>Dynamic Programming is just a fancy way to say <strong>remembering stuff to save time later</strong>.</li>
</ul>
</div>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>用了一段英文作为本篇 Blog 的引言，你要问我为啥不给你翻译一下，答案就是 “格调”，显得更高大上，你就会点进来了（是不是要喷我？一段英文还谈格调？嘿，但你还就真点进来了）。</p>
<p>是不是又要说我咋这多废话？这不活跃活跃气氛，让你能更放松一些看完后面的内容嘛。</p>
<p>言归正传。对于动态规划，首先来看看「<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">百度百科的解释</a>」：</p>
<blockquote>
<p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解<strong>决策过程</strong>最优化的过程。20 世纪 50 年代初，美国数学家<strong>贝尔曼</strong>（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的<strong>最优化原理</strong>，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在<strong>背包问题</strong>、生产经营问题、<strong>资金管理问题</strong>、<strong>资源分配问题</strong>、<strong>最短路径问题</strong>和复杂系统可靠性问题等中取得了显著的效果。</p>
</blockquote>
<p>据 Bellman 描述，DP 这个名字是他编的，主要为了规避军方的厌恶，否则就要用什么 decision research 这种名字了。那他编这个名字又有什么意义呢？其实，这里 <strong>programming</strong> 不是编程的意思，而是<strong>决策</strong>。但这种决策不是一下就出来的，而是一步步（multistage）<strong>积累</strong>出来。换句话说我们需要一个决策，但这个决策太大了，我们做不了，所以需要把它递归到我们可以简单做出决策的状态，然后从这些状态开始，慢慢的 “动态地” 演进到最终的决策。</p>
<blockquote>
<p>关于 DP 的起源，Bellman 在它的自传 《Eye of the Hurricane: An Autobiography(P159)》 中写下了这样一段话：</p>
<p>An interesting question is, ‘Where did the name, dynamic programming, come from?’ The 1950s were not good years for mathematical research. We had a very interesting gentleman in Washington named Wilson. He was Secretary of Defense, and he actually had a pathological fear and hatred of the word, research. I’m not using the term lightly; I’m using it precisely. His face would suffuse, he would turn red, and he would get violent if people used the term, research, in his presence. You can imagine how he felt, then, about the term, mathematical. The RAND Corporation was employed by the Air Force, and the Air Force had Wilson as its boss, essentially. Hence, I felt I had to do something to shield Wilson and the Air Force from the fact that I was really doing mathematics inside the RAND Corporation. What title, what name, could I choose? In the first place I was interested in planning, in decision making, in thinking. But planning, is not a good word for various reasons. I decided therefore to use the word, ‘programming.’ I wanted to get across the idea that this was dynamic, this was multistage, this was time-varying—I thought, let’s kill two birds with one stone. Let’s take a word that has an absolutely precise meaning, namely dynamic, in the classical physical sense. It also has a very interesting property as an adjective, and that is it’s impossible to use the word, dynamic, in a pejorative sense. Try thinking of some combination that will possibly give it a pejorative meaning. It’s impossible. Thus, I thought dynamic programming was a good name. It was something not even a Congressman could object to. So I used it as an umbrella for my activities.</p>
</blockquote>
<p>所以，总结来说，动态规划最核心的思想在于 “<mark>把一个大问题拆分为若干小问题，这若干小问题互相联系，求解后面的小问题时，会用到前面小问题的解</mark>”。这句话里，有两个重点 “<strong>拆分</strong>” “<strong>联系</strong>”。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>网上对于 DP 的解释很多，但是 “一千个人就有一千个哈姆雷特” 每个人都可能会有一些细节的问题遗漏。所以，这一小节的目的是全面的了解 DP，作为一种科普，如不感兴趣可以跳过。</p>
<p>以下内容主要来自百度百科，未来遇到更多的内容还会继续添加。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。</p>
<p>虽然动态规划主要用于求解<strong>以时间划分阶段</strong>的动态过程的优化问题，但是一些与时间无关的静态规划（如线性规划、非线性规划），只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。</p>
<h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个<strong>前后关联具有链状结构的多阶段过程就称为多阶段决策过程</strong>，这种问题称为<strong>多阶段决策问题</strong>。</p>
<p><mark>在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法</mark>。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<ul>
<li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。<mark>我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路</mark>。具体的动态规划算法多种多样，但它们具有相同的填表格式。</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="多阶段决策问题"><a href="#多阶段决策问题" class="headerlink" title="多阶段决策问题"></a>多阶段决策问题</h4><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。</p>
<p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</p>
<h4 id="动态规划问题中的术语"><a href="#动态规划问题中的术语" class="headerlink" title="动态规划问题中的术语"></a>动态规划问题中的术语</h4><div class="table-container">
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>阶段</td>
<td>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同。</td>
<td>描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用 k 表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。</td>
</tr>
<tr>
<td>状态</td>
<td>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。</td>
<td>在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点。</td>
</tr>
<tr>
<td>无后效性</td>
<td>我们要求状态具有下面的性质：<br>如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。</td>
<td>换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。<br>状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。</td>
</tr>
<tr>
<td>决策</td>
<td>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。</td>
<td>在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。决策变量的范围称为允许决策集合。</td>
</tr>
<tr>
<td>策略</td>
<td>由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。允许策略集合中达到最优效果的策略称为最优策略。</td>
<td>给定 <code>k</code> 阶段状态变量 <code>x(k)</code> 的值后，如果这一阶段的决策变量一经确定，第 <code>k+1</code> 阶段的状态变量 <code>x(k+1)</code> 也就完全确定，即 <code>x(k+1)</code> 的值随 <code>x(k)</code> 和第 <code>k</code> 阶段的决策 <code>u(k)</code> 的值变化而变化，那么可以把这一关系看成 <code>(x(k)，u(k))</code> 与 <code>x(k+1)</code> 确定的对应关系，用 <code>x(k+1)=Tk(x(k),u(k))</code> 表示。这是从 <code>k</code> 阶段到 <code>k+1</code> 阶段的状态转移规律，称为状态转移方程。</td>
</tr>
<tr>
<td>最优化原理</td>
<td>作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”。最优性原理实际上是要求问题的最优策略的子策略也是最优。</td>
<td>无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。</p>
<h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性：</p>
<ul>
<li><strong>最优化原理（最优子结构性质）</strong>：<ul>
<li>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</li>
</ul>
</li>
<li><strong>无后效性</strong>：<ul>
<li>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</li>
</ul>
</li>
<li><strong>子问题的重叠性</strong>：<ul>
<li>动态规划算法的关键在于<strong>解决冗余</strong>，这是动态规划算法的根本目的。动态规划实质上是一种<strong>以空间换时间</strong>的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间。</li>
<li>注意：该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</li>
</ul>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>动态规划的数学模型。根据决策过程的演变是确定性的还是随机性的。可分为「确定性决策过程」和「随机性决策过程」。另外。也可按时间参量是离散的或是连续的变量。分为「离散决策过程」和「连续决策过程」。组合起来就有离散确定性、离散随机性、连续确定性、连续随机性四种决策过程模型。</p>
<p>对于确定性的决策过程。问题中下一段的状态已由当前段的状态及决策完全确定。对于随机性决策过程。它与确定性决策过程的区别在于下一段的状态并不能由当前段的状态及决策完全确定。而是按<strong>某种概率分布</strong>来决定下一段的状态。这种概率分布是由当前段的状态和决策完全确定。</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性：</p>
<ul>
<li>首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；</li>
<li>另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是“维数障碍”。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说了这么多大白话，是不是觉得有点一头雾水了。我们来看一道 『<a href="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/">剑指 offer：跳台阶</a>』问题，题目描述：</p>
<blockquote>
<p>剑指 offer T8 / Leetcode T70：<br>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>为了便于描述，我们将问题转换一下形势：</p>
<p><img src="http://img.thebetterkong.cn/blog/DynamicProgramming/stepproblem.png" alt="stepproblem"></p>
<p>假如我们使用暴力遍历方式，我们首先计算 <code>0-&gt;1</code> 的所有可能路径，再计算 <code>0-&gt;2</code> 的所有可能路径…最终计算 <code>0-&gt;10</code> 的所有可能路径，这中间就有一个问题：我们在计算 <code>0-&gt;5</code> 的路径时，会把前面 <code>0-&gt;1</code>、<code>0-&gt;2</code>、<code>0-&gt;3</code>、<code>0-&gt;4</code> 的路径再遍历一次，这样就造成了大量的重复计算。</p>
<p>我们其实可以重复利用这些中间信息，因为任意时刻，只可能走一步或者两步，这意味着再求 <code>0-&gt;5</code> 的路径时，我们可以先计算它的上一个状态，即上一时刻可能处于的位置（<code>3</code>/<code>4</code>）。那么，如果我们假设 <code>0-&gt;5</code> 的路径数为 $f(5)$，那么 $f(5)=f(3)+f(4)$。推广至任意时刻，有 $f(n)=f(n-2)+f(n-1)$。</p>
<p>求 <code>f(10)</code> 的过程也就为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
  f(0) &= 1 \\
  f(1) &= 1 \\
  f(2) &= f(0) + f(1) = 2 \\
  f(3) &= f(1) + f(2) = 3 \\
  \dots \\
  f(10) &= f(8) + f(9) = 89
\end{aligned}</script><p>具体的算法实现，可点击上面的链接，参考我的另一篇 Blog；</p>
<p>这个问题就可以作为一种动态规划问题，题目中任意时刻所处的位置就是 “<strong>状态</strong>”，下一次是走 1 级台阶还是两级台阶就是 “<strong>决策</strong>”，从位置 0 到位置 n 的所有决策合起来就是一种 “<strong>策略</strong>”，本题要求的就是有多少种策略。另外，如果在题目上在加一条 “青蛙落在不同台阶上可以获得不同数量的金币，问什么样的策略能得到的金币最多”，这就变成了一个<strong>最优决策问题</strong>。</p>
<h1 id="问题求解框架"><a href="#问题求解框架" class="headerlink" title="问题求解框架"></a>问题求解框架</h1><p>现在，对于 DP 问题你已经有了深刻的认识，那么在遇到这类问题的时候，我们具体应该怎么做呢？</p>
<p>做过动态规划题目的你一定意识到，大多数 DP 问题都是在要你求最值，比如最长递增子序列、最小编辑距离等等。而解决这些问题<strong>最简单暴力的方法就是 「穷举」</strong>，将问题的所有可行解罗列出来，然后再在其中寻找最值。这看似愚蠢的做法却正是 DP 问题的核心所在。</p>
<p>不同于 「穷举」，DP 有三个关键点：</p>
<div class="note warning"><ol>
<li><p>首先，动态规划问题⼀定会具备 “<strong>最优⼦结构</strong>”，因为只有这样才能通过⼦问题的最值得到原问题的最值。</p>
<ul>
<li>这里用两个例子解释一下最优子结构。⽐如说，你的原问题是考出最⾼的总成绩，那么你的⼦问题就是要把语⽂考 到最⾼，数学考到最⾼…… 为了每门课考到最⾼，你要把每门课相应的选 择题分数拿到最⾼，填空题分数拿到最⾼…… 当然，最终就是你每门课都是满分，这就是最⾼的总成绩。得到了正确的结果：最⾼的总成绩就是总分。因为这个过程符合最优⼦结构，“每门科⽬考到最⾼”这些⼦问题是互相独⽴，互不⼲扰的。但是，如果加⼀个条件：你的语⽂成绩和数学成绩会互相制约，此消彼⻓。这样的话，显然你能考到的最⾼总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为⼦问题并不独⽴，语⽂数学成绩⽆法同时最优，所以最优⼦结构被破坏。</li>
</ul>
</li>
<li><p>DP 问题往往存在 “<strong>重叠子问题</strong>”，如果暴力穷举效率会极低。所以，DP 往往会需要「<strong>备忘录</strong>」或者 「<strong>DP table</strong>」来记录中间状态，避免不必要的计算，从而优化穷举过程；</p>
</li>
<li><p>穷举时，我们也需要一种 “<strong>穷举策略</strong>” 才能不遗漏的写出问题的所有可行解，但 DP 问题千变万化，找出这种策略也不是一件容易的事。这所谓的策略，对应到 DP 上也就是我们常说的「<strong>状态转移方程</strong>」；</p>
</li>
</ol>
</div>
<p>以上三点，分别对应着 DP 问题的 “<mark>确定问题阶段</mark>、<mark>确定各个阶段的状态</mark>、<mark>确定相邻两个状态间的递推关系</mark>”，这也是 DP 问题的核心三要素。如果将整个求解过程用一张<mark>最优决策表</mark>来描述，具体如下：</p>
<ul>
<li>最优决策表是一张二维表，行：决策阶段，列：问题的状态；</li>
<li>表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值，如最短路径，最长公共子序列，最大价值等；</li>
<li>填表的过程就是根据递推关系，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</li>
</ul>
<p>上面的描述可能还是很抽象，我们将问题更加具体化，描述一下 <mark>DP 问题的基本步骤</mark>：</p>
<div class="note warning"><ul>
<li>任何一个 DP 问题都按<strong>时刻</strong>划分为这种形式：<ul>
<li>$初始状态 \rightarrow │决策 1│ \rightarrow │决策 2│ \rightarrow \dots \rightarrow │决策 n│ \rightarrow 结束状态$</li>
</ul>
</li>
<li>划分：<ul>
<li>按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的；</li>
</ul>
</li>
<li>确定状态和状态变量：<ul>
<li>将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性；</li>
</ul>
</li>
<li>确定决策并写出状态转移方程：<ul>
<li>状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程；</li>
<li>这往往也是最难的一步；</li>
</ul>
</li>
<li>边界条件：<ul>
<li>状态转移方程是一个递推式，因此需要找到递推终止的条件；</li>
</ul>
</li>
</ul>
</div>
<p>现在，我总结一下 DP 问题固定的思维模式：</p>
<div class="note warning"><ol>
<li>确定问题是否属于 DP 问题：<ul>
<li>问题能否穷举实现？思考应如何按时刻分解问题？分解的各子问题是否构成最优子结构？</li>
</ul>
</li>
<li>确定各阶段状态、状态变量，决策，然后尝试写出状态转移方程：<ul>
<li>这是最关键的一步，此时眼光一定要放广，要从全局考虑问题，可以先不考虑细枝末节的东西。</li>
<li>可能需要与第一步联合思考，DP 问题可能会有许多种划分方式，但并不一定每一种都能写出合适的状态转移方程；</li>
<li>建议将状态描述为 $f(args)$ 的形式，这其实就是所谓的 <code>DP 函数</code>，其中 $args$ 可能是一组参量，但不管咋样它的目的只有一个，用来标识状态；</li>
<li>另外，状态（DP 函数）的意义一定要明确；</li>
</ul>
</li>
<li>如果问题是 “最优” 问题，确定择优策略：<ul>
<li>往往伴随着 <code>判断、max、min</code> 函数的使用</li>
</ul>
</li>
<li>确定问题的边界条件 base case：<ul>
<li>它意味着递归算法的出口，迭代问题的初始状态；</li>
<li>它的求解比较简单，要么题目会给出，要么就直接人工计算即可；</li>
</ul>
</li>
<li>查找是否存在重复子问题：<ul>
<li>这一步的主要目的是优化，不是刚需，但也很重要</li>
</ul>
</li>
</ol>
</div>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>接下来用两个例子，第一个例子是来帮助你理解上述框架，并看看 DP 问题是如何优化的。第二个例子，带你一起感受 DP 问题固定的思维模式。</p>
<h3 id="斐波拉契数列问题"><a href="#斐波拉契数列问题" class="headerlink" title="斐波拉契数列问题"></a>斐波拉契数列问题</h3><p>它的数学描述为：</p>
<script type="math/tex; mode=display">
f(n) = \begin{cases}
          1,                \quad & n = 1,2 \\\\
          f(n-1) + f(n-2),  \quad & n > 2
        \end{cases}</script><p>上面的数学表达式实际上就是将<strong>状态转移方程</strong>告诉了我们。利用这个方程，最简单的求解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样一个递归算法的效率极低，我们假设 n = 20，画出他们递归树如下：</p>
<p><img src="http://img.thebetterkong.cn/blog/DynamicProgramming/FibonacciRecTree.png" alt="FibonacciRecTree.png"></p>
<p>在这样一棵树里，将涉及到 $O(2^n)$ 次计算 $f(k)$，指数爆炸。最大递归深度也为 n。</p>
<p>观察算法低效的原因：存在了大量的重复计算。例如，图中 $f(18)、f(17)$ 都被计算了两次，而且越往下，k 越小，被重复计算的次数就越多。这就是我们之前谈到的，<strong>重复子问题</strong>。</p>
<p>为了解决这个问题，我们可以建立一个数组充当「<strong>备忘录</strong>」，将这些中间结果保存下来再返回。这样，每次遇到新的子问题时，如果数组里有就直接返回，没有再去做计算。代码描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> helper(help, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] help, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n ==<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (help[n] != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> help[n];</span><br><span class="line">  &#125;</span><br><span class="line">  help[n] = helper(help, n - <span class="number">1</span>) + helper(help, n - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> help[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的递归树如下所示：</p>
<p><img src="http://img.thebetterkong.cn/blog/DynamicProgramming/FibonacciRecBwTree.png" alt="FibonacciRecBwTree.png"></p>
<p>图中被梯形包住的部分都是可以省去的计算。此时时间复杂度降至 $O(1)$。</p>
<p>这种方案已经可以接受，但是我们都知道，任何一个算法，递归绝对不是最优的解决方案。本题也可以直接利用数组「<strong>DP table</strong>」，从前往后完成计算。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述问题其实还可以进一步优化，因为我们每一次计算实际只需要前两次的计算结果，所以我们并不需要 <code>dp[n+1]</code>，这么大的数组，只需要两个变量保存前两次的计算结果即可，这样可将空间复杂度降为 $O(1)$。这一步和 DP 的联系不是很大，这里不再细说，详细实现可见我的文章：<a href="http://www.thebetterkong.cn/2020/04/05/DataStructure-Algorithm/Finger-offer67/">剑指 offer 67题</a>。</p>
<h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><p>上面的例子，你可能会觉得 “啥 DP？就这？这么简单？”。问题才刚开始，你要记住，上面的例子可是直接将状态转移方程告诉你了，而如何确定状态转移方程才是 DP 问题最难的点。所以，我们再看一个例子：</p>
<blockquote>
<p>Leetcode T322：<br>假如你的手上有三种金额的硬币，1 元、2 元、5 元，各种硬币的数量足够多。现在你需要从中挑选硬币凑出 11 元，问：最少需要挑选多少枚硬币？</p>
<p>题目也可以用数学形式表述：</p>
<p>有三个数 $x_1$，$x_2$，$x_3$，满足 $x_1 + 2 \ast x_2 + 5 \ast x_3 = 11$，求 $min(x_1 + x_2 + x_3)$</p>
</blockquote>
<p>确定是否属于 DP 问题，回答三个问题：</p>
<ul>
<li>能穷举：把这三个数所有取值穷举一遍。假设在某一时刻，我们已经凑出来 amount 元（子问题），假如 amount = 10，我们再拿一枚 1 元的硬币即可。由于硬币数量无限制，子问题间不存在相互制约，是相互独立的。</li>
</ul>
<p>确定状态，状态变量，状态转移方程：</p>
<ul>
<li>状态是随着时刻变化的，硬币数量不限，那就只有金额会变，于是将状态描述为 $dp(amount)$，状态变量 $amount$ 即当前凑出来得钱数目。那 DP 函数 $dp(amount)$ 的意义就是：凑出 amount 的钱，最少需要 $dp(amount)$ 枚硬币；</li>
<li>对于每个状态，改变它们的方式就是选取一枚硬币（对应三种情况），目标金额就会随着相应减少。</li>
<li>$dp(n) = min(dp[n - coin]+1\ |\ coin \in coins)$</li>
</ul>
<p>确定最优策略：</p>
<ul>
<li>硬币数量最少，就是上述式子里的 min 函数；</li>
</ul>
<p>确定边界条件：</p>
<ul>
<li>⽬标⾦额为 0 时，所需硬币数量为 0；当⽬标⾦额 ⼩于 0 时，⽆解，返回 -1：</li>
</ul>
<p>总结上述分析过程，最后得到完整的状态转移方程：</p>
<script type="math/tex; mode=display">
dp(n) = \begin{cases}
          -1, \quad & n < 0 \\\\
          0, \quad & n = 0 \\\\
          min(dp[n - coin]+1\ |\ coin \in coins), \quad & n > 0
        \end{cases}</script><p>代码描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">int</span> subcount = coinChange(coins, n - coin);</span><br><span class="line">        <span class="comment">// 无解则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (subcount == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        count = Math.min(count, subcount + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count != Integer.MAX_VALUE ? count : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画一下递归树，分析一下重叠子问题：</p>
<p><img src="http://img.thebetterkong.cn/blog/DynamicProgramming/CoinsRecTree.png" alt="CoinsRecTree.png"></p>
<p>发现还是存在优化空间的，因为「备忘录」式求解策略仍然存在递归，所以不太推荐使用，这里直接利用「DP table」优化，具体实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findConis</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, n + <span class="number">1</span>);     <span class="comment">// 相当于初始化为正无穷</span></span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n] == n + <span class="number">1</span> ? -<span class="number">1</span> : dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h1><p>本文的目的是让你熟练使用 DP 问题的求解思路，因此，这里会罗列一系列 DP 问题，但不会给出具体的实现，我们要注意分析对比这些题目之间的差别联系。具体问题细节的讨论，后面再慢慢补充。</p>
<p>如果是 Leetcode 上的题目，其具体的实现可见我的 <a href="https://github.com/TheBetterKong/MyLeetcodes" target="_blank" rel="noopener">GitHub</a>。</p>
<h2 id="DP-vs-贪心问题，分治、BFS"><a href="#DP-vs-贪心问题，分治、BFS" class="headerlink" title="DP vs. 贪心问题，分治、BFS"></a>DP vs. 贪心问题，分治、BFS</h2><p>说到「DP 问题」，我们脑海里最常联想出来的就是「贪心问题」和「回溯问题」，我们常常容易把这两类问题弄混。这里，我简单描述一下他们的区别，后面再在别的文章里详细描述；</p>
<p><strong>贪心</strong>：它可以被看做是 DP 的一个特例，它往往需要问题满足 “贪心” 性质，好处在于，效率更高；</p>
<ul>
<li>“贪心” 性质：每一步都做局部最优的选择，最终的结果就是全局最优；<ul>
<li>例如：面前有 100 张人民币，让你从中拿出 10 张，怎么拿才能保证前最多呢？当然是每一次都拿金额最大的，这就是满足贪心性质的问题。但如果，在里面加入一些限制，例如，如果你拿的金额太大，下一次拿的时候限制你只能从部分里面选，这样你就没法保证每一次局部最优能达到全局最优；</li>
</ul>
</li>
<li>效率优势在于，如果一个算法 “暴力解法” 需要指数级的时间，那么 “DP” 就是通过消除重复问题，将指数级时间降至多项式级时间，而 “贪心” 就是利用 “DP” 里满足贪心性质，将时间进一步降低，甚至达到线性级时间;</li>
</ul>
<p><strong>分治</strong>：前面已经说过了，将大问题拆分为一个一个的小问题，它是 DP 的主要思想，说白了，DP 就是利用分治子问题的相关性，消除重复性问题，从而优化效率的思想；</p>
<p><strong>BFS</strong>：回溯的核心也是分治，它也是在暴力穷举所有可能的子问题时，利用剪枝，将不满足条件的子问题提前结束，不再往下进行，从而优化效率。</p>
<p>当遇到某种问题可以用暴力穷举破解时，我们采用分治法的思想，利用递归，构造出递归树。在这棵递归树的基础上，DP 的核心在于<mark>合并子树</mark>，BFS 的核心在于<mark>去除子树</mark>。如下：</p>
<p><img src="http://img.thebetterkong.cn/blog/DynamicProgramming/FZvsDPvsBFS.png" alt="FZvsDPvsBFS.png"></p>
<h2 id="背包类型问题"><a href="#背包类型问题" class="headerlink" title="背包类型问题"></a>背包类型问题</h2><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p>问题描述：</p>
<blockquote>
<p>给你⼀个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两 个属性。其中第 i 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你⽤ 这个背包装物品，最多能装的价值是多少？</p>
<p>例如：<br><code>N = 3, W = 4</code><br><code>wt = [2, 1, 3]</code><br><code>val = [4, 2, 3]</code></p>
</blockquote>
<p>思路：</p>
<ul>
<li>状态：描述局面，本题中就是 “当前背包容量” 和 “背包里物品价值”，物品 i</li>
<li>决策：某件物品装还是不装</li>
<li>DP 数组：<code>dp[i][w]</code>，对于前 i 个物品，当前背包剩余容量为 w，最大价值。例如：<code>dp[3][5] = 6</code> 表示前三个物品进行选择，当剩余容量为 5 时，能装下的最大价值为 6</li>
<li>状态转移方程：<ul>
<li>$dp[i][w] = \max \big(dp\big[i-1\big]\big[w\big],\ dp\big[i-1\big]\big[w - wt[i-1]\big] + val\big[i-1\big] \big)$</li>
</ul>
</li>
<li>处理相关边界：主要是两点，“初始状态” 和 “$w - wt[i-1] &lt; 0$ 可能越界” </li>
<li>压缩：在求 <code>dp[i][w]</code> 时，只需要用到上一行 dp 数组的值，所以可以压缩空间，将二维的 dp 数组压缩为一维。相当于在迭代过程中，用迭代进行的时刻 i 替换 dp 的第一维。</li>
</ul>
<h3 id="子集背包问题"><a href="#子集背包问题" class="headerlink" title="子集背包问题"></a>子集背包问题</h3><p>问题描述：</p>
<blockquote>
<p>Leetcode T416：<br>给你一个 只包含正整数 的 非空 数组 <code>nums</code>。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p>
</blockquote>
<p>问题转换（联系）：</p>
<ul>
<li>给一个可装载重量为 $\frac{sum}{2}$ 的背包和 $N$ 个物品，每个物品的重量为 $nums[i]$。问，是否存在一种装法可以刚好装满背包？</li>
</ul>
<p>思路：</p>
<ul>
<li>状态：当前背包容量，物品 i</li>
<li>决策：某件物品装与不装</li>
<li>DP 数组：<code>dp[i][j]</code> 表示从数组的 <code>[0,i]</code> 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。</li>
<li>状态转移方程：</li>
</ul>
<script type="math/tex; mode=display">
dp[i][j] = \begin{cases}
          dp\big[i-1\big]\big[j\big]\ \big|\ dp\big[i-1\big]\big[j - nums[i-1]\big], \quad & j \geq nums[i-1] \\\\
          dp[i-1][j], \quad & j < nums[i-1]
        \end{cases}</script><ul>
<li>边界：初始时，<code>dp[i][0] = true</code> 以及 <code>dp[0][nums[0]] = true</code></li>
<li>压缩：原理同上</li>
</ul>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>问题描述：</p>
<blockquote>
<p>Leetcode T518：<br>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p>
<p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额:<br>5 = 5<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 1 + 1<br>5 = 1 + 1 + 1 + 1 + 1</p>
</blockquote>
<p>问题转换（联系）：</p>
<ul>
<li>给一个可装载重量为 $amount$ 的背包，有一系列物品 $coins$，每个物品的重量为 $coins[i]$，每种物品数量无限。问：有多少种方法能刚好把背包装满？</li>
</ul>
<p>思路：</p>
<ul>
<li>状态：当前背包容量，物品 i</li>
<li>决策：某件物品装与不装</li>
<li>DP 数组：<code>dp[i][j]</code> 表示若只使用前 <code>i</code> 个物品，当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种办法刚好将背包装满</li>
<li>状态转移方程：<ul>
<li>如果你不把这第 <code>i</code> 个物品装入背包，也就是说你不使用 <code>coins[i-1]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</li>
<li>如果你把这第 <code>i</code> 个物品装入了背包，也就是说你使用 <code>coins[i-1]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</li>
<li>也就是说：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
dp[i][j] = \begin{cases}
          dp\big[i-1\big]\big[j\big]\ +\ dp\big[i\big]\big[j - coins[i-1]\big], \quad & j \geq coins[i-1] \\\\
          dp[i-1][j], \quad & j < coins[i-1]
        \end{cases}</script><ul>
<li>边界：初始时，<code>dp[0][...] = 0</code> 以及 <code>dp[...][0] = 1</code></li>
<li>压缩：dp 状态的转移只与 <code>dp[i][...]</code> 和 <code>dp[i-1][...]</code> 有关，原理同上</li>
</ul>
<p>注意：</p>
<ul>
<li>这里有的人会觉得 <code>dp[i]</code> 和 <code>dp[i-1]</code> 似乎还是要保存第一维的值，怎么压缩，差别在哪？但是这就是 “0-1 背包问题” 和 “完全背包” 问题的区别。可以将本题改为每种物品数量固定，再品味一下这其中的差别；</li>
</ul>
<h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最大子数组：最大子数组和问题"><a href="#最大子数组：最大子数组和问题" class="headerlink" title="最大子数组：最大子数组和问题"></a>最大子数组：最大子数组和问题</h3><p>问题描述：</p>
<blockquote>
<p>Leetcode T53：<br>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<p>输入：<code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code><br>输出：<code>6</code><br>解释：连续子数组 <code>[4,-1,2,1]</code> 的和最大，为 <code>6</code>。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>状态：遍历到某个位置时连续子数组的最大和</li>
<li>决策：当前位置的数字是否加入连续子数组</li>
<li>dp 数组：<code>dp[i] = k</code> 表示，已经求出至数组 <code>nums[i]</code> 位置连续子数组的最大和为 <code>k</code></li>
<li>状态转移方程：</li>
</ul>
<script type="math/tex; mode=display">
dp[i+1] = \max \big( dp[i]\ +\ num[i+1] ，nums[i+1] \big)；</script><ul>
<li>压缩：本题也不需要我们求出这个连续子数组，因此只需要再使用一个变量 result 来时刻更新最大值即可，而不需要 dp 数组；</li>
</ul>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>问题描述：</p>
<blockquote>
<p>Leetcode T72：<br>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1：</p>
<p>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
</blockquote>
<p>思路：</p>
<ul>
<li>状态：两个字符串某时刻变换到得位置</li>
<li>决策：三种操作 <code>插入</code>，<code>删除</code>，<code>替换</code></li>
<li>dp 数组：假定 <code>dis[i][j]</code> 表示 word1 的前 i 个字母，到 word2 的前 j 个字母的编辑距离</li>
<li>状态转移方程：<ul>
<li>根据决策，求解 <code>dis[i][j]</code> 时应该分为如下三种情况：<ol>
<li><code>dis[i][j-1]</code>：<ul>
<li>对于 <code>word2</code> 的第 <code>j</code> 个字符，我们在 <code>word1</code> 的末尾添加了一个相同的字符，那么 <code>dis[i][j]</code> 最小可以为 <code>dis[i][j-1] + 1</code>；</li>
</ul>
</li>
<li><code>dis[i-1][j]</code>：<ul>
<li>对于 <code>word1</code> 的第 <code>i</code> 个字符，我们在 <code>word2</code> 的末尾添加了一个相同的字符，那么 <code>dis[i][j]</code> 最小可以为 <code>dis[i-1][j] + 1</code>；</li>
</ul>
</li>
<li><code>dis[i-1][j-1]</code>：<ul>
<li>对于 <code>word2</code> 的第 <code>j</code> 个字符，我们修改 <code>word1</code> 的第 <code>i</code> 个字符使它们相同，那么 <code>dis[i][j]</code> 最小可以为 <code>dis[i-1][j-1] + 1</code>。</li>
<li>特别地，如果 <code>word1</code> 的第 <code>i</code> 个字符和 <code>word2</code> 的第 <code>j</code> 个字符原本就相同，那么我们实际上不需要进行修改操作。在这种情况下，<code>dis[i][j]</code> 最小可以为 <code>dis[i-1][j-1]</code>。</li>
</ul>
</li>
</ol>
</li>
<li>总结起来，状态转移方程就是：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
dis[i][j] = \begin{cases}
          min\big( dis[i][j-1] + 1,\ dis[i-1][j] + 1,\ dis[i-1][j-1] \big), \quad &word1[i] = word2[j]  \\\\
          1 + min\big( dis[i][j−1],\ dis[i−1][j],\ dis[i−1][j−1] \big), \quad &word1[i] \neq word2[j]
        \end{cases}</script><ul>
<li>边界：初始时 <code>dis[0][0] = 0</code>，<code>dis[0][k] = dis[k][0] = k</code></li>
</ul>
<h3 id="最长公共子序列-LCS："><a href="#最长公共子序列-LCS：" class="headerlink" title="最长公共子序列 LCS："></a>最长公共子序列 LCS：</h3><p>问题描述：</p>
<blockquote>
<p>Leetcode T1143<br>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p>示例 1：</p>
<p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>状态：两个字符串某时刻遍历的位置</li>
<li>决策：字符算不算在这个 LCS 里</li>
<li>dp 数组：<code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列的长度。</li>
<li>状态转移方程：<ul>
<li>当 <code>text1[i-1] == text2[j-1]</code>：<ul>
<li>存在公共字符，考虑 <code>text1[0 : i-1]</code> 和 <code>text2[0 : j-1]</code>，再加上当前这个公共字符，就得到了 <code>text1[0 : i]</code> 和 <code>text2[0 : j]</code> 的 LCS，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
</ul>
</li>
<li>当 <code>text1[i-1] != text2[j-1]</code>：<ul>
<li>此时应考虑 <code>text1[0 : i-1]，text2[0 : j]</code> 和 <code>text1[0 : i]，text2[0 : j-1]</code>，这两种情况。而 <code>dp[i][j]</code> 很明显就应该是它们中较大的一个；</li>
</ul>
</li>
<li>总结起来，就是：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
dp[i][j] = \begin{cases}
          dp[i-1][j-1] + 1, \quad &text1[i-1] = text2[j-1]  \\\\
          \max \big( dp[i-1][j],\ dp[i][j-1] \big), \quad &text1[i-1] \neq text2[j-1]
        \end{cases}</script><ul>
<li>边界：<code>dp[0][j] = 0</code> 和 <code>dp[i][0] = 0</code></li>
</ul>
<p>与本题相似的还要 Leetcode 的 T583 和 T712</p>
<h3 id="最长递增子序列-LIS：俄罗斯套娃信封问题"><a href="#最长递增子序列-LIS：俄罗斯套娃信封问题" class="headerlink" title="最长递增子序列 LIS：俄罗斯套娃信封问题"></a>最长递增子序列 LIS：俄罗斯套娃信封问题</h3><p>本题最基本的形式是 Leetcode T491，它要求你求所有递增子序列 “IS 问题”，而这个问题是采用 BFS 实现的，不是我们这里讨论的目标。只有 LIS 才是基于递归实现的。所以，我们用其扩展形式来讨论这类问题。</p>
<p>问题描述：</p>
<blockquote>
<p>Leetcode T354：<br>给你一个二维整数数组 envelopes ，其中 <code>envelopes[i] = [wi, hi]</code>，表示第 i 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 最多能有多少个 信封能组成一组 “俄罗斯套娃” 信封（即可以把一个信封放到另一个信封里面）。</p>
<p>注意：不允许旋转信封。</p>
<p>示例 1：</p>
<p>输入：<code>envelopes = [[5,4],[6,4],[6,7],[2,3]]</code><br>输出：<code>3</code><br>解释：最多信封的个数为 3, 组合为: <code>[2,3] =&gt; [5,4] =&gt; [6,7]</code></p>
</blockquote>
<p>问题转换：</p>
<ul>
<li>本题很明显，需要同时满足信封的 “长” 和 “高” 都是递增顺序。</li>
<li>首先，我们对 <code>长 w</code> 进行升序排序，如果遇到 w 相同时，则按 <code>高 h</code> 降序排序。例如上面的例子，排完序后就是：<code>[[2,3],[5,4],[6,7],[6,4]]</code><ul>
<li>这一步的关键在于，对于长度相同的信封，要对高度降序排列。这是因为两个长度相同的信封没法包含，而逆序就保证了 w 相同的数对中，最多只选择一个计入 LIS；</li>
</ul>
</li>
<li>然后再在 h 维度上寻找 LIS，就可得到所求答案<ul>
<li>相当于求 <code>[3,4,7,4]</code> 的 LIS</li>
</ul>
</li>
</ul>
<p>思路一：</p>
<ul>
<li>状态：</li>
<li>决策：</li>
<li>dp 数组：设 <code>f[i]</code> 表示 <code>h</code> 的前 <code>i</code> 个元素可以组成的最长严格递增子序列的长度，并且我们必须选择第 <code>i</code> 个元素 <code>h[i]</code></li>
<li>状态转移方程：</li>
</ul>
<script type="math/tex; mode=display">
f[i] = \begin{cases}
          \max_{j<i\ \And\ h_j < h_i}\{f[j]\}\ +\ 1, \quad &if\ \exist(j<i\ \And\ h_j < h_i) \\\\
          1, \quad &else
        \end{cases}</script><ul>
<li>边界：<code>f[0] = 1</code> </li>
</ul>
<p>思路二：基于二分查找的 DP</p>
<ul>
<li>状态：</li>
<li>决策：</li>
<li>dp 数组：设 <code>f[j]</code> 表示 <code>h</code> 的前 <code>i</code> 个元素可以组成的长度为 <code>j</code> 的最长严格递增子序列的末尾元素的最小值；<ul>
<li>注：理论上应该是 <code>f[i][j]</code>，但是第一维可以想背包问题描述的一样，在利用迭代，压缩已节省空间；</li>
<li>如果不存在长度为 j 的最长严格递增子序列，对应的 f 值无定义。</li>
<li>在定义范围内，可以看出 f 值是严格单调递增的，因为越长的子序列的末尾元素显然越大。</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>若当前元素 <code>h[i]</code> 大于 <code>f</code> 中的最大值，那么 <code>h[i]</code> 就可以接在 f 中的最大值之后，形成一个长度更长的递增子序列；</li>
<li>否则，找出 <code>f</code> 中比 <code>h[i]</code> 严格小的最大的元素 <code>f[j0]</code>，即 <code>f[j0] &lt; h[i] &lt; f[j0+1]</code>，那么 <code>h[i]</code> 就可以接在 <code>f[j0]</code> 之后，形成一个长度为 <code>j0+1</code> 的严格递增子序列，则更新 <code>f[j0+1] = h[i]</code>；<ul>
<li>在求 <code>f[j0]</code> 时可用二分查找搜索；</li>
</ul>
</li>
</ul>
</li>
<li>在遍历所有的 <code>h[i]</code> 之后，f 中最后一个有定义的元素的下标增加 1（下标从 0 开始）即为最长严格递增子序列的长度。</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>这里开始，题目难度会变大，只是为了给你一个直观的感受。所以，对问题的描述将会更加简单，重点关注状态转移方程，如有不理解，可去原题查看。</p>
<h3 id="KMP-问题"><a href="#KMP-问题" class="headerlink" title="KMP 问题"></a>KMP 问题</h3><p>详情见：<a href="http://www.thebetterkong.cn/2020/10/02/DataStructure-Algorithm/KMP-Algorithm/">KMP 算法详讲</a></p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>问题描述：</p>
<blockquote>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>示例 1：</p>
<p>输入：s = “aab” p = “c<em>a</em>b”<br>输出：true<br>解释：因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
</blockquote>
<p>解题思路：</p>
<ul>
<li>dp 数组：<code>f[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个字符与 <code>p</code> 中的前 <code>j</code> 个字符是否能够匹配</li>
<li>状态转移方程：</li>
</ul>
<script type="math/tex; mode=display">
f[i][j] = \begin{cases}
    if(p[j] \neq *) = \begin{cases}
          f[i-1][j-1], \quad &matches(s[i],p[j]) \\\\
          false, \quad &otherwise
    \end{cases} \\\\
    otherwise = \begin{cases}
          f[i-1][j]\ or\ f[i][j-2], \quad &matches(s[i],p[j-1]) \\\\
          f[i][j-2], \quad &otherwise
    \end{cases}
\end{cases}</script><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>哇，真的不行了，回顾整个 Leetcode，要说 DP 问题属实太多了，而且问题类型千变万化，从简单到难。属实列不完了，越看越多，就烂个尾吧！哭…</p>
<p>如果你想挑战难度的，建议：</p>
<ul>
<li>T877，鸡蛋掉落，通过率 28.9%。和它类似的 T312，戳气球问题</li>
<li>石头游戏的博弈问题</li>
<li>股票买卖问题</li>
<li>T1312，让字符串成为回文串的最少插入次数</li>
</ul>
<p>……</p>
<p>【未完，待续…】</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看到这里，</p>
<p><strong>你 “悟” 了吗？</strong></p>
<p>DP 问题肯定远远不止我罗列出来的这些，但所谓万变不离其宗，所有 DP 问题的核心思路都一样，同类别问题，甚至连代码都可能相同，只存在一些「边界」「条件」上的细微差别。</p>
<p>当然了，我们在掌握基本框架的同时，也要学会灵活推广，具体问题具体分析！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin" target="_blank" rel="noopener">百度百科：动态规划</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_169a33d090102y36t.html" target="_blank" rel="noopener">五大经典算法—动态规划算法（DP算法）</a></li>
<li>labuladong 的算法小抄</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="TheBetterKong 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="TheBetterKong 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>TheBetterKong
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://www.thebetterkong.cn/2021/05/22/DataStructure-Algorithm/DynamicProgramming/" title="动态规划搭建 “摩天大厦”">http://www.thebetterkong.cn/2021/05/22/DataStructure-Algorithm/DynamicProgramming/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/21/DataStructure-Algorithm/TOP-K/" rel="prev" title="有关 TOP-K 你到底了解多少？">
                  <i class="fa fa-chevron-left"></i> 有关 TOP-K 你到底了解多少？
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/06/25/DeepLearning/style-transfer/" rel="next" title="图像风格转换系统">
                  图像风格转换系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鄂ICP备20005224号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TheBetterKong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">521k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:53</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


<script color="105,105,105" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"FzJ2kTqyh92urg7N9KHkL0RA-9Nh9j0Va","appKey":"aTVY6lFVOvNPNgaDGtgHVoQy","serverURLs":"https://valine.thebetterkong.cn","placeholder":"Just go go","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":true,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2021/05/22/DataStructure-Algorithm/DynamicProgramming/",
      serverURLs: "https://valine.thebetterkong.cn"
    }));
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
