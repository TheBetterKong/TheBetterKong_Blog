<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheBetterKong</title>
  
  <subtitle>自律即自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thebetterkong.cn/"/>
  <updated>2021-03-15T02:19:18.301Z</updated>
  <id>http://www.thebetterkong.cn/</id>
  
  <author>
    <name>TheBetterKong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文搞透快速幂算法</title>
    <link href="http://www.thebetterkong.cn/2021/03/13/DataStructure-Algorithm/FastEponentiation-Algorithm/"/>
    <id>http://www.thebetterkong.cn/2021/03/13/DataStructure-Algorithm/FastEponentiation-Algorithm/</id>
    <published>2021-03-13T07:42:21.000Z</published>
    <updated>2021-03-15T02:19:18.301Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/FastEponentiation-Algorithm/header.png" width="100%" alt="header.png" /> </div>  <p>快速幂算法是算法中使用十分广泛的一中基础算法，它能将幂指运算的时间复杂度由 $O(n)$ 降为 $O(log\ n)$。</p><a id="more"></a> <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们首先来看一道 『<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035" target="_blank" rel="noopener">ACM 程序设计题</a>』，题目大致如下：   </p><blockquote><p>求 A^B 的最后三位数表示的整数。<br>说明：A^B 的含义是 “A 的 B 次方”</p></blockquote><p>这道题，咋眼看上去很简单，直接用一个循环累积即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Test().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">long</span> base = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> power = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">long</span> answer = solution.normalPower(base, power);</span><br><span class="line">        System.out.print(answer); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">normalPower</span><span class="params">(<span class="keyword">long</span> base, <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= power; i++)&#123;</span><br><span class="line">                result= result * base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result % <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果令人很意外，输出竟然为 0，可是我们的算法并没有错啊。再回顾一下题目，有个很奇怪的地方，为啥让我们输出的是结果的最后三位数，按理来说，直接输出结果不行吗？这样是不是有点多次一举。    </p><p>出题人当然不会这么无聊。想想我们在学习指数运算的时候，一定听过一个词叫 <code>指数爆炸</code>。这是什么意思呢？   </p><blockquote><p>我们小时候一定都做过这样一个游戏：给你一张纸，如何做到让它不能被轻易撕破？ 很简单，就是将这张纸不停的对折。一张纸对折一次，厚度变成原来的 2 倍。再对折第二次，变为原来的 4 倍。以此类推，假设纸的厚度为 0.1mm，则对折 24 次以后，厚度超过 1 千米；对折 39 次达 55000 千米，超过地球赤道长度；对折 42 次达 44 万千米，超过地球至月球的距离；对折 51 次达 22 亿千米，超过地球至太阳的距离；对折 82 次为 51113 光年，超过银河系半径的长度。</p></blockquote><p>再回到这个题目，我们的测试用例是求 $2^{100}$，这个结果有多大，反正 java 里 64 位的 long 类型一定会发生溢出。这也就解释了为什么我们输出的结果会是 0。   </p><p>既然我们无法算出最终的结果，那我们应该怎样算结果的最后三位数呢？   </p><p>关于 “取模” 运算，有三条很重要的运算规则：</p><script type="math/tex; mode=display">\begin{aligned}    (a + b) \% p &= (a \% p + b \% p) \% p \\    (a - b) \% p &= (a \% p - b \% p) \% p \\    (a * b) \% p &= (a \% p \ast b \% p) \% p\end{aligned}</script><p>再回到这个题目，很明显，我们就借助第 3 条运算规则来求解。具体做法即：在每次循环求积时，都对中间结果做一个 “取模”，这个效果等效于对最后的结果进行 “取模”。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Test().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">long</span> base = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> power = <span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> answer = solution.normalPower(base, power);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"执行结果："</span> + answer);</span><br><span class="line">        System.out.println(<span class="string">"执行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="comment">// 执行结果：376</span></span><br><span class="line">        <span class="comment">// 执行时间：6450ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">normalPower</span><span class="params">(<span class="keyword">long</span> base, <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= power; i++)&#123;</span><br><span class="line">                result = result * base;</span><br><span class="line">                result = result % <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result % <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交，通过。这下问题是得以解决了。但是有一点需要注意的是，这一次我夸张的求到了 $2^{2000000000}$，代码的执行时间既然达到了 6450ms，这是一个很夸张的数字了。在实际生产过程中，如果这样求幂指运算，效率自然是极低的。   </p><p>那我们应该怎么办呢？这时候 <code>『快速幂算法』</code> 就派上用场了。</p><h1 id="算法主要原理"><a href="#算法主要原理" class="headerlink" title="算法主要原理"></a>算法主要原理</h1><p>传统求幂指运算算法的时间复杂度（$O(n)$）之所以很高，是因为当指数 n 很大时，需要执行的循环次数非常大。因此，快速幂算法的核心思想在于<mark>用类似二叉树的方式，不断的二分指数，而相应的底数做平方运算</mark>。这样就可以将大指数不断减小，相应的循环次数也就可以降低，时间复杂度可以降至 $O(log\ n)$。   </p><p>上述描述比较抽象，你也许不能理解，我们来看一个实例：</p><blockquote><p>① 先对计算做一个简单的变形，如下：</p><script type="math/tex; mode=display">\begin{aligned}    3^{10} &= 3 \ast 3 \ast 3 \ast 3 \ast 3 \ast 3 \ast 3 \ast 3 \ast 3 \ast 3 \\    &= (3 \ast 3) \ast (3 \ast 3) \ast (3 \ast 3) \ast (3 \ast 3) \ast (3 \ast 3) \\    &= (3 \ast 3)^5 \\    &= 9^5\end{aligned}</script><p>可以发现，此时，指数从 10 缩减为了原来的一半 5，底数变成了原来底数的平方。算法在求解过程中，循环次数也会减半，当幂很大的时候，运算效率的提高是十分显著的。</p><p>② 我们再重复一次上面的过程。这一次发现 “幂=5”，是一个奇数，我们没法直接二分。那就换个思路，拆分如下：</p><script type="math/tex; mode=display">\begin{aligned}    3^{10} &= 9^5 \\    &= (9^4) \ast (9^1) \\    &= ((9 \ast 9) \ast (9 \ast 9)) \ast 9^1 \\    &= (9 \ast 9)^2 \ast 9^1 \\    &= 81^2 \ast 9^1\end{aligned}</script><p>这一次，我们先抽出了一个底数的一次方 $9^1$，那么剩下的 $9^4$，也就能继续进行 “指数二分” 了。</p><p>③ 发现还可以继续 “指数缩减”，如下：</p><script type="math/tex; mode=display">\begin{aligned}    3^{10} &= 81^2 \ast 9^1 \\    &= (81 \ast 81) \ast 9^1 \\    &= 6561^1 \ast 9^1\end{aligned}</script><p>④ 幂再次成为一个奇数，同样抽取底数的一次方 $6561^1$，此时，拆分如下：</p><script type="math/tex; mode=display">\begin{aligned}    3^{10} &= 6561^1 \ast 9^1 \\    &= 6561^0 \ast 6561^1 \ast 9^1 \\\end{aligned}</script><p>这一次抽出底数的一次方后，剩下的 $6561^0$，幂已经为 0，不再需要进行二分，算法到此结束。此时的计算式为：</p><script type="math/tex; mode=display">3^{10} = 6561^0 \ast 6561^1 \ast 9^1 = 6561 \ast 9 = 59049</script></blockquote><p>观察上面这个例子，可以发现一个规律：<mark>最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积</mark>。    </p><p>基于上述实例的分析，我们给出 <code>『快速幂算法』</code> 的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Test().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">long</span> base = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> power = <span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> answer = solution.fastPower(base, power);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"执行结果："</span> + answer);</span><br><span class="line">        System.out.println(<span class="string">"执行时间："</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">        <span class="comment">// 执行结果：376</span></span><br><span class="line">        <span class="comment">// 执行时间：2800ns</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> base, <span class="keyword">long</span> power)</span></span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (power % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    power = power / <span class="number">2</span>;              <span class="comment">// 把指数缩小为一半</span></span><br><span class="line">                    base = base * base % <span class="number">1000</span>;      <span class="comment">// 底数变大成原来的平方</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    power = power - <span class="number">1</span>;              <span class="comment">// 把指数减去 1，使其变成一个偶数</span></span><br><span class="line">                    result = result * base % <span class="number">1000</span>;  <span class="comment">// 指数为奇数时分离出来的底数的一次方要参与到结果的运算中</span></span><br><span class="line">                    power = power / <span class="number">2</span>;              <span class="comment">// 此时指数为偶数，继续执行二分操作</span></span><br><span class="line">                    base = base * base % <span class="number">1000</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上述代码是为了便于理解，但是它的两条分支间存在代码冗余，可以进行合并：</span></span><br><span class="line">        <span class="comment">//      这样代码更加整洁，而且分支数减少，汇编出来的跳转指令数也会减少，</span></span><br><span class="line">        <span class="comment">//      从某种程度上来说也是可以提高性能的。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// public long fastPower(long base, long power)&#123;</span></span><br><span class="line">        <span class="comment">//     long result = 1;</span></span><br><span class="line">        <span class="comment">//     while (power &gt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//         if (power % 2 == 1) &#123;</span></span><br><span class="line">        <span class="comment">//             result = result * base % 1000;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         power = power / 2;</span></span><br><span class="line">        <span class="comment">//         base = base * base % 1000;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return result;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该代码还有一种写法，就是利用 “位运算” 来替代 “%” 和 “/” 运算</span></span><br><span class="line">        <span class="comment">//      </span></span><br><span class="line">        <span class="comment">// public long fastPower(long base, long power)&#123;</span></span><br><span class="line">        <span class="comment">//     long result = 1;</span></span><br><span class="line">        <span class="comment">//     while (power &gt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//         if ((power &amp; 1) == 1) &#123;</span></span><br><span class="line">        <span class="comment">//             result = result * base % 1000;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         power = power &gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">//         base = base * base % 1000;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     return result;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>计算同样的数据，结果相同，但是我们计算所需的时间从 <code>6450ms</code> 降至了 <code>2800ns</code>，计算效率得到了大大的提高。</p><h1 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h1><p>通过上文对算法原理的讲解，我们看到了 “快速幂算法” 的优势，但你也许会说，我们平常求 “幂指运算” 时，用的语言就已经帮我们优化好了，我们直接调用相关 API 即可（例如：java 的 <code>Math.pow()</code>），那它是不是就没有其他用了呢？    </p><p>俗话说的好，<mark>算法学的是思维，要活以致用，灵活多变才是王道！</mark>   </p><p>我们看这样一道例子：<code>斐波拉契数列的求解</code>，问题如下：</p><blockquote><p>斐波拉契数列的每一项数字都是前两项数字的和：<br><code>1,1,2,3,5,8,13,21,34,...</code><br>现在，要求该数列的第 n 项</p></blockquote><p>这是一个非常常见的问题，通常我们的解法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Test().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = solution.Fibonacci(n);</span><br><span class="line">        System.out.println(<span class="string">"执行结果："</span> + answer);</span><br><span class="line">        <span class="comment">// 执行结果：13</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">                c = a + b;</span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个算法的时间复杂度也是 $O(n)$。这必然不是我们想要的结果，我们回顾一下斐波拉契数列的定义：</p><script type="math/tex; mode=display">F_n = \begin{cases}    1, \quad (n \leq 2) \\    F_{n-1} + F_{n-2}, \quad (n \geq 3)\end{cases}</script><blockquote><p>假设，我们有一个矩阵 $A = \begin{bmatrix}0 &amp; 1 \\ 1 &amp;1\end{bmatrix}$，有 $A \begin{bmatrix}F_n \\ F_{n+1}\end{bmatrix} = \begin{bmatrix}F_{n+1} \\ F_n + F_{n+1}\end{bmatrix} = \begin{bmatrix}F_{n+1} \\ F_{n+2}\end{bmatrix}$，于是可推导出：</p><script type="math/tex; mode=display">\begin{bmatrix}F_n \\ F_{n+1} \end{bmatrix} = A \begin{bmatrix}F_{n-1} \\ F_n \end{bmatrix}= A^2 \begin{bmatrix}F_{n-2} \\ F_{n-1} \end{bmatrix}= ... = A^{n-1} \begin{bmatrix}F_1 \\ F_2 \end{bmatrix}= A^{n-1} \begin{bmatrix}1 \\ 1 \end{bmatrix}</script></blockquote><p>这样我们就把原来复杂的问题转化为了<strong>求某个矩阵的幂</strong>的问题，这个时候，我们的 “快速幂算法” 也就派上用场了。有一点点不一样的是，这一次是<strong>矩阵的幂指运算</strong>，我们只需要在原先的算法上稍作修改即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Test().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = solution.Fibonacci(n);</span><br><span class="line">        System.out.println(answer); <span class="comment">// 13</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[][] A = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">            <span class="keyword">int</span>[][] res = pow(A, n-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// 相当于最后还需要乘的列向量 [[1],[1]]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矩阵的快速幂算法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] pow(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] ans = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans = multiply(ans, A);</span><br><span class="line">                &#125;</span><br><span class="line">                n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                A = multiply(A, A);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助函数：用来求两个矩阵相乘</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[][] multiply(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                    c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在问题总算是得到了解决。但是在上面的过程中，有一个很关键的问题在于<mark>如何找到幂矩阵 A</mark>？   </p><p><strong>构造这个幂矩阵的方法是多种多样的，并不唯一，只需要满足能让所有包含变量 n 的项递减即可</strong>。这里给出一些常见的例子：   </p><p>（1）对于 $f_n = a \ast f_{n-1} + b \ast f_{n-2} + c$，其中 $a,b,c$ 为常数，有：</p><script type="math/tex; mode=display">\begin{bmatrix}a & b & c\\ 1 & 0 & 0 \\ 0 & 0 & 1\end{bmatrix} \ast \begin{bmatrix}f_{n-1} \\ f_{n-2} \\ 1 \end{bmatrix} = \begin{bmatrix}f_n \\ f_{n-1} \\ 1 \end{bmatrix}</script><p>（2）对于 $f_n = a \ast f_{n-1} + b \ast f_{n-2} + c^n$，其中 $a,b,c$ 为常数，有：</p><script type="math/tex; mode=display">\begin{bmatrix}a & b & c\\ 1 & 0 & 0 \\ 0 & 0 & c\end{bmatrix} \ast \begin{bmatrix}f_{n-1} \\ f_{n-2} \\ c^{n-1} \end{bmatrix} = \begin{bmatrix}f_n \\ f_{n-1} \\ c^n \end{bmatrix}</script><p>（3）对于 $f_n = f_{n-1} + f_{n-2} + n^2$，有：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 1 & 1 & 2 & 1\\ 1 & 0 & 0 & 0 & 0\\ 0 & 0 & 1 & 2 & 1\\ 0 & 0 & 0 & 1 & 1 \\ 0 & 0 & 0 & 0 & 1\end{bmatrix} \ast \begin{bmatrix}f_n \\ f_{n-1} \\ n^2 \\ n \\ 1 \end{bmatrix} = \begin{bmatrix}f_{n+1} \\ f_n \\ (n+1)^2 \\ (n+1) \\ 1 \end{bmatrix}</script><p>看了这几个例子，如果你还是很懵的话，这里给一个比较形式化的求矩阵 A 的方法，见下图：   </p><p><img src="http://img.thebetterkong.cn/blog/FastEponentiation-Algorithm/findA.png" alt="findA">   </p><p>其实上面这些步骤里，最难的就是<mark>构造递减关系</mark>，解决这个问题最常用的方法就是 <mark>二项式展开</mark>。  </p><p> 我们再来看看更复杂的例子：</p><p>（4）计算 k 次方和：$S_n = \sum_{i=1}^n\ i^k$，表示为递推式 $S_n = n^k + S_{n-1}$：</p><blockquote><p>利用二项式展开，展开递推式：</p><script type="math/tex; mode=display">\begin{aligned}    S_n &= [(n-1)+1]^k + S_{n-1} \\        &= C_k^0(n-1)^k + C_k^1(n-1)^{k-1} + ... + C_k^k + S_{n-1}\end{aligned}</script><p>此时，令 $X_{n-1} = \begin{bmatrix} (n-1)^k \\ (n-1)^{k-1} \\ \vdots \\ (n-1)^0 \\ S_{n-1}\end{bmatrix}$，则有 $X_n = \begin{bmatrix} n^k \\ n^{k-1} \\ \vdots \\ n^0 \\ S_n\end{bmatrix}$，现在的问题在于找到 A 使得 $A \ast X_{n-1} = X_n$。  </p><p>上面的递推公式就指明了 A 的最后一行，至于其他行，利用二项式展开也很容易得到，有：</p><script type="math/tex; mode=display">\begin{bmatrix} C_k^0 & C_k^1 & \ldots & C_k^k & 0 \\ 0 & C_{k-1}^0 & \ldots & C_{k-1}^{k-1} & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & \ldots & \ldots & C_0^0 & 0 \\ C_k^0 & C_k^1 & \ldots & C_k^k & 1 \end{bmatrix} \ast \begin{bmatrix} (n-1)^k \\ (n-1)^{k-1} \\ \vdots \\ (n-1)^0 \\ S_{n-1}\end{bmatrix} = \begin{bmatrix} n^k \\ n^{k-1} \\ \vdots \\ n^0 \\ S_n\end{bmatrix}</script><p>其中，$X_1 = \{1\ 1\ \ldots\ 1\}^T$ </p></blockquote><p>（5）计算：$S_n = \sum_{i=1}^n\ (ai+b)^k$，表示为递推式 $S_n = (an+b)^k + S_{n-1}$：  </p><blockquote><p>利用二项式展开，展开递推式：</p><script type="math/tex; mode=display">\begin{aligned}    S_n &= [a(n-1)+(a+b)]^k + S_{n-1} \\        &= C_k^0a^k(n-1)^k + C_k^1a^{k-1}(a+b)(n-1)^{k-1} + ... + C_k^k(a+b)^k + S_{n-1}\end{aligned}</script><p>接下来的步骤和之前的一样，这里直接给出结论：</p><script type="math/tex; mode=display">\begin{bmatrix} C_k^0 & C_k^1 & \ldots & C_k^k & 0 \\ 0 & C_{k-1}^0 & \ldots & C_{k-1}^{k-1} & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & \ldots & \ldots & C_0^0 & 0 \\ C_k^0a^k & C_k^1a^{k-1}(a+b) & \ldots & C_k^k(a+b)^k & 1 \end{bmatrix} \ast \begin{bmatrix} (n-1)^k \\ (n-1)^{k-1} \\ \vdots \\ (n-1)^0 \\ S_{n-1}\end{bmatrix} = \begin{bmatrix} n^k \\ n^{k-1} \\ \vdots \\ n^0 \\ S_n\end{bmatrix}</script></blockquote><p>（6）计算：$S_n = \sum_{i=1}^n\ i^kk^i$，表示为递推式 $S_n = n^kk^n + S_{n-1}$：  </p><blockquote><p>利用二项式展开，展开递推式：</p><script type="math/tex; mode=display">\begin{aligned}    S_n &= [(n-1)+1]^kk^{[(n-1)+1]} + S_{n-1} \\        &= C_k^0(n-1)^kk^{(n-1)+1} + C_k^1(n-1)^{k-1}k^{(n-1)+1} + ... + C_k^kk^{(n-1)+1} + S_{n-1}\end{aligned}</script><p>此时，令 $X_{n-1} = \begin{bmatrix} (n-1)^kk^{(n-1)+1} \\ (n-1)^{k-1}k^{(n-1)+1} \\ \vdots \\ (n-1)^0k^{(n-1)+1} \\ S_{n-1}\end{bmatrix}$，则有 $X_n = \begin{bmatrix} n^kk^{n+1} \\ n^{k-1}k^{n+1} \\ \vdots \\ n^0k^{n+1} \\ S_n\end{bmatrix}$</p><p>同样，上面的递推公式就指明了 A 的最后一行，至于其他行，利用二项式展开也很容易得到，只是相差了一个系数 k。有：</p><script type="math/tex; mode=display">\begin{bmatrix} kC_k^0 & kC_k^1 & \ldots & kC_k^k & 0 \\ 0 & kC_{k-1}^0 & \ldots & kC_{k-1}^{k-1} & 0 \\ \vdots & \vdots & \ddots & \vdots & \vdots \\ 0 & \ldots & \ldots & kC_0^0 & 0 \\ C_k^0 & C_k^1 & \ldots & C_k^k & 1 \end{bmatrix} \ast \begin{bmatrix} (n-1)^kk^{(n-1)+1} \\ (n-1)^{k-1}k^{(n-1)+1} \\ \vdots \\ (n-1)^0k^{(n-1)+1} \\ S_{n-1}\end{bmatrix} = \begin{bmatrix} n^kk^{n+1} \\ n^{k-1}k^{n+1} \\ \vdots \\ n^0k^{n+1} \\ S_n\end{bmatrix}</script></blockquote><p>说了这么多例子，看着这些复杂的公式，并不是为了要你记住它们。真实的使用场景是千变万化的，这里肯定不能涵盖到所有情况。所以关键在于理解这些公式的推导方法，具体情况具体分析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实快速幂算法的思想很简单，实现起来也不难。这里之所以花了这么大的篇幅介绍实际运用，是为了告诫我们，算法的精髓不在于它本身，而是在于这种思想的灵活运用。懂了不代表会了，一定要多总结多悟！在我们刷 leetcode 时，也一定要保持这种心态，不要一味的求多！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/qq_19782019/article/details/85621386" target="_blank" rel="noopener">快速幂算法（全网最详细地带你从零开始一步一步优化）</a></li><li><a href="https://blog.csdn.net/qq_40061421/article/details/82625338" target="_blank" rel="noopener">快速幂和矩阵快速幂(取模)算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/FastEponentiation-Algorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;快速幂算法是算法中使用十分广泛的一中基础算法，它能将幂指运算的时间复杂度由 $O(n)$ 降为 $O(log\ n)$。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RSA 算法详讲</title>
    <link href="http://www.thebetterkong.cn/2020/10/22/Cryptography/RSA-Algorithm/"/>
    <id>http://www.thebetterkong.cn/2020/10/22/Cryptography/RSA-Algorithm/</id>
    <published>2020-10-22T03:06:32.000Z</published>
    <updated>2020-10-22T08:29:39.670Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/RSA-Algorithm/header.png" width="100%" alt="header.png" /> </div>   <p>RSA 说它是 “地球最重要的算法”，应该也不过分。它是 1978 年由 R.Rivest、A.Shamir 和 L.Adleman 提出的一种用数论构造的、也是迄今为止理论上最为成熟、完善的公钥密码体制，它已经得到了广泛的应用。</p><a id="more"></a><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>在 1976 年以前，所有的加密方法都使用<strong>对称加密算法</strong>，即：加密和解密使用同一套规则。</p><ul><li>举例来说：甲使用密钥 A 加密，将密文传递给乙，乙仍使用密钥 A 解密。如果密钥 A 在甲传递给乙的过程中泄露，或者根据已知的几次密文和明文推导出密钥 A，则甲乙之间的通讯将毫无秘密。</li></ul><p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不传递密钥的情况下，完成解密，这被称为 <strong>Diffie-Hellman 密钥交换算法</strong>。 </p><ul><li>假如甲要和乙通讯，甲使用公钥 A 加密，将密文传递给乙，乙使用私钥 B 解密得到明文。其中公钥在网络上传递，私钥只有乙自己拥有，不在网络上传递，这样即使知道了公钥 A 也无法解密。反过来通讯也一样。只要私钥不泄漏，通信就是安全的，这就是<strong>非对称加密算法</strong>。</li></ul><p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人的名字命名，叫做 RSA 算法。直到现在，RSA 算法仍是最广泛使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有 RSA。</p><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><h2 id="密钥对的生成"><a href="#密钥对的生成" class="headerlink" title="密钥对的生成"></a>密钥对的生成</h2><ol><li><strong>选两个保密的大素数 p 和 q （越大越安全）；</strong></li><li><strong>计算 $n = p \ast q$；</strong><ul><li>比如 $P = 67$，$Q = 71$。计算他们的乘积 $n = P * Q = 4757$，转化为二进为  1 0010 1001 0101，该加密算法即为 13 位；</li><li>实际算法是 1024 位 或 2048 位，位数越长，算法越难被破解；</li></ul></li><li><strong>计算 n 的欧拉函数，即：$\varphi (n) = (p-1)(q-1)$；</strong><ul><li>$\varphi(n)$ 表示在小于等于 n 的正整数之中，与 n 构成互质关系的数的个数；<ul><li>例如：在 1 到 8 之中，与 8 形成互质关系的是1、3、5、7，所以 $\varphi(n)$ = 4；</li></ul></li><li>如果 $n = P \ast Q$，P 与 Q 均为质数，则 $\varphi(n) = \varphi(P \ast Q)= \varphi(P)\varphi(Q) = (P - 1)(Q - 1)$；<ul><li>本例中 $\varphi(n) = 66 \ast 70 = 4620$，这里记为 m， $m = \varphi(n) = 4620$；</li></ul></li></ul></li><li><strong>选择一个整数 $e$，满足 $1 &lt; e &lt; \varphi(n)$，且 $gcd(\varphi(n),e)=1$；</strong><ul><li>$gcd$ 函数是求最大公约数，其值为 1 表示 $e$ 与 $\varphi(n)$ 互质；<ul><li>这里我们随机选择 e = 101。注意：不要选择 4619，如果选这个，则公钥和私钥将变得相同；</li></ul></li></ul></li><li><strong>计算 $d$，满足 $d \cdot e \equiv1\ mod\ \varphi(n)$；</strong><ul><li>即 d 是 e 在模 $\varphi(n)$ 下的乘法逆元，因为 e 与 $\varphi(n)$ 互素，由模运算知，它的乘法逆元一定存在；<ul><li>即找一个整数 d，使得 $(d \ast e)\ \%\ m = 1$。等价于 $d \ast e - 1 = y \ast m$ (y 为整数）；</li><li>找到 d ，实质就是对下面二元一次方程求解：$e \ast x - m \ast y =1$，<ul><li>其中: $e = 101，m = 4620$；</li><li>$101x - 4620y =1$ 这个方程可以用 “扩展欧几里得算法” 求解，最后算出一组整数解 $(x，y)=(1601，35)$，即 d = 1601；</li><li>到此密钥对生成完毕。不同的 e 生成不同的 d，因此可以生成多个密钥对；</li></ul></li></ul></li></ul></li><li><strong>以 $\{e,n\}$ 为公钥，$\{d,n\}$ 为私钥；</strong><ul><li>本例中公钥为 （n，e) = (4757 , 101)，私钥为 （n，d) = (4757 ，1601)；</li><li>仅（n，e) = (4757 , 101) 是公开的，其余数字均不公开。可以想像如果只有 n 和 e，如何推导出 d，目前只能靠暴力破解，位数越长，暴力破解的时间越长；</li></ul></li></ol><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p><strong>加密是首先将明文比特串分组，使得每个分组对应的十进制数小于 $n$，即分组长度小于 $log_2\ n$。然后对每个明文分组 $m$，作加密运算，即</strong>：<script type="math/tex">c \equiv m^e\ mod\ n</script></p><ul><li>以汉字 “中” 为例，取 ascii 值或 unicode 值折为三个字节 $[228,184,173]$，分别对三个字节加密：<ul><li>$228^{101}\ \%\ 4757 = 4296$</li><li>$184^{101}\ \%\ 4757 = 2458$</li><li>$173^{101}\ \%\ 4757 = 3263$</li></ul></li><li>即 $[228,184,173]$ 加密后得到密文 $[4296，2458，3263]$，如果没有私钥 d ,神仙也无法从 $[4296，2458，3263]$ 中恢复 $[228,184,173]$；</li></ul><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p><strong>对密文分组的解密运算为</strong>：<script type="math/tex">m \equiv c^d\ mod\ n</script></p><ul><li>密文 $[4296，2458，3263]$ 的明文如下：<ul><li>$4296^{1601}\ \%\ 4757 = 228$</li><li>$2458^{1601}\ \%\ 4757 = 184$</li><li>$3263^{1601}\ \%\ 4757 = 173$</li></ul></li><li>即密文 $[4296，2458，3263]$ 解密后得到 $[228,184,173]$ 将 $[228,184,173]$ 再按 utf-8 解码为汉字 “中”，至此解密完毕；</li></ul><h1 id="解密的正确性证明"><a href="#解密的正确性证明" class="headerlink" title="解密的正确性证明"></a>解密的正确性证明</h1><p>由加密过程知： $c \equiv m^e\ mod\ n$，则 $c^d\ mod\ n \equiv m^{ed}\ mod\ n \equiv m^{k\varphi (n) +1}\ mod\ n$；   </p><p>分两种情况考虑：</p><ol><li>m 与 n 互为素数：<ul><li>则由 Euler 定理：$m^{\varphi (n)}\equiv 1\ mod\ n,\ m^{k \varphi (n)}\equiv 1\ mod\ n,\ m^{k\varphi (n)+1}\equiv 1\ mod\ n$，也即：$c^d\ mod\ n \equiv m$；</li></ul></li><li>m 与 n 不互为素数：<ul><li>即 $gcd(m,n) \neq 1$，$n=pq$ 这也就意味着 m 是 p 或者 q 的倍数；</li><li>令 $m=tp$，其中 t 为一个正整数。此时，必有 $gcd(m,q) = 1$；<ul><li>不然，m 也是 q 的倍数，从而 m 是 pq 的倍数，与 $m &lt; n = pq$ 矛盾；</li></ul></li><li>由 $gcd(m,q) = 1$ 即 Euler 定理得 $m^{\varphi (n)} \equiv 1\ mod\ q$；因此：$m^{k \varphi (q)}\equiv 1\ mod\ q,\ [m^{k\varphi (q)}]^{\varphi (p)}\equiv 1\ mod\ q$，$m^{k\varphi (n)} \equiv 1\ mod\ q$；</li><li>那么也就存在一个整数 r 使得 $m^{k\varphi (n)} = 1+rq$，两边同时乘以 $m=tp$ 得：$m^{k\varphi (n) +1} = m+rtpq = m+rtn$。即：$m^{k\varphi (n) +1} \equiv m\ mod\ n$，所以 $c^d\ mod\ n \equiv m$；</li></ul></li></ol><h1 id="安全性说明"><a href="#安全性说明" class="headerlink" title="安全性说明"></a>安全性说明</h1><p>问题：有没有可能在已知 （n，e) 的情况下，推导出 d。</p><ul><li>根据以上密钥对的生成过程：<ul><li>如果想知道 $d$ 需要知道欧拉函数 $\varphi(n)$；</li><li>如果想知道欧拉函数 $\varphi(n)$ 需要知道 $P$ 和 $Q$；</li><li>要知道 $P$ 和 $Q$ 需要对 $n$ 进行因数分解；</li></ul></li><li>对于本例中的 4757 你可以轻松进行因数分解，但对于大整数的因数分解，是一件很困难的事情，目前除了暴力破解，还没有更好的办法，如果以目前的计算速度，破解需要 50 年以上，则这个算法就是安全的。</li></ul><p>维基百科这样描述：</p><blockquote><p>“对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法，那么 RSA 的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 密钥才可能被暴力破解。到 2008 年为止，世界上还没有任何可靠的攻击 RSA 算法的方式。只要密钥长度足够长，用 RSA 加密的信息实际上是不能被解破的。”</p></blockquote><p>目前已经破解的最大整数：（232 个十进制位，768 个二进制位），目前被破解的最长 RSA 密钥就是 768 位。实际应用中 RSA 的密钥长度为 1024 位，重要场合 2048 位，未来半个世纪不可能破解。</p><h1 id="RSA-算法中的计算问题"><a href="#RSA-算法中的计算问题" class="headerlink" title="RSA 算法中的计算问题"></a>RSA 算法中的计算问题</h1><h2 id="RSA-加、解密过程"><a href="#RSA-加、解密过程" class="headerlink" title="RSA 加、解密过程"></a>RSA 加、解密过程</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>由前面的定义，我们知道 RSA 算法的加解密过程都为求一个整数的整数次幂，再取模。如果，直接按其含义计算，则中间结果会非常大，有可能超出计算机所允许的整数取值范围。</p><ul><li>例如：$66^{77} mod\ 119$ ，$66^{77}$ 已经远超出了计算机所能表示的范围。</li></ul><p>这时候利用 mod 运算的性质：<script type="math/tex">(a \times b)\ mod\ n = [(a\ mod\ n) \times (b\ mod\ n)]\ mod\ n</script>  就可以减小中间结果。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如何提高加解密运算中指数运算的有效性？</p><ul><li>例如：求 $x^{16}$ ，直接计算需要做 15 次乘法。如果重复对每个部分结果做平方运算，即：求 $x.x^2,x^4,x^8,x^{16}$ 就只需要 4 次乘法；</li></ul><p>一般的，求 $a^m$（其中 a，m 为正整数）可按如下过程进行：</p><ul><li>将 m 表示为二进制形式 $b_kb_{k-1}…b_0$ 则：$m=b_k2^k+b_{k-1}2^{k-1}+…+b_12+b_0$，因此：<script type="math/tex">a^m = (...(\ (\ (a^{b_k})^2\ a^{b_{k-1}}\ )^2\ a^{b_{k-2}})^2...a^{b_1})^2\ a^{b_0}</script></li></ul><p>得到以下快速指数算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c&#x3D;0; d&#x3D;1;</span><br><span class="line">for i&#x3D;k downto 0 do &#123;</span><br><span class="line">    c &#x3D; 2 *c;           &#x2F;&#x2F; 指数的部分结果</span><br><span class="line">    d &#x3D; (d*d) mod n;    &#x2F;&#x2F; 中间结果，终值即为所求</span><br><span class="line">    if b_i&#x3D;1 then &#123;</span><br><span class="line">        c &#x3D; c+1;</span><br><span class="line">        d &#x3D; (d*a) mod n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return d;</span><br></pre></td></tr></table></figure><h2 id="密钥的产生"><a href="#密钥的产生" class="headerlink" title="密钥的产生"></a>密钥的产生</h2><p>产生密钥时，需要考虑两个大素数 p、q 的选取，以及 e 的选取和 d 的计算；</p><ul><li>寻找大素数时，一般先随机选取一个大的奇数（用伪随机数产生器），然后用素性检验算法检验这一奇数是否为素数，如果不是则选取另一大奇数，重复这一过程，直到找到素数为止。<ul><li>这是一项十分繁琐的工作，幸运的是在 RSA 体制中只有在产生新密钥时才需要这一工作；</li></ul></li><li>p 和 q 决定后，关于如何选取满足 $1 &lt; e &lt; \varphi (n)$ 和 $gcd(\varphi(n),e)=1$ 的 $e$，并计算满足 $d \cdot e \equiv 1\ mod\ \varphi(n)$ 的 $d$。这一问题可由推广的 Euclid 算法完成；</li></ul><h1 id="改进的-RSA-实现"><a href="#改进的-RSA-实现" class="headerlink" title="改进的 RSA 实现"></a>改进的 RSA 实现</h1><p>利用中国剩余定理，可极大的提高解密运算的速度。方法：</p><ul><li>解密方需要计算如下值：<ul><li>$d_p \equiv d\ mod\ (p-1)$，$d_q \equiv d\ mod\ (q-1)$；</li><li>$m_p \equiv c^{d_p}\ mod\ p$，$m_q \equiv c^{d_q}\ mod\ q$；</li></ul></li><li>正确性由中国剩余定理可证：<ul><li>$m_p \equiv c^{d_p}\ mod\ p \equiv c^d\ mod\ p \equiv m\ mod\ p$；</li><li>$m_q \equiv c^{d_q}\ mod\ q \equiv c^d\ mod\ q \equiv m\ mod\ q$</li></ul></li></ul><p>已证明：</p><ul><li>如果不考虑中国剩余定理的计算代价，则改进后的解密运算速度是原解密运算速度的 4 倍；</li><li>若考虑，则改进后的解密运算速度分别是原解密运算速度的 3.24 倍（模为 768 bit）、3.32 倍（模为 1024 bit）、3.47 倍（模为 2048 bit）；</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/44185847" target="_blank" rel="noopener">一文搞懂 RSA 算法</a></li><li>《现代密码学（第 3 版）》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/RSA-Algorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;RSA 说它是 “地球最重要的算法”，应该也不过分。它是 1978 年由 R.Rivest、A.Shamir 和 L.Adleman 提出的一种用数论构造的、也是迄今为止理论上最为成熟、完善的公钥密码体制，它已经得到了广泛的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Cryptography" scheme="http://www.thebetterkong.cn/categories/Cryptography/"/>
    
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
      <category term="Cryptography" scheme="http://www.thebetterkong.cn/tags/Cryptography/"/>
    
      <category term="Security" scheme="http://www.thebetterkong.cn/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>KMP 算法详讲</title>
    <link href="http://www.thebetterkong.cn/2020/10/02/DataStructure-Algorithm/KMP-Algorithm/"/>
    <id>http://www.thebetterkong.cn/2020/10/02/DataStructure-Algorithm/KMP-Algorithm/</id>
    <published>2020-10-02T08:09:24.000Z</published>
    <updated>2020-10-08T09:42:38.661Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/KMP-Algorithm/header.gif" width="100%" alt="header.png" /> </div>   <p>KMP 算法是由 D.E.Knuth、J,H,Morris 和 V.R.Pratt 一同提出，因此它也被称为 Knuth-Morria-Pratt 算法。该算法在 “ 字符串匹配问题 ” 中，相较于 Brute-Force（暴力）算法有很大的改进。它的核心思想就是通过一个 <code>next()</code> 数组（包含了模式串的局部匹配信息），利用匹配失败后的信息，尽量减少模式串与主串的匹配次数，以达到快速匹配的目的。</p><a id="more"></a><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>“ 字符串匹配 ” 是计算机的基本任务之一。而 KMP 算法主要就是用来解决这个问题，举例来说：有一个字符串 <code>aabaabaaf</code>，我们想知道，里面是否包含另一个字符串 <code>aabaaf</code>？</p><h1 id="算法由来"><a href="#算法由来" class="headerlink" title="算法由来"></a>算法由来</h1><p>在说到 KMP 算法前，我们先看一下常规匹配算法的思路：  </p><p><img src="http://img.thebetterkong.cn/blog/KMP-Algorithm/kmp1.png" alt="kmp1">  </p><p>在第六轮时，匹配失败。最简单的思路就是，将模式串整个后移一位，再重新从头进行比较，此时，后续的比较过程如下：    </p><p><img src="http://img.thebetterkong.cn/blog/KMP-Algorithm/kmp2.png" alt="kmp2">   </p><p>经过上述描述，可以发现，这种思路虽然可行，但是效率很低，时间复杂度 $O(m \ast n)$，因为每次匹配失败时，我们都得从头开始匹配模式串。而这个重新开始的过程，模式串前面的一些字符可能已经匹配过了，例如：第六轮时，字符 <code>f</code> 前的 <code>aa</code> 其实就是已经匹配过的（这里如果不理解这个意思，可以先往后看，不要太在意），所以我们大可直接将模式串后移 3 位，再开始进行比较，如下所示：</p><ul><li>$aabaabaaf$</li><li>$\ \ \ \ \ \ aabaaf$</li></ul><p>要完成上述步骤，我们就需要一个信息，即：当第六轮 <code>b</code> 与 <code>f</code> 不匹配时，我们知道模式串前面的字符是 <code>aabaa</code>。而 KMP 算法的核心就是利用这个信息，找到应该直接将模式串后移多少位，从而节省时间。</p><h1 id="前缀表（next-数组）"><a href="#前缀表（next-数组）" class="headerlink" title="前缀表（next 数组）"></a>前缀表（next 数组）</h1><p>按照前面的叙述，我们需要知道在每次匹配失败时，应该将模式串后移多少位来进行新一轮的匹配。而这个需要后移位数的信息就是存储在『前缀表』里的，表现到算法里就是 <code>next 数组</code>。</p><p>也许你对这个概念很陌生，那首先看一下到底什么是前缀表？它存储的到底是什么信息？这个信息又有什么用？</p><p>首先，先聊聊字符串的 “前缀” 和 “后缀”：</p><ul><li>字面意思，前缀就是字符串前几个字符，后缀就是字符串后几个字符。还是以模式串 <code>aabaaf</code> 为例，它的前缀可以是 <code>aab</code>，后缀可以是 <code>af</code>。</li><li>特别注意：后缀应该保持字符串原序列，不可认为是 <del><code>fa</code></del>；</li></ul><p>那这和前缀表有什么关系呢？前缀表里存储的就是<strong>当前字符前的子字符串的最长公共前后缀</strong>。这句话比较绕口，观察一下下面的例子就好理解了：</p><p><img src="http://img.thebetterkong.cn/blog/KMP-Algorithm/kmp3.png" alt="kmp3"></p><p>那么，知道了这个前缀表（next 数组），有什么作用呢？我们还是以前面第六轮匹配失败的时候为例：</p><p><img src="http://img.thebetterkong.cn/blog/KMP-Algorithm/kmp4.png" alt="kmp4"></p><p>前缀表就是通过这样一种方式，省去了很多不必要的比较，很好地降低了时间复杂度。那么还剩下最后一个，也是最难的问题，前缀表应该怎么求？在前面的描述中，你也许大概知道前缀表是怎么求的了，但是具体落实到算法，应该怎么去实现呢？</p><ul><li>我们可以按照下面四个步骤来书写代码：<ol><li>函数初始化；</li><li>前后缀不相同的情况；</li><li>前后缀相同的情况；</li><li>更新 next；</li></ol></li><li>另外，求解过程中，我们会涉及到两个引用 <code>i</code> 和 <code>j</code>，它们分别代表：<ul><li><code>i</code>：指向后缀末尾位置；</li><li><code>j</code>：指向前缀末尾位置，它还代表着 <code>i</code> 之前，包括 <code>i</code> 在内的子字符串的最长公共字符串的长度；</li></ul></li><li>有了上述的约定，代码就好写了（注意该函数仅针对了模式串，与匹配串无关），具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> []next, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;       <span class="comment">// 前缀末尾</span></span><br><span class="line">    next[<span class="number">0</span>] = j;    <span class="comment">// 前缀表，第一项置 0，表示不回退</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; needle.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前后最不相同的情况，注意该回退过程是循环进行的</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">            j = next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前后缀相同的情况</span></span><br><span class="line">        <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 next</span></span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法主要过程"><a href="#算法主要过程" class="headerlink" title="算法主要过程"></a>算法主要过程</h1><p>已经有了最重要的前缀表（next 数组），前面怎么利用其进行字符串匹配，我们也已经说过了，那么接下来整个 KMP 算法的具体实现也就是水到渠成了。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P28_ImplementStrstr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> P28_ImplementStrstr().<span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="comment">// TO TEST</span></span><br><span class="line">        String haystack = <span class="string">"aabaabaaf"</span>, needle = <span class="string">"aabaaf"</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = solution.strStr(haystack, needle);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="comment">// KMP 算法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(needle == <span class="keyword">null</span> || needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先构造 next 数组；</span></span><br><span class="line">            <span class="keyword">int</span> []next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">            getNext(next,needle);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用 next 数组开始匹配</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 模式串最初匹配位置</span></span><br><span class="line">            <span class="keyword">for</span>( ; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123; <span class="comment">// 不匹配时，根据前缀表找到回退的位置</span></span><br><span class="line">                    j = next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123; <span class="comment">// 当前字符匹配成功，往后继续进行</span></span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == needle.length()) &#123; <span class="comment">// 匹配成功，返回成功位置</span></span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span>-j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 失败，则返回 -1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求 next 数组</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> []next, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;       <span class="comment">// 前缀末尾</span></span><br><span class="line">            next[<span class="number">0</span>] = j;    <span class="comment">// 前缀表，第一项置 -1，表示到此结束回退</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; needle.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                    j = next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，能看出，KMP 算法的复杂度为：</p><ul><li>时间复杂度 $O(m+n)$</li><li>空间复杂度 $O(m)$</li><li>其中，$m$ 为模式串的长度，$n$ 为匹配串的长度</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>B 站讲解视频：<a href="https://www.bilibili.com/video/BV1PD4y1o7nd/" target="_blank" rel="noopener">帮你把KMP算法学个通透</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/KMP-Algorithm/header.gif&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;KMP 算法是由 D.E.Knuth、J,H,Morris 和 V.R.Pratt 一同提出，因此它也被称为 Knuth-Morria-Pratt 算法。该算法在 “ 字符串匹配问题 ” 中，相较于 Brute-Force（暴力）算法有很大的改进。它的核心思想就是通过一个 &lt;code&gt;next()&lt;/code&gt; 数组（包含了模式串的局部匹配信息），利用匹配失败后的信息，尽量减少模式串与主串的匹配次数，以达到快速匹配的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之图</title>
    <link href="http://www.thebetterkong.cn/2020/09/09/DataStructure-Algorithm/DataStructure-Graph/"/>
    <id>http://www.thebetterkong.cn/2020/09/09/DataStructure-Algorithm/DataStructure-Graph/</id>
    <published>2020-09-09T03:56:44.000Z</published>
    <updated>2020-09-15T07:38:35.938Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/header.png" width="100%" alt="header.png" /> </div>  <p><strong>图</strong>（Linear List）是一种比较复杂的数据结构。在树中，节点会存在明显的分层关系，但是图中却不会受到这种限制。它是由顶点和顶点之间的关系组成的集合。通常，图中的顶点数量或者一个顶点与其他顶点之间的连线的个数不会受限制。</p><a id="more"></a> <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><p>谈到图，我们通常是用它的<strong>二元组定义</strong>方式：</p><ul><li>图 $G$ 是一个有序二元组 $(V,E)$，其中 $V$ 称为<strong>顶点集</strong>（Vertices Set），$E$ 称为<strong>边集</strong>（dges set），$E$ 与 $V$ 不相交。它们也可写成 $V(G)$ 和 $E(G)$；</li><li>$E$ 的元素都是二元组，用 $(x,y)$ 表示，其中 $x,y \in V$；</li></ul><h2 id="图的分类"><a href="#图的分类" class="headerlink" title="图的分类"></a>图的分类</h2><div class="table-container"><table><thead><tr><th>种类</th><th>解释</th></tr></thead><tbody><tr><td>有向图(Digraph)</td><td>若图 G 中的每条边都是有方向的；</td></tr><tr><td>无向图(Undigraph)</td><td>若图 G 中的每条边都是没有方向的；</td></tr><tr><td>完全图</td><td>若无向图中的每个顶点之间存在着一条边，有向图中的每两个定点之间都存在着方向相反的两条边，则称此图为完全图。</td></tr><tr><td>稠密图</td><td>当一个图接近完全图时，则称它为稠密图。</td></tr><tr><td>稀疏图</td><td>当一个图含有较少边数（即 e&lt;&lt; n(n-1)，双小于号表示非常小于的含义）时，则称它为稀疏图。</td></tr><tr><td>简单图</td><td>图中每条边的顶点均不相同。</td></tr></tbody></table></div><p>注意：下面还有一些不是特别常见的分类；</p><ul><li><strong>二分图</strong>：图中的每一条边所连接的两个顶点都分别属于不同的部分，如图：<br>  <img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/binarygraph.png" alt="binarygraph"></li></ul><h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><ul><li><strong>相邻</strong>：如果两个顶点通过一条边相连， 则称这两个顶点是相邻的，并称这条边依附于这两个顶点，相邻的两个顶点互为邻接点；</li><li><strong>度数</strong>：某个顶点的度数即为依附于它的边的总数，注意，又可再细分为：入度、出度；</li><li><strong>子图</strong>：一幅图的所有边的一个子集以及他们所依附的所有顶点组成的图。</li><li><strong>路径</strong>：由边顺序链接的一系列顶点；</li><li><strong>简单路径</strong>：一条没有重复顶点的路径；</li><li><strong>环</strong>：一条至少包含一条边且起点和终点相同的路径；</li><li><strong>简单环</strong>：除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的环；</li><li><strong>可达分量</strong>：有向图中，若顶点 s 到 v 有一条通路，称 v 是从 s 可达的。对于 s，从 s 可达的所有顶点的集合叫可达分量；</li><li><strong>连通图</strong>：任意两个顶点之间互通。一副非连通的图由诺干个连通的部分组成；</li><li><strong>连通分量</strong>：指无向图的极大连通子图；</li><li><strong>图的密度</strong>：已连接的顶点对占所有可能被连接的顶点对的比例；</li><li><strong>平行边</strong>：连接同一对顶点的两条边称为平行边；</li><li><strong>权</strong>：与图中边有关的实数，那么带权图或网就是边上具有权值的图；</li><li><strong>有向图强连通分量</strong>：<ul><li>在有向图 G 中，如果两个顶点 $v_i,v_j$ 间（$v_i &gt; v_j$）有一条从 $v_i$ 到 $v_j$ 的有向路径，同时还有一条从 $v_j$ 到 $v_i$ 的有向路径，则称两个顶点强连通（strongly connected）；</li><li>如果有向图 G 的每两个顶点都强连通，称 G 是一个强连通图；</li><li>有向图的极大强连通子图，称为强连通分量（strongly connected components）；</li></ul></li><li><strong>最小生成树（MST）</strong>：从图中的不同顶点或从同一顶点按不同的优先搜素过程可以得到不同的树。而对于一个连通网（连通带权图）来说，生成的树不同，每棵树的代价（树中每条边上权值之和）也可能不同，代价最小的生成树为图的最小生成树；</li></ul><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>图主要是使用<strong>邻接矩阵</strong>和<strong>邻接表</strong>这两种存储结构来存储的；</p><ul><li>邻接矩阵以矩阵的形式存储图所有顶点间的关系。它具有以下特点：<ul><li>邻接矩阵是正矩阵，即横纵维数相等；</li><li>矩阵的每一行或一列代表一个顶点，行与列的交点对应这两个顶点的边；</li><li>矩阵的点代表边的属性，1 代表有边，0 代表无边，所以矩阵的对角线都是 0，因为对角线上对应的横纵轴代表相同的顶点，边没有意义；</li><li>如果是无向图，那么矩阵是对称矩阵；如果是有向图则不一定；</li><li>如果是有权图，矩阵点数值可以是权值；</li><li>邻接矩阵表示图的关系非常清晰，但消耗空间较大；</li></ul></li><li>邻接表是以一组链表来表示顶点间关系，有以下特点:<ul><li>邻接表示一个有但链表组成的数组；</li><li>图中的每一个顶点都有一个链，数组的大小等于图中顶点的个数；</li><li>无向图的链的第一个元素是本顶点，后继分别连接着和这个顶点相连的顶点；有向图的链第一个顶点是本顶点，后继是以本顶点为起点的边的终点；</li><li>如果是有权图，可以在节点元素中设置权值属性；</li><li>邻接链表关系表示不如邻接矩阵清晰，数据结构相对复杂，但节省空间；</li></ul></li></ul><p>这里以无向图为例详细描述，对于有向图的实现基本相同；</p><h2 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h2><p>图的存储无非就是存储图的顶点和边，而如果采用矩阵的形式就可以间接的用矩阵的坐标表示顶点，用每个位置的值表示边。示例如下：</p><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/AdjacencyMatrix.png" alt="AdjacencyMatrix"></p><p>如图所示，在无向图中，如果存在从顶点 1 到顶点 2 的边，那就一点存在从顶点 2 到顶点 1 的边，对应到矩阵里表示就应该是：$A[1,2]=A[2,1]=1$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 无向图的邻接矩阵表示法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 10:28 2020/9/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixNDG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;       <span class="comment">// 图顶点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] vertexs; <span class="comment">// 存储图顶点</span></span><br><span class="line">    <span class="keyword">int</span>[][] matrix; <span class="comment">// 图的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MatrixNDG</span><span class="params">(<span class="keyword">char</span>[] vertexs,<span class="keyword">char</span>[][] edges)</span></span>&#123;</span><br><span class="line">        size = vertexs.length;</span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="keyword">int</span>[size][size];</span><br><span class="line">        <span class="keyword">this</span>.vertexs = vertexs;</span><br><span class="line">        <span class="comment">// 将给点的边信息存入邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c:edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(c[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            matrix[p1][p2] = <span class="number">1</span>; <span class="comment">// 无向图，需在两个对称位置存储</span></span><br><span class="line">            matrix[p2][p1] = <span class="number">1</span>; <span class="comment">// 对于有向图只需要删除此句即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的遍历输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] i:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j:i)&#123;</span><br><span class="line">                System.out.print(j+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据顶点名称获取对应的矩阵下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vertexs.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i] == ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造图的顶点</span></span><br><span class="line">        <span class="keyword">char</span>[] vexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>,<span class="string">'J'</span>,<span class="string">'K'</span>&#125;;</span><br><span class="line">        <span class="comment">// 构造图的边</span></span><br><span class="line">        <span class="keyword">char</span>[][] edges = <span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'D'</span>, <span class="string">'G'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'I'</span>,<span class="string">'J'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'J'</span>,<span class="string">'G'</span>&#125;,&#125;;</span><br><span class="line">        MatrixNDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义"图"(输入矩阵队列)</span></span><br><span class="line">        <span class="comment">// 采用已有的"图"</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> MatrixNDG(vexs, edges);</span><br><span class="line">            pG.print();   <span class="comment">// 打印图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/AdjacencyList.png" alt="AdjacencyList">   </p><p>在这种结构中，我们一般分为两种节点来存储：</p><ul><li><strong>头结点</strong>：每条边起点（图示中第 1 列的节点），该类节点主要包括两个域：<ul><li><code>data 域</code>：存储顶点（Vi）的数据信息；</li><li><code>firstarc 域</code>：该域作为指针域，它指向与顶点（Vi）相连的第一条弧（arc）。注意，这里指的第一条并没有特定的顺序，只是为了和之后的弧进行区分而出现的概念；</li></ul></li><li><strong>边节点（表节点，弧节点）</strong>：每条边终点（图示中除第 1 列外的其他节点），该类节点主要包括三个域：<ul><li><code>adjvex</code>：指示通过该边，与顶点（Vi）连接的另一个顶点在图中的位置，这里的位置可以用头结点在数组中的位置（下标）来表示；</li><li><code>next</code>:指向与顶点（Vi）连接的下一条弧（该弧以顶点（Vi）为弧头）；</li><li><code>info</code>：这是一个可以用来存储边的权值的域；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDG</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Character&gt;[] vertexLists; <span class="comment">// 邻接表的数组</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 顶点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListDG</span><span class="params">(<span class="keyword">char</span>[] vertexs,<span class="keyword">char</span>[][] edges)</span></span>&#123;</span><br><span class="line">        size = vertexs.length;</span><br><span class="line">        <span class="keyword">this</span>.vertexLists = <span class="keyword">new</span> LinkedList[size];</span><br><span class="line">        <span class="comment">// 设置邻接表头节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>.vertexLists[i] = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">            vertexLists[i].add(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将边的信息存入邻接表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c:edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = getPosition(c[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">this</span>.vertexLists[p].add(c[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据顶点名称获取链表下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            <span class="keyword">if</span>(vertexLists[i].get(<span class="number">0</span>)==ch)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            LinkedList&lt;Character&gt; temp=vertexLists[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++)&#123;</span><br><span class="line">                System.out.print(temp.get(j)+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vexs = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>,<span class="string">'J'</span>,<span class="string">'K'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[][] edges = <span class="keyword">new</span> <span class="keyword">char</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'C'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'D'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'A'</span>, <span class="string">'F'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'B'</span>, <span class="string">'C'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'C'</span>, <span class="string">'D'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'E'</span>, <span class="string">'G'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'D'</span>, <span class="string">'G'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'I'</span>,<span class="string">'J'</span>&#125;,</span><br><span class="line">                &#123;<span class="string">'J'</span>,<span class="string">'G'</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        ListDG pG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            pG = <span class="keyword">new</span> ListDG(vexs, edges);</span><br><span class="line">            pG.print();   <span class="comment">// 打印图</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end=System.nanoTime();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有向图来说，每一条链表（每行）的节点数，就是节点 Vi 的出度，但有时候我们还需要求顶点的入度，这样的存储方式就不太方便。于是，就有了<strong>逆邻接表</strong>的表示方法，它唯一的不同就是，链表后所连的节点不再是 Vi 指向的节点，而是指向 Vi 的节点；</p><h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><p>有了这两种存储方式，我们可能就会遇到如何抉择的问题？   </p><p>对于这两种结构，它们各有优缺点：</p><ul><li>从空间上来说：<ul><li>邻接矩阵主要是以存点为主，而邻接表则是存边。邻接矩阵的空间复杂度是 $O(V \ast V)$，而邻接表的复杂度为 $O(V+E)$，$V$ 为顶点数，$E$ 为边数；</li><li>所以自然而然就会有一个简单的认识：在图的顶点少时，选择邻接矩阵；图的顶点较多时，选择邻接表；</li></ul></li><li>从操作上来分析：<ul><li>如果我们需要处理顶点 V 的邻接顶点，使用邻接表只需要简单的 $deg(v)$ 步（deg：图中点的出度），而使用邻接矩阵则至少需要 $v$ 步；邻接矩阵具有明显优势；</li><li>但是，如果我们需要插入或者删除一个 v 的邻接节点时，就需要对邻接表进行结构调整，而对于邻接矩阵，只需要简单的在相应位置进行 0 和 1 的变换即可；邻接矩阵又开始具有明显优势；</li></ul></li></ul><p>综上分析，我们还是需要根据实际的运用场景来选择合适的存储结构。但是在一般的应用场景中，我们遇到的都是稀疏图，并且图中的顶点数都会很多，而邻接矩阵指数的空间开销对此是十分致命的。因此，我们用的更多的还是邻接表，后文介绍的算法也基本都是围绕邻接表的存储结构而展开。</p><h2 id="补充：十字链表法"><a href="#补充：十字链表法" class="headerlink" title="补充：十字链表法"></a>补充：十字链表法</h2><p>十字链表法就是结合了邻接表和逆邻接表，以方便求出图形结构的出度和入度。</p><ul><li>头结点：有三个域<ul><li><code>信息域 data</code>：存储顶点（Vi）数据信息；</li><li><code>指针域 firstin</code>：存储第一个以顶点（Vi）为弧头的边节点地址；</li><li><code>指针域 firstout</code>：存储第一个顶点（Vi）为弧尾的边节点地址；</li></ul></li><li>表节点（边节点）：有五个域<ul><li><code>头域 headvex</code> 和 <code>尾域 tailvex</code> 存储的是该边（弧）的弧头和弧尾的信息，可以是弧头和弧尾在数组中的位置；</li><li><code>链域 hlink</code> 存储的是和该边弧头一样的边位置，即 hlink 指向和该边弧头一样的边；</li><li><code>链域 tlink</code> 存储的是和该边弧尾一样的边位置，即 hlink 指向和该边弧尾一样的边；</li><li><code>信息域 info</code> 中可以存储边的信息如权值；</li></ul></li></ul><p>图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/CrossLinkedList.png" alt="CrossLinkedList"></p><h2 id="补充：邻接多重表"><a href="#补充：邻接多重表" class="headerlink" title="补充：邻接多重表"></a>补充：邻接多重表</h2><p>邻接多重链表就是针对于无向图改进的存储结构，让一条边仅仅用一个节点表示。<br>一条边由一个节点六个域表示：</p><ul><li><code>mark 域</code>：用来标记这条边是否被检索过;</li><li><code>ivex</code> 和 <code>jvex 域</code>：这两个域中存储的是顶点的位置，因为一条边连接两个顶点，所以这两个域放在一起讲，ivex 域中存储节点 Vi 的位置，jvex 域中存储节点 Vj 的位置；</li><li><code>ilink</code> 和 <code>jlink 域</code>：这两个域中存放的是边的位置。因为一条边对应两个顶点，而顶点的边都是由一个个边节点链接起来的，ilink 中存储顶点 Vi 的下一条边的位置。jlink 中存储顶点 Vj 的下一条边的位置；</li><li><code>info 域</code>：可以用来存储边的权值；</li></ul><p>图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/AdjacencyMultipleList.png" alt="AdjacencyMultipleList"></p><h1 id="图的抽象类型"><a href="#图的抽象类型" class="headerlink" title="图的抽象类型"></a>图的抽象类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 重点关注其相关函数，Node 具体类型和图的存储结构相关</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 10:09 2020/9/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> UndirectedGraph = <span class="keyword">false</span>;    <span class="comment">// 无向图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DirectedGraph   = <span class="keyword">true</span>;    <span class="comment">// 有向图</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ADJACENCY_MATRIX = <span class="keyword">true</span>;    <span class="comment">// 邻接矩阵实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ADJACENCY_LIST = <span class="keyword">false</span>;     <span class="comment">// 邻接表实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************* 基本方法 ******************************/</span></span><br><span class="line">    <span class="comment">// 可以简单的借助图的存储数据结构来实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的顶点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVexNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getVertex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图的所有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getEdge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个顶点 v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一条边 e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Edge e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个顶点 v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一条边 e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Edge e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断顶点 u、v 是否邻接，即是否有边从 u 到 v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areAdjacent</span><span class="params">(Vertex u, Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从 u 指向 v 的边，不存在则返回 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Edge <span class="title">edgeFromTo</span><span class="params">(Vertex u, Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从 u 出发可以直接到达的邻接顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">adjVertexs</span><span class="params">(Vertex u)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************* 补充方法 ******************************/</span></span><br><span class="line">    <span class="comment">// 补充的一些其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">DFSTraverse</span><span class="params">(Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">BFSTraverse</span><span class="params">(Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与结点 s 相连通的所有结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">search</span><span class="params">(Vertex s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否存在 S 结点到 V 结点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出节点 s 到 v 的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求顶点 v 到其他顶点的最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">shortestPath</span><span class="params">(Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求无向图的最小生成树，如果是有向图不支持此操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateMST</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedOperation</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求有向图的拓扑序列，无向图不支持此操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">toplogicalSort</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedOperation</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求有向无环图的关键路径，无向图不支持此操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">criticalPath</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedOperation</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在图的抽象类型中，前九个函数的实现都比较简单。后文，将重点介绍后面相关函数的具体实现。</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p>图的遍历和树的遍历主要思想基本相同，唯一的差别就是需要手动的给每个节点打上一个 marked 标签，来标识节点是否都被访问过，以此作为递归出口。    </p><p>这里主要是描述无向图的遍历，有向图的遍历思想也基本相同。</p><h2 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h2><p>深度优先遍历 DFS（depth-first search）算法思想：</p><ol><li>从初始顶点 v 出发，选择一个与 v 相邻的未被访问的顶点 w；</li><li>再从 w 开始，进行新的一轮 DFS 算法；</li><li>若一个顶点 u 的所有相邻顶点都被访问过了，则回退到最近被访问的、且未被访问的 w 顶点；</li><li>再重新从 w 顶点出发开始 DFS 算法；</li><li>当从任何已经访问的顶点出发，不再有未访问的顶点时，搜索终止；</li></ol><p>无向图的递归算法 java 实现（非递归实现，利用栈即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 无向图的深度优先遍历（递归）算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 14:08 2020/9/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;   <span class="comment">// 用来标记节点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;          <span class="comment">// 计数被访问的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearch</span><span class="params">(UndirGraph graph, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];    <span class="comment">// 初始化图中每个节点的标记</span></span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(UndirGraph graph, <span class="keyword">int</span> s)</span> </span>&#123; <span class="comment">// 从节点 s 出发开始递归遍历</span></span><br><span class="line">        marked[s] = <span class="keyword">true</span>;   <span class="comment">// 置标记位为已访问</span></span><br><span class="line">        count++;    <span class="comment">// 已访问节点数 +1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:graph.aadjVertexs(s))&#123;   <span class="comment">// 对从 s 可以直接访问到的节点递归遍历</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[v])&#123;</span><br><span class="line">                dfs(graph,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回节点 w 是否被访问过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getMarked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回已访问的节点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上述的深度优先遍历算法，就不难推导出，前面定义的图里一些函数的实现方式：</p><ul><li>首先，以 DFS 算法为基础，构造出路径搜索的中间类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearchPath</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从起点到一个顶点的已知路径上面的最后一个顶点，例如：</span></span><br><span class="line"><span class="comment">     *  0-3-4-5-6 则 edgeTo[6] = 5</span></span><br><span class="line"><span class="comment">     * 这样就相当于用 int[] edgeTo 串起来了一条路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 graph 中找出以 s 为起点的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstSearchPath</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.getVertex()];</span><br><span class="line">        dfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:graph.adjVertexs(s))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[v])&#123;</span><br><span class="line">                edgeTo[v] = s;</span><br><span class="line">                dfs(graph, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * v 的顶点是否可达，也就是说是否存在 s 到 v 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 s 到 v 的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x]) &#123;</span><br><span class="line">            path.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现图的抽象类型的函数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    DepthFirstSearchPath dfsPath = <span class="keyword">new</span> DepthFirstSearchPath(<span class="keyword">this</span>,s);</span><br><span class="line">    <span class="keyword">return</span> dfsPath.hasPathTo(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    DepthFirstSearchPath dfsPath = <span class="keyword">new</span> DepthFirstSearchPath(<span class="keyword">this</span>,s);</span><br><span class="line">    <span class="keyword">return</span> dfsPath.pathTo(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，还可以进一步扩展：寻找出一幅图的所有连通分量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 无向图的连通分量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 15:01 2020/9/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id 代表：结点属于哪个连通分量，例如：</span></span><br><span class="line"><span class="comment">     * id[1] = 0, id[3] = 1</span></span><br><span class="line"><span class="comment">     * 代表 1 结点属于 0 连通分量，3 结点属于 1 连通分量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 连通分量的表示，0，1……</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CC</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[graph.getVertex()];</span><br><span class="line">        <span class="comment">// 对每个节点开始打标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s:graph.getVertex())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[s])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                dfs(graph,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w:graph.adjVertexs(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                dfs(graph, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v 和 w 是否属于同一连通分量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v]==id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得连通分量的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结点属于哪一个连通分量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[w];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历 BFS"></a>广度优先遍历 BFS</h2><p>递归思想将不再适用于 BFS 算法，这里借助队列来实现其非递归算法。</p><p>广度优先遍历 BFS( Breadth-first search) 算法思想：</p><ol><li>顶点 v 入队列；</li><li>当队列非空时则继续执行，否则算法结束；</li><li>出队列，得到队头顶点 v；访问顶点 v 并标记顶点 v 已被访问；</li><li>查找顶点 v 的第一个邻接顶点 col；</li><li>若 v 的邻接顶点 col 未被访问过的，则 col 入队列；</li><li>继续查找顶点 v 的另一个新的邻接顶点 col，转到步骤（5）。直到顶点 v 的所有未被访问过的邻接点处理完。转到步骤（2）；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstSearch</span><span class="params">(Graph graph,<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.getVertex()];</span><br><span class="line">        bfs(graph, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 将 s 加入队列中</span></span><br><span class="line">        queue.offer(s);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 从队列中删除结点</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w: graph.adjVertexs(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.offer(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于从 s 可达的任意顶点 v，广度优先搜索都能找到一条从 s 到 v 的最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasPathTo(v))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v; i != s; i = edgeTo[i]) &#123;</span><br><span class="line">            path.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题补充"><a href="#问题补充" class="headerlink" title="问题补充"></a>问题补充</h2><p>其实，图里大部分的算法，都是在图的存储数据结构和图的遍历算法上引申而来，所以弄透前面这两大模块的内容是十分重要的。    </p><p>这里提出一个问题：<strong>如何判断无向图里是否有环？</strong></p><ul><li>采用图的任意一种遍历算法。在进行搜索的时候，如果 A 结点的邻居结点 B 已经被被标记了，并且在节点 B 中，它的邻居结点 C 也已经被标记了，此时如果邻居结点 C 并不是结点 A，那么这幅图就是一个有环图；</li><li>原理：在图的遍历算法中，任意一个被标记的节点都一定与起点 s 间存在一条路径。现在，节点 A 和 B 都已经被标记，也就是说存在 s-A 和 s-B 这两条路径。现在，如果与 B 相邻的 C 也被标记了，那也就存在 s-C 的路径。那么，这样就会形成一个 s-B-C 的环路（画个图，关系就能很明显）；</li></ul><h1 id="其他常见算法的深入研究"><a href="#其他常见算法的深入研究" class="headerlink" title="其他常见算法的深入研究"></a>其他常见算法的深入研究</h1><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>同无向图一样，有向图也会存在遍历和路径问题，唯一的不同是，有向图的边是带有方向的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectGraphDFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectGraphDFS</span><span class="params">(DiGraph diGraph,<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[diGraph.getVertex()];</span><br><span class="line">        dfs(diGraph,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph diGraph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w:diGraph.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                dfs(diGraph,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起点 s 是否可达 v</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环路问题"><a href="#环路问题" class="headerlink" title="环路问题"></a>环路问题</h3><p>有向图的环路问题则比无向图稍微复杂一些。因为，无向图是双向导通的，在检测时，只要某个节点被标记了，我们就可以通过该节点回溯到任意一个节点；但是，有向图因为单向导通，就可能存在某些节点回溯不到的现象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cycle; <span class="comment">// 有向环中所有顶点</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点是否在递归调用栈上:</span></span><br><span class="line"><span class="comment">     *  当某结点A的邻居结点的onStack为true的时候，说明该邻居结点结点正处于递归的过程中，</span></span><br><span class="line"><span class="comment">     *  则该邻居结点能够通过递归得到结点A。而当onStack为false的时候则说明改邻居结点不能</span></span><br><span class="line"><span class="comment">     *  通过递归回到回到结点A。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[graph.getVertex()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:graph.getVertex())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[v])&#123;</span><br><span class="line">                dfs(graph,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w:graph.adjVertexs(s))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasCycle())&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(graph,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当它的邻居结点已经被标记时，且在同一个调用栈中。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w])&#123;</span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x= v;x != w;x = edgeTo[x])&#123;</span><br><span class="line">                    cycle.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">                cycle.push(w);</span><br><span class="line">                cycle.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有向图中是否含有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得有向环中的顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable <span class="title">cycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调度问题（拓扑排序）"><a href="#调度问题（拓扑排序）" class="headerlink" title="调度问题（拓扑排序）"></a>调度问题（拓扑排序）</h3><blockquote><p><strong>AOV 网</strong>：一个较大的工程往往被划分成许多子工程，我们把这些子工程称作活动（activity）。在整个工程中，有些子工程（活动）必须在其它有关子工程完成之后才能开始，也就是说，一个子工程的开始是以它的所有前序子工程的结束为先决条件的，但有些子工程没有先决条件，可以安排在任何时间开始。为了形象地反映出整个工程中各个子工程（活动）之间的先后关系，可用一个有向图来表示，图中的顶点代表活动（子工程），图中的有向边代表活动的先后关系，即有向边的起点的活动是终点活动的前序活动，只有当起点活动完成之后，其终点活动才能进行。通常，我们把这种顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网（Activity On Vertex network），简称 AOV 网。</p></blockquote><p>在优先级限制中，明确的指明了哪些任务必须在哪些任务之前完成。对应到有向图中，优先级限制下的调度问题等价于<strong>拓扑排序</strong>：给定一幅有向无环图（DAG），将所有的顶点排序， 使得所有的有向边均从排在前面的元素指向排在后面的元素（或者说明无法做到这一点）；   </p><p>那么，由 AOV 网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为 0 的顶点为止。</p><ul><li>选择一个入度为 0 的顶点并输出之；</li><li>从网中删除此顶点及所有出边；</li><li>循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</li></ul><p>注意：拓扑排序的结果并不唯一；</p><p>例如：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/TopologicalSort.png" alt="TopologicalSort"></p><p>实际上深度优先搜索也是一种拓扑排序。在深度优先搜索中，能够保证每个顶点的访问顺序必定会符合拓扑排序的规律。根据递归的情况，将产生下面 3 种排序规律：</p><ul><li>前序：在递归调用之前将顶点加入队列</li><li>后序：在递归调用之后将顶点加入队列</li><li>逆后序：在递归调用之后将顶点压入栈</li></ul><p>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DfsOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; pre; <span class="comment">// 前序</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; post; <span class="comment">// 后序</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost; <span class="comment">// 逆后序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DfsOrder</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.post = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.reversePost = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:graph.getVertex()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])&#123;</span><br><span class="line">                dfs(graph,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        pre.offer(v);</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w:graph.adjVertexs(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                dfs(graph,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        post.offer(v);</span><br><span class="line">        reversePost.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reversePost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="强连通性"><a href="#强连通性" class="headerlink" title="强连通性"></a>强连通性</h3><p>在前面图的相关术语中，已经介绍了强连通性的概念。</p><p>而强连通性有一个特点：两个顶点是强连通的当且尽当它们都在一个普通的有向环中；</p><p>连通性也具有下面 3 个性质：</p><ul><li>自反性：任意顶点和自己是强连通的</li><li>传递性：v 和 w 是强连通，w 和 x 是强连通的，则 v 和 x 是强连通的；</li><li>对称性：v 和 w 是强连通，则 w 和 v 也是强连通的；</li></ul><p>强连通分量的例子如下：</p><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/StronglyConnectedComponent.png" alt="StronglyConnectedComponent"></p><p>在无向图中，求连通分量比较简单。但是在有向图中，寻找强连通分量这个过程将变得十分复杂。</p><p>首先，最简单的思路就是暴力求解法。对于某个节点 v，先求得有向图中 v 可以到达的所有顶点。然后进行遍历，得到可到达 v 的顶点。之后，取这两个顶点集的交集，就可以得到连通分量。但是，这个过程，时间复杂度会达到 $O(n^2)$，对于顶点较多的图显然不可取。</p><p>对此，不得不提到 <strong>Kosaraju 算法</strong>，算法步骤如下：</p><ul><li>将一幅图 G 中的所有边进行反向，也就是调用 reverse() 函数得到 G2；</li><li>将 G2 进行拓扑排序得到它的逆后序排序（也就是一个序列）；</li><li>然后对图进行深度优先搜索，进行深度搜索的顺序就是第 2 个步骤中的逆后序序列；</li><li>在构造函数中，使用同一个 dfs() 函数调用被访问的顶点，都在同一个强连通分量中间；</li></ul><p>原理分析：</p><ul><li>首先我们知道，每个和 s 强连通的顶点 v 都会在构造函数 dfs(graph,s) 被访问到。接下来需要思考的是：为什么构造函数中 dfs(graph,s) 函数所到达的任意顶点 v 都必然是和 s 强连通的：</li><li>设 v 是 dfs(graph,s) 达到的某个顶点，那么原图 G 中必然会有一条 s 到 v 的路径，现在我们只需要找到 v 到 s 的路径即可。那么，这样就等价于证明：G2（G 通过 reverse() 函数得到的图）有一条 s 到 v 的路径；</li><li>在原图 G 中，顶点 v 是 dfs(graph,s) 函数所到达的，所以 dfs(graph,v) 一定在 dfs(graph,s) 中调用，也即 v 结点在拓扑排序中一定在 s 结点的后面；这也就代表着在 G2 的深度优先遍历中，dfs(graph,v) 调用结束绝逼在 dfs(graph,s) 之前调用（栈是先进后出），那么在图 G2 中就分为两种情况：<ul><li>dfs(graph,v) 在 dfs(graph,s) 调用之前结束</li><li>dfs(graph,v) 在 dfs(graph,s) 调用结束之前结束</li></ul></li><li>因为在图 G 中有一条 s-&gt;v 的路径，在图 G2 中有一条 v-&gt;s 的路径，则第一种情况不可能出现。则第二种情况说明了 G2 中有一条 s-&gt;v 的路线。则图 G 中有一条 v-&gt;s 的路径。</li></ul><p>算法的 java 实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DfsSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DfsSCC</span><span class="params">(DiGraph graph)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[graph.getVertex()];</span><br><span class="line">        DfsOrder order = <span class="keyword">new</span> DfsOrder(graph.reverse());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s:order.reversePost())&#123;</span><br><span class="line">            dfs(graph,s);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DiGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w:graph.adjVertexs(v))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[v])&#123;</span><br><span class="line">                dfs(graph,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回某结点强连通的 id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 v 和 w 是否属于强连通</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stronglyConnected</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v]==id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回强连通分量的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法示例的过程示意图（左边是对 G2 进行逆后序排序，右边是根据排序的结果进行深度递归）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/ExampleOfKosaraju.png" alt="ExampleOfKosaraju"></p><h2 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h2><p>这里我们讲述的主要都是加权无向图。加权图和图的区别就是在它的每一条边上加了权重，它在现在的网络流量，工程图，路径搜索中都有着重大的作用。也可以说是图里十分重要的一部分。</p><h3 id="加权无向图的数据结构"><a href="#加权无向图的数据结构" class="headerlink" title="加权无向图的数据结构"></a>加权无向图的数据结构</h3><p>首先，定义一下带权重的边：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边的两个顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight; <span class="comment">// 权重</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到边的某一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">either</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过某一个顶点得到边的另外一个顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> vertex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vertex == w)&#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vertex==v)&#123;</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有这一条边"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边进行比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Edge o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.weight() &gt; o.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight() &lt; o.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转化为字符串输出边信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Edge&#123;"</span> +</span><br><span class="line">                <span class="string">"v="</span> + v +</span><br><span class="line">                <span class="string">", w="</span> + w +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，加权无向图也即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">// 顶点总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;  <span class="comment">// 边的总数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Edge&gt;[] adj; <span class="comment">// 边</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本质也是一种邻接表的存储方式，注意区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        adj = <span class="keyword">new</span> ArrayList[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> ArrayList&lt;Edge&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Edge e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e.either(), w = e.other(v);</span><br><span class="line">        adj[v].add(e);</span><br><span class="line">        adj[w].add(e);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图中的所有边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Edge&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Edge&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge e:adj[i])&#123;</span><br><span class="line">                <span class="comment">// 如果i和j为一条边e，那么adj[i] = e;adj[j] = e;这两条边是一样的，所以我们需要去除一条边</span></span><br><span class="line">                <span class="keyword">if</span> (e.other(i)&gt;i)&#123;</span><br><span class="line">                    list.add(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树（无向图）"><a href="#最小生成树（无向图）" class="headerlink" title="最小生成树（无向图）"></a>最小生成树（无向图）</h3><p>在求解无向加权图的最小生成树时，运用最多的就是 <strong>Kruskal 算法</strong>和 <strong>Prim 算法</strong>，他们的本质都是一种贪心算法。</p><h4 id="克鲁斯卡尔（Kruskal）算法"><a href="#克鲁斯卡尔（Kruskal）算法" class="headerlink" title="克鲁斯卡尔（Kruskal）算法"></a>克鲁斯卡尔（Kruskal）算法</h4><p>它很好的体现了贪心算法的精髓，在含有 n 个顶点的图中，该算法总共选择 n-1 条边。它使用的贪婪准则：从剩下的边中选择一条不会产生环路的且具有最小权重的边，加入已选择的边的集合中（注意：所选取的边若产生环路则不可能形成一棵生成树）。</p><p>kruskal 算法分 e 步（e 是网络中边的数目）。按权重递增的顺序来考虑这 e 条边，每次考虑一条边。当考虑某条边时，若将其加入到已选边的集合中会出现环路，则将其抛弃，否则，将它选入。具体过程如下：</p><ol><li>将所有的边的权重排序，用排序的结果作为选择边的依据（再次体现了贪心算法的思想：资源排序，对局部最优的资源进行选择）；</li><li>再选边：AD —&gt; CE —&gt; DF —&gt; AB —&gt; BE<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/Kruskal.png" alt="Kruskal"></li><li>接下来，尽管现在未选择的边的权重最小为 8。但是他们已经连通了，再选择就会出现环路。因此，现在只有 FG、EG 这两条边可选，选择权重较小边 EG；</li></ol><p>观察上述过程，不难发现，整个算法中最关键的两步就是：</p><ul><li>如何对边进行排序；<ul><li>这个直接参考《排序算法》即可，一般使用堆排序，使用优先队列</li></ul></li><li>如何检测环路；<ul><li>这个问题在前面已经探讨过，这里再着重介绍一下 <strong>union-find 算法</strong>，他的主要原理是：假设有 N 个独立分散的点，将点用线段进行连接。连接时可以想像，像树一样，有根节点，如果两个结点的根节点是一样的，那么毋庸置疑，将两个结点进行连接肯定会成环。</li><li>该算法的 3 种写法：<ul><li>quick-find 算法</li><li>quick-union算法</li><li>加权 quick-union 算法（运用最多，最最坏的情况下时间复杂度也只有 $O(logn)$）</li></ul></li></ul></li></ul><p>加权 quick-union 算法的 java 实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightQuickUnionUF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;  <span class="comment">// 结点的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;  <span class="comment">// （由结点索引的）各个根节点所对应的根节点的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 连通分量的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行初始化，初始化后其中每一个结点都是一个连通分量</span></span><br><span class="line"><span class="comment">     * 其中结点的父节点为自己本身</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightQuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * p 和 q 是否相链接，若相连接，则在同一个连通分量里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在根节点中 id[v]= v（在初始化的时候定义的）</span></span><br><span class="line">        <span class="keyword">while</span>(v != id[v])&#123;</span><br><span class="line">            v = id[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 p 和 q 之间添加一条链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line">        <span class="comment">// 如果是同一条连通分量，则返回，没必要添加</span></span><br><span class="line">        <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这一步的目的是将小树加入大树</span></span><br><span class="line">        <span class="comment">// 目的是减少在最坏情况下的时间复杂度</span></span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[j])&#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            sz[j] += sz[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            sz[i] += sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">        count --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kruskal 算法的 java 实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Edge&gt; pq; <span class="comment">// 优先队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst; <span class="comment">// 最小生成树</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        mst =  <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将边加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edge:graph.edges())&#123;</span><br><span class="line">            pq.add(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        mst(graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mst</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        WeightQuickUnionUF uf = <span class="keyword">new</span> WeightQuickUnionUF(graph.getVertex());</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 从里面取出最小的元素</span></span><br><span class="line">            Edge e = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> v = e.either();</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">// 防止成环</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(v,w))&#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(v,w);</span><br><span class="line">            mst.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">getMst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="普里姆（Prim）算法"><a href="#普里姆（Prim）算法" class="headerlink" title="普里姆（Prim）算法"></a>普里姆（Prim）算法</h4><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/Kruskal.png" alt="Kruskal"><br>主要步骤：</p><ol><li>任选一个顶点 D 作为起始点；</li><li>在所有与 D 相连的边（D-&gt;A、D-&gt;B、D-&gt;E、D-&gt;F）中，搜索权重最小的边（D-&gt;A）加入树中，并将树的顶点集更新（A、D）；</li><li>搜索与树的顶点集里的顶点相连的边（A-&gt;B、D-&gt;B、D-&gt;E、D-&gt;F），将权重最小的边（D-&gt;F）加入树，再更新顶点集（A、D、F），但是注意，避免成环；</li><li>重复上述过程，直至树的顶点集包含图的所有顶点；</li></ol><p>在具体实现时，我们有两种实现方式：</p><ul><li><strong>延时实现</strong>：<ul><li>把一个顶点加入最小生成树中；</li><li>再把它的所有的连接着未访问顶点的邻接边都放入优先队列（作为横切边）；</li><li>然后从横切边中弹出权重最小的一条，检查它两边的顶点是否在最小生成树中，如果在，则忽略该边，从头开始步骤3。如果不在，则把它和它所连接的顶点加入最小生成树中；</li><li>再对它所连接的顶点作和以上相同的操作。直到优先队列为空；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该实现在优先队列中保存了很多无用边，带来了较大的空间浪费；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Edge&gt; pq; <span class="comment">// 横切边</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span><span class="params">(EdgeWeightedGraph graph)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.V()];</span><br><span class="line">        pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        mst = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        mst(graph);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mst</span><span class="params">(EdgeWeightedGraph graph)</span></span>&#123;</span><br><span class="line">        visit(graph,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 从优先队列中得到最小的边</span></span><br><span class="line">            Edge e= pq.poll();</span><br><span class="line">            <span class="keyword">int</span> v = e.either();</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">// 如果两个顶点都被标记了，则看下一条边</span></span><br><span class="line">            <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将边加入mst</span></span><br><span class="line">            mst.add(e);</span><br><span class="line">            <span class="keyword">if</span> (!marked[v])&#123;</span><br><span class="line">                visit(graph,v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                visit(graph,w);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记顶点 v 并将其（所有）边（边所相连接的另外一个顶点未被标记）加入队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph graph,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e:graph.adj(v))&#123;</span><br><span class="line">            <span class="comment">// 另外一个顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[e.other(v)])&#123;</span><br><span class="line">                <span class="comment">// 将顶点假如优先队列</span></span><br><span class="line">                pq.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title">getMst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>即时实现</strong>：<ul><li>先把一个顶点放入最小生成树中；</li><li>遍历该顶点的邻接边结点（结点 A），如果边（边 W）所连接的某个顶点（结点 B）不在最小生成树中，且它（结点 B）到该顶点（结点 A）的距离大于该边（边 W）的权重，则该结点（结点 B）到顶点（结点A）的距离变成该边的权重，并且更新索引优先队列中的边；</li><li>从索引优先队列弹出权重最小的边，然后对它所连接的顶点作以上操作，直到栈空；</li><li>示例：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/Prim.png" alt="Prim"></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即时的 prim 算法和延时的 prim 算法很相似，原理上面并没有什么发生改变；</span></span><br><span class="line"><span class="comment">// 只不过在即时的 prim 算法中，我们只将有用的边假如优先队列，而没有用的边就不管它了。这样我们就节约了空间，以及遍历边的时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Edge[] edgeTo; <span class="comment">// 某结点距离树最近的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo; <span class="comment">// 某结点距离树的权重距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked; <span class="comment">// 结点是否在树中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有效的横切边（也就是被保存在优先队列中有效的边）</span></span><br><span class="line"><span class="comment">     * key: 结点的id</span></span><br><span class="line"><span class="comment">     * value:权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph graph)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> Edge[graph.getVertex()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getVertex()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getVertex()];</span><br><span class="line">        <span class="comment">// IndexMinPQ 是索引优先队列，并不是 Java 本身的库</span></span><br><span class="line">        <span class="comment">// 地址：https://github.com/xiaohuiduan/algorithm_code/blob/master/graph/weight/IndexMinPQ.java</span></span><br><span class="line">        pq = <span class="keyword">new</span> IndexMinPQ&lt;&gt;(graph.getVertex());</span><br><span class="line">        <span class="comment">// 初始化结点到树的距离为无限大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:graph.getVertex()) &#123;</span><br><span class="line">            distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.insert(<span class="number">0</span>,<span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            visit(graph,pq.delMin());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(EdgeWeightedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 遍历与v相连的结点</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e:graph.adj(v))&#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">            <span class="comment">// 假如w已经为最小树的结点,则不进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (marked[w])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 假如w结点的权重小于w结点到树的距离</span></span><br><span class="line">            <span class="keyword">if</span> (e.weight()&lt;distTo[w])&#123;</span><br><span class="line">                <span class="comment">// w结点到最小树的边为e</span></span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                <span class="comment">// 距离为e边的权重</span></span><br><span class="line">                distTo[w] = e.weight();</span><br><span class="line">                <span class="comment">// 将结点放入优先队列</span></span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w))&#123;</span><br><span class="line">                    pq.changeKey(w,distTo[w]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pq.insert(w,distTo[w]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最小生成树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Edge&gt; <span class="title">mst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Edge&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge e:edgeTo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比分析-1"><a href="#对比分析-1" class="headerlink" title="对比分析"></a>对比分析</h4><ul><li>克鲁斯尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；</li><li>普里姆算法主要是针对顶点来展开，对于稠密图，即边数非常多的情况会更好一些；</li></ul><p>时间复杂度（V 个顶点 E 条边）：</p><div class="table-container"><table><thead><tr><th>算法（最坏情况下）</th><th>空间</th><th>时间</th></tr></thead><tbody><tr><td>Kruskal 算法</td><td>$O(E)$</td><td>$O(ElogE)$</td></tr><tr><td>延时的 Prim 算法</td><td>$O(E)$</td><td>$O(ElogE)$</td></tr><tr><td>即时的 Prim 算法</td><td>$O(V)$</td><td>$O(ElogV)$</td></tr></tbody></table></div><ul><li>邻接矩阵实现的普里姆算法的时间复杂度为 $O(n^2)$；</li></ul><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><p>算法介绍：</p><ul><li>Dijkstra 算法是典型的<strong>单源最短路径算法</strong>，用于<strong>计算一个节点到其他所有节点的最短路径</strong>；</li><li>主要特点：是以起始点为中心向外层层扩展，直到扩展到终点为止；</li><li>Dijkstra 算法是很有代表性的最短路径算法，注意该算法要求图中不存在负权边；</li></ul><p>问题描述：</p><ul><li>单源最短路径：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径；</li></ul><p>算法思想：</p><ul><li>设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组：<ul><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了）；</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。</li></ul></li><li>在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度；</li><li>此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度，U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度；</li></ul><p>算法步骤：</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0。U 包含除 v 外的其他顶点，即 U={其余顶点}，若 v 与 U 中顶点 u 有边，则 <u,v> 正常有权值，若 u 不是 v 的出边邻接点，则 <u,v> 权值为 $\infty$；</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离就是 v到 k 的最短路径长度）；</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权；</li><li>重复步骤 2 和 3 直到所有顶点都包含在 S 中；</li></ol><p>算法动图展示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/Dijkstra" alt=""></p><p>java 实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @来源： https://blog.csdn.net/ochangwen/article/details/50730937</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphByMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> UNDIRECTED_GRAPH = <span class="keyword">false</span>;<span class="comment">//无向图标志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DIRECTED_GRAPH = <span class="keyword">true</span>;<span class="comment">//有向图标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ADJACENCY_MATRIX = <span class="keyword">true</span>;<span class="comment">//邻接矩阵实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ADJACENCY_LIST = <span class="keyword">false</span>;<span class="comment">//邻接表实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> graphType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vertexSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> matrixMaxVertex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储所有顶点信息的一维数组</span></span><br><span class="line">    <span class="keyword">private</span> Object[] vertexesArray;</span><br><span class="line">    <span class="comment">//存储图中顶点之间关联关系的二维数组,及边的关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edgesMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录第i个节点是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graphType 图的类型：有向图/无向图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method    图的实现方式：邻接矩阵/邻接表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphByMatrix</span><span class="params">(<span class="keyword">boolean</span> graphType, <span class="keyword">boolean</span> method, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graphType = graphType;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.vertexSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.matrixMaxVertex = size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.method) &#123;</span><br><span class="line">            visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrixMaxVertex];</span><br><span class="line">            vertexesArray = <span class="keyword">new</span> Object[matrixMaxVertex];</span><br><span class="line">            edgesMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[matrixMaxVertex][matrixMaxVertex];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对数组进行初始化，顶点间没有边关联的值为Integer类型的最大值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; edgesMatrix.length; row++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; edgesMatrix.length; column++) &#123;</span><br><span class="line">                    edgesMatrix[row][column] = MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********************最短路径****************************/</span></span><br><span class="line">    <span class="comment">//计算一个顶点到其它一个顶点的最短距离</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Dijkstra(getVertexIndex(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[matrixMaxVertex];</span><br><span class="line">        <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[matrixMaxVertex];</span><br><span class="line">        <span class="comment">//初始化visited、dist和path</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            <span class="comment">//一开始假定取直达路径最短</span></span><br><span class="line">            dist[i] = edgesMatrix[v0][i];</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//直达情况下的最后经由点就是出发点</span></span><br><span class="line">            <span class="keyword">if</span> (i != v0 &amp;&amp; dist[i] &lt; MAX_VALUE)</span><br><span class="line">                prev[i] = v0;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev[i] = -<span class="number">1</span>; <span class="comment">//无直达路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始时源点v0∈visited集，表示v0 到v0的最短路径已经找到</span></span><br><span class="line">        visited[v0] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下来假设经由一个点中转到达其余各点,会近些,验证之</span></span><br><span class="line">        <span class="comment">// 再假设经由两个点中转,会更近些,验证之,.....</span></span><br><span class="line">        <span class="comment">// 直到穷举完所有可能的中转点</span></span><br><span class="line">        <span class="keyword">int</span> minDist;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            <span class="comment">//挑一个距离最近经由点,下标装入 v</span></span><br><span class="line">            minDist = MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((!visited[j]) &amp;&amp; dist[j] &lt; minDist) &#123;</span><br><span class="line">                    v = j;                             <span class="comment">// 经由顶点j中转则距离更短</span></span><br><span class="line">                    minDist = dist[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*顶点v并入S，由v0到达v顶点的最短路径为min.</span></span><br><span class="line"><span class="comment">              假定由v0到v，再由v直达其余各点，更新当前最后一个经由点及距离*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((!visited[j]) &amp;&amp; edgesMatrix[v][j] &lt; MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minDist + edgesMatrix[v][j] &lt;= dist[j]) &#123;</span><br><span class="line">                        <span class="comment">//如果多经由一个v点到达j点的 最短路径反而要短,就更新</span></span><br><span class="line">                        dist[j] = minDist + edgesMatrix[v][j];</span><br><span class="line">                        prev[j] = v;                    <span class="comment">//经由点的序号</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; matrixMaxVertex; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"**"</span> + vertexesArray[v0] + <span class="string">"--&gt;"</span> +vertexesArray[i] + <span class="string">" 的最短路径是："</span> + dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点值在数组里对应的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getVertexIndex</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertexesArray[i].equals(obj)) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"没有这个值！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单源最短路径算法，用于计算一个节点到其他!!所有节点!!的最短路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dijkstra2</span><span class="params">(<span class="keyword">int</span> v0)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// LinkedList实现了Queue接口 FIFO</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个循环是为了确保每个顶点都被遍历到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> row = queue.remove();</span><br><span class="line">                    System.out.print(vertexesArray[row] + <span class="string">"--&gt;"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = getMin(row); k &gt;= <span class="number">0</span>; k = getMin(row)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!visited[k]) &#123;</span><br><span class="line">                            queue.add(k);</span><br><span class="line">                            visited[k] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">( <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minDist = MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!visited[j]) &amp;&amp; edgesMatrix[row][j] &lt; minDist) &#123;</span><br><span class="line">                minDist = edgesMatrix[row][j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addVertex</span><span class="params">(Object val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (val != <span class="keyword">null</span>);</span><br><span class="line">        vertexesArray[vertexSize] = val;</span><br><span class="line">        vertexSize++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vnum1, <span class="keyword">int</span> vnum2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (vnum1 &gt;= <span class="number">0</span> &amp;&amp; vnum2 &gt;= <span class="number">0</span> &amp;&amp; vnum1 != vnum2 &amp;&amp; weight &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//有向图</span></span><br><span class="line">        <span class="keyword">if</span> (graphType) &#123;</span><br><span class="line">            edgesMatrix[vnum1][vnum2] = weight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            edgesMatrix[vnum1][vnum2] = weight;</span><br><span class="line">            edgesMatrix[vnum2][vnum1] = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************** 测试 *********************************/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWeight</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    GraphByMatrix graph = <span class="keyword">new</span> GraphByMatrix(Graph.UNDIRECTED_GRAPH, Graph.ADJACENCY_MATRIX, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    graph.addVertex(<span class="string">"1"</span>);</span><br><span class="line">    graph.addVertex(<span class="string">"2"</span>);</span><br><span class="line">    graph.addVertex(<span class="string">"3"</span>);</span><br><span class="line">    graph.addVertex(<span class="string">"4"</span>);</span><br><span class="line">    graph.addVertex(<span class="string">"5"</span>);</span><br><span class="line">    graph.addVertex(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line">    graph.addEdge(<span class="number">0</span>, <span class="number">5</span>,<span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">3</span>,<span class="number">15</span>);</span><br><span class="line">    graph.addEdge(<span class="number">1</span>, <span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">    graph.addEdge(<span class="number">2</span>, <span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    graph.addEdge(<span class="number">3</span>, <span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">    graph.addEdge(<span class="number">4</span>, <span class="number">5</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    graph.Dijkstra(<span class="number">0</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    graph.Dijkstra(<span class="string">"1"</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">    graph.Dijkstra2(<span class="number">0</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h4><p>算法介绍：</p><ul><li>Floyd-Warshall 算法又称为插点法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包；</li><li>Floyd-Warshall 算法的时间复杂度为 $O(N^3)$，空间复杂度为 $O(N^2)$；</li></ul><p>算法思想原理：</p><ul><li>Floyd 算法是一个经典的动态规划算法；目标是寻找从点 <code>i</code> 到点 <code>j</code> 的最短路径；</li><li>从任意节点 <code>i</code> 到任意节点 <code>j</code> 的最短路径不外乎 2 种可能：<ul><li>① 是直接从 <code>i</code> 到 <code>j</code>；</li><li>② 是从 <code>i</code> 经过若干个节点 <code>k</code> 到 <code>j</code>；</li></ul></li><li>所以，假设 <code>Dis(i,j)</code> 为节点 <code>u</code> 到节点 <code>v</code> 的最短路径的距离，对于每一个节点 <code>k</code>，检查 <code>Dis(i,k) + Dis(k,j) &lt; Dis(i,j)</code> 是否成立：<ul><li>如果成立，证明从 <code>i</code> 到 <code>k</code> 再到 <code>j</code> 的路径比 <code>i</code> 直接到 <code>j</code> 的路径短，我们便设置 <code>Dis(i,j) = Dis(i,k) + Dis(k,j)</code>；</li></ul></li><li>这样一来，当遍历完所有节点 <code>k</code>，<code>Dis(i,j)</code> 中记录的便是 <code>i</code> 到 <code>j</code> 的最短路径的距离；</li></ul><p>算法描述：</p><ol><li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　</li><li>对于每一对顶点 <code>u</code> 和 <code>v</code>，看看是否存在一个顶点 <code>w</code> 使得从 <code>u</code> 到 <code>w</code> 再到 <code>v</code> 比己知的路径更短。如果是更新它。</li></ol><p>Floyd 算法过程中的矩阵计算——十字交叉法：</p><ul><li>方法：两条线，从左上角开始计算一直到右下角</li><li>图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Graph/Floyd.png" alt="Floyd"></li></ul><p>java 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @来源： https://blog.csdn.net/ochangwen/article/details/50730937</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shortestPath_FLOYD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = vertexSize;</span><br><span class="line">    <span class="keyword">int</span>[][] D = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//保存从i到j的最小路径值</span></span><br><span class="line">    <span class="keyword">int</span>[][] p = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//保存经过的中间节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//初始化D，p</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edgesMatrix[i][j] &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line"></span><br><span class="line">                p[i][j] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            D[i][j] = edgesMatrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;<span class="comment">//进行Floyd算法，从0到n-1所有可能进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[i][j] &gt; D[i][x] + D[x][j]) &#123;</span><br><span class="line">                    D[i][j] = D[i][x] + D[x][j];</span><br><span class="line">                    p[i][j] = p[i][x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面对获得的结果进行展示</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span> + D[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"++++++++++++++++++++++++++++++++++++"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span> + p[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"+++++++++++++++++++++++++++++++++++"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输出i="</span> + i + <span class="string">"到j="</span> + j + <span class="string">"最短路径："</span>);</span><br><span class="line">            <span class="keyword">int</span> k = p[i][j];</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"没有最短路径"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span> + k);</span><br><span class="line">                <span class="keyword">while</span> (k != j) &#123;</span><br><span class="line">                    k = p[k][j];</span><br><span class="line">                    System.out.print(<span class="string">" "</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//              System.out.println(" "+k);</span></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="https://www.cnblogs.com/xiaohuiduan/p/11352209.html" target="_blank" rel="noopener">算法之《图》Java实现</a>》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-Graph/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;图&lt;/strong&gt;（Linear List）是一种比较复杂的数据结构。在树中，节点会存在明显的分层关系，但是图中却不会受到这种限制。它是由顶点和顶点之间的关系组成的集合。通常，图中的顶点数量或者一个顶点与其他顶点之间的连线的个数不会受限制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2020 | 最长 “小” 假期</title>
    <link href="http://www.thebetterkong.cn/2020/08/24/Black%20Hole/LongestHolidayEver/"/>
    <id>http://www.thebetterkong.cn/2020/08/24/Black%20Hole/LongestHolidayEver/</id>
    <published>2020-08-23T18:01:43.000Z</published>
    <updated>2020-11-19T10:50:32.477Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/LongestHolidayEver/header.png" width="100%" alt="header.png" /> </div>   <p>2020 遇到了一句很喜欢的话，它出自诗人北岛的《过节》。    </p><p>“玻璃晴朗，橘子辉煌。”  </p><p>而我更喜欢在后面加上一句：  </p><p>“生有热烈，藏与俗藏！”</p><a id="more"></a><hr><p>这一转眼 2020 又已经过去了一大半。还记得 2020 的第一天，曾信誓旦旦的说一定要把这一年过得与众不同。而现在，好像确实做到了，只是这种 “与众不同” 太过的 “与众不同”。     </p><p>这一年，注定是个不平凡的一年，谁也不曾想到突如其来的疫情，让我这 1 月份开始为期一个月左右寒假，一过就过成了快九个月。</p><p>从最开始尽情放纵享受最后的假期，到后来开始网课，再到后来突然意识到短期内回不去学校了。这彻底打乱了我的学习计划，Blog 的搭建只能在家里完成。我开始重新制定计划，打算着能在回所之前把自己丢掉的那些基础重新捡回来。想想这段日子，每天宅在家里按计划学习，生活起居都有着老妈悉心照顾，身边还有着抗击在疫情一线的榜样老爸，闲余也能和小梦梦同学聊聊天打打游戏。日子重复枯燥，却真乐在其中！</p><p>但就像大冰说过的那样 “任何一种长期单一模式的生活都是在对自己犯罪”。也不知道从哪一天开始，我突然开始怀疑自己之前那段日子的学习是不是都在做无用功，自然而然也就开始觉得这种日子再也不香了，开始天天翘首以盼，能早日开学。于是想给自己放个小假，去见想见的人，可是 6 月底疫情的反弹让我计划再次泡汤。无奈只能转变学习方向，可是效率始终提不上去。</p><p>总算，这种状态没过多久，导师找到了我，给我派发了任务，于是乎日子总算是又变得忙碌起来。可偏偏就这个时候，我用了 5 年的笔记本突然暴毙，手头又有很多的事要做。果断下单了 <code>lenovo yoga s740</code>，但是看错了参数赶紧又换成了 <code>lenovo yoga 14s</code>，一波三折，而且没用多久又发现我机器的散热风扇似乎有问题，家里又没有联想服务站，只能回北京了再送去看吧，虽不影响使用，但心里总是有点膈应（有机会的话，再好好写写这台机器的测评吧）。拿到新电脑，就立马投入到手头工作，这种无缝衔接真是第一次。 </p><p>也是这里的一个多月的时间，事情一件一件的发生。成了我最压抑，最低谷的日子，咬牙坚持，为了心中的那道光……</p><p>时过至今，学校终于通知，还有两周左右的时间就要回学校了。看了看这段时间以来每天的计划和完成的事，效率可能不算高，也谈不上进步，但也算得上自己一个全新的开始。未来如何，就看下一步的造化了。</p><p>忙忙碌碌，人有时候就总会丢三落四。等意识到时，有些东西可能就晚了。</p><p>在这个时候，拖着满是困意的大脑，想啥写啥，没有目的，就算是对过去近九个月的 “寒假疫情” 生活做个了结吧。在返校前所剩不多的日子里，想把失去的原封不动的找回来，想好好收个结尾，准备迎接下一阶段的新生活。</p><p>未来，一定可期！</p><p>美好，一定如期而至！</p><p>冲！</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/LongestHolidayEver/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;2020 遇到了一句很喜欢的话，它出自诗人北岛的《过节》。    &lt;/p&gt;
&lt;p&gt;“玻璃晴朗，橘子辉煌。”  &lt;/p&gt;
&lt;p&gt;而我更喜欢在后面加上一句：  &lt;/p&gt;
&lt;p&gt;“生有热烈，藏与俗藏！”&lt;/p&gt;
    
    </summary>
    
    
      <category term="Black Hole" scheme="http://www.thebetterkong.cn/categories/Black-Hole/"/>
    
    
      <category term="Mood" scheme="http://www.thebetterkong.cn/tags/Mood/"/>
    
  </entry>
  
  <entry>
    <title>《High Performance FV Somewhat Homomorphic Encryption on GPUs:An Implementation using CUDA》阅读笔记</title>
    <link href="http://www.thebetterkong.cn/2020/08/20/Literature-reading-notes/High-Performance-FV-Somewhat-HE-on-GPUs/"/>
    <id>http://www.thebetterkong.cn/2020/08/20/Literature-reading-notes/High-Performance-FV-Somewhat-HE-on-GPUs/</id>
    <published>2020-08-20T06:17:24.000Z</published>
    <updated>2020-08-23T18:11:01.432Z</updated>
    
    <content type="html"><![CDATA[<p>在云计算时代，安全问题可谓是层出不穷。由此而衍生出的同态加密技术可以解决各种保护隐私的计算问题。它通过对数据进行加密处理，并允许任何人直接在加密后数据上进行处理（加减乘除等计算），生成加密结果，但是只有解密密钥的所有者才能进行解密进而得到所需的数据。但是由于 HE 需要进行大量的计算，导致其对性能的要求很高，这也是 HE 方案很大的不足。这篇论文就介绍了一种基于 CUDA 的 SHE （Somewhat Homomorphic Encryption）实现方案。</p><a id="more"></a> <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这一部分主要介绍了 FHE 方案的产生以及不足之处，由此产生了两种改进方案：</p><ol><li>针对特定需求涉及的 SHE 方案：<ul><li><strong>FHE（Fully Homomorphic Encryption，全同态加密）</strong>：直白说就是支持任意函数 f 的同态加密方案，它主要由两种思路：<ul><li>从计算机原理考虑：计算机的运算也就是位运算。而一个计算机只要支持逻辑与运算（AND），以及异或运算（XOR），那么这个计算机理论上就可以实现计算机的所有运算了（这种性质称之为图灵完备性，Turing Completeness）；</li><li>从抽象代数考虑：只需要加法和乘法就可以完成全部运算了。但其实更严格的说，只要我们在一个域（Field）上构造 HE，理论上我们就可以支持所有的 f；</li></ul></li><li><strong>SHE（Somewhat Homomorphic Encryption，半同态加密）</strong>：<ul><li>这种 HE 方案只支持一些特定的 f 函数；</li><li>SHE 方案稍弱，但也意味着开销会变得较小，容易实现，现在已经可以在实际中使用；</li></ul></li></ul></li><li>将计算卸载到硬件加速器，例如：FPGA、ASIC、GPU 等：<ul><li>本论文的主要研究方向也就是基于 GPU 加速的；</li><li>沿用之前的，将 HE 计算的某些部分（通常是多项式乘法）在硬件加速器上运行，但它们包括大量的主机到设备和设备到主机的数据传输速率；</li><li>于是，通过启用 CUDA 的 GPU 加速方案进一步加速 FV SHE，实现的主要功能是所有 FV 原语：密钥生成，加密，解密以及同态加法和乘法完全在 GPU 上运行，这样从而降低了主机到设备和设备到主机的传输速率；</li><li>另外，利用了一些代数工具、模块化算法以及 FV 的改编，避免了计算的关键路径上多精度算术问题；</li></ul></li></ol><p>论文结构：</p><ul><li>第 2 节：介绍 HE 方案的几种软件和硬件实现，重点是 FV 方案；</li><li>第 3 节：部分简要介绍了通用的 CUDA 编程范例。；</li><li>第 4 节：介绍一些代数工具，例如<mark>中国剩余定理（CRT）</mark>和<mark>离散伽罗瓦变换（DGT）</mark>；</li><li>第 5 节：回顾了<mark>教科书 FV</mark> 方案及其<mark>残数系统（RNS）</mark>变体；</li><li>第 6 节：提供所用实现和优化技术的布局；</li><li>第 7 节：作者的实验和比较结果；</li><li>第 8 节：总结工作并提供了潜在的未来工作指南；</li></ul><h1 id="文献回顾"><a href="#文献回顾" class="headerlink" title="文献回顾"></a>文献回顾</h1><p>总结起来大致内容如下：</p><ul><li>使用硬件平台提高 HE 性能，主要是基于 ASIC、FPGA、GPU。并且与 ASIC 相比，FPGA 和 GPU 更加灵活便宜，更具有优势。</li><li>最早将 FPGA 用在 HE 的是 Cousins 等人，他们使用 FPGA 和 Matlab Simulink 利用基本构造块来实现的基于 FHE 的 NTRU，但没有报告结果；</li><li>Gentry-Halevi（GH）FHE 的加密，解密和重新加密过程在定制的 ASIC 实现中分别花费了 18.1 毫秒，16.1 毫秒和 3.1 秒钟；</li><li>GH FHE 的 GPU 实现，作者设法加快了中小参数设置的方案，但是，对于安全推荐的大参数，由于 GPU 内存不足以存储所有必需的预先计算的常量，因此他们失败了；</li><li>FV SHE 方案是基于错误学习（LWE）的 FHE 对环形 RLWE 的扩展，该方案结构简单比较实用受到了广泛关注，目前已有两个团队实现。它也是作者评估 GPU 实现的一个标准；</li><li>SEAL（v2.3.0-4）利用 C++，CPU 实现了大数值的多项式算法。该方案后来提出 RNS FV 方案变体显著提高了性能。<ul><li>它的主要特征是可以对解密和同态乘法的轻微修改，具体来说就是可根据秘钥能力来接受任意大小的密文，以及允许密文在同态乘法之后增大大小，进而可以去完成重新线性化；</li><li>采用 Nussbaumer 算法计算 $\frac{Z_q[x]}{x^{2^k}+1}$ 中多项式乘法的数论变换（NTT），并使用特殊质数作为密文系数模数，以进行有效的模运算；</li><li>该库提供了一个用户友好的界面，其中包括几个功能，例如：用于表示多项式数据的编码功能（FV 的关键要求），默认参数选择器，噪声监控和 CRT 批处理程序；</li></ul></li><li>NFLlib-FV 是并行的多核 CPU 实现：<ul><li>它利用 NFLlib（一种基于 NTT 的快速晶格库）在 $\frac{Z_q[x]}{x^{2^k}+1}$ 中执行多项式算法；NFLlib 利用向量指令（SSE 和 AVX2）在多处理器体系结构上执行算术运算；</li><li>该库与著名的数论库（例如 NTL 和 FLINT）相比具有优势；</li><li>与 SEAL 不同，NFLlib-FV 具有较少的功能。例如，它不包括编码或 CRT 批处理技术。</li></ul></li></ul><h1 id="知识准备（代数知识）"><a href="#知识准备（代数知识）" class="headerlink" title="知识准备（代数知识）"></a>知识准备（代数知识）</h1><h2 id="CUDA-编程范例"><a href="#CUDA-编程范例" class="headerlink" title="CUDA 编程范例"></a>CUDA 编程范例</h2><p>GPU 或者其他硬件加速器可以看做是一种帮助 CPU 完成特定任务的辅助计算元素。在使用时，通常需要我们利用映射和简化过程来手动分配任务，这一过程比较麻烦。   </p><p>目前很受欢迎的两个框架：OpenCL 和 CUDA 他们都扩展自 C 语言，并提供了一组 API 供多平台并行编程，其中：</p><ul><li>CUDA 仅受 NVIDIA GPU 等 NVIDIA 设备支持；</li><li>而 OpenCL 可与包括 NVIDIA GPU 在内的各种平台一起使用；</li><li>与 OpenACC 不同，程序员必须进行映射并减少这些框架中的过程；</li></ul><p>下面主要介绍本文工作采用的 CUDA 原理；</p><p><strong>CUDA 结构模型：</strong></p><ul><li>CUDA GPU 包括许多<strong>流式多处理器（SM）</strong>。SM 由片上多个内核组成，也称为<strong>流处理器（SP）</strong>：<ul><li>它们共享计算资源（例如共享内存，L1 高速缓存，寄存器文件和特殊功能单元）。</li><li>通过启动多个线程（每个线程在单个内核上运行），SM 可以看作是向量处理器，能够对多个操作数执行相同的指令，也称为单指令多数据（SIMD）指令。</li><li>CUDA 提供了一组内部变量，这些变量提供元数据以唯一地标识线程；</li></ul></li><li>程序员通过将线程组织为两种结构：<strong>线程块</strong>和<strong>网格</strong>，来确定执行特定内核的线程总数（CUDA 线程执行的部分代码）：<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/CUDAStructModel.png" alt="CUDAStructModel"><ul><li>线程块是 1-3 维度的结构，用于指定每个维度中的线程数；</li><li>线程块也按 1-3 个维度的网格进行分组，指定每个维度中的块数；</li><li>线程块和网格的大小受硬件功能的限制；</li><li>GPU 将线程块分配为在单个 SM 上运行。这些线程也被分组为 warps2。 GPU 确保扭曲中的线程在一个 SM 上同时运行。可同时在 SM 上运行的扭曲的数量是特定于硬件的，具体取决于扭曲调度程序的数量。尽管每个线程都有自己的一组寄存器，但是请注意，warp 中的线程可能会通过 CUDA  shuffle 指令访问彼此的寄存器。</li></ul></li></ul><p><strong>CUDA 内存模型：</strong><br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/CUDAMemModel.png" alt="CUDAMemModel"></p><ul><li>一个块中的线程可以直接通过共享内存进行通信。相反，不同块的线程只能通过全局内存进行通信。在设备代码中，一个块中线程之间的同步点是可能的，而所有线程（不同块中）之间的全局同步点是不可能的，直到通过协作线程实现 CUDA 9。全局同步也可以通过几个内核启动来计算大型任务来完成。</li><li>CUDA GPU 包括各种类型的存储器，这些存储器的访问速度，作用域和读/写权限不同：<ul><li>例如，全局内存很大，很慢，在整个程序执行过程中都是持久性的，并且可以由任何线程访问以进行读/写。</li><li>另一方面，共享内存是片上的，快速的，但是只有声明了该内存的块中的线程才能看到。</li><li>快速且可全局访问的另一种类型的内存是常量内存。它被限制为较小的大小，通常为 64 KB，并且只能用作针对时间局部性优化的只读存储器。</li><li>最后，还有另一种类型的持久性只读存储器，它利用了空间局部性的原理，即纹理存储器。纹理适用于非镶嵌访问模式。它们比全局内存快，但比恒定内存慢。</li></ul></li></ul><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="符号（Notation）表示"><a href="#符号（Notation）表示" class="headerlink" title="符号（Notation）表示"></a>符号（Notation）表示</h3><ul><li>大写字母表示集合，小写字母表示集合里的元素；</li><li>$Z$、$Q$、$R$、$C$ 分别表示整数，有理数，实数和复数；</li><li>$\lceil \cdot \rceil$、$\lfloor \cdot \rfloor$、$\lfloor \cdot \rceil$ 分别表示向上舍入，向下舍入和舍入到最接近的整数；</li><li>$[\cdot]_q$ 表示由平衡集 $\{\lceil -\frac{q}{2} \rceil,…,\lfloor \frac{q-1}{2} \rfloor\}$ 表示的 $q$ 模整数的集合；$|\cdot|_q$ 表示 $\{0,…,q-1\}$；</li><li>$|\cdot|$ 表示数字或集合基数的 bits 大小；</li><li>$R_q$ 是多项式环 $\frac{Z_q[x]}{x^n+1}$，其中 $n$ 是 2 的幂；</li><li>环算术是对 $x^n+1$ 和 $q$ 求模的；</li><li>从集合 $S$ 中对 $a$ 进行统一采样表示为 $a \stackrel{$}{\leftarrow} S$；</li></ul><h3 id="多项式的残数系统表示"><a href="#多项式的残数系统表示" class="headerlink" title="多项式的残数系统表示"></a>多项式的残数系统表示</h3><p>问题产生及解决方式：</p><ul><li>对于安全设置和高深度乘法支持，环 $\frac{Z_q[x]}{x^n+1}$ 包含系数较大的长多项式。特别是当 $|q|$ 是几百位时，n 可以是几千了。这些多项式执行基本算术运算（加法和乘法）可以通过多精度算术完成，尽管此方法更直观，并且可能更易于实现，但效率不高，尤其是对于大型参数来说。</li><li>其他模块化技术和代数工具可用于实现更有效的解决方案。<strong>基本思想是基于分而治之</strong>。较大的计算问题分为几个较小的独立子问题，可以并行有效地解决这些子问题。 然后将子解决方案合并以形成原始问题的最终解决方案。</li></ul><p>将其应用于多项式算术：</p><ul><li>CRT/RNS 可用于将系数较大的多项式 $a(x)$ 分解为系数较小的多项式集合；</li><li>首先，我们需要选择一组互质数模 $M = \{m_0,m_1,\dots,m_{r-1}\}$；</li><li>模数取决于两个主要因素：<ul><li>选择 $m_i$ 使其适合基础机器字；</li><li>$m = \prod_{i=0}^{r-1}$，$m_i$ 大于或等于系数模数 $q$； </li></ul></li><li>映射 $a(x)(mod) \rightarrow (a(x)(mod\ m_0),a(x)(mod\ m_1),\dots,a(x)(mod\ m_{r-1}))$，定义了环同构 $\frac{Z_m[x]}{x^n+1} \cong \frac{Z_{m_0}[x]}{x^n+1} \times \frac{Z_{m_1}[x]}{x^n+1} \times \dots \times \frac{Z_{m_{r-1}}[x]}{x^n+1}$；</li><li>换句话说，可以在每个环 $\frac{Z_{m_i}[x]}{x^n+1}$ 中并行执行计算，并使用 CRT 重建算法以 $\frac{Z_m[x]}{x^n+1}$ 重建所需结果。如下所示： <ul><li>设 $(x_0,x_1,\dots,x_{r-1})$ 是整数 $x$ 模 $M$ 的残差，可以通过下面重建整数 $x$：<script type="math/tex">x = \sum_{i=0}^{r-1} \frac{m}{m_i} \times ((\frac{m}{m_i})^{-1}x_i\ (mod\ m_i))\ (mod\ m)</script></li></ul></li><li>通过对每个系数残基进行 CRT 重构，可以从其残基重构多项式。可以清楚地注意到，该运算对于每个系数都是完全独立的，这使其非常适合 GPU 平台。 </li></ul><h3 id="多项式的数论变换表示"><a href="#多项式的数论变换表示" class="headerlink" title="多项式的数论变换表示"></a>多项式的数论变换表示</h3><ul><li>通过按系数逐项增加/减少多项式残差，CRT 表示可用于有效地增加或减少多项式；</li><li>不幸的是，乘法不是这种情况。为了迎合有效的乘法，可以用点和值而不是标准系数表示来表示多项式：</li><li>这可以使用 DFT-like 变换（长度为 2n 的数论变换（NTT））来评估一组点上的多项式（degree 度 &lt; n）来完成：<ul><li>两个多项式 NTT 表示的逐点相乘对应于多项式不进行归约的乘积的 NTT 表示；</li><li>仍然需要以环多项式模为模的归约算法；</li><li>但是，由于我们在 $\frac{Z_q[x]}{x^{2^k}+1}$ 中进行工作，因此可以使用负包绕卷积而无需归约。这可以通过离散加权变换（DWT）有效地进行计算。此外，对于负包裹卷积，仅需要长度为 n 的 DWT 变换。</li></ul></li><li>为了进一步改善，可以使用 Crandall 的离散伽罗瓦变换（ Discrete Galois Transform，DGT）使用 n/2 变换数据路径来计算 NTT 等效表示，在 $GF(p^2)$ 中称为 DGT 表示；<ul><li>Crandall 最初提出了他的算法，假设 p 必须是高斯素数，即 $p \equiv 3(mod 4)$；</li><li>但是，在另一项工作中，我们推广了他的算法，使其也可以用于非高斯素数，即 $p \equiv 1(mod 4)$；</li><li>在这里使用基于广义 DGT 的算法来计算具有类似 n/2 FFT 数据路径的 DGT 表示。使用我们的通用算法，CRT 模数不再受到其他限制。下面的算法显示了基于 DGT 的多项式乘法算法：<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/DGTAlgorithm.png" alt="DGTAlgorithm"></li><li>该算法显示：给定 DGT 表示的两个多项式，它们的乘积可通过逐系数乘法以 $O(n)$ 计算。应指出的是，在可以开始乘法之前，应将每个多项式残差（在 RNS/CRT 域中）转换为 DGT。</li><li>请注意，DWT/DGT 需要在上述算法中用一些扭曲因子 h 加权多项式。这些扭曲器应与变换中使用的扭曲因子 g 区分开。</li></ul></li></ul><h3 id="使用环-frac-Z-x-x-2-k-1-的局限性"><a href="#使用环-frac-Z-x-x-2-k-1-的局限性" class="headerlink" title="使用环 $\frac{Z[x]}{x^{2^k}+1}$ 的局限性"></a>使用环 $\frac{Z[x]}{x^{2^k}+1}$ 的局限性</h3><p>尽管此处使用的多项式环提供了快速的环乘法，但它遇到了与明文批处理有关的关键问题。明文批处理（也称为 <strong>CRT 批处理</strong>）是 Brakerski 等人提出的一种常见技术，以降低 HE 的计算复杂度。这项技术可以将多个明文打包在一个密文中。密文上的操作以 SIMD 方式影响打包的明文。为了突出使用环 $\frac{Z[x]}{x^{2^k}+1}$ 的局限性，我们需要提供一个简单的明文批处理概述。</p><ul><li>正如后续章节会看到那样，明文空间是多项式环 $R_t = \frac{Z_t[x]}{x^{2^k}+1}$。对于某些 $(k，t)$，$x^{2^k} + 1$ 可以以 t 为模分解为一组互互质数多项式，例如 $f_i(x)，0 \leq i &lt; s$。使用 CRT，可以通过以下映射对 $R_t$ 进行分区：<script type="math/tex">R_t = \frac{Z_t[x]}{x^{2^k}+1} \cong \frac{Z_t[x]}{f_0(x)} \times \dots \times \frac{Z_t[x]}{f_{s-1}(x)}</script>   </li><li>这意味着我们可以编码 s 明文消息，使用 $f_i(x)$ 作为模数应用 CRT，假设 $f_i(x)$ 是互质数，并生成一个编码 s 消息的单多项式。 $R_t$ 中的问题在于仅考虑 $t=2$ 才将其分解为一个因子。这是重要的情况，因为它允许使用同态加法和乘法来处理布尔门 XOR 和 AND，这使得构造布尔电路非常简单。</li><li>然而，可以通过选择较大的 t 值来解决该问题，但代价是 XOR 的成本与 AND 的噪声增长相同。可以通过以下示例说明其原因：   <ul><li>示例：假设 $c_0$，$c_1$ 是两个 1 的加密数。假设我们要评估 $c_0$，$c_1$ 上的 XOR 门。注意，较大的 t 值意味着多项式系数可以增长到 $t-1$。对输入进行同态加法运算得出的加密值为 2。可以通过减去（$2 \times c_0 \times c_1$）进行校正。因此，考虑到可以高效地乘以 2，几乎免费的同态加法变得与同态乘法一样昂贵。</li></ul></li></ul><h1 id="Textbook-FV-及其-RNS-变体"><a href="#Textbook-FV-及其-RNS-变体" class="headerlink" title="Textbook FV 及其 RNS 变体"></a>Textbook FV 及其 RNS 变体</h1><h2 id="明文和密文空间"><a href="#明文和密文空间" class="headerlink" title="明文和密文空间"></a>明文和密文空间</h2><ul><li>明文和密文空间是由明文模数 t 和密文模数 q （$both \in Z$）决定的多项式环，其中 $2 \leq t \ll q$。</li><li>我们将这些环称为 $R_t:\ \frac{Z_t[x]}{x^n+1}$ 和 $R_q:\ \frac{Z_q[x]}{x^n+1}$。</li><li>尽管明文是单个元素 $m \in R_t$，但是密文是一对两个元素 $(ct[0],ct[1])$，其中 $ct[i] \in R_q$。</li><li>比率 $\Delta = \lfloor \frac{q}{t} \rfloor$ 决定方案的乘法深度。</li><li>$n$，$q$ 的选择通过定义潜在的 RLWE 问题的难度来影响安全级别。</li></ul><h2 id="Textbook-FV-方案"><a href="#Textbook-FV-方案" class="headerlink" title="Textbook FV 方案"></a>Textbook FV 方案</h2><p>Textbook FV 方案是一个由 5 个过程组成的元组：密钥生成，加密，解密，同态加法和同态乘法。除了明文和密文空间参数外，该方案还定义了以下描述的其他参数：</p><ul><li>$\lambda$：一元表示法表示的安全性参数；</li><li>$\omega$：一个分解基，用于根据基 $w \in Z$ 中的 $l+1$ 个多项式来表示 $R_q$ 中的多项式，其中 $l = \lfloor log^q_w \rfloor$；</li><li>$\chi_{err+}$：截短的零均值离散高斯分布，用于对误差多项式进行采样。通过标准偏差 $\sigma$ 和误差范围 $\beta_{err}$ 对分布进行参数化；</li></ul><p>该方案的主要过程：<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/TextbookFV.png" alt="TextbookFV"></p><ul><li>可以看出，所有过程都在多项式环中合并了算术。多项式很长，并且系数很大。因此，可以使用多精度算法或模块化算法来处理它们。模块化算法可提供更好的性能，特别是如果它们并行执行。一种基于 CRT/RNS 的已知模块化算法有助于将长多项式和大多项式分解为一组具有小系数的独立多项式。系数的大小可以通过改变 CRT 模数的大小来控制。通常，选择 CRT 的模数大小以使模量可以适合一个机器字，以实现高效实现。</li><li>模块化方法在处理多项式算术上吸引人的特性源于以下事实：所生成的多项式是独立的，并且可以并行操作，从而使该问题适合于并行平台。CRT/RNS 方法的唯一问题是某些操作变得更加困难，例如除法和舍入以及基数分解。对 Textbook FV 的仔细检查表明，解密和同态乘法需要这些操作。<ul><li>这里应该指出：关于除法和舍入，问题不在于可以通过模逆转换为乘法的除法，而是舍入需要比较，而这与 RNS 几乎不兼容。</li><li>正如之前第 4 节提到的，多项式以两种表示形式表示：① CRT/RNS；② NTT 表示形式。乘法后，多项式在 NTT 域中表示。还不知道是否有可能在 NTT 表示中进行四舍五入，从而迫使转换成 CRT 表示。即使在 CRT 表示中，舍入也不便宜，并且需要复杂的实现。因此，需要对多项式的典范系数表示进行另一种转换，以执行多精度比较。相同的论点适用于基本分解。</li></ul></li><li>幸运的是，Bajard 等人提出了一种巧妙的方法，即利用下限功能在 RNS 域中执行近似舍入。由于 FV 是基于噪声/错误的加密方案，因此只要控制错误，引入额外的错误就不会违反其功能。他们改编了 textbook Dec 和 EvalMul 以在 CRT/RNS 域中执行近似取整。此外，他们通过分解 CRT 模中的多项式来避免碱基分解。Bajard 等人的改进的 Dec 和 EvalMul 程序。效率更高，并且对方案支持的最大乘法深度影响不大。之后将回顾它们的过程，并介绍如何将它们映射到 GPU。</li></ul><p>实用说明：重新线性化过程（EvalMul 中的第 2 步和第 3 步）对于减少同态评估期间的密文长度和错误增长至关重要。此外，可以通过 Karatsuba 乘法算法将步骤 1 中的乘积 $c_1$ 计算出来，以将乘法次数从 4 减少到 3。</p><h2 id="FV-的-RNS-变体"><a href="#FV-的-RNS-变体" class="headerlink" title="FV 的 RNS 变体"></a>FV 的 RNS 变体</h2><p>Bajard 等人提出的 RNS FV 的核心组件是在下面方程式中提供的称为快速基数转换（FastBconv）的 RNS 基数之间进行转换的有效方法：<script type="math/tex">FastBconv(x,q,B)=(\sum_{i=1}^r\ {|x_i\frac{q_i}{q}|}_{q_i} \times \frac{q}{q_i}\ (mod\ b))_{b \in B}</script> </p><ul><li>FastBconv 将基数 q 中具有 r 模数的整数 x 转换为基数 B 中的 RNS 表示；</li><li>它还可以用于多项式，其中将运算应用于每个系数；</li><li>FastBconv 与 CRT 重建相似，除了不需要模块化的降低模数。这意味着转换是近似的，并引入了可以通过某些校正技术（例如 Shenoy-Kumaresan 算法）通过冗余模量消除的误差。  </li></ul><p>RNS FV 的另一个重要方面是逐轮替换：</p><ul><li>四舍五入需要与 RNS 比较几乎不兼容的比较，相反，如果除数是 RNS 模数子集的乘积，则可以有效地进行平整；</li><li>对于解密，他们使用下层函数的基本定义（$\lfloor \frac{a}{q} \rfloor = \frac{a-(a\ mod\ q)}{q}$）来计算 $[\lfloor \frac{t}{q} [ct[0]+ct[1]sk]_q \rfloor]_t$ 的近似值；</li><li>冗余模量 $\gamma$ 被选为与 q 互质，并且大于或等于 r 在 q 中的 CRT 模数；</li><li>为了纠正由于快速基数转换以及向下取整而不是四舍五入而导致的错误，他们应用了 Shenoy-Kumaresan 算法。算法 2 中显示了新的解密过程：<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/DecRNSAlgorithm.png" alt="DecRNSAlgorithm"></li></ul><p>同态乘法更多的是通过下面四个步骤进行：</p><ol><li>将更大 RNS 模的多项式扩展为包含 $\frac{Z[x]}{x^n+1}$ 的多项式乘积，即不对系数进行模减少。</li><li>在 NTT 域中乘以扩展多项式；</li><li>通过向下取整进行近似四舍五入；</li><li>通过分解 q 的 RNS 模中的 $c_2$ 而不是 $\omega$ 来进行线性化；</li></ol><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/FlowDivideAndRoundinRNSFV.png" alt="FlowDivideAndRoundinRNSFV"></p><ul><li>上图显示了如何执行步骤 1-3 以计算 $c_0 = [\lfloor \frac{t}{q}ct_0[0]ct_1[0] \rfloor]_q$:<ul><li>最初，我们在多项式的基数 q 中有 RNS 表示：$ct_0[0]$ 和 $ct_1[0]$。每个多项式以辅助模 $B_{sk} = B \cup m_{sk}$ 为模扩展。选择 B 中的模与 q 互质，使得 $\prod_{i=1}^l m_i \geq 4(q-1)^2n \cdot t,\forall m_i \in \{q \cup B\}$。这将包含乘积 $c_0$，$c_1$ 和 $c_2$，就好像它们是按 $\frac{Z[x]}{x^n+1}$ 计算的一样，即没有减少模 q。冗余模数 $m_{sk}$ 必须是 $\{q \cup B\}$ 的素数，并且必须大于 $2(|B|+\lceil \tau \rceil)$，其中 $\tau$ 是多项式积在任何计算点都可能包含的 B 的最大倍数。<ul><li>应当指出的是，当我们进行从基数 q 到 $B_{sk}$ 的快速转换时，可能会产生 q 的溢出，因此会产生额外的模数 $\tilde{m} &gt;|q|$。用于使用 Shenoy-Kumaresan 算法消除这些溢出。</li></ul></li><li>接下来，将 NTT 域中的扩展多项式相乘。乘积被转换回 RNS 基数 $\{q∪B_{sk}\}$。</li><li>在步骤 3 中，通过除以 q 进行向下取整。尽管除法与 RNS 几乎不兼容，但除以模子集的乘积（也称为缩放）要简单得多。 Bajard 等使用了 Barsi 和 Pinotti 缩放算法。在计算下限函数时，将多项式乘以 t，如图中步骤 3 所示。至此，我们有了底数为 $B_{sk}$ 的底多项式。</li><li>最后，我们使用 Shenoy-Kumaresan 算法和冗余模数 $m_{sk}$ 将乘积转换回基数 q。所得乘积包含一个额外的误差 e，其中 $||e||_{\infty} \leq |q|$。</li></ul></li></ul><p>为了绕过 EvalMul 中的基本分解，他们采用了如下的线性化步骤：</p><ol><li>$\xi_q(c_2) = \sum_{i=1}^k |c_2 \frac{q_i}{q}|_{q_i}$；</li><li>$P_{RNS,q}(sk^2)=(|sk^2 \frac{q}{q_1}|_q,\dots,|sk^2 \frac{q}{q_k}|_q)$；</li><li>用 $evk_{RNS}[i] = (| P_{RNS,q}(sk^2)[i]-(e_i+a_i \cdot sk)]_q,a_i)$ 来取代 evk；</li></ol><p>为了完整起见，算法3中列出了 RNS EvalMul 过程：<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/EvalMulRNSAlgorithm.png" alt="EvalMulRNSAlgorithm"></p><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/PerformanceTextbookFVRNSVariant.png" alt="PerformanceTextbookFVRNSVariant"></p><h1 id="实施方案"><a href="#实施方案" class="headerlink" title="实施方案"></a>实施方案</h1><p>我们的 GPU 实现受到 cuHE（基于 CUDA 的多项式算法库）的启发。cuHE 专为在 CUDA GPU 上的任意环中执行多项式算法而设计。该库将 NTL 用于 CPU 接口，并使用 CRT，NTT 和多项式 Barrett 约简。cuHE 本身仅支持三个多项式度：{8192、16384、32768}，即，不同度的多项式将零填充为更高的支持度。由于库处理任意多项式环，因此在计算 NTT 之前，将多项式长度加倍并补零。乘法之后，使用 Barrett 约简来减少环中的乘积。下面我们描述我们的实现，指出与 cuHE 的异同。</p><h2 id="多项式表示"><a href="#多项式表示" class="headerlink" title="多项式表示"></a>多项式表示</h2><ul><li>在 CPU 上使用 NTL 初始化多项式。我们主要使用 NTL 初始化加密密钥。最终，所有密钥都会转换为 CRT 和 NTT 域，并存储在 GPU 全局内存中。</li><li>在 GPU 上，我们将以双 CRT 表示的多项式存储在数组结构（SOA）布局中。 这允许合并访问模式，从而允许每个线程一次处理一个多项式系数/残差。</li></ul><h2 id="中国剩余定理及其重构"><a href="#中国剩余定理及其重构" class="headerlink" title="中国剩余定理及其重构"></a>中国剩余定理及其重构</h2><p>CRT 操作采用具有较大多字系数的多项式，并生成一组系数较小的多项式残差，可以适合一个机器字。CRT 重建是 CRT 的逆过程，它应用中国余数定理并从其残差重建多项式。</p><ul><li>CUDA cards 中的字长为 32 位。在这种情况下，理想的解决方案是选择 32 位 CRT 模数以最大程度地减少残数并避免使用多精度算法。<ul><li>请注意，如果硬件/软件支持有效的 4 字算术，则可以使用 2 字模数。</li></ul></li><li>影响 CRT 模数选择的另一个因素是模数运算的效率。<ul><li>精心选择的模数比任意模数提供更有效的模数运算。</li><li>我们使用 32 位素数形成 CRT 模，并使用本机 CUDA 模运算执行模运算。实际上，在 30 位素数上使用 32 位素数可能会导致表示 q 的模数减少，从而导致 NTT 过程数量减少。</li></ul></li></ul><h3 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h3><p>我们启动 n 个线程来减少以 CRT 模为模的度数小于 n 的多项式。每个线程以单精度 CRT 模为模减少多精度整数。</p><ul><li>令 x 为 d 字整数；</li><li>在基数 $2^{32}$ 中分解 x 会得到 $x_{d-1}(2^{32})^{d-1} + x_{d-2}(2^{32})^{d-2} + \dots + x_0(2^{32})^0$，其中 $x_i$ 是一个 32 位数字；</li><li>可以将 x 模的降幅 $m_j$ 分别应用于每个项.由于 CUDA 支持 doubleprecision 运算，因此我们独立减少 x 的每个项，并对余数取模 $m_j$ 求和;</li><li>为了获得更有效的实现，可以选择预先计算常数 $(2^{32})^i\ (mod\ m_j)$ 并将其存储在 GPU 常数存储器中；</li></ul><h3 id="CRT-重构"><a href="#CRT-重构" class="headerlink" title="CRT 重构"></a>CRT 重构</h3><p>CRT 重建可以通过两种方法执行：① 使用前面介绍过得两个等式展示的中文余数定理；② 使用混合基数系统。两种方法都可以在 GPU 上实现，但是我们认为第二种方法更适合 GPU 平台。为了证明这一点，首先需要介绍采用混合基数系统的 Garner 算法。指出，cuHE 实现了经典的 CRT 重建。</p><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/GarnerAlgorithm.png" alt="GarnerAlgorithm"></p><ul><li>算法显示了两个主要步骤：① 常数 $C_i$ 的预计算和 ② 重构；</li><li>由于我们处理的是固定模 M，因此在程序初始化时会进行预计算，并且常量 $C_i$ 会存储在 GPU 常量内存中。$C_i$ 的存储要求是 $O(r)$，其中 r 是 CRT 模数;</li><li>然而，重建步骤涉及更多，并且必须应用于每个系数。此步骤所需的操作如下：① 2 个以单精度整数 $m_i$ 为模的多精度减法/加法；② 1 个多精度整数（$\prod_{j=0}^{i-1}$）与单精度整数 u 的乘积。我们通过 CUDA PTX 语言执行这些操作以获得对进位的访问；</li><li>此处使用的另一种优化方法是将常数 $K_i = \prod_{j=0}^{i-1}$ 存储在 GPU 常数存储器中。乘积 $K_i$ 需要 i 的存储词。假设 CRT 素数的最大数量为 z，我们分配大小为 $\frac{(z-1) \cdot z}{2}$ 的常量内存。<ul><li>下图说明了 $K_i$ 的存储和索引。注意：我们使用 z 而不是 r，因为在编译时应该知道恒定的内存大小。<br><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/GarnerCRTReconstructMemLayout.png" alt="GarnerCRTReconstructMemLayout"></li></ul></li></ul><p>Garner 算法在 GPU 上的效率：</p><ul><li>与使用等式 1 进行的经典 CRT 重建相比，Garner 的 CRT 重建更适合 GPU：</li><li>首先，经典 CRT 重建需要对另一个多精度整数 m 取模的多精度整数（总和）减少。该操作不仅成本高昂，而且需要复杂的实现。通过利用在每次迭代中总和小于 2m 的事实可以避免这种代价昂贵的减少，即可以通过检查总和是否大于或等于 m 并在条件为真的情况下减去m来代替减少。尽管这种方法的成本较低，但由于条件检查可能会在线程执行中产生差异，进而导致线程扭曲中的顺序执行，因此它不适用于 GPU 平台。</li><li>此外，经典 CRT 重构中使用的常量的存储要求比 Garner 算法中的要高。在经典的 CRT 重构中，必须存储 r 个多精度数 $m/m_i$ 的值和 r 单精度数的 r，而在 Garner 算法中，存储要求是 $\frac{r(r-1)}{2}$ 和 r 单精度的 r 数字。</li></ul><h2 id="离散伽罗瓦变换（DGT）及其逆"><a href="#离散伽罗瓦变换（DGT）及其逆" class="headerlink" title="离散伽罗瓦变换（DGT）及其逆"></a>离散伽罗瓦变换（DGT）及其逆</h2><p>DGT 及其逆用于计算多项式的 NTT 表示。正如之前提到的，此转换允许使用类似 n/2 FFT 的数据路径来计算 NTT（或更准确地说是 DGT）表示。因此，我们只需要存储 n/2 个旋转根。另一方面，扭曲因子是高斯整数，每个实数和虚数部分都需要两个整数。 由于不同的存储器访问模式，我们在纹理存储器中存储旋转，而在全局存储器中存储旋转因子。</p><p>算法调整与分析：</p><ul><li>DGT 和 IDGT 通过多基数 Stockham 算法进行计算。我们调整了算法以在 $GF(m^2_i)$ 中工作。</li><li>应该指出，cuHE 使用单个特殊的 64 位 Solinas 素数 $\hat{p} = 2^{64} - 2^{32}+1$ 计算 NTT 表示形式，它提供了有效的 128 位整数约简。实际上，此质数最初由 Emmart 和 Weems 在其大型整数 GPU 乘法器中使用。</li><li>在一个素数中计算 NTT 具有以下优点：① 一个人可以针对一个模数优化模运算，并且② 仅需要预先计算的旋转和单个素数的扭曲因子。</li><li>但是，这种方法具有明显的缺点： CRT 模数 $m_i$ 必须 $\leq \lfloor | \sqrt{\hat{p}/(2n)} | \rfloor$，以便以 $\hat{p}$ 模数支持最大卷积值。此界限仅覆盖两个多项式的单个乘法，如果要在 NTT 域中相乘两个以上的多项式，则界限将更小。较小的 CRT 模数会增加 NTT 转换的次数，从而降低性能。</li></ul><p>具体实现：</p><ul><li>对于较小的多项式度（$\leq 4k$），我们启动了一个用于计算 DGT/IDGT 的内核。整个计算由一个块完成，这使我们能够同步所有线程并以多次通过处理多项式。</li><li>对于更大的程度，可能需要 2-3 个内核，因为一起启动了几个块。</li><li>线程之间的全局同步是通过在同一流上启动连续的内核来实现的。</li><li>应该指出，我们同时对所有多项式残差执行 DGT/IDGT 计算。我们将所有多项式残差打包在一起，只启动一次转换内核。这减少了昂贵的内核启动总数。只需通过启动 2D 螺纹块网格即可完成打包。网格尺寸为 x 和 y，其中 x 是计算单个残基的 DGT/IDGT 所需的线程块数，而 y=r 是 CRT 模数中的质数。</li></ul><p>对比 cuHE：</p><ul><li>在 cuHE 中，NTT/INTT 计算是使用 3 个针对每个多项式度进行硬编码的内核进行的，而无需进行批处理。我们注意到内核启动时间比内核计算花费更多。通过减少内核启动次数，可以实现明显的改进。此外，可以在 cuHE 中一次完成一次 NTT/INTT 转换。 这是由于使用单个共享缓冲区作为 NTT 计算的临时存储。我们为每个 DGT/IDGT 启动提供一个单独的缓冲区，允许并发 DGT/IDGT 调用。</li></ul><h2 id="快速基转换"><a href="#快速基转换" class="headerlink" title="快速基转换"></a>快速基转换</h2><p>对快速基本转换的仔细检查显示出它与 CRT 重建之间的相似性。 但是，由于求和是对 $b \in B$ 取模，即单个单词模数，因此常数 $\frac{q}{q_i}(mod\ b)$ 可以预先计算并存储在常数存储器中。它们的存储要求是 $O(z \cdot v)$ 字，其中 z 和 v 是为基数 q 和 B 选择的最大模数。类似地，常数 $\frac{q_i}{q}(mod\ q_i)$ 被预先计算并存储在需要 $O(z)$ 个字的常数存储器中。</p><p>在更受约束的设备上，可以选择通过不计算与 CRT 重建相似的常数的方法来计算转换，方法是从其残差中重建数量，然后进行多精度模 b 重建。唯一的区别是不需要动态范围的多精度减法。然而，这种方法需要昂贵的多精度乘法。</p><h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>密钥生成和加密所需的随机多项式是通过 CUDA cuRAND 在 GPU 上生成的。确定了三个分布：$\chi_2$、$\chi_q$ 和 $\chi_{err}$。前两个是均匀分布，而第三个是离散的截断的高斯分布。</p><ul><li>要从 $\chi_2$ 采样随机多项式，我们启动 n 个线程。每个线程从模 2 的 cuRAND 统一随机数生成器中采样一个数字：</li><li>对于 $\chi_q$，每个线程生成 r 个随机数并以 CRT 表示形式构造一个随机系数。最后；</li><li>对于 $\chi_{err}$，我们启动 n/2 个线程，每个线程使用其自己的统一随机数使用 Box-Muller 方法生成一对独立的标准正态分布随机数。</li></ul><h2 id="多个-CUDA-流"><a href="#多个-CUDA-流" class="headerlink" title="多个 CUDA 流"></a>多个 CUDA 流</h2><p>为了充分利用 GPU 并提高吞吐量，我们在多个流上启动了独立的内核。这允许独立操作的并发和交错执行。一个清楚的例子是同态乘法过程。计算 $c_0$，$c_1$ 和 $c_2$ 是独立的，可以同时完成。我们还通过使用固定的内存分配将内存传输的延迟隐藏在内核执行之后。</p><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>处理多项式的几种表示形式需要在计算过程中分配和取消分配大量内存。另外，对同态乘法的求值需要大量的临时存储以用于基本转换。为了降低成本，我们在系统初始化时采用了内存池机制在 GPU 上预分配内存。</p><h1 id="实验和结果"><a href="#实验和结果" class="headerlink" title="实验和结果"></a>实验和结果</h1><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/TestEnvironmentAndParameter.png" alt="TestEnvironmentAndParameter">  </p><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/ResultPowerUtilization.png" alt="ResultPowerUtilization"></p><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/ResultLatency.png" alt="ResultLatency"></p><p><img src="http://img.thebetterkong.cn/blog/High-Performance-FV-Somewhat-HE-on-GPUs/ResuiltLatency2.png" alt="ResuiltLatency2"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>在这项工作中，介绍了 FV SHE 方案的 GPU 实现的详细信息。我们为多项式环 $\frac{Z_q[x]}{x^{2^k}+1}$ 开发了一个高性能的模块化算法库。在该库中，我们使用了几种代数工具，例如 CRT，RNS 和 DGT/IDGT，以对具有大系数的长多项式进行算术运算。</li><li>我们证明，由于需要 positional numbering system，textbook FV 方案中的除法和基数分解需要多精度算法。在 GPU 上处理起来更加困难。为了克服这个问题，我们采用了 Bajard 等人的快速碱基转换技术。在 GPU上 的 CRT/RNS 域中进行计算，而无需将计算工作转移到 CPU。</li><li>这里使用的 RNS 技术需要将 NTT 格式转换为 RNS 域。如果直接在 NTT 域中进行除法和基数分解，将导致更有效的解决方案。此外，其他 CUDA 编程模型可能适用于进一步改进我们的实现，例如通过线程的扭曲或半扭曲而不是单个线程来处理多项式系数。</li><li>将我们的实现与 textbook FV 的成熟的最新实现进行了比较，并提供了所实现的加速。</li><li>作为这项工作的直接扩展，我们认为我们的实现可以移植到其他硬件加速器上，例如 FPGA 和 ASIC。这些平台比 GPU 提供更高的计算能力。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在云计算时代，安全问题可谓是层出不穷。由此而衍生出的同态加密技术可以解决各种保护隐私的计算问题。它通过对数据进行加密处理，并允许任何人直接在加密后数据上进行处理（加减乘除等计算），生成加密结果，但是只有解密密钥的所有者才能进行解密进而得到所需的数据。但是由于 HE 需要进行大量的计算，导致其对性能的要求很高，这也是 HE 方案很大的不足。这篇论文就介绍了一种基于 CUDA 的 SHE （Somewhat Homomorphic Encryption）实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献阅读笔记" scheme="http://www.thebetterkong.cn/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CUDA" scheme="http://www.thebetterkong.cn/tags/CUDA/"/>
    
      <category term="Homomorphic Encryption" scheme="http://www.thebetterkong.cn/tags/Homomorphic-Encryption/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之树</title>
    <link href="http://www.thebetterkong.cn/2020/07/09/DataStructure-Algorithm/DataStructure-Tree/"/>
    <id>http://www.thebetterkong.cn/2020/07/09/DataStructure-Algorithm/DataStructure-Tree/</id>
    <published>2020-07-09T14:05:23.000Z</published>
    <updated>2020-08-14T09:28:31.984Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/header.png" width="100%" alt="header.png" /> </div>  <p><strong>树</strong>（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n （$n \geq 0$）个有限节点组成一个具有层次关系的集合。在任意一棵非空树中，它都满足如下特点：</p><div class="note warning"><ul><li>有且仅有一个特定的称为根（Root）的结点；</li><li>当 $n &gt;1$ 时，其余结点可分为 m（$m &gt;0$）个互不相交的有限集 $T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；</li></ul></div><a id="more"></a> <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="Why-tree？"><a href="#Why-tree？" class="headerlink" title="Why tree？"></a>Why tree？</h2><p>我们知道两种十分常用的线性表：有序数组、链表。在实际使用中，它们都有着自己的优势与不足：</p><ul><li>在有序数组中插入数据项太慢：<ul><li>数组的特点是查找迅速，根据 <code>index</code> 可以快速定位到一个元素。但是，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。平均来讲，一个长度为 $N$ 的有序数组，插入元素要移动的元素个数为 $N/2$。有序数组的插入和删除的时间复杂度为 $O(N)$，效率很低；</li></ul></li><li>在链表中查找太慢：<ul><li>链表的插入和删除效率就很高，只要改变一些值的引用就行了，时间复杂度为 $O(1)$。但是链表的查询效率却很低，每次都要从头开始找，依次访问链表的每个数据项。平均来说，要从一个有 $N$ 个元素的链表查询一个元素，要遍历 $N/2$ 个元素，时间复杂度为 $O(N)$；</li></ul></li></ul><p>而树的存在，就很好的权衡了这两种结构，它结合了数组和链表的优点，在实际中有十分广泛的应用领域。可以说生活中几乎无处不存在树，例如：家族族谱、企业用人结构、体育竞赛组织结构、HTML 的文档对象模型（DOM），特别是操作系统的文件目录组织结构你一定不可能不知道吧！</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeTerms.png" alt="TreeTerms">  </p><div class="table-container"><table><thead><tr><th>名称</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>根结点</td><td>树最顶层结点</td><td>结点 A</td></tr><tr><td>边</td><td>两个结点之间的连接</td><td>略</td></tr><tr><td>父节点</td><td>若一个节点含有子节点，则这个节点称为其子节点的父节点；</td><td>H 的父结点为 F；</td></tr><tr><td>子节点</td><td>一个节点含有的子树的根节点称为该节点的子节点；</td><td>C 的子节点为 F、G；</td></tr><tr><td>兄弟节点</td><td>具有相同父节点的节点互称为兄弟节点；</td><td>I 的兄弟结点为 H、J；</td></tr><tr><td>堂兄弟节点</td><td>父节点在同一层的节点互为堂兄弟；</td><td>结点 E 和 F 为堂兄弟结点；</td></tr><tr><td>节点的祖先</td><td>从根到该节点所经分支上的所有节点；</td><td>F 的祖先为 C、A；</td></tr><tr><td>子孙</td><td>以某节点为根的子树中任一节点都称为该节点的子孙；</td><td>F 的子孙为 H、I、J；</td></tr><tr><td>节点的度</td><td>一个节点含有的子树的个数称为该节点的度；</td><td>结点 C 的度为 2；</td></tr><tr><td>树的度</td><td>一棵树中，最大的节点度称为树的度；</td><td>上述树的度为 3；</td></tr><tr><td>叶节点（终端节点）</td><td>度为零的节点；</td><td>D、E、G、H、I、J；</td></tr><tr><td>分支节点（非终端节点）</td><td>度不为零的节点；</td><td>A、B、C、F；</td></tr><tr><td>节点的层次</td><td>从根开始定义起，根为第 0 层，根的子节点为第 1 层，以此类推；</td><td>见图中标注；</td></tr><tr><td>路径</td><td>从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径；</td><td>结点 A 到结点 I 的路径为：A、C、F、I；</td></tr><tr><td>深度</td><td>对于任意节点 n，n 的深度为从根到 n 的唯一路径长（经过的结点个数），根的深度为 1；</td><td>结点 F 的深度为 3；</td></tr><tr><td>高度</td><td>对于任意节点 n，n 的高度为从 n 到一片树叶的最长路径长（路径上结点个数的最大值），所有树叶的高度为 1；</td><td>结点 F 的深度为 2；</td></tr><tr><td>森林</td><td>由 m（$m \geq 0$）棵互不相交的树的集合称为森林；</td><td>见后面的讲解；</td></tr></tbody></table></div><ul><li>注意：有关高度、深度这两个概念，在不同的地方初始值的设定可能有所不同。有些地方习惯将根结点的深度定为 0，将叶结点的高度定为 0，我们没必要特别纠结于到底谁对谁错。关键还是得弄清高度和深度的含义。</li></ul><h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeCategory.png" alt="TreeCategory"></p><div class="table-container"><table><thead><tr><th>名称</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>无序树（自由树）</td><td>树中任意节点的子节点之间没有顺序关系；</td><td></td></tr><tr><td>有序树</td><td>树中任意节点的子节点之间有顺序关系；</td><td></td></tr><tr><td>二叉树</td><td>每个节点最多含有两个子树的树；</td><td></td></tr><tr><td>完全二叉树</td><td>对于一颗二叉树，假设其深度为 d（d&gt;1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</td><td>见本文二叉树部分；</td></tr><tr><td>满二叉树</td><td>所有叶节点都在最底层的完全二叉树；</td><td>见本文二叉树部分；</td></tr><tr><td>平衡二叉树（AVL 树）</td><td>当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；</td><td>参见：<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>；</td></tr><tr><td>排序二叉树（Binary Search Tree）</td><td>也称二叉搜索树、有序二叉树、二叉查找树；</td><td>也可参见上述文章；</td></tr><tr><td>B 树</td><td>一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树；</td><td>也可参见上述文章；</td></tr><tr><td>霍夫曼树（最优二叉树）</td><td>带权路径最短的二叉树；</td><td>本文后面会详细介绍；</td></tr></tbody></table></div><h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><p>树的结构定义是一个基于递归的定义（即在树的定义中又用到树的概念），这道出了树的固有特性；   </p><p>除去前面展示过的树形图外，树还有其他三种常用表示形式：</p><ul><li>以<strong>嵌套集合</strong>（即一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）的形式表示；</li><li><strong>广义表</strong>的形式，根作为由子树森林组成的表的名字写在表的左边；</li><li><strong>凹入法</strong>（类似书的目录）；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeExpression.png" alt="TreeExpression"></p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历有两种方法：</p><ul><li>先根（次序）遍历树：先访问树的根结点，然后依次先根遍历根的每棵子树；<ul><li>上图的遍历结果为：<code>A B E K L F C G D H M I J</code></li></ul></li><li>后根（次序）遍历树：先依次后根遍历每棵子树，然后访问根结点；<ul><li>上图遍历结果为：<code>K L E F B G C M H I J D A</code></li></ul></li></ul><h2 id="树的抽象（ADT）及实现"><a href="#树的抽象（ADT）及实现" class="headerlink" title="树的抽象（ADT）及实现"></a>树的抽象（ADT）及实现</h2><p>树作为一个抽象的数据类型，它主要有基于数组、基于链表这两种实现方式；</p><h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p>使用数组实现，节点在数组中的位置对应于它在树中的位置:</p><ul><li>下标为 0 的节点是根，下标为 1 的节点是根的左子节点，依次类推，按从左到右的顺序存储树的每一层；</li><li>树中的每个位置，无论是否存在节点，都对应数组中的一个位置。把节点插入树的一个位置， 意味着要在数组的相应位置插入一个数据项。树中没有节点的位置在数组中的对应位置用 0 或 null 来表示；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeImpleBaseArray.png" alt="TreeImpleBaseArray"></p><p>在这种表示方式中，如果树是一棵二叉树（每个结点最多只有两个子节点），那么找节点的子节点和父节点就可以利用简单的算术计算它们在数组中的索引值：</p><ul><li>设节点索引值为 $index$，则节点的左子节点是：$2 \times index + 1$，它的右子节点是$2 \times index + 2$，它的父节点是 $\frac{index-1}{2}$；</li></ul><p>通过上述的定义，我们就能看出这种实现方式的优缺点如下：</p><ul><li>因为树中的每个位置都需要在数组中表示出来（不管该位置有无结点），这样树中空缺的结点或者被删除的结点都会在数组里留下 “空洞”，造成了内存浪费；</li><li>如果树中某个结点被删除后，需要调整树的结构（移动子树），那么子树对应到数组的每个元素都需要移动位置，在大型的树结构中，这一操作将十分耗时；</li><li>上述问题反映的也可以说是数组的劣势。当然了，如果某种树结构中不允许有删除操作，特别是在为结点动态分配空间比较耗时的情况下，这种实现方式也将很好的展现出它的优势；</li></ul><h3 id="基于链表实现"><a href="#基于链表实现" class="headerlink" title="基于链表实现"></a>基于链表实现</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>假设以一组<strong>连续空间</strong>存储树的结点，同时<strong>在每个结点中附设一个指示器指示其双亲结点在链表中的位置</strong>；</p><p>该结构利用的是每个结点（除根节点外）只有唯一双亲的性质。示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ParentsTree.png" alt="ParentsTree"></p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有以下两种结点格式：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildsTree.png" alt="ChildsTree"></p><ul><li>第一种结构，多重链表中的结点时同构的，其中 d 为树的度。由于树中很多结点的度小于 d，因此链表中会有很多空链表，造成空间浪费；</li><li>第二种结构，多重链表中的结点时不同构的，其中 $\overline{d}$ 是结点的度，degree 域的值同 $\overline{d}$。此时虽然节约存储空间，但操作不方便；</li></ul><p>还有一种办法：把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构（上面的树存储为如下形式）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildLinkedTree.png" alt="ChildLinkedTree"></p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>基于链表实现时采用的是 <code>父亲-长子-弟弟</code> 模型来定义，结构示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeLinkedList.png" alt="TreeLinkedList"></p><p>首先，定义树的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 树的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:25 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点中存放的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span></span>; <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 实现树接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:36 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkedList</span> <span class="keyword">implements</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object element; <span class="comment">// 树根节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeLinkedList parent, firstChild, nextSibling; <span class="comment">// 父节点、长子及最大的弟弟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">(Object object, TreeLinkedList parent, TreeLinkedList firstChild, TreeLinkedList nextSibling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = object;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.firstChild = firstChild;</span><br><span class="line">        <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前结点存放的对象元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Object bak = element;</span><br><span class="line">        element = obj;</span><br><span class="line">        <span class="keyword">return</span> bak;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>; <span class="comment">// 当前节点也是自己的后代</span></span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            size += subtree.getSize(); <span class="comment">// 累加</span></span><br><span class="line">            subtree = subtree.getNextSibling(); <span class="comment">// 所有孩子的后代数目</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size; <span class="comment">// 得到当前节点的后代总数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            height = Math.max(height, subtree.getHeight()); <span class="comment">// 在所有孩子中取最大高度</span></span><br><span class="line">            subtree = subtree.getNextSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height + <span class="number">1</span>; <span class="comment">// 每往下一行高度加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        TreeLinkedList p = parent; <span class="comment">// 从父亲开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            p = p.getParent(); <span class="comment">// 访问各个真祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth; <span class="comment">// 真祖先的数目，即为当前节点的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两颗子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。 </p><p>根据定义就能看出二叉树的 5 种基本形态如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeFiveStructure.png" alt="BinaryTreeFiveStructure">   </p><p>具有特殊形态的二叉树如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/SpecialFormBinaryTree.png" alt="SpecialFormBinaryTree"></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质 1</strong>：二叉树的第 i 层上至多有 $2^{i-1}$ 个结点（$i \geq 1$）；</p><ul><li>证明：利用归纳法<ul><li>当 $i = 1$ 时，只有一个根节点，显然成立；</li><li>假设对所有的 $j$，$1 \leq j &lt; i$，命题成立，即第 $j$ 层上至多有 $2^{j-1}$ 个结点；</li><li>由于二叉树每个结点的度至多为 2，则对于 $j+1$ 层来说：至多有 $2 \times 2^{j-1}=2^j$ 个结点，上述命题也成立；</li><li>因此，命题为真；</li></ul></li></ul><p><strong>性质 2</strong>：深度为 k 的二叉树至多有 $2^k-1$ 个结点（$k \geq1$）；</p><ul><li>证明：由性质 1，深度为 k 的二叉树的最大节点数为：<script type="math/tex">\sum^k_{i=1}\ (第\ i\ 层上的最大结点数)=\sum^k_{i=1}\ 2^{i-1}=2^k-1</script></li></ul><p><strong>性质 3</strong>：对任何一棵二叉树 T，如果其终端节点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$；</p><ul><li>证明：设 $n_1$ 为二叉树 T 中度为 1 的节点数，$n$ 为二叉树的总结点数，则：$n=n_0+n_1+n_2$；</li><li>考察二叉树的分支数。除了根节点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$；</li><li>由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_1+2\cdot n_2$；</li><li>将上述表达式联合起来也就不难推出：$n_0=n_2+1$；</li></ul><p>由于完全二叉树在实际中的运用比较多，接下来的两条性质就是围绕完全二叉树展开：   </p><p><strong>性质 4</strong>：具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n \rfloor+1$；</p><ul><li>证明：假设深度为 k，则根据性质 2 和完全二叉树的定义有：<script type="math/tex">2^{k-1}-1 < n \leq 2^k-1\ 或\ 2^{k-1} \leq n < 2^k</script>，于是 $k-1 \leq log_2n &lt; k$，因为 k 是整数，所以 $k=\lfloor log_2n \rfloor+1$；</li></ul><p><strong>性质 5</strong>：如果对一棵有 n 个结点的完全二叉树（其深度为 $\lfloor log_2n \rfloor+1$）的结点按层序编号（从第 1 层到第 $\lfloor log_2n \rfloor+1$ 层，每层从左到右），则对任一结点 i（$1\leq i \leq n$），有：</p><ol><li>如果 $i=1$，则结点 i 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲 $PARENT(i)$ 是结点 $\lfloor i/2 \rfloor$；</li><li>如果 $2i&gt;n$，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子 $LCHILD(I)$ 是结点 $2i$；</li><li>如果 $2i+1&gt;n$，则结点 i 无右孩子；否则其右孩子 $RCHILD(i)$ 是结点 $2i+1$；</li></ol><ul><li>证明：结论 1 可由结论 2 和 3 推导而出；<ul><li>对于 $i=1$ 的情况，很好推出；</li><li>对 $i&gt;1$ 分两种情况讨论：<ul><li>设第 $j（1 \leq j \leq \lfloor log_2n \rfloor）$层的第一个结点的编号为 i（由前面性质易推出 $i=2^{j-1}$）：<ul><li>则其左孩子必为第 $j+1$ 层的第一个结点，其编号为 $2^j=2(2^{j-1})=2i$，若 $2i&gt;n$，则无左孩子；</li><li>其右孩子必为第 $j+1$ 层的第二个结点，其编号为 $2i+1$，若 $2i+1&gt;n$，则无右孩子；</li></ul></li><li>假设第 $j(1 \leq j \leq \lfloor log_2n \rfloor)$ 层上某个结点的编号为 $i(2^{j-1} \leq i &lt; 2^j-1)$，且 $2i+1&lt;n$：则其左孩子为 $2i$，右孩子为 $2i+1$；<ul><li>又编号为 $i+1$ 的结点是编号为 $i$ 的结点的右兄弟或者堂兄弟，若它有左孩子，则编号必为 $2i+2=2(i+1)$，若它有右孩子，则其编号必为 $2i+3=2(i+1)+1$;</li></ul></li></ul></li><li>文字描述比较抽象，可以参照具体的完全二叉树的图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/LRChild.png" alt="LRChild"></li></ul></li></ul><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>假设用下面的图示来表示表达式：<code>a+b*(c-d)-e/f</code><br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TraverseBinaryTree.png" alt="TraverseBinaryTree"></p><div class="table-container"><table><thead><tr><th></th><th>先序遍历</th><th>中序遍历</th><th>后序遍历</th></tr></thead><tbody><tr><td>定义</td><td>先访问根结点，再访问左子树，再访问右子树；</td><td>先访问左子树，再访问根结点，再访问右子树；</td><td>先访问左子树，在访问右子树，再访问根结点；</td></tr><tr><td>遍历结果</td><td><code>-+a*b-cd/ef</code></td><td><code>a+b*c-d-e/f</code></td><td><code>abcd-*+ef/-</code></td></tr><tr><td>表达式类型</td><td>前缀表达式（波兰式）</td><td>中缀表达式</td><td>后缀表达式（逆波兰式）</td></tr></tbody></table></div><h2 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h2><p><strong>树转换为二叉树</strong>：</p><ul><li>加线：在所有的兄弟结点之间加线</li><li>去线：对树中的每一个结点，只保留它与第一个结点的连线，删除与其他孩子结点之间的连线</li><li>层次调整：调整成一颗二叉树（第一个孩子是二叉树的左孩子，兄弟转换过来是它的右孩子）</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeToBinaryTree.png" alt="TreeToBinaryTree"></p><p><strong>二叉树转换为树</strong>：就是树转换成二叉树的逆过程</p><ul><li>加线：若某结点的左孩子结点存在，则将左孩子的n个右孩子结点与此结点连接在一起</li><li>去线：删除二叉树中所有结点与其右孩子之间的连线</li><li>层次调整</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToTree.png" alt="BinaryTreeToTree"></p><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><p>这里只是给出一种实现示例，该数据结构使用十分广泛，实际运用时可根据需求进行调整，例如：《<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>》 文章里的 『二叉搜索树』、『平衡二叉树』、 『B 树』等；</p><details>  <summary><b>二叉树的 java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binarytree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> WWX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 二叉树的链式存储结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:07 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的节点数据结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span>  <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key=<span class="number">0</span>; <span class="comment">// 序号</span></span><br><span class="line">        <span class="keyword">private</span> String data=<span class="keyword">null</span>; <span class="comment">// 值（数据域）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isVisted=<span class="keyword">false</span>; <span class="comment">// 用来判断结点是否被访问到</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode leftChild=<span class="keyword">null</span>; <span class="comment">// 左儿子节点</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode rightChild=<span class="keyword">null</span>; <span class="comment">// 右儿子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="comment">// 默认构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 带参数构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> key,String data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.leftChild=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightChild=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode root=<span class="keyword">null</span>;  <span class="comment">// 二叉树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法</span></span><br><span class="line"><span class="comment">     * 指定根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(<span class="number">1</span>,<span class="string">"rootNode(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建一棵二叉树</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *           A</span></span><br><span class="line"><span class="comment">     *     B          C</span></span><br><span class="line"><span class="comment">     *  D     E            F</span></span><br><span class="line"><span class="comment">     *  &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode newNodeB = <span class="keyword">new</span> TreeNode(<span class="number">2</span>,<span class="string">"B"</span>);</span><br><span class="line">        TreeNode newNodeC = <span class="keyword">new</span> TreeNode(<span class="number">3</span>,<span class="string">"C"</span>);</span><br><span class="line">        TreeNode newNodeD = <span class="keyword">new</span> TreeNode(<span class="number">4</span>,<span class="string">"D"</span>);</span><br><span class="line">        TreeNode newNodeE = <span class="keyword">new</span> TreeNode(<span class="number">5</span>,<span class="string">"E"</span>);</span><br><span class="line">        TreeNode newNodeF = <span class="keyword">new</span> TreeNode(<span class="number">6</span>,<span class="string">"F"</span>);</span><br><span class="line"></span><br><span class="line">        newNodeC.rightChild = newNodeF;<span class="comment">//root.rightChild.rightChild=newNodeF;</span></span><br><span class="line">        newNodeB.leftChild = newNodeD;<span class="comment">//root.leftChild.leftChild=newNodeD;</span></span><br><span class="line">        newNodeB.rightChild = newNodeE;<span class="comment">//root.leftChild.rightChild=newNodeE;</span></span><br><span class="line"></span><br><span class="line">        root.leftChild = newNodeB;</span><br><span class="line">        root.rightChild = newNodeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断根节点是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的规模（树中结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树某个节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归结束：空树高度为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = height(subTree.leftChild);</span><br><span class="line">            <span class="keyword">int</span> j = height(subTree.rightChild);</span><br><span class="line">            <span class="keyword">return</span> (i &lt; j) ? (j + <span class="number">1</span>) : (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + size(subTree.leftChild) + size(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找某结点的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span> || root == element) ? <span class="keyword">null</span> : parent(root, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 subTree 为根的树中，element 的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode subTree,TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(subTree.leftChild == element || subTree.rightChild == element)</span><br><span class="line">            <span class="comment">//返回父结点地址</span></span><br><span class="line">            <span class="keyword">return</span> subTree;</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="comment">//现在左子树中找，如果左子树中没有找到，才到右子树去找</span></span><br><span class="line">        <span class="keyword">if</span>((p = parent(subTree.leftChild, element)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//递归在左子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//递归在右子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> parent(subTree.rightChild, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回左孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.leftChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回右孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.rightChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根为 subTree 的子树</span></span><br><span class="line">    <span class="comment">//   在释放某个结点时，该结点的左右子树都已经释放，</span></span><br><span class="line">    <span class="comment">//   所以应该采用后续遍历，当访问某个结点时将该结点的存储空间释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//删除左子树</span></span><br><span class="line">            destroy(subTree.leftChild);</span><br><span class="line">            <span class="comment">//删除右子树</span></span><br><span class="line">            destroy(subTree.rightChild);</span><br><span class="line">            <span class="comment">//删除根结点</span></span><br><span class="line">            subTree=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + subTree.key + <span class="string">"--name:"</span> + subTree.data);;</span><br><span class="line">        traverse(subTree.leftChild);</span><br><span class="line">        traverse(subTree.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            visted(subTree); <span class="comment">// 输出根节点</span></span><br><span class="line">            preOrder(subTree.leftChild); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            preOrder(subTree.rightChild); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrder(subTree.leftChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">            inOrder(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subTree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(subTree.leftChild);</span><br><span class="line">            postOrder(subTree.rightChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecPreOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node=p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                visted(node);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecInOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack =<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//存在左子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈非空</span></span><br><span class="line">            <span class="keyword">if</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                visted(node);</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noRecPostOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//左子树入栈</span></span><br><span class="line">            <span class="keyword">for</span>(;p.leftChild!=<span class="keyword">null</span>;p=p.leftChild)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前结点无右子树或右子树已经输出</span></span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;(p.rightChild==<span class="keyword">null</span>||p.rightChild==node))&#123;</span><br><span class="line">                visted(p);</span><br><span class="line">                <span class="comment">//纪录上一个已输出结点</span></span><br><span class="line">                node =p;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                p=stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理右子树</span></span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被访问到就输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visted</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        subTree.isVisted=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+subTree.key+<span class="string">"--name:"</span>+subTree.data);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree bt = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        bt.createBinTree(bt.root);</span><br><span class="line">        System.out.println(<span class="string">"the size of the tree is "</span> + bt.size());</span><br><span class="line">        System.out.println(<span class="string">"the height of the tree is "</span> + bt.height());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.preOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.inOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.postOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecPreOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecInOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.noRecPostOrder(bt.root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>线索二叉树是在二叉树的基础上新增了下列规则：</p><ul><li>若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；</li><li>若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 域指示其后继；</li></ul><p>为了避免混淆，尚需改变结点结构，增加两个标志域：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ClueBinaryTreeStruct.png" alt="ClueBinaryTreeStruct">   </p><p>由定义的结构，我们知道线索二叉树也应该分为：前序线索树、中序线索树、后序线索树。这其中在后序线索树中找结点后继较复杂，以其为例，分为 3 种情况考虑：</p><ul><li>若结点 x 是二叉树的根，则其后继为空；</li><li>若结点 x 是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；</li><li>若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点；</li></ul><p>若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作为存储结构；</p><h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><p>前面已经说过，森林是 $m（m \geq 0）$棵互不相交的树的集合；   </p><p><strong>将森林转换为二叉树</strong>：</p><ul><li>转换：把每一棵树转换成二叉树</li><li>连线：第一棵二叉树不变，从第二棵二叉树开始，依次将后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子，用线连起来</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ForestToBinaryTree.png" alt="ForestToBinaryTree"></p><p><strong>二叉树转换为森林</strong>：</p><ul><li>判断二叉树转换成森林还是树：二叉树的根节点是否有右孩子，若有是森林，否则是树</li><li>从根节点开始，若有右孩子，则把与右孩子结点的连线删除，再看分离后的二叉树，若还有右孩子连线继续删除，则到没有为止</li><li>将分离的二叉树转换成树</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToForest.png" alt="BinaryTreeToForest"></p><p><strong>森林的遍历</strong>：</p><ul><li>先序遍历：<ul><li>若森林非空，则按如下规则遍历：<ul><li>访问森林中第一棵树的根结点；</li><li>先序遍历第一棵树中根结点的子树森林；</li><li>先序遍历除去第一棵树之后剩余的树构成的森林；</li></ul></li><li>上述森林的遍历结果：<code>A B C D E F G H J I</code></li></ul></li><li>中序遍历：<ul><li>若森林非空，则按如下规则遍历：<ul><li>中序遍历森林中第一棵树的根结点的子树森林；</li><li>访问第一棵树的根结点；</li><li>中序遍历除去第一棵树之后剩余的树构成的森林；</li></ul></li><li>上述森林的遍历结果：<code>B C D A F E J H I G</code></li></ul></li></ul><h1 id="哈夫曼（Huffman）树"><a href="#哈夫曼（Huffman）树" class="headerlink" title="哈夫曼（Huffman）树"></a>哈夫曼（Huffman）树</h1><p>哈（赫）夫曼树又称最优树，它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度最小的二叉树；</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>路径与路径长</strong>：</p><ul><li><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成的部分，而分支（边）的数目就是<strong>路径长度</strong>；</li><li><strong>树的路径长度</strong>：就是从树根到每一结点的路径长度之和；</li></ul><p><strong>考虑带权的结点</strong>：</p><ul><li><strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积；</li><li><strong>树的带权路径长度 WPL</strong>（weighted path length）：树中所有叶子结点的带权路径长度之和；<ul><li>假设一个有 $n$ 个带权叶子结点的二叉树，其权值为 $\{w_1,w_2,….w_n\}$，每个叶子结点带权 $w_k$，每个叶子的路径长度为 $l_k$，则从根结点到各个叶子结点的路径长度与相应的权值的乘积之和叫做<strong>二叉树的带权路径长度</strong>，通常记作：<script type="math/tex">WPL = \sum^n_{k=1}\ w_kl_k</script></li><li>示例：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanWPL.png" alt="HuffmanWPL"></li></ul></li></ul><p>观察上述示例，（b）所示的二叉树的 WPL 最小，为哈夫曼树（最优树）；</p><ul><li>注意：由相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径。在由 n 个带权叶子结点所构成的二叉树中，满二叉树或完全二叉树不一定是最优二叉树。<strong>权值越大的结点离根结点越近的二叉树才是最优二叉树</strong>；</li></ul><h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>哈夫曼算法是用来构造二叉树的，其描述如下：</p><ul><li>根据给定的 $n$ 个叶子结点的权值 $\{w_1,w_2,….w_n\}$ 构成 $n$ 棵二叉树的集合 $F=\{T_1,T_2,…T_n\}$，其中每棵二叉树 $T_i$ 中只有一个带权为 $w_i$的根结点，其左右子树均为空;</li><li>在 $F$ 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为左右子树上根结点的权值之和；</li><li>在 $F$ 中删除这两棵树，同时将新得到的二叉树加入 $F$ 中；</li><li>重复步骤 2、3，直到 $F$ 只含一棵树为止。这棵树便是哈夫曼树；</li></ul><p>示例如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanTreeBuild.png" alt="HuffmanTreeBuild"></p><h2 id="应用：哈夫曼编码"><a href="#应用：哈夫曼编码" class="headerlink" title="应用：哈夫曼编码"></a>应用：哈夫曼编码</h2><p>在数字通信中，经常需要将传送的文字转换成由二进制字符 <code>0、1</code> 组成的二进制串，这一过程被称为<strong>编码</strong>。在传送电文时，总是希望电文代码尽可能短，采用哈夫曼编码构造的电文的总长最短。</p><ul><li>从根节点出发，每个父节点都会有分支，现在给左右分支各赋予一个数值，左分支表示 <code>0</code>，右分支表示 <code>1</code>；</li><li>当从根节点一直数到叶子结点过程中所经历的左右分支以 <code>0</code>、<code>1</code> 表示时，每个叶子结点会形成一个特定的编码，这个就是哈夫曼编码。如图所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanCode.png" alt="HuffmanCode"></li></ul><div class="note warning"><p>来自：<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">本段来源</a><br>在电文传输中，需要将电文中出现的每个字符进行二进制编码。在设计编码时需要遵守两个原则：</p><ul><li>发送方传输的二进制编码，到接收方解码后必须具有唯一性，即解码结果与发送方发送的电文完全一样；</li><li>发送的二进制编码尽可能地短;</li></ul><p>下面我们介绍两种编码的方式。</p><ol><li><p>等长编码：</p><ul><li>这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）；</li><li>假设字符集只含有 4 个字符 A，B，C，D，用二进制两位表示的编码分别为 00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为 14 位。当接收方接收到这段电文后，将按两位一段进行译码。</li><li>这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</li></ul></li><li><p>不等长编码：</p><ul><li>在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编；</li><li>例如，可以为 A，B，C，D 四个字符分别分配 0，00，1，01，并可将上述电文用二进制序列：000011010 发送，其长度只有 9 个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面 4 个 0 是 4 个 A，1 个 B、2 个 A，还是 2 个 B，即译码不唯一，因此这种编码方法不可使用。</li><li>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即（<strong>前缀编码</strong>）在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀。<strong>这个问题可以采用哈夫曼编码解决</strong>。</li></ul></li></ol></div><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将一个字符串中出现的字符生成其对应的哈夫曼编码，分为以下几步：</p><ol><li>统计出现的字符及频率；</li><li>将各个字符创建为叶子结点，频率为结点的权值，用链表保存这些叶子结点；</li><li>将结点队列中的结点按权值升序排列；</li><li>取出权值最小的两个结点构建父节点（要从链表中删除取出的结点），将新生成的父节点添加到结点链表，并从新排序；</li><li>重复（4）步骤，直到只剩下一个结点；</li><li>返回最后的结点，即为哈夫曼树的根节点；</li></ol><details>  <summary><b>哈夫曼树的 java 实现</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 哈夫曼树的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 23:47 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树的结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String code = <span class="string">""</span>; <span class="comment">// 节点的哈夫曼编码</span></span><br><span class="line">        <span class="keyword">public</span> String data = <span class="string">""</span>; <span class="comment">// 节点的数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;        <span class="comment">// 节点的权值</span></span><br><span class="line">        <span class="keyword">public</span> HNode lChild;     <span class="comment">// 左孩子</span></span><br><span class="line">        <span class="keyword">public</span> HNode rChild;     <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(<span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String str;                     <span class="comment">// 最初用于压缩的字符串</span></span><br><span class="line">    <span class="keyword">private</span> HNode root;                     <span class="comment">// 哈夫曼二叉树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;                   <span class="comment">// 最新的字符是否已经存在的标签</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;CharData&gt; charList;  <span class="comment">// 存储不同字符的队列 相同字符存在同一位置</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;HNode&gt; NodeList;     <span class="comment">// 存储节点的队列</span></span><br><span class="line">    <span class="comment">// 字符类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CharData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 字符个数</span></span><br><span class="line">        <span class="keyword">char</span> c; <span class="comment">// 字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharData</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">            c = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatHfmTree</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line"></span><br><span class="line">        NodeList = <span class="keyword">new</span> LinkedList&lt;HNode&gt;();</span><br><span class="line">        charList = <span class="keyword">new</span> LinkedList&lt;CharData&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.统计字符串中字符以及字符的出现次数</span></span><br><span class="line">        <span class="comment">// 以CharData类来统计出现的字符和个数</span></span><br><span class="line">        getCharNum(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.根据第一步的结构，创建节点</span></span><br><span class="line">        creatNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对节点权值升序排序</span></span><br><span class="line">        Sort(NodeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">        <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">        creatTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.重复第四五步，就是那个while循环</span></span><br><span class="line">        <span class="comment">// 7.将最后的一个节点赋给根节点</span></span><br><span class="line">        root = NodeList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是构造哈夫曼树的子方法实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计出现的字符及其频率</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCharNum</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i); <span class="comment">// 从给定的字符串中取出字符</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charList.size(); j++) &#123; <span class="comment">// charList中存放的是已经识别出来的字符</span></span><br><span class="line">                CharData data = charList.get(j);</span><br><span class="line">                <span class="keyword">if</span>(ch == data.c)&#123; <span class="comment">// 字符对象链表中有相同字符则将个数加1</span></span><br><span class="line">                    data.num++;</span><br><span class="line">                    flag = <span class="keyword">false</span>;  <span class="comment">// 标志该字符已被识别出来不再加入 charList</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                charList.add(<span class="keyword">new</span> CharData(ch)); <span class="comment">// 字符对象链表中没有相同字符,则创建新对象加如链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将出现的字符创建成哈夫曼树单个的结点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charList.size(); i++) &#123;</span><br><span class="line">            String data = charList.get(i).c + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> count = charList.get(i).num;</span><br><span class="line">            HNode node = <span class="keyword">new</span> HNode(data, count); <span class="comment">// 创建节点对象</span></span><br><span class="line">            NodeList.add(node); <span class="comment">// 加入到节点链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (NodeList.size() &gt; <span class="number">1</span>) &#123;    <span class="comment">// 当节点数目大于一时</span></span><br><span class="line">            <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">            <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">            HNode left = NodeList.poll();</span><br><span class="line">            HNode right = NodeList.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在构建哈夫曼树时设置各个结点的哈夫曼编码</span></span><br><span class="line">            left.code = <span class="string">"0"</span>;  <span class="comment">// 左节点为 1</span></span><br><span class="line">            right.code = <span class="string">"1"</span>; <span class="comment">// 右节点为 0</span></span><br><span class="line">            setCode(left);</span><br><span class="line">            setCode(right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parentWeight = left.count + right.count; <span class="comment">// 父节点权值等于子节点权值之和</span></span><br><span class="line">            HNode parent = <span class="keyword">new</span> HNode(parentWeight, left, right);</span><br><span class="line">            NodeList.addFirst(parent); <span class="comment">// 将父节点置于首位</span></span><br><span class="line">            Sort(NodeList); <span class="comment">// 重新排序，避免新节点权值大于链表首个结点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodelist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(LinkedList&lt;HNode&gt; nodelist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodelist.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nodelist.size(); j++) &#123;</span><br><span class="line">                HNode temp;</span><br><span class="line">                <span class="keyword">if</span> (nodelist.get(i).count &gt; nodelist.get(j).count) &#123;</span><br><span class="line">                    temp = nodelist.get(i);</span><br><span class="line">                    nodelist.set(i, nodelist.get(j));</span><br><span class="line">                    nodelist.set(j, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(HNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.lChild.code = root.code + <span class="string">"0"</span>;</span><br><span class="line">            setCode(root.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.rChild.code = root.code + <span class="string">"1"</span>;</span><br><span class="line">            setCode(root.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(HNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.lChild == <span class="keyword">null</span> &amp;&amp; node.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node.data + <span class="string">": "</span> + node.code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果字符的哈夫曼编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是编解码的实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String hfmCodeStr = <span class="string">""</span>;<span class="comment">// 哈夫曼编码连接成的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHufmCode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            String c = str.charAt(i) + <span class="string">""</span>;</span><br><span class="line">            search(root, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hfmCodeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在哈夫曼树里查找字符对应的结点（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 需要生成编码的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(HNode root, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.equals(root.data)) &#123;</span><br><span class="line">                hfmCodeStr += root.code; <span class="comment">// 找到字符，将其哈夫曼编码拼接到最终返回二进制字符串的后面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.lChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.rChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存解码的字符串</span></span><br><span class="line">    String result=<span class="string">""</span>; <span class="comment">// 初始为空串</span></span><br><span class="line">    <span class="keyword">boolean</span> target = <span class="keyword">false</span>; <span class="comment">// 解码标记</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeStr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CodeToString</span><span class="params">(String codeStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt;= codeStr.length())&#123;</span><br><span class="line">            target = <span class="keyword">false</span>;</span><br><span class="line">            String s = codeStr.substring(start, end);</span><br><span class="line">            matchCode(root, s); <span class="comment">// 解码</span></span><br><span class="line">            <span class="comment">// 每解码一个字符，start向后移</span></span><br><span class="line">            <span class="keyword">if</span>(target)&#123;</span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配字符哈夫曼编码，找到对应的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 需要解码的二进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">matchCode</span><span class="params">(HNode root, String code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code.equals(root.code)) &#123;</span><br><span class="line">                result += root.data; <span class="comment">// 找到对应的字符，拼接到解码字符穿后</span></span><br><span class="line">                target = <span class="keyword">true</span>; <span class="comment">// 标志置为true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.lChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.rChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuffmanTree huff = <span class="keyword">new</span> HuffmanTree();<span class="comment">// 创建哈弗曼对象</span></span><br><span class="line">        String data = <span class="string">"我喜欢用 java 实现哈夫曼编码"</span>;</span><br><span class="line">        </span><br><span class="line">        huff.creatHfmTree(data);<span class="comment">// 构造树</span></span><br><span class="line"></span><br><span class="line">        huff.output(); <span class="comment">// 显示各个字符的哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目标字符串利用生成好的哈夫曼编码生成对应的二进制编码</span></span><br><span class="line">        String hufmCode = huff.toHufmCode(data);</span><br><span class="line">        System.out.println(<span class="string">"编码:"</span> + hufmCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上述二进制编码再翻译成字符串</span></span><br><span class="line">        System.out.println(<span class="string">"解码："</span> + huff.CodeToString(hufmCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>『<a href="https://www.jianshu.com/p/4716b2f49e8e" target="_blank" rel="noopener">数据结构：二叉树的原理及java实现</a>』</li><li>『<a href="https://blog.csdn.net/xin917480852/article/details/50503501" target="_blank" rel="noopener">树、森林与二叉树的转换总结</a>』</li><li>『<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">Java 实现哈夫曼树及简易编码解码</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-Tree/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n （$n \geq 0$）个有限节点组成一个具有层次关系的集合。在任意一棵非空树中，它都满足如下特点：&lt;/p&gt;
&lt;div class=&quot;note warning&quot;&gt;&lt;ul&gt;
&lt;li&gt;有且仅有一个特定的称为根（Root）的结点；&lt;/li&gt;
&lt;li&gt;当 $n &amp;gt;1$ 时，其余结点可分为 m（$m &amp;gt;0$）个互不相交的有限集 $T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之字符串</title>
    <link href="http://www.thebetterkong.cn/2020/07/02/DataStructure-Algorithm/DataStructure-String/"/>
    <id>http://www.thebetterkong.cn/2020/07/02/DataStructure-Algorithm/DataStructure-String/</id>
    <published>2020-07-02T10:25:36.000Z</published>
    <updated>2020-08-14T09:28:18.323Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-String/header.png" width="100%" alt="header.png" /> </div>  <p><strong>字符串</strong>（String）是由零个或多个字符（char）组成的有序序列。学过 C/C++ 的人会有一种固定的思维模式，凡是字符串都是以 <code>\0</code> 结束。但是 java 却不同，要知道 java 里始终秉承的一句话 『<strong>everything is object</strong>』，字符串也不例外，它也被作为 String 类型的对象处理。</p><a id="more"></a> <h1 id="认识-java-字符串"><a href="#认识-java-字符串" class="headerlink" title="认识 java 字符串"></a>认识 java 字符串</h1><p><code>String</code> 类表示字符串，Java 程序中的所有字符串文字（例如 <code>abc</code>）都实现为此类的实例。让我们来看一下 java 中 <code>String</code> 类的声明源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这里我们可以看出两点结论：</p><ul><li><strong><code>String</code> 类是通过 <code>char</code> 数组来保存字符串的</strong>，因此有如下关系：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">char</span> [] data = &#123;<span class="string">'a'</span>，<span class="string">'b'</span>，<span class="string">'c'</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String (data);</span><br></pre></td></tr></table></figure></li><li><strong>字符串是常量，它们的值在内存创建后则无法更改（字符串的不变性）</strong>，平常我们用到的更改实际上都只是重新创建了一个新的字符串（后面会进行详细描述），这样效率很低。因此如果需要一个可以改变的字符串，更推荐使用 <code>StringBuffer</code> 或者 <code>StringBuilder</code>；</li></ul><h1 id="创建-java-String-对象的方法"><a href="#创建-java-String-对象的方法" class="headerlink" title="创建 java String 对象的方法"></a>创建 java String 对象的方法</h1><p>在具体讲解之前，我们有必要先弄清楚 java String 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 构造方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对 jdk 源码里常用方法的总结罗列，如果有疑惑，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 注意：除非另有说明，否则将 null 参数传递给此类中的构造函数或方法将引发  NullPointerException；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空字符串，由于字符串不可变，所以它通常不会被使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>.value = <span class="string">""</span>.value;&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建参数字符串的副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;...&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新的 String，它包含参数字符数组的字符序列；</span></span><br><span class="line"><span class="comment">// 字符数组的内容被复制，字符数组的后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;...&#125;;          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这次创建的是参数数组的子数组</span></span><br><span class="line"><span class="comment">// @param offset 是子数组第一个字符的索引</span></span><br><span class="line"><span class="comment">// @param count 指定子数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 Uncode 编码数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 ascii 编码字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 通过使用指定的字符集解码指定的字节子数组，构造一个新的 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string buffer 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string buffer 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string builder 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string builder 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="comment">// 提供此构造函数可简化向 StringBuilder 的迁移；</span></span><br><span class="line"><span class="comment">// 通过 toString 方法从 StringBuilder 获取字符串可能运行得更快，通常是首选。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了共享数组的包私有构造器，但是总是期望 share == true</span></span><br><span class="line"><span class="comment">// 因为已经有一个公共 String（char []）构造函数，它可以复制给定char []，因此需要一个单独的构造函数</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>源码嘛，比较复杂一点，但其实我们实际使用中经常用到的也就<strong>两种形式，特别关注他们的差异</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、使用 "" 引号创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：单独使用 "" 引号创建的字符串都是常量，编译期就已经确定，存储</span></span><br><span class="line"><span class="comment">*       到 String Pool 中</span></span><br><span class="line"><span class="comment">* 具体过程：在执行到双引号包含字符串的语句时，如 String a = "123"，</span></span><br><span class="line"><span class="comment">*           JVM 会先到常量池里查找，如果有的话返回常量池里的这个实</span></span><br><span class="line"><span class="comment">*           例的引用，否则的话创建一个新实例并置入常量池里</span></span><br><span class="line"><span class="comment">* 注意：使用此方法，对象可能并没有被创建！而只是将引用指向了一个先前</span></span><br><span class="line"><span class="comment">*       已经创建的对象  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 创建一个字符串对象 imooc，引用名为 s1</span></span><br><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line"><span class="comment">// 新声明一个字符串引用，名为 s2，也指向了常量池里与上面字符串相同的字符串</span></span><br><span class="line">String s2 = <span class="string">"imooc"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二、使用 new 关键字创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：使用 new String("") 创建的对象会存储到 heap 中，是运行期新创建的；</span></span><br><span class="line"><span class="comment">* 具体过程：new 首先在堆中创建一个对象，引用 s3 指向这个对象。然后在常量池中找值</span></span><br><span class="line"><span class="comment">*          为 "immoc" 的对象：</span></span><br><span class="line"><span class="comment">*          如果没有，则进行创建，然后将这个 String 对象成员变量 char 数组</span></span><br><span class="line"><span class="comment">*          （value[]），指向值为 "immoc" 的这个对象（这时就创建了两个对象）；</span></span><br><span class="line"><span class="comment">*          如果有，则直接将 String 对象成员变量 char 数组指向这个 "immoc" 对象</span></span><br><span class="line"><span class="comment">*          即可（这时只创建了一个对象）；</span></span><br><span class="line"><span class="comment">*    </span></span><br><span class="line"><span class="comment">* 注意：此方法一定有一个新的对象被创建，至于最终有几个对象创建得分情况考虑，这也</span></span><br><span class="line"><span class="comment">*      是面试中的高频考点！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 分配内存，创建一个新的字符串对象 imooc，引用名为 s2</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 补充说明：</span></span><br><span class="line"><span class="comment">*   （1）使用只包含常量的字符串连接符如 "aa" + "aa" 创建的也是常</span></span><br><span class="line"><span class="comment">*        量，编译期就能确定，已经确定存储到 String Pool 中；</span></span><br><span class="line"><span class="comment">*   （2）使用包含变量的字符串连接符如 "aa" + s1 创建的对象是运行期</span></span><br><span class="line"><span class="comment">*        才创建的，存储在 heap 中；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>上面对这两种形式的差异解释可能有点晕，给出一段代码帮助理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"爱慕课"</span>;  </span><br><span class="line">String s2 = <span class="string">"爱慕课"</span>; </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);       <span class="comment">// 多次出现的字符常量，Java 编译程序只创建一个，所以返回 true</span></span><br><span class="line">System.out.println(s1 == s3);       <span class="comment">// s1 和 s3 是不同的对象，所以返回 false</span></span><br><span class="line">System.out.println(s3 == s4);       <span class="comment">// s3和 s4 是不同的对象，所以返回 false</span></span><br><span class="line">s1 = <span class="string">"欢迎来到："</span> + s1;</span><br><span class="line">System.out.println(s1);             <span class="comment">// 字符串 s1 被修改，指向新的内存空间，输出“欢迎来到：爱慕课”</span></span><br></pre></td></tr></table></figure></p><h1 id="java-字符串的不可变性"><a href="#java-字符串的不可变性" class="headerlink" title="java 字符串的不可变性"></a>java 字符串的不可变性</h1><p>首先，我们来认识一下，什么叫做<strong>类的不可变性</strong>：<br><div class="note warning"><ul><li><strong>定义</strong>：简单地说，就是其实例一旦创建完成，在其整个生命周期内状态都不会发生变化。状态这个词有一些抽象，在 Java 中对象的状态是由其成员变量来表现的，那么状态不变即是成员变量不变（具体来说，基本类型变量的值不变、引用类型变量的引用地址不变）；</li><li><strong>不可变的类的好处</strong>：<ul><li>更加易于设计、实现和使用。</li><li>并发时，不容易出错，并且更加安全。</li></ul></li><li><strong>为了使类成为不可变，要遵循下面五条规则</strong>（来自《Effective Java》）：<ul><li>不提供任何会修改对象状态的方法；</li><li>保证类不能被扩展；</li><li>所有的成员变量都被 final 修饰的；</li><li>所有的成员变量都是 private 的；</li><li>确保对于任何可变组件的互斥访问。如果一个类的成员变量引用了可变对象，则必须确保外部调用类无法获取指向这些对象的引用；</li></ul></li><li>当然，所有的这些条件都是针对正常调用而言的，如果使用反射，则仅仅满足上述的条件也无法保证对象不可变；</li><li>看到这里，你就一定明白上面为什么说 java 的字符串是一个不可变的常量；</li></ul></div></p><p>关于 java 字符串，就需要牢记一句话：<strong><mark>String 对象一旦被创建就是固定不变的了，对 String 对象的任何改变都不影响到原对象，相关的任何 change 操作都会生成新的对象</mark></strong>；    </p><p>关于这一点结合前文所学，就有必要认识一下<strong>三个比较重要的方法</strong>：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String.intern()</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：在常量池中查找值等于（equals）当前字符串的对象，如果找到，则直接返回</span></span><br><span class="line"><span class="comment">*          这个对象的地址；如果没有找到，则将当前字符串拷贝到常量池中，然后返回</span></span><br><span class="line"><span class="comment">*          拷贝后的对象地址；    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String a = <span class="string">"123"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);                     <span class="comment">// false</span></span><br><span class="line">System.out.println(a == b.intern());            <span class="comment">// true</span></span><br><span class="line">System.out.println(c == b.intern());            <span class="comment">// false</span></span><br><span class="line">System.out.println(c.intern() == b.intern());   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equals 和 ==</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*（1）对于 ==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,</span></span><br><span class="line"><span class="comment">*     double,boolean ），则直接比较其存储的"值"是否相等；如果作用于引用类型的变</span></span><br><span class="line"><span class="comment">*     量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）；</span></span><br><span class="line"><span class="comment">*（2）equals 方法是基类 Object 中的方法，因此对于所有的继承于 Object 的类都会有</span></span><br><span class="line"><span class="comment">*    该方法。在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是</span></span><br><span class="line"><span class="comment">*    否指向同一个对象；</span></span><br><span class="line"><span class="comment">*（3）对于 equals 方法，注意：equals 方法不能作用于基本数据类型的变量。如果没有</span></span><br><span class="line"><span class="comment">*    对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而 </span></span><br><span class="line"><span class="comment">*    String 类对 equals 方法进行了重写，用来比较指向的字符串对象所存储的字符串</span></span><br><span class="line"><span class="comment">*    是否相等。其他的一些类诸如 Double，Date，Integer 等，都对 equals 方法进行</span></span><br><span class="line"><span class="comment">*    了重写用来比较指向的对象所存储的内容是否相等；   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);          <span class="comment">// true，表示 s1 和 s2 指向同一对象，它们都指向常量池中的 "hello" 对象</span></span><br><span class="line">System.out.println(s1 == s3);          <span class="comment">// flase，表示 s1 和 s3 的地址不同，即它们分别指向的是不同的对象，s1 指向常量池中的地址，s3 指向堆中的地址</span></span><br><span class="line">System.out.println(s1.equals(s3));     <span class="comment">// true，表示 s1 和 s3 所指向对象的内容相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符串的连接："+"</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：连接两个字符串</span></span><br><span class="line"><span class="comment">*    工作细节：连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符</span></span><br><span class="line"><span class="comment">*             串常量连接起来，形成新的字符串常量参与后续连接。接下来的字符串连接</span></span><br><span class="line"><span class="comment">*             是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创</span></span><br><span class="line"><span class="comment">*             建 StringBuilder 对象，然后依次对右边进行 append 操作，最后将</span></span><br><span class="line"><span class="comment">*             StringBuilder 对象通过 toString() 方法转换成 String 对象（注</span></span><br><span class="line"><span class="comment">*             意：中间的多个字符串常量不会自动拼接）。      </span></span><br><span class="line"><span class="comment">*   例如：String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程</span></span><br><span class="line"><span class="comment">*         是： String c = new StringBuilder("xxyy ").append(a).append("zz").</span></span><br><span class="line"><span class="comment">*         append("mm").append(b).toString();</span></span><br><span class="line"><span class="comment">*   结论：当使用 + 进行多个字符串连接时，实际上是产生了一个 StringBuilder 对象</span></span><br><span class="line"><span class="comment">*         和一个 String 对象。也正因如此，导致了 string 中 + 连接符效率十分低</span></span><br><span class="line"><span class="comment">*         下。因此，当经常涉及字符串的改变（拼接）时，更推荐用 StringBuffer 或 </span></span><br><span class="line"><span class="comment">*         StringBulider 对象来进行 append 操作，特别是在循环中；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;         <span class="comment">// 创建时，编译器可以进行优化，这里只创建了一个对象。变量 s 的创建等价于 String s = "abc"; </span></span><br><span class="line">String s1  =  <span class="string">"a"</span>; </span><br><span class="line">String s2  =  <span class="string">"b"</span>; </span><br><span class="line">String s3  =  <span class="string">"c"</span>; </span><br><span class="line">String s4  =  s1  +  s2  +  s3;</span><br><span class="line"><span class="comment">// s4 不能在编译期进行优化，其对象创建相当于：</span></span><br><span class="line"><span class="comment">// StringBuilder temp = new StringBuilder();   </span></span><br><span class="line"><span class="comment">// temp.append(a).append(b).append(c);   </span></span><br><span class="line"><span class="comment">// String s = temp.toString();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   最后再来一段代码加深理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="string">"12"</span>;</span><br><span class="line">String s1 = <span class="string">"34"</span>;</span><br><span class="line">String s2 = s + s1;</span><br><span class="line">String s3 = <span class="string">"1234"</span>;</span><br><span class="line">String s4 = <span class="string">"12"</span> + <span class="string">"34"</span>;</span><br><span class="line">String s5 = s + <span class="string">"34"</span>;</span><br><span class="line">String s6 = <span class="string">"12"</span> + <span class="keyword">new</span> String(<span class="string">"34"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s4);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="String-的方法"><a href="#String-的方法" class="headerlink" title="String 的方法"></a>String 的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//*********************** 基础方法 **************************************</span></span><br><span class="line"><span class="function">String <span class="title">intern</span><span class="params">()</span></span>;        <span class="comment">// 在常量池中查找值等于（equals）当前字符串的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                            <span class="comment">// 返回当前字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                          <span class="comment">// 判断字符串是否为空（length == 0）</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 获取字符串中指定位置的字符</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;           <span class="comment">// 是否包含</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;            <span class="comment">// 返回去除了前后空格的字符串</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>;                  <span class="comment">// 将指定字符串连接到此字符串的结尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;     <span class="comment">// 返回字符串的 hashcode，计算方式：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 转换 ************************************</span></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span></span>;  <span class="comment">// 指定转换规则</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 其他类型转换为 string</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;      <span class="comment">// 它本身就是一个 srtring，所以返回他自身</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回 Object 参数的字符串表示形式，null 或者 obj.toString()</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;    <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>; <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>; <span class="comment">// 返回 b 代表的 "true" 或者 "false"</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### string 转换为其他类型</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray();   <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;    </span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到 dst 中从 dstBegin 开的位置（无范围检查）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;  </span><br><span class="line">    <span class="comment">// 将字符串 srcBegin 到 srcEnd-1 的字符复制到 dst 中从 dstBegin 开的位置（有范围检查）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] getBytes();      <span class="comment">// 将该字符串本身转化为 byte 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">byte</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;</span><br><span class="line"><span class="comment">// 将该字符串指定位置的内容转换至 byte 数组指定位置</span></span><br><span class="line"><span class="comment">// 每个字节接收相应字符的8个低位，每个字符的八个高位不被复制，也不以任何方式参与传输（汉子占两个字节，英文字符一个字节）</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName)；   <span class="comment">// 指定字符串转化为 bytes 数组，返回这个数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 比较方法 **************************************</span></span><br><span class="line"><span class="comment">//（1）比较是否完全相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>;            <span class="comment">// 将该字符串与指定对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span></span>;     <span class="comment">// 将该字符串与指定 StringBuffer 对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>；    <span class="comment">// 两个 String 比较，不考虑大小写</span></span></span><br><span class="line"><span class="function"><span class="comment">//（2）按字典序从头至尾对比（不一定完全相等）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>;    <span class="comment">// 从左至右挨个字符对比（只比较公共长度的部分）</span></span><br><span class="line">    <span class="comment">// 如果参数字符串等于此字符串，则值为 0；</span></span><br><span class="line">    <span class="comment">// 如果此字符串在字典上小于字符串参数，则小于 0的值；</span></span><br><span class="line">    <span class="comment">// 如果该字符串在字典上大于字符串参数，则该值大于 0；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;    <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">//（3）匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span>;  <span class="comment">// 告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="comment">// 将该字符串从 toffset 开始的 len 个字符与 other 字符串从 ooffset 开始的 len 个字符进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 拼接 **************************************</span></span><br><span class="line"><span class="comment">// 用 delimiter 作为分割符，将后面的序列拼接起来</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  String message = String.join("-", "Java", "is", "cool"); </span></span><br><span class="line"><span class="comment">//  message returned is:"Java-is-cool"</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  List&lt;String&gt; strings = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//  strings.add("Java");strings.add("is");</span></span><br><span class="line"><span class="comment">//  strings.add("cool");</span></span><br><span class="line"><span class="comment">//  String message = String.join(" ", strings);</span></span><br><span class="line"><span class="comment">//  message returned is: "Java is cool"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 分割 aplit ************************************</span></span><br><span class="line"><span class="comment">// 将字符串按正则规则分割为子字符串，返回字符串数组</span></span><br><span class="line">String[] aplit(String regex,<span class="keyword">int</span> limit); </span><br><span class="line"><span class="comment">// limit 参数控制应用模式的次数，因此会影响结果数组的长度：</span></span><br><span class="line"><span class="comment">// - 如果限制 n 大于零，则将最多应用 n-1 次该模式，该数组的长度将不大于 n，并且该数组的最后一个条目将包含除最后一个匹配的定界符之外的所有输入;</span></span><br><span class="line"><span class="comment">// - 如果 n 为非正数，则该模式将被尽可能多地应用，并且数组可以具有任何长度；</span></span><br><span class="line"><span class="comment">// - 如果 n 为零，则该模式将被尽可能多地应用，该数组可以具有任何长度，并且尾随的空字符串将被丢弃</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// Regex    Limit   Result</span></span><br><span class="line"><span class="comment">// :    2       &#123;@code &#123; "boo", "and:foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :    5    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :    -2    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    5    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    -2    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    0    &#123;@code &#123; "b", "", ":and:f" &#125;&#125;</span></span><br><span class="line">String[] split(String regex);   <span class="comment">// 相当于 limit=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 替换 replace ************************************</span></span><br><span class="line"><span class="comment">// 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的第一个子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的所有子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>;   </span><br><span class="line"><span class="comment">// 用指定的文字替换序列替换该字符串中与文字目标序列匹配的每个子字符串。 替换从字符串的开头到结尾进行，例如，在字符串“ aaa”中将“ aa”替换为“ b”将得到“ ba”而不是“ ab”</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//********************* 索引 index ************************************</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;            <span class="comment">// 查找 ch 字符在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>; <span class="comment">// 指定从字符串的 fromIndex 处开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;            <span class="comment">// 查找 str 字符串在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;            <span class="comment">// 查找 ch 字符在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;    <span class="comment">// 查找 str 字符串在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="comment">// 处理（罕见）带有补充字符的 indexOf 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 AbstractStringBuilder 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 StringBuffer 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 子字符串 **************************************</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span></span>; <span class="comment">// 测试此字符串的子字符串是否从指定的索引开始，并以指定的前缀开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>;               <span class="comment">// 获取从 beginIndex 位置开始到结束的子字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span>;  <span class="comment">// 获取从 beginIndex 位置开始到 endIndex-1 位置的子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 格式化字符串 ************************************</span></span><br><span class="line"><span class="comment">// 字符串的格式化内容较多，还需另外具体学习</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(String format, Object... args)</span></span>;   </span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 不常用方法 **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                         <span class="comment">// 返回指定位置的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 返回指定位置的前一个字符的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;   <span class="comment">// 返回从 beginIndex 到 endIndex-1 范围内的 Unicode code 数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span></span>; <span class="comment">// 返回从 index 开始，偏移 codePointOffset 的索引</span></span><br></pre></td></tr></table></figure><h1 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h1><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 不同于 <code>String</code> 的地方在于：它们在修改时会改变对象自身，每次结果都会对他们对象的本身进行操作；而不是像 string 那样生成新的对象，再改变对象引用。</p><p>这三者的区别如下：</p><div class="table-container"><table><thead><tr><th>类型</th><th>可变性</th><th>线程安全性</th></tr></thead><tbody><tr><td>String</td><td>字符串常量, 内容不可变</td><td>线程安全, 可多线程使用</td></tr><tr><td>StringBuffer</td><td>字符串变量</td><td>线程安全, 可多线程使用</td></tr><tr><td>StringBuilder</td><td>字符串变量</td><td>非线程安全, 单线程使用，单线程效率优于 StringBuffer</td></tr></tbody></table></div><p>大多数方法和 String 都相同，需要重点关注的如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append：将任何数据类型的字符串表示，拼接到调用的对象的末尾</span></span><br><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">s.append(<span class="string">" World"</span>);</span><br><span class="line">s.append(<span class="string">" !"</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// 输出字符串 “Hello World !”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(int index，String str); 将一个字符串插入到另一个字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse(); 颠倒 StringBuffer 对象中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete(int startIndex,int endIndex); 调用对象中删除一串字符</span></span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>体会：写之前我是怎么也没想到这个点的内容量如此之多，很多细节知识都需要好好体会。所以说，在平时的学习过程中真的不能小瞧任何一个知识点，要保持敢钻的态度！</p><ul><li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li><li>『 jdk1.8.0_231 源码 』</li><li>『 <a href="https://blog.csdn.net/xialei199023/article/details/63251366" target="_blank" rel="noopener">重新认识Java——字符串（String）</a> 』</li><li>『 <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">深入理解Java中的String</a> 』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-String/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;（String）是由零个或多个字符（char）组成的有序序列。学过 C/C++ 的人会有一种固定的思维模式，凡是字符串都是以 &lt;code&gt;\0&lt;/code&gt; 结束。但是 java 却不同，要知道 java 里始终秉承的一句话 『&lt;strong&gt;everything is object&lt;/strong&gt;』，字符串也不例外，它也被作为 String 类型的对象处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核设计 | （1）从开机到 main 函数执行</title>
    <link href="http://www.thebetterkong.cn/2020/06/29/Linux/LinuxKernelDesign-1.PowerOnToMainFunction/"/>
    <id>http://www.thebetterkong.cn/2020/06/29/Linux/LinuxKernelDesign-1.PowerOnToMainFunction/</id>
    <published>2020-06-29T08:04:25.000Z</published>
    <updated>2020-08-14T09:32:26.816Z</updated>
    
    <content type="html"><![CDATA[<p>这里提到的 linux 版本是 0.11，在当时，操作系统都是存在软盘里的，而 CPU 的逻辑电路被设计为只能运行内存中的程序。电路刚通电时，内存（RAM）里什么都没有，那么计算机是怎样将操作系统运行起来的呢？</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里约定的计算机是基于 IA-32 系列 CPU，安装了标准单色显示器、标准键盘、一个软盘、一块硬盘、16 MB 内存，在内存中开辟了 2 MB 内存作为虚拟盘，并在 BIOS 中设置软驱为启动设备。    </p><p>为什么选 Linux 0.11 内核？</p><ul><li>Linux 0.11 内核代码虽然只有约两万行，但却实实在在的撑起了一个现代OS，更便于初学者学习理解；</li><li>它是 Linux 其他后续版本的鼻祖，这样我们能更容易的看清设计者最初的、最根本的设计意图和设计指导思想；</li></ul><p>系列参考资料：</p><ul><li>《Linux 内核设计的艺术-图解 Linux 操作系统架构设计与实现原理（第 2 版）》</li><li>《IA-32-3》</li><li>《Linux 内核完全注释》- 内核版本0.11 - 赵炯</li></ul><p>说明：该系列是本人结合国科大相关课程总结的笔记心得，按书籍教程主要分为三大部分：</p><ol><li>分析从开机加电到 OS 启动完成并进入怠速状态的整个过程：<ul><li>开机加电启动 BIOS，通过 BIOS 加载操作系统程序，对主机的初始化，打开保护模式和分页，调用 main 函数，创建进程 0、进程 1、进程 2 以及 shell 进程，并且具备用文件的形式与外设交互。</li></ul></li><li>OS 进入系统怠速后，在执行用户程序的过程中，OS 和用户进程的实际运行过程和状态：<ul><li>利用几个设计好的简单的又具有代表性的应用程序，以其执行作为引导，详细讲解安装文件系统、文件操作、用户进程与内存管理、多个进程对文件的操作以及进程间的通信。</li></ul></li><li>整个 Linux 的设计指导思想，从微观到宏观的回归分析：<ul><li>重点部分：详细阐述主奴机制以及实现主奴机制的三项关键技术（保护和分页、特权级、中断），分析保障主奴机制实现的决定性因素—先机，详细讲解缓冲区、共享页面、信号、管道的设计指导思想。（作者尝试从操作系统设计者的视角讲解操作系统的设计指导思想。希望帮助读者用体系的思想理解、把握、驾驭整个操作系统以及背后的设计思想和设计意图）</li></ul></li></ol><h1 id="BIOS-启动"><a href="#BIOS-启动" class="headerlink" title="BIOS 启动"></a>BIOS 启动</h1><p>前面说到 CPU 只能执行内存里的程序，而刚通电时，计算机内存为空，OS 处在软盘。那么，自然就需要由某个部分将 OS 加载到内存，而完成这项工作的就是 <strong>BIOS</strong>。    </p><p>问题就来了，BIOS 自身也是一段程序，那它最开始又是如何执行的呢？      </p><p>这一过程得益于硬件 CPU 强制执行 BIOS。CPU 都被设计为<strong>加电即进入 16 位实模式状态运行</strong>，其硬件逻辑在加电瞬间就会设置 CS（<code>0xF000</code>）和 IP（<code>0xFFF0</code>），这样 CS:IP 也就指向 <strong><code>0xFFFF0</code></strong> 这个地址，而这里就处在 BIOS 中，是 <strong>BIOS 程序的入口地址</strong>。    </p><div class="note warning"><ul><li>CPU 将要执行的指令的内存地址是由 IP（偏移）和 CS（段基址）组合来指定。实模式下该地址为绝对地址，指令指针为 16 位；保护模式下为线性地址，指令指针为 32 位，即 EIP。    </li><li>BIOS 是固化在计算机主板上一块很小的 ROM 芯片里的程序。不同主板会有所不同，这里的 BIOS 是 8KB，所占地址段为 <code>0xFE000 ~ 0xFFFFF</code>。</li></ul></div><h1 id="BIOS-执行"><a href="#BIOS-执行" class="headerlink" title="BIOS 执行"></a>BIOS 执行</h1><p>BIOS 启动后，开始执行一系列 BIOS 代码，完成自检等操作。检测显卡、内存等，并在屏幕上显示这些机器系统数据（显卡信息、内存信息等）。而这个过程需要重点说的就是：<strong>BIOS 在内存里建立中断向量表和中断服务程序</strong>。     </p><p>具体来说就是：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Mem-BIOS.png" alt="Mem-BIOS"></p><ul><li>在 <code>0x00000 ~ 0x003FF</code> 这 1 KB 的内存空间里构建<strong>中断向量表</strong>；<ul><li>一共有 256 个中断向量，每个占 4 B（2 B 为 CS 的值，2 B 为 IP 的值）；</li></ul></li><li>在紧接着的 <code>0x00400 ~ 0x004FF</code> 这 256 B 的内存空间里构建 <strong>BIOS 数据区</strong>（存放机器系统数据）；</li><li>在接着大约 57 KB 之后的位置 <code>0x0E05B</code> 处加载了 8 KB 左右的与中断向量表相对应的<strong>中断服务程序</strong>；</li></ul><p>在上述自检过程完成后，计算机硬件（体系结构的设计）和 BIOS 一同产生一个 <strong><code>int 0x19</code></strong> 中断。CPU 收到此中断后，查找中断向量表，并找到 <code>int 0x19 中断向量</code>。这个中断向量就将 CPU 指向 <strong><code>0x0E6F2</code></strong> 这个地址执行（<code>int 0x19</code> 对应的中断服务程序的入口地址）。这个中断服务程序是 BIOS 事先设计好的（代码固定，与 OS 无关），它的工作就是：<strong>把软盘第一扇区中的程序 <code>bootsect.s</code>（512 B，因此两个扇区为 1 KB）加载到内存指定位置（<code>0x07C00</code>）</strong>。    </p><div class="note warning"><p>这个过程就需要 OS 设计者和 BIOS 的设计者完成一种两头约定：   </p><ul><li>操作系统：必须把最开始执行的程序 “定位” 在启动扇区（软盘中的 0 盘面 0 磁道 1 扇区）；   </li><li>BIOS：“约定” 接到启动操作系统的命令，就 “定位识别” 只从启动扇区把代码加载到 <code>0x7C00</code>（BOOTSEG）这个位置；</li></ul></div><h1 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h1><p>在实模式下，指令指针 CS 和 IP 都是 16 位的，它们组合的内存寻址最大范围为 1 MB（20 位）。而 <strong>bootsect.s 首先的工作就是对这 1 MB 的内存空间进行规划</strong>，来确保后续代码的加载与已加载的代码互不干扰，并且都有足够大的内存空间可用；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemPlanning-bootsect.png" alt="MemPlanning-bootsect"></p><ul><li>bootsect.s 的开头会设定一段代码来设置相应的内存位置：<ul><li>将要加载的 setup 程序的扇区数（<code>SETUPLEN</code>）以及它要被加载到的位置（<code>SETUPSEG</code>）；</li><li>启动扇区 bootsect 被 BIOS 重新加载的位置（<code>BOOTSEG</code>）及将要移动到的新位置（<code>INITSEG</code>）；</li><li>内核（kernel）被加载的位置（<code>SYSSEG</code>）、内核的末尾位置（<code>ENDSEG</code>）；</li><li>根文件系统设备号（<code>BOOT_DEV</code>）；    </li></ul></li></ul><p>接着，booesect 按之前的内存规划将自己全部（512 B）的内容从 <code>0x07C00</code>（<code>BOOTSEG</code>） <strong>拷贝到新的内存位置</strong> <code>0x90000</code>（<code>INITSEG</code>）。    </p><ul><li>由于之前说过的 OS 设计和 BIOS 设计的约定，才会在开始时 bootsect 被迫被加载到 <code>0x07C00</code> 的位置。现在将自身拷贝的 <code>0x90000</code> 处，则说明 OS 已经开始根据自身需要安排内存了；</li></ul><p>拷贝完成后，但是 CPU 的 CS 还在原先的 <code>0x07C0</code>（BOOTSEG）处，于是需要<strong>修改 CS</strong> 值为 <code>0x9000</code>（INITSEG），并<strong>修改 IP</strong> 偏移值至下一条指令。这样，使程序在新的地方接着原先的过程执行。此时，代码整体位置改变，代码中的各个段也会随之改变，所以还需要<strong>设置 DS、ES、SS、SP 的值</strong>。这也是个分水岭，至此，程序可以开始执行更为复杂的数据运算类指令。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/JumpAndSSSPDSES-bootsect.png" alt="JumpAndSSSPDSES-bootsect">   </p><p>接下来，bootsect 还需要负责<strong>将 os 剩余的代码（<code>setup.s</code> 和 <code>system 模块</code>）拷贝进内存中</strong>。整个拷贝过程分两次进行：</p><ul><li>拷贝 <code>setup.s</code>：<ul><li><strong>传参</strong>：事先将指定的扇区、加载的内存位置等信息传递给服务程序；</li><li>参数传递完毕后，<strong>执行 <code>int 0x13</code> 指令</strong>，产生 <code>int 0x13</code> 中断，通过中断向量表找到对应的中断服务程序（<code>0x0E6FE</code>），将软盘<strong>第二个扇区开始的 4 个扇区（setup.s，2 KB）加载至内存的 SETUPSEG（0x90200）处</strong>，紧挨着重新拷贝后的 bootset.s；（注意：它还不足以影响到栈的内存空间）；</li></ul></li><li>拷贝 <code>system 模块</code>（包括 head.s 和 main 函数开始的 os 内核程序）：<ul><li>bootsect 同样借助 BIOS 的 <code>int 0x13</code> 中断，<strong>调用 <code>read_it</code> 子程序</strong>，将软盘第六扇区开始的 <strong>240 个扇区</strong>的 sysytem 模块加载至内存的 <strong>SYSSEG（0x10000）处</strong>往后的 <strong>120 KB 空间</strong>中；</li><li>整个加载过程时间较长，所以也会有一段用汇编编写的程序，使显示器显示 “Loading system…”，也涉及到其他 BIOS 中断；</li></ul></li></ul><div class="note warning"><ul><li><strong>system 模块</strong>是整个 OS 的核心部分，它由两部分构成：head.s 和 main 函数。</li><li><strong>head.s</strong> 同之前加载的 bootsect.s 和 setup.s 一样，是由汇编代码生成的程序，它处在 system 的开头位置，在内存中占有 25 KB + 184 B 的空间；</li><li><strong>main 函数</strong>紧接着 head.s 存在，它是由 c 语言编写的内核程序，可以说它才是真正的操作系统，在它之前执行的 bootsect.s、setup.s 和 head.s 都是为它做准备的；</li><li>这种特殊性，也让 syetem 模块和 bootsect.s、setup.s 的加载方式不同。<strong>大致的过程</strong>是：先将 head.s 汇编成目标代码，将用 c 语言编写的内核程序编译成目标代码，然后再将它们链接成 system 模块。</li></ul></div><p>至此，<mark>整个 OS 的代码都已被加载进内存</mark>。最后，由 bootsect 确认根设备号。根据开始处假设的计算机组成，这里经过一系列检测后，会确认计算机中实际安装的软盘驱动器为根设备，并将此信息写入机器系统数据。    </p><p>bootsect.s 的工作已全部完成。</p><h1 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h1><p>在 bootsect.s 完成它所有的任务后，会<strong>执行 <code>jmpi 0,SETUPSEG</code> 跳转</strong>至 <code>0x90200</code> 处（setup.s 所在的位置），也即 CS:IP 指向 setup 程序的第一条指令，<strong>setup.s 开始执行</strong>。</p><p>首先，setup.s 会利用 BIOS 提供的中断服务从设备上<strong>提取内核运行所需的机器系统数据 510 B</strong>（注意这里加载的不是 BIOS 数据区里的），并将这些数据加载到内存的 <code>0x90000 ~ 0x901FC</code> 位置。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/LoadMachineSystemData-setup.png" alt="LoadMachineSystemData-setup"></p><ul><li>注意：加载的这部分机器系统数据是覆盖了原先已经执行完的 512 B 的 bootsect.s，只有 2 B 未被覆盖，这样很好的利用了内存空间，使内存利用率更高；</li></ul><p>至此，<mark>整个操作系统内核程序所需的加载工作都已完成，通过内存中的这些代码数据，将开始实现从实模式到保护模式的转变</mark>。</p><p>之前，我们所有用到的中断服务都是由 BIOS 提供，而之后 OS 会接管整个系统，它自身也会提供一套的中断服务系统。为了完全这个转变，不让接下来的工作出错，此时就得<strong>先关中断（cli）</strong>。即：<strong>将 CPU 的标志寄存器（EFLAGS）中的中断允许标志（IF）置 0</strong>；</p><div class="note warning"><ul><li>关中断（cli）和开中断（sti）它们在 OS 里总是成对出现的，目的就是为了防止中断在某个过程中介入；   </li><li>此处，即将进行的是实模式下中断向量表和保护模式下中断描述符表（IDT）的交接。如果在此期间，用户不小心碰到键盘等引入了中断，就会导致不可预估的后果；</li></ul></div><p>接下来，setup 程序会<strong>将位于 <code>0x10000</code> 的内核程序复制至内存的起始地址 <code>0x00000</code> 处</strong>（由 DS 和 ES 配合完成）。</p><ul><li>这个过程也就意味着，原先 BIOS 提供的中断向量表、BIOS 数据区以及相应的中断服务程序都完全被覆盖，旧的中断体系已经失效，系统准备向 32 位的保护模式转变；</li></ul><p>然后，setup 程序利用自身提供的数据信息<strong>对中断描述符表寄存器（IDTR）和全局描述符表寄存器（GDTR）进行初始化设置</strong>，进而完成<strong>中断描述符比表（IDT）和全局描述符表（GDT）的初始化</strong>；   </p><div class="note "><ul><li><strong>GDT（全局描述符表）</strong>：是一个存放段寄存器内容（段描述符）的数组，用来配合程序进行保护模式下的段寻址。在 OS 中进程切换具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务（task）局部描述符表（LDT）地址和任务状态段（TSS）地址，完成进程中各段的寻址、现场保护与现场恢复；   </li><li><strong>GDTR（GDT 基址寄存器）</strong>：GDT 可以存放在内存中任意位置，而 GDTR 的内容就是标识 GDT 的入口地址；</li><li><strong>IDT（中断描述符表）</strong>：保存保护模式下所有中断服务程序的入口地址；</li><li><strong>IDTR（IDT 基址寄存器）</strong>：保存 IDT 起始地址；</li></ul></div><ul><li>这个过程可以理解为：内核设计时，已经将两个表（包括所需的初始数据）写好，随着 OS 代码一起已经被加载到了内存，之后程序通过 <code>lidt</code> 和 <code>lgdt</code> 指令将两个专用寄存器指向这两个表（即 idt_48 和 gdt_48 对应的标号处）即可；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetGDTRAndIDTR.png" alt="SetGDTRAndIDTR"><ul><li>由图可以看到：IDTR 指向了 <code>0x00000</code> 位置（IDT 基址），此时出于关中断状态，IDT 还是一张空表；</li><li>GDTR 指向了 <code>0x90200+</code> 位置（现在创建的 GDT 基址），此时内核还未运行没有进程，GDT 的内容也就如图所示，其余项全为空；</li></ul></li></ul><p>接下来的工作就是：<strong>打开 A20</strong>，<strong>这也就意味着 CPU 可以进行 32 位寻址，最大寻址空间为 4 GB</strong>。下图显示了此时内存寻址空间的变化（注意区别）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemAddressingChange.png" alt="MemAddressingChange"></p><ul><li>此时，物理地址空间虽然受限于 16 MB，但是其线性地址空间已经变成了 4 GB；</li><li>实模式下，CPU 寻址范围为 <code>0 ~ 0xFFFFF</code>，共 1 MB，需要 0 ~ 19 号（20 根）地址线。进入保护模式，使用 32 位寻址，自然也就需要打开剩余的 20 ~ 31 号地址线；</li><li>实模式下，CS 和 IP 的最大值都为 <code>0xFFFF</code>，这两者组合而成的最大绝对地址为 <code>0x10FFEF</code>（16*CS+IP），而此时 CPU 最大寻址为 <code>0xFFFFF</code>。对于超出的这 16 KB 地址，CPU 会将其 “回滚” 至内存起始处寻址。而启用 A20 后，相当于关闭了 CPU 在实模式下的 “回滚” 机制，也就正好可以利用这个特点验证 A20 地址线是否已经打开；</li></ul><p>为了建立保护模式下的中断机制，setup 开始<strong>对可编程中断控制器 8259A 进行重新编程</strong>；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Pragram8259A.png" alt="Pragram8259A">    </p><p>之后，setup 还需要<strong>将 CR0（0 号 32 位控制寄存器，存放系统控制标志）寄存器的第 0 位（PE）置 1</strong>，即开启 CPU 的工作方式为保护模式；此后，寻址方式变化如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/ChangeToAddressing.png" alt="ChangeToAddressing">    </p><p>至此，setup 的工作全部完成，它还有最后一行<strong>代码 <code>jmpi 0,8</code>，跳转至 head 程序起始地址开始执行</strong>；</p><ul><li>关于 <code>0,8</code>，对应到二进制也就为：<code>0000,1000</code>：<ul><li>最后两位 <code>00</code>：表示内核特权级，对应的 <code>11</code> 就是用户特权级，其他形式无效；</li><li>第三位 <code>0</code>：表示 GDT，如果为 <code>1</code> 则表示 LDT；</li><li>再接下来的 <code>1</code>：表示所选的表（GDT）的 1 项（GDT 表项从 0 开始）；</li><li>由这些信息就可以推算出：<strong>内核代码段（0x08）、内核数据段（0x10）、用户代码段（0x17）、用户数据段（0x0F）</strong>；</li></ul></li><li>再对整个的跳转指令寻址进行解读：<ul><li><code>jmpi 0,8</code>：它是处在内核级，会选择 GDT 的 1 项（代码段），这一项的解读如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/GDT1item.png" alt="GDT1item"></li><li>由此确定段基址为 <code>0x00000000</code>，偏移为 0，也即 head 程序的起始位置处；</li></ul></li></ul><h1 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h1><p>经过前面一连串的准备工作，这里终于进入到了 system 模块，但是这并不意味着就进入到了 main 函数的执行。前面加载时说过，在 system 模块的开头还有一段叫做 head.s 的代码。此时的 system 在内存的分布情况如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SystemInMem.png" alt="SystemInMem">      </p><p>head 程序的除了<strong>做一些调用 main 函数的准备工作</strong>之外，还会<strong>用程序自身的代码在程序自身所在的内存空间创建内核分页机制</strong>，即在 <code>0x000000</code> 的位置创建页目录表、页表、缓冲区、GDT、IDT，并将 head 程序已经执行过的代码所占内存空间覆盖（自身边执行，边自我覆盖）。具体过程如下：</p><p><strong>标号 <code>_pg_dir</code></strong> 标识内核分页机制完成后的内核起始位置，即物理内存起始位置 <code>0x000000</code>；</p><p>前面的 <code>jmpi 0,8</code>，已经使得 CS 和 GDT 第二项关联（CS 不再是代码段基址而是代码段选择符），并且使代码段基址指向 <code>0x000000</code>。相应的，也需要<strong>修改 DS、ES、FS 和 GS 的值为 0x10</strong>（内核数据段）；具体内容如下图：<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS-head.png" alt="DSESFSGS-head"></p><p><strong>SS</strong> 也需要变为栈段选择符（也是 <code>0x10</code>），栈顶指针也由 16 位的 SP 变为 32 位的 <strong>ESP</strong>（并且起始位置大概在 <code>0x1E25C</code>）<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SSESP-head.png" alt="SSESP-head">   </p><p><strong>设置 IDT，搭建中断机制的整体框架</strong>，具体内容如下：</p><ul><li>IDT 有 256 个表项，每个表项占 64 位，因此其大小为 2 KB。每个表项（中断描述符）结构如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/InterruptDescriptor.png" alt="InterruptDescriptor"></li><li>设置相关的 IDT 寄存器：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/IDT-head.png" alt="IDT-head"></li><li>让所有的中断描述符默认指向 ignore_int 这个位置（将来 main 函数再让中断描述符对应到具体的中断服务程序），即此时所有的中断服务程序都是指向同一段只显示一行提示信息就返回的服务程序（这样，既可以避免无意中覆盖代码数据，也可给开发过程中的误操提供提示）；</li></ul><p><strong>废除旧的 GDT，并在内核新的位置重新创建 GDT</strong>：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/RebuildGDT-head.png" alt="RebuildGDT-head"></p><ul><li>重新设置一方面是设置新的位置，另一方面是修改段限长，这样做的目的也明显：旧 GDT 由 setup.s 设置，处在 <code>0x90200+</code> 的位置，而现在它已经执行完毕，未来它所处的内存位置必然会被替换为别的用途（缓冲区），这样只好重新将它放在 head.s 已经执行完的位置最好，物尽其用。</li></ul><p>段限长被修改了，那么相应的 <strong>DS、ES、FS、GS 及 SS</strong> 的段选择符也需要重新设置（再来一遍 <code>0x10</code>，重新加载 GDT 相应表项，这只是在原有基础上将<strong>段限长扩大为 16 MB</strong>，其他内容并未发生改变）；ESP 不需要；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS2-head.png" alt="DSESFSGS2-head">    </p><p><strong>检验 A20 地址线是否打开</strong>，检验方法就是之前提及的 “回滚法”，具体如下：</p><ul><li>通过在内存 <code>0x000000</code> 位置写入一个数据，然后比较此处和 1 MB（<code>0x100000</code>，已超过实模式寻址范围）处数据是否一致；</li></ul><p>head 程序如果检测到数学协处理器，则将其设置为保护模式工作状态；</p><ul><li>486 处理器以前，为弥补 CPU 浮点运算不足设置的外置可选芯片。486 处理器之后，CPU 就都基本内置了协处理器，也就不需要此步；</li></ul><p>接下来，就是 head.s <strong>为调用 main 函数做最后的准备工作</strong>：</p><ul><li><strong>将 envp、argv、argc 压栈：将 L6 标号（也就是 main 函数异常退出后返回的执行位置）和 main 函数入口地址压栈</strong>。此时，栈顶为 main 函数的入口地址，这样在 head.s 执行完毕后，就可以直接通过 ret 指令执行 main 函数；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PushForMain.png" alt="PushForMain"></li><li>压栈完成后，head.s 跳转至 <code>setup_paging:</code> 执行，开始<strong>创建分页机制</strong>（下面创建的 4 个页表是内核专属页表，将来每个用户进程也会有它们自己的专属页表）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetPageTable.png" alt="SetPageTable"></li><li>页表设置完毕，但分页机制还没完全建立，还需要<strong>设置页目录表基址寄存器 CR3</strong>（3 号 32 位控制寄存器，高 20 位存放页目录表基址，当 CR0 的 PG=1 时，CPU 使用 CR3 指向的页目录表和页表进行虚拟地址到物理地址的映射）<strong>使之指向页目录表</strong>，再将 <strong>CR0 寄存器的最高位（PG</strong>，分页机制控制位，它必须在 PE=1 的保护模式下才能开启）<strong>置 1</strong>。此时分页机制完成后，总体状态如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PageTableStatus.png" alt="PageTableStatus"><ul><li>注意：标号 pg_dir 标识的 <code>0x0000</code> 这个位置是内核通过分页机制能够实现线性地址等于物理地址的唯一起始位置；</li></ul></li><li>此时的内存分布情况如下（注意 head.s 的大小和内存分布的情况）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemDistribution-head.png" alt="MemDistribution-head"></li></ul><p>现在，就是 head.s 的最后一步，<strong>通过 ret 指令，将压入栈的 main 函数的执行入口地址弹出给 EIP</strong>，跳入 main 函数开始执行；</p><ul><li>这里需要说明一下，OS 的 main 函数和其他普通函数的调用过程不太一样；</li><li>通常函数：都是通过 call 指令调用，它会将 EIP 的值自动压栈，保护返回现场，然后执行被调函数的程序。等到执行被调函数的 ret 指令时，自动出栈给 EIP 并还原现场，继续执行 call 的下一条执行；</li><li>而操作系统则不同，它是用 ret 实现的调用操作系统的 main 函数。事先由 OS 的设计者手工编写代码压栈（压栈的 EIP 值为 main 函数的入口地址）和跳转，来模仿 call 的全部动作，进而去调用 <code>setup_paging</code> 函数。然后，当 <code>setup_paging</code> 函数执行到 ret 时，从栈中将 main 函数的入口地址 _main 弹出给 EIP，构成 CS:EIP，这也就等价于 CPU 开始执行 main 函数程序；</li></ul><p>之后，操作系统 main 函数开始执行，但是注意：此时仍然是关中断的状态！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里提到的 linux 版本是 0.11，在当时，操作系统都是存在软盘里的，而 CPU 的逻辑电路被设计为只能运行内存中的程序。电路刚通电时，内存（RAM）里什么都没有，那么计算机是怎样将操作系统运行起来的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.thebetterkong.cn/categories/Linux/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux Kernel" scheme="http://www.thebetterkong.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之线性表</title>
    <link href="http://www.thebetterkong.cn/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/"/>
    <id>http://www.thebetterkong.cn/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/</id>
    <published>2020-06-27T06:23:33.000Z</published>
    <updated>2020-08-14T09:28:07.995Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/header.png" width="100%" alt="header.png" /> </div>  <p><strong>线性表</strong>（Linear List）是最简单也是最常用的一种数据结构。简言之，线性表是 n 个数据元素的有限序列。每个数据元素可以使一个数或一个符号，也可以是一页书，甚至其他更加复杂的信息。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>依据数据元素之间的关系，线性表主要有两种实现方式：<strong>顺序存储</strong>、<strong>链式存储</strong></p><ul><li>顺序存储结构：是依靠<strong>元素在存储器中的相对位置</strong>来表示数据元素之间的逻辑关系；</li><li>链式存储结构：是<strong>依靠指针</strong>（Java 为引用）来表现数据元素之间的逻辑关系；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/TwoStructure.png" alt="TwoStructure"></p><p>接着，我们来看一下线性表在 java 集合里的对应部分：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinearListInJavaSet.png" alt="LinearListInJavaSet">   </p><p>图中阴影部分就是和线性表相关的接口和类，其中红色标明的是重点。</p><h1 id="顺序表（ArrayList）"><a href="#顺序表（ArrayList）" class="headerlink" title="顺序表（ArrayList）"></a>顺序表（ArrayList）</h1><p>顺序表中的<strong>数据元素存储是连续的</strong>，<strong>内存划分的区域也是连续的</strong>。其存储结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/SequenceTableExample.png" alt="SequenceTableExample">      </p><p>而顺序表对应到 java 中的实现就是：<strong>ArrayList 类</strong></p><ul><li>它是利用<strong>大小可变的数组</strong>来实现的 <strong>List 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li><li>此类<strong>与 Vector 大致等效</strong>，但它是<strong>不同步</strong>的；</li><li><code>size</code>、<code>isEmpty</code>、<code>get</code>、<code>set</code>、<code>iterator</code> 和 <code>listIterator</code> 操作在恒定时间内运行。加法运算以固定的固定时间运行，即添加 n 个元素需要 $O(n)$ 时间。所有其他操作均以线性时间运行（大致而言）。与 LinkedList 实现相比，常数因子较低；</li><li>每个 ArrayList 实例都有一个<strong>容量</strong>；<ul><li>容量:是用于在列表中存储元素的数组的大小,它总是至少与列表大小一样大；</li><li>将元素添加到 ArrayList 时，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定增长策略的详细信息；</li><li>应用程序可以使用 <code>ensureCapacity</code> 操作在添加大量元素之前增加 ArrayList 实例的容量。这可以减少增量重新分配的数量；</li></ul></li><li>此类是 Java Collections Framework 的成员；</li><li><strong>擅长随机访问</strong>，查找速度快，添加删除操作慢；</li></ul><p>ArrayList 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ArrayList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;...&#125;     <span class="comment">// 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;...&#125;                        <span class="comment">// 构造一个初始容量为 10 的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;   <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>;              <span class="comment">// 将此 ArrayList 实例的容量调整为列表的当前大小。应用程序可以使用此操作来最小化 ArrayList 实例的存储。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>;   <span class="comment">// 手动增加此 ArrayList 实例的容量，以确保它至少可以容纳最小容量参数指定的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回动态数组里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;              <span class="comment">// 动态数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 动态数组是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 设定指定位置的元素值，执行完毕会返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向动态数组的末尾添加元素（实现时，先用 ensureCapacityInternal 函数扩容，再添加）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向动态数组的指定位置添加元素，index 位置元素和其后面所有元素后移一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 将指定集合中的所有元素按指定集合的Iterator返回的顺序追加到此列表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此列表</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 删除指定位置的元素，并且该位置后面的元素全部左移一个位置，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 删除首次出现的对象 o，如果不存在，则不进行任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除指定集合中包含的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除所有未包含在指定集合中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 清空动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回动态数组里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回动态数组里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;                 <span class="comment">// 返回动态数组实例的拷贝，数组里的元素没有被复制</span></span><br><span class="line"></span><br><span class="line">Object[] toArray();             <span class="comment">// 分配一个新数组来（按原顺序）存储该动态数组里的所有元素，调用者可以随意修改返回的数组</span></span><br><span class="line">T[] toArray(T[] a);             <span class="comment">// 转化到指定数组，但是该数组必须足够大，否则会分配一个新的数组</span></span><br></pre></td></tr></table></figure></p><h1 id="链表（LinkedList）"><a href="#链表（LinkedList）" class="headerlink" title="链表（LinkedList）"></a>链表（LinkedList）</h1><p>链表的特点是用一组<strong>任意的存储单元存储线性表的数据元素</strong>（这组存储单元可以是连续的，也可以不连续）。链表的结点通常包含：<strong>数据域、指针域</strong>，数据域用来存储数据信息，指针域则负责将这些结点串接成一个链式结构。   </p><p>链表又通常有三种表示结构，如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinkedListExample.png" alt="LinkedListExample">    </p><p>链表对应到 java 里的实现就是：<strong>LinkedList 类</strong></p><ul><li>它是利用<strong>双链表</strong>实现的 <strong>List 和 Deque 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li><li>所有操作都执行双链表所期望的操作：索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的位置为准；</li><li>此实现<strong>未同步</strong>；</li></ul><p>LinkedList 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;       <span class="comment">// 构造一个空链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;  <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回链表里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 链表是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回链表里指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;                   <span class="comment">// 返回链表里第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;                    <span class="comment">// 返回链表里最后一个元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 用指定元素取代链表里指定位置的元素，并返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;                <span class="comment">// 移除并返回链表第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;                 <span class="comment">// 移除并返回链表最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 移除链表里指定元素首次出现的结点，如果没有，链表不变</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 移除并返回指定位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;             <span class="comment">// 向链表开头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;              <span class="comment">// 向链表末尾插入指定元素，等效于 add 方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向链表指定位置插入指定元素，该位置和后续元素会被后移</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 移除链表里所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回链表里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回链表里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 下面的函数是用来实现栈和队列时所用；</span></span><br><span class="line"><span class="comment">* 这里可以先不关注，在后面讲解栈和队列时再回来查看</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue operations.</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 移除并返回队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 移除并返回队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列末尾添加指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;        <span class="comment">// 向双端队列头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;         <span class="comment">// 向双端队列尾插入指定元素</span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;                  <span class="comment">// 返回但不删除双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;                   <span class="comment">// 返回但不删除双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;                  <span class="comment">// 移除并返回双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;                   <span class="comment">// 移除并返回双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack operations</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;                 <span class="comment">// 用链表实现，元素入栈</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>;                        <span class="comment">// 用链表实现，元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure></p><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p>栈是一种特殊（操作受限）的线性表。它仅允许在线性表的尾部进行添加和删除操作，这一端被称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。向一个栈添加新元素叫<strong>压栈</strong>，删除元素又称为<strong>出栈</strong>。<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/StackExample.png" alt="StackExample">    </p><p>栈对应到 java 里的实现就是：<strong>Stack 类</strong></p><ul><li>Stack 类表示对象的后进先出（<strong>LIFO</strong>）堆栈；</li><li>它通过五个操作<strong>扩展了 Vector 类</strong>，这些操作允许将 Vector 视为 Stack：<ul><li>提供了通常的 push 和 pop 操作；</li><li>peek 堆栈顶部元素的方法；</li><li>用于测试堆栈是否为空的方法；</li><li>用于在堆栈中搜索元素并发现其距顶部距离的方法；</li></ul></li><li>首次创建堆栈时，它不包含任何项目；</li><li><code>{@link Deque}</code> 接口及其实现提供了一组更完整和一致的 LIFO 堆栈操作，应优先使用此类。 例如：<code>{@code Deque stack = new ArrayDeque（）;}</code></li></ul><p>Stack 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Stack</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造一个空栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span></span>;          <span class="comment">// 向栈顶压入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span>;    <span class="comment">// 将栈顶元素弹出并返回该对象，栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span></span>;   <span class="comment">// 返回栈顶元素（不删除），栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>;         <span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>;   <span class="comment">// 返回该元素距离栈顶的位置（栈顶元素返回 1）；如果栈里不存在该元素返回 -1</span></span><br></pre></td></tr></table></figure></p><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列也是一种操作受限制的线性表。只能从<strong>队头</strong>取出（删除）元素，从<strong>队尾</strong>添加元素，其结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueExample.png" alt="QueueExample"></p><p>它在 java 中比较特殊，只是一个接口：<strong>Queue</strong></p><ul><li>它只是一个<strong>接口</strong>，代表了我们通常理解的 <strong>FIFO 队列</strong>（通常利用 LinkedList 实现），但这不是绝对的，例外情况包括：<strong>优先级队列</strong>（根据提供的比较器对元素进行排序或元素的自然排序）和 <strong>LIFO 队列</strong>（或堆栈）；<ul><li>无论使用哪种顺序，队列的开头都是该元素，可以通过调用 <code>remove()</code> 或 <code>poll()</code> 来删除该元素。在 FIFO 队列中，所有新元素都插入队列的尾部。其他种类的队列可能使用不同的放置规则；</li><li>每个 Queue 实现都必须指定其排序属性；</li></ul></li><li>Queue 实现<strong>通常不允许插入 <code>null</code> 元素</strong>，尽管某些实现（例如：<code>LinkedList</code>）不禁止插入 <code>null</code>；<ul><li>即使在允许的实现中，也不应将 <code>null</code> 插入 Queue 中，因为 <code>poll</code> 方法将 <code>null</code> 用作特殊的返回值，以指示队列不包含任何元素；</li></ul></li><li>Queue 实现通常不定义方法 <code>equals</code> 和 <code>hashCode</code> 的基于元素的版本，而是从类 <code>Object</code> 继承基于身份的版本，因为基于元素的相等性并不总是对于元素相同但排序属性不同的队列，定义明确。</li><li>该接口是 Java Collections Framework 的成员。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queue</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们通常用的 FIFO 队列是基于 LinkedList 实现的</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> LinkedList(); <span class="comment">// 相关方法的实现可见 LinkedList 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************接口声明的方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，可能抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，此方法更可取</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 返回并删除此队列的头，如果此队列为空，它将引发异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 返回并删除此队列的头，队列为空时，返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队头，如果队列为空，抛异常</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队头，如果队列为空，返回 null</span></span><br></pre></td></tr></table></figure><p>java 里 Queue 的家族还是很大的，但是很多我们也不常用，我做了个简单的整理如下（图片较乱）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueStructure.png" alt="QueueStructure"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li><li>『 jdk1.8.0_231 源码 』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-LinearList/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;（Linear List）是最简单也是最常用的一种数据结构。简言之，线性表是 n 个数据元素的有限序列。每个数据元素可以使一个数或一个符号，也可以是一页书，甚至其他更加复杂的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>查找算法（详解 + java 实现）</title>
    <link href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/"/>
    <id>http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/</id>
    <published>2020-06-15T04:53:23.000Z</published>
    <updated>2020-08-14T09:29:03.045Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  <p><strong>查找</strong>（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>查找表是由同一类型的数据元素（或记录）构成的集合。由于 “集合” 中的元素之间存在着完全松散的关系，因此它是一种非常灵便的数据结构。     </p><p>针对查找表，常涉及的操作如下：</p><ul><li>查询某个 “特点的” 数据元素是否在查找表中；</li><li>检索某个 “特定的” 数据源是的各种属性；</li><li>在查找表中插入或删除一个数据元素；</li></ul><h2 id="查找算法的分类"><a href="#查找算法的分类" class="headerlink" title="查找算法的分类"></a>查找算法的分类</h2><ul><li><strong>静态查找</strong>：对查找表的操作只涉及前两种 “查找” 操作；</li><li><strong>动态查找</strong>：在查找的过程中同时会涉及插入和删除操作；</li><li><strong>有序查找</strong>：被查找的数据元素必须有序；</li><li><strong>无序查找</strong>：被查找的数据元素有序无序均可；</li></ul><p>下面是常见查找算法的分类情况：</p><ol><li>静态查找：<ul><li>顺序表的查找：顺序查找、分块查找（索引顺序查找）</li><li>有序表的查找：折半查找（二分查找）、斐波那契查找、插值查找</li></ul></li><li>动态查找：<ul><li>二叉排序树和平衡二叉树查找</li><li>B- 树和 B+ 树查找</li><li>键树查找</li></ul></li><li>哈希查找：</li></ol><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>平均查找长度</strong>（Average Search Length）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度；    </p><p>对于含有 n 个记录的表，查找成功时的平均查找长度为：   </p><script type="math/tex; mode=display">ASL\ =\ \sum^n_{i=1}\ P_iC_i</script><p>其中：</p><ul><li>$P_i$ 为查找表中第 i 个记录的概率，且 $\sum^n_{i=1}\ P_i=1$；</li><li>$C_i$ 为找到表中期关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。它随查找过程不同而不同；</li></ul><h1 id="静态线性表查找"><a href="#静态线性表查找" class="headerlink" title="静态线性表查找"></a>静态线性表查找</h1><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DataStructure.png" alt="DataStructure"> </p><p>线性表中的元素一旦有序，就可以称为有序表；</p><h2 id="顺序查找（Sequential-Search）"><a href="#顺序查找（Sequential-Search）" class="headerlink" title="顺序查找（Sequential Search）"></a>顺序查找（Sequential Search）</h2><p>也称线形查找，属于无序查找算法；</p><p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；   </p><p><strong>基本思想</strong>：从表中开头或结尾元素开始，逐个进行记录的关键字和给定值比较，若某记录的关键字和给定值比较相等，则查找成功；反之，若直至线性表的另一端，都未发现某记录的关键字和给定值比较相等，则查找失败；   </p><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找（Sequential Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：</p><ul><li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） $ASL = \frac{1}{n \times (1+2+3+…+n)} = \frac{n+1}{2}$;</li><li>查找不成功时，需要 $n+1$ 次比较;</li><li>时间复杂度为 $O(n)$</li></ul><h3 id="分块查找（Block-Search）"><a href="#分块查找（Block-Search）" class="headerlink" title="分块查找（Block Search）"></a>分块查找（Block Search）</h3><p>又称：索引顺序查找，是对顺序查找的改进；    </p><p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；  </p><p><strong>基本思想</strong>：对需要查找的顺序表进行分块，保证 “分块有序”，然后在此基础上进行查找：</p><ul><li>除待查找表本身外，新建一个 “索引表”：<ul><li><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/IndexTable.png" alt="IndexTable"> </li><li>上图中，将 18 个记录分为了 3 个子表：$(R_1,R_2,…,R_6)$、$(R_7,R_8,…,R_{12})$、$(R_{13},R_{14},…,R_{18})$；</li><li>对每个子表（块）建立一个索引项，其包括两个内容：最大关键字（子表内的最大关键字）、指针项（指示该子表的第一个记录在表中的位置）；</li><li>索引表按关键字有序，则表要么有序要么分块有序（是指：第二个子表中所有记录的关键字均大于第一个子表中的关键字，依次类推…）</li></ul></li><li>接下来的查找过程分为两部分：<ul><li>先确定待查记录所在的块（子表），这里是有序的，可以采用顺序查找或者插入查找算法；</li><li>然后在块中顺序查找；</li></ul></li></ul><details>  <summary><b>分块查找 java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找算法</span></span><br><span class="line"><span class="comment">// 只是展示分块查找的思想，具体实现时，需要根据具体情况灵活运用此思想；</span></span><br><span class="line"><span class="comment">// 算法来源：参考 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexItem</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index; <span class="comment">//值比较的索引</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start; <span class="comment">//开始位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;<span class="comment">//块元素长度(非空)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexItem</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... getter and setter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引查找算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexSearch</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem indexItem = <span class="keyword">null</span>; <span class="comment">// 目标子表</span></span><br><span class="line">        <span class="comment">//建立索引规则：</span></span><br><span class="line">        <span class="comment">// 以 100 作为划分，每 100 项一组，子表存储范围分别为：</span></span><br><span class="line">        <span class="comment">//  indexItemList[0]：0-99</span></span><br><span class="line">        <span class="comment">//  indexItemList[1]：100-199</span></span><br><span class="line">        <span class="comment">//  ......</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//遍历索引表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找到索引项</span></span><br><span class="line">            <span class="keyword">if</span>(indexItemList[i].index == index) &#123;</span><br><span class="line">                indexItem = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span>(indexItem == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据索引项，在主表中查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainList[i] == key)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem item = <span class="keyword">null</span>; <span class="comment">// 用来保存查找的子表</span></span><br><span class="line">        <span class="comment">// 按索引规则，映射为索引</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历索引表，找到对应的索引项</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexItemList[i].index == index) &#123;</span><br><span class="line">                item = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引项将值插入到主表中</span></span><br><span class="line">        mainList[item.start + item.length] = key;</span><br><span class="line">        <span class="comment">// 更新索引表长度</span></span><br><span class="line">        indexItemList[i].length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示开始 ********"</span>);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 每10个数换行一次</span></span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示结束 ********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个主表，size=30</span></span><br><span class="line">        <span class="keyword">int</span>[] mainList = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">301</span>, <span class="number">302</span>, <span class="number">303</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照前面所述的索引规则，声明一个索引表</span></span><br><span class="line">        IndexItem[] indexItemList = <span class="keyword">new</span> IndexItem[]&#123;</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"******** 索引查找 ********"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始数据："</span>);</span><br><span class="line">        display(mainList);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">203</span>;</span><br><span class="line">        System.out.println(<span class="string">"元素"</span> + key + <span class="string">"列表中的位置为："</span> + indexSearch(key,indexItemList,mainList) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按规则插入数据并查找</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">106</span>;</span><br><span class="line">        System.out.println(<span class="string">"插入数据："</span> + value);</span><br><span class="line">        <span class="comment">// 如果插入成功，则查找插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (insert(value,indexItemList,mainList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"插入后的主表："</span>);</span><br><span class="line">            display(mainList);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"元素"</span> + value + <span class="string">"在列表中的位置为："</span> + indexSearch(value,indexItemList,mainList));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>       <p><strong>性能分析</strong>：</p><ul><li>平均查找长度为：$ASL_{bs}=L_b+L_w$<ul><li>$L_b$：为查找索引表确定所在快的平均查找长度；</li><li>$L_w$：为在块中查找元素的平均查找长度；</li></ul></li><li>一般，可将长度为 n 的表均匀分为 b 块，每块含有 s 个记录（$b=\lceil n/s \rceil$）；再假定表中每个记录的查找概率相等，则每块查找的概率为 $1/b$，块中每个记录的查找概率为 $1/s$；<ul><li><mark>当 $s=\sqrt{n}$ 时，$ASL_{bs}$ 取最小值 $\sqrt{n}+1$；</mark></li></ul></li><li>若用顺序查找确定所在块，则分块查找的平均长度为：<ul><li>$ASL_{bs}=L_b+L_w=\frac{1}{b}\sum^b_{j=1}j+\frac{1}{s}\sum^s_{i=1}i=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}(\frac{n}{s}+s)+1$</li></ul></li><li>若用折半查找确定所在块，则分块查找的平均长度为：<ul><li>$ASL_{bs}\approx log_2(\frac{n}{s}+1)+\frac{s}{2}$</li></ul></li></ul><h2 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h2><p>也称二分查找，属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li></ul><p><strong>基本思想</strong>：先确定待查记录所在的范围（区间），然后逐渐缩小范围，直至找到或找不到该记录为止；   </p><ul><li>维护两个指针 <code>low</code> 和 <code>high</code>，他们指向线性表两端；然后再引入一个指针 <code>mid</code>，指示区间的中间位置；</li><li>将给定值 <code>key</code> 和 <code>mid</code> 所指示元素比较：<ul><li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li><li>若 <code>key &gt; mid</code>，把 <code>low</code> 指向 <code>mid+1</code> 位置，查找区间改为 <code>[ low(mid+1), high ]</code>；</li><li>若 <code>key &lt; mid</code>，把 <code>high</code> 指向 <code>mid-1</code> 位置，查找区间改为 <code>[ low, high(mid-1) ]</code>；</li></ul></li><li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找（Binary Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BinarySearchTreeEx.png" alt="BinarySearchTreeEx"><br>假设有如图所示的一棵深度为 h 的满二叉树，用来描述一个长度 $n=2^h-1$ 的有序表的二分查找过程。其中，层次为 h 的结点有 $2^{h-1}$ 个。 并且，假设各个节点的查找概率相等（$P_i=\frac{1}{n}$）。   </p><p>则，查找成功时折半查找的平均查找长度为：   </p><script type="math/tex; mode=display">\begin{aligned}ASL_{bs}&=\sum^n_{i=1}\ P_iC_i=\frac{1}{n}\ \sum^h_{j=1}\ j \cdot 2^{j-1}\\\\&=\frac{1}{n}(\ \sum^{h-1}_{i=0}2^i+2\sum^{h-2}_{i=0}2^i+...+2^{h-1}\sum^{h-1}_{i=0}2^i\ )\\\\&=\frac{1}{n}\ [h \cdot 2^h -(2^0+2^1+...+2^{h-1})]=\frac{1}{n}\ [(h-1)2^h+1]\\\\&= \frac{1}{n}\ [\ (n+1)(log_2(n+1)-1)+1\ ]\\\\&=\frac{n+1}{n}log_2(n+1)-1\end{aligned}</script><p>当 n 较大时 (&gt;50)，可以近似为：$ASL_{bs}=log_2(n+1)-1$</p><h3 id="插值查找（Insertion-Search）"><a href="#插值查找（Insertion-Search）" class="headerlink" title="插值查找（Insertion Search）"></a>插值查找（Insertion Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li><li>需要关键字均匀分布的表；</li></ul><p><strong>基本思想</strong>：折半查找中，每次都是从中间位置开始，而插值查找就是为了避免这种 “傻瓜” 式的搜索，希望将比例因子改为自适应的，即：根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，进而间接地减少比较次数；</p><ul><li>新的 mid 求法：$mid=low+\frac{key-a[low]}{a[high]-a[low]}\ast(high-low)$</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertionSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：   </p><ul><li>查找成功或者失败的时间复杂度均为 $O(log(logn))$；</li><li>分布均匀，且表长较大时，平均性能优于折半查找；</li></ul><h3 id="斐波拉契查找（Fibonacci-Search）"><a href="#斐波拉契查找（Fibonacci-Search）" class="headerlink" title="斐波拉契查找（Fibonacci Search）"></a>斐波拉契查找（Fibonacci Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）； </li></ul><p><strong>基本思想</strong>：类似二分查找，根据斐波那契序列的特点对有序表进行分割；它要求开始时，表中记录的个数为某个斐波那契数减 1，及 $n=F(k)-1$；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/FibonacciSegmentation.png" alt="FibonacciSegmentation"></p><ul><li>同样，维护三个指针，初始时，<code>low</code> 和 <code>high</code> 指向线性表两端，将 <code>key</code> 与第 <code>F(k-1)</code> 位置的记录进行比较（即：<code>mid=low+F(k-1)-1</code>）：<ul><li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li><li>若 <code>key &gt; mid</code>，则更新：<code>low=mid+1,k-=2</code>；查找区间更新为 <code>[mid+1,high]</code>，<code>k-=2</code> 说明新的查找区间内元素个数为：$n-F(k-1)= F(k)-1-F(k-1)=F(k-2)-1$；</li><li>若 <code>key &lt; mid</code>，则更新：<code>high=mid-1,k-=1</code>；查找区间更新为 <code>[low,mid-1]</code>，<code>k-=1</code> 说明新的查找区间内元素个数为：$F(k-1)-1$；</li></ul></li><li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>; <span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波拉契查找（Fibonacci Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 斐波那契分割数值的下标</span></span><br><span class="line">    <span class="keyword">int</span> f[] = fib(); <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    <span class="comment">// 计算获取，斐波那契分割数值的下标</span></span><br><span class="line">    <span class="comment">//  f(k) 是大于数组长度的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f[k] 值可能大于 arr 的长度，则构造一个新的数组 temp[]，该方法不足的部分会使用 0 填充</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">// 但是，实际上需求使用 arr 数组最后的数填充 temp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        temp[i] = arr[high];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环进行查找</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//值过小，从左半部分继续</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">//值过大，从右半部分继续</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//查找成功，但是因为前面扩充了数组，则需要确定，返回的是哪个下标</span></span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= arr.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.length-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：</p><ul><li>平均复杂度为：$O(longn)$，最坏情况下的时间复杂度也是 $O(longn)$；</li><li>平均性能优于折半查找，但最坏情况下的性能（虽然仍是 $O(longn)$）却比折半查找差；</li><li>另一个优势：分割时只需要进行加减运算；</li></ul><h1 id="动态树表查找"><a href="#动态树表查找" class="headerlink" title="动态树表查找"></a>动态树表查找</h1><h2 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h2><p><strong>“二叉排序树”</strong>（也称 “二叉查找树” 或者 “二叉搜索树”）：它或者是一棵空树，或者是具有下列性质的二叉树：（左小右大）</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ul><p>根据其定义，也就可以看出，二叉排序树具有如下<strong>性质</strong>：</p><ul><li>中序遍历的结果是一个有序序列；</li></ul><p><strong>二叉排序树查找算法基本思想</strong>：</p><ul><li><p><strong>建树</strong>：从一棵空树开始，将被查找序列的数据不断插入树中，生成一棵二叉排序树<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTBuild.png" alt="BSTBuild"></p><ul><li><strong>插入</strong>：新插入的节点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点；<ul><li>若当前的二叉查找树为空，则插入的元素为根节点；</li><li>若插入的元素值小于根节点值，则将元素插入到左子树中；</li><li>若插入的元素值不小于根节点值，则将元素插入到右子树中；</li><li>总结来说就是：首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败；</li></ul></li><li><strong>删除</strong>：分三种情况进行处理：<ol><li>p 为叶子节点：直接删除该节点（不会破坏树的整体结构），再修改其父节点的指针（注意分是根节点和不是根节点），如图 a；</li><li>p 为单支节点（即只有左子树或右子树）：让 p 的子树与 p 的父亲节点相连，删除 p 即可（也不会破坏树的整体结构）（注意分是根节点和不是根节点），如图 b；</li><li>有两个孩子的情况：当前结点与左子树中最大的元素交换，然后删除当前结点。左子树最大的元素至多只有一个左子节点，交换后，删除就可以参考上面两种的情况。另一种方法是，当前结点与右子树中最小的元素交换，然后删除当前结点。如图 c（删除 z 结点）；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTDelete.png" alt="BSTDelete"></li></ol></li></ul></li><li><p><strong>查找</strong>：树非空时，将给定值与根节点比较，若相等则查找成功；否则，根据给定值与根节点的大小关系，分别在左子树或右子树上继续查找；迭代进行，直至查找成功，或者不再存在左右子树时查找失败；</p></li></ul><details>  <summary><b>java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树数据结构*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value, TreeNode parent, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这部分是树里面的一些操作，详细可见二叉树的操作*/</span></span><br><span class="line">    <span class="comment">// 求 BST 的最小值，即最左边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 BST 的最大值，即最右边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中中序遍历的某节点的前驱节点，即查找数据值小于该结点的最大结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">preNode</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMax(x.left);</span><br><span class="line">        <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则"x的前驱结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的右儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.left == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中某节点的后继节点.即查找数据值大于该结点的最小结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">postNode</span><span class="params">(TreeNode x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在右孩子，则"x的后继结点"为"以其右孩子为根的子树的最小结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMin(x.right);</span><br><span class="line">        <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则"x的后继结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的查找算法*/</span></span><br><span class="line">    <span class="comment">// 查找值为val的节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">searchRec</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找值为 val 的节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">search</span><span class="params">(TreeNode root ,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点插入算法*/</span></span><br><span class="line">    <span class="comment">//BST 插入节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insertRec</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left,  x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right,  x);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BST 插入节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root = x;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>; <span class="comment">//需要记录父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位插入的位置</span></span><br><span class="line">            p = root; <span class="comment">//记录父节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        x.parent = p;<span class="comment">//定位到合适的叶节点的空白处后，根据和父节点的大小比较插入合适的位置</span></span><br><span class="line">        <span class="keyword">if</span>(x.value &lt; p.value)</span><br><span class="line">            p.left = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; p.value)</span><br><span class="line">            p.right = x;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点删除算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位到需要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//找到了，root指向待删结点，p指向root的父结点</span></span><br><span class="line">                <span class="comment">// 情景一：待删除的是 叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)</span><br><span class="line">                            p.left = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有左孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>)<span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.left;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.left;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有右孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.right;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景三：待删除节点同时拥有左右孩子</span></span><br><span class="line">                <span class="comment">//  方法：得到待删除节点右子树的最小值，该最小值与待删除节点进行“ 值 ”交换，删除该最小值位置处的节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此情况就不需要考虑被删结点是不是根节点了，操作都相同</span></span><br><span class="line">                    TreeNode rMin = root.right; <span class="comment">// 待删除节点的右孩子的最小值(找到的后继节点肯定没有左孩子！！！)</span></span><br><span class="line">                    TreeNode rMinP = root;<span class="comment">// 因为需要删除后继节点位置，所以需要记录父节点</span></span><br><span class="line">                    <span class="keyword">while</span>(rMin.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        rMinP=rMin;</span><br><span class="line">                        rMin = rMin.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> rootVtemp = root.value;<span class="comment">//值交换</span></span><br><span class="line">                    root.value = rMin.value;</span><br><span class="line">                    rMin.value = rootVtemp;</span><br><span class="line">                    <span class="comment">//删除rMin位置的节点，此时此位置的值已是待删节点的值</span></span><br><span class="line">                    <span class="keyword">if</span>(rMinP.left == rMin)</span><br><span class="line">                        rMinP.left = rMin.right;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rMinP.right == rMin) <span class="comment">// 待删结点root的右孩子结点就是其右子树的最小值</span></span><br><span class="line">                        rMinP.right = rMin.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到后删了后就跳出while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的不完全测试模块：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node45 = <span class="keyword">new</span> TreeNode(<span class="number">45</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node24 = <span class="keyword">new</span> TreeNode(<span class="number">24</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node53 = <span class="keyword">new</span> TreeNode(<span class="number">53</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node12 = <span class="keyword">new</span> TreeNode(<span class="number">12</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node37 = <span class="keyword">new</span> TreeNode(<span class="number">37</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node93 = <span class="keyword">new</span> TreeNode(<span class="number">93</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        insert(node45,node24);</span><br><span class="line">        insert(node45,node53);</span><br><span class="line">        insert(node45,node12);</span><br><span class="line">        insert(node45,node37);</span><br><span class="line">        insert(node45,node93);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以写个中序遍历的函数，遍历一遍</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"查找45结果："</span>);</span><br><span class="line">        TreeNode out1 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out1 +<span class="string">":"</span>+ out1.value);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"删除45后，再次查询结果："</span>);</span><br><span class="line">        delete(node45,node45);</span><br><span class="line">        TreeNode out2 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out2);</span><br><span class="line"></span><br><span class="line">        System.out.println(node45.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>性能分析</strong>：</p><ul><li>含有 n 个节点的二叉排序树的平均查找长度和树的形态有关；</li><li>和二分查找一样，插入和查找的时间复杂度均为 $O(logn)$，但是在最坏的情况下仍然会有 $O(n)$ 的时间复杂度；</li><li>最坏情况时，树形结构为每层一个结点，这样算法会退化为顺序查找，于是，平衡二叉查找树应运而生；</li></ul><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p><strong>来历</strong>：前面介绍，最坏情况下，如果连续插入已经排好序的键到二叉查找树，二叉查找树会变成了一个链表，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BadBST.png" alt="BadBST"><br>这样，相应的查找算法也就退化为了顺序查找，时间复杂度变为了 $O(n)$。而平衡二叉树就是为了避免这种情况。    </p><p><strong>平衡二叉树</strong>（Balance Binary Tree，Height-Balance Tree，AVL 树）：它或者是一棵空树，或者具有以下性质：</p><ul><li>首先，它是一棵二叉查找树；</li><li>它的左右子树也构成一棵平衡二叉树；</li><li>并且，左右子树的深度之差的绝对值不超过 1；</li></ul><p>若将二叉树上结点的<strong>平衡因子 BF</strong>（Balance Factor）定义为：该结点的左子树深度减去它的右子树深度，则平衡二叉树上所有结点的 BF 只可能取值为：-1、0、1，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/AVLExample.png" alt="AVLExample">   </p><p>在一个平衡二叉树上插入结点，就可能导致失去平衡，此时仅需对最小不平衡子树进行平衡旋转处理即可。现假设由于二叉排序树上插入结点而失去平衡的最小子树根节点指针为 a（即：a 是离插入结点最近，且平衡因子绝对值超过 1 的祖先结点），则<strong>失去平衡后进行调整（旋转） 的规律</strong>可归结为以下四种情况：   </p><ul><li><strong>LL 型：单向右旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LLRotate.png" alt="LLRotate"><ul><li>由于在 A 结点的左子树根节点的左子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如上图；</li></ul></li><li><strong>RR 型：单向左旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RRRotate.png" alt="RRRotate"><ul><li>由于在 A 结点的右子树根节点的右子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需进行一次向左的逆时针旋转操作，如上图；</li></ul></li><li><strong>LR 型：双向旋转（先左后右）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LRRotate.png" alt="LRRotate"><ul><li>由于在 A 结点的左子树根节点的右子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先左旋转再右旋转），如上图；</li></ul></li><li><strong>RL 型：双向旋转（先右后左）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RLRotate.png" alt="RLRotate"><ul><li>由于在 A 结点的右子树根节点的左子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先右旋转再左旋转），如上图；</li></ul></li></ul><p>以上旋转操作的正确性容易由 “保持二叉排序树的特性：中序遍历所得关键字序列自小而大有序” 证明。    </p><p><strong>插入和删除</strong>：与二叉查找树类似，只是额外加入了平衡操作。下面以插入算法思想来进行分类讨论：</p><ul><li>若 BBST 为空树，则插入一个数据元素为 e 的新结点作为 BBST 的根节点，树的深度增 1；</li><li>若 e == BBST 的根节点，则不进行插入；</li><li>若 e &lt; BBST 的根结点，并且 BBST 的左子树中不存和 e 相等的结点，则将 e 插入至 BBST 的左子树上，并且在插入之后的左子树深度增加（+1）时，分别就以下情况进行处理：<ul><li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li><li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 1，BBST 深度增 1；</li><li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：<ul><li>若 BBST 的左子树根结点的平衡因子为 1：则需要进行 LL 型（单向右旋）平衡处理，并且在右旋处理之后，将根节点和其右子树根结点的平衡因子改为 0，树的深度不变；</li><li>若 BBST 的左子树根结点的平衡因子为 -1：则需进行 LR 型（先左后右）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li></ul></li></ul></li><li>若 e &gt; BBST 的根结点，并且 BBST 的右子树中不存和 e 相等的结点，则将 e 插入至 BBST 的右子树上，并且在插入之后的右子树深度增加（+1）时，分别就以下情况进行处理：<ul><li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li><li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 -1，BBST 深度增 1；</li><li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：<ul><li>若 BBST 的右子树根结点的平衡因子为 -1：则需要进行 RR 型（单向左旋）平衡处理，并且在左旋处理之后，将根节点和其左子树根结点的平衡因子改为 0，树的深度不变；</li><li>若 BBST 的右子树根结点的平衡因子为 1：则需进行 RL 型（先右后左）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li></ul></li></ul></li></ul><details>  <summary><b>java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 具体的实现依赖于前面的 二叉排序树 */</span></span><br><span class="line"><span class="comment">/** 下面给出里面的几个核心函数：BBST 的辅助旋转算法 */</span></span><br><span class="line"><span class="comment">// 其中，bf 是添加在树节点里的成员变量，代表节点的平衡因子（左子树高度-右子树高度）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的左子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.left; <span class="comment">// p 指向 root 的左子树的根结点</span></span><br><span class="line">    root.left = p.right; <span class="comment">// p 的右子树挂载至 root 的左子树</span></span><br><span class="line">    p.right = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的右子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.right; <span class="comment">// p 指向 root 的右子树的根结点</span></span><br><span class="line">    root.right = p.left; <span class="comment">// p 的左子树挂载至 root 的右子树</span></span><br><span class="line">    p.left = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在上述两种基础上，完成平衡二叉树的左右平衡处理</span></span><br><span class="line"><span class="comment">// 左平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode rl = root.left;</span><br><span class="line">    <span class="keyword">switch</span> (rl.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的左孩子的左子树上，做单向右旋处理</span></span><br><span class="line">            root.bf = rl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的左孩子的右子树上，做双旋（先左后右）处理</span></span><br><span class="line">            TreeNode rlr = rl.right;</span><br><span class="line">            <span class="keyword">switch</span> (rlr.bf)&#123; <span class="comment">// 修改 root 及其左孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = -<span class="number">1</span>; rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">0</span>; rl.bf = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rlr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root.left); <span class="comment">// 对 root 的左子树作左旋处理</span></span><br><span class="line">            rRotate(root); <span class="comment">// 对 root 做右旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected value: "</span> + rl.bf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode rr = root.right;</span><br><span class="line">    <span class="keyword">switch</span> (rr.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的右孩子的右子树上，做单向左旋处理</span></span><br><span class="line">            root.bf = rr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的右孩子的左子树上，做双旋（先右后左）处理</span></span><br><span class="line">            TreeNode rrl = rr.left;</span><br><span class="line">            <span class="keyword">switch</span> (rrl.bf)&#123; <span class="comment">// 修改 root 及其右孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = <span class="number">0</span>; rr.bf = -<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">1</span>; rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rrl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root.right); <span class="comment">// 对 root 的左子树作右旋处理</span></span><br><span class="line">            lRotate(root); <span class="comment">// 对 root 做左旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>性能分析</strong>：</p><ul><li>在平衡二叉树上进行查找的时间复杂度为：$O(logn)$，注意，它一种动态查找算法，在树形维护上的时间复杂度还是相对较高的；</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>对比说明</strong>：</p><div class="table-container"><table><thead><tr><th>名称</th><th>简介</th><th>局限性</th><th>应用</th></tr></thead><tbody><tr><td>AVL 树</td><td>严格的平衡二叉树，平衡条件必须满足：所有节点的左右子树高度差不超过 1；</td><td>① 平衡调整时的旋转操作十分耗时，因此，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多；更多的地方是用追求局部而不是非常严格整体平衡的红黑树;<br>② 也就更适合用于插入与删除次数比较少，但查找多的情况；</td><td>windows 对进程地址空间的管理；</td></tr><tr><td>红黑树</td><td>弱平衡二叉树，相同的节点情况下，AVL 树的高度低于红黑树；</td><td>旋转操作更少，更适用于搜索、插入、删除等操作较多的情况；<br>但相应的，相同情况下其查找次数会略高于 AVL 树；</td><td>① 著名的 linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块；<br>② epoll 在内核中的实现，用红黑树管理事件块；<br>③ nginx 中，用红黑树管理 timer 等；<br>④ Java 的 TreeMap 实现；</td></tr></tbody></table></div><p><strong>红黑树的定义</strong>：</p><ul><li>每个结点非黑即红；</li><li>根结点是黑色；</li><li>每个叶子结点都是黑色的空结点（NIL 结点）；</li><li>每个红色结点的两个子结点都是黑色;<ul><li>可推出：从每个叶子到根的所有路径上不能有两个连续的红色结点；</li></ul></li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；<ul><li>可推出：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul></li></ul><p>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTree.png" alt="RedBlackTree">     </p><p><strong>红黑树总是通过 “旋转” 和 “变色” 达到自平衡</strong>：</p><p><strong>红黑树插入</strong>：同样与二叉树类似，也分为两部分：1.查找插入的位置；2.插入后自平衡</p><p>查找流程：注意，插入的位置一定是叶子结点<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackSearch.png" alt="RedBlackSearch">      </p><p>接下来，就是将待插结点以 “红色” 插入，此时一共有 8 中情景，如下：</p><ul><li>“红色” 原因：如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡；并且，如果选择红色，在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作，也可以进一步减少平衡操作；   </li></ul><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeInsertSituation.png" alt="RedBlackTreeInsertSituation">   </p><p><strong>红黑树删除</strong>：同样也分为两部分：1.查找删除的位置；2.删除后自平衡    </p><p>查找流程：直接用前述的过程替代，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除目标结点，若目标结点存在子结点，还需找到结点进行替代，之后还得进行自平衡处理；     </p><p>结点删除的第一步，找替代结点分为以下 3 种情景：</p><ul><li>情景 1：若删除结点无子结点，直接删除</li><li>情景 2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景 3：若删除结点有两个子结点，用中序遍历的后继结点（大于删除结点的最小结点，也即：删除结点右子树的最左边的结点）替换删除结点；</li></ul><p>经过上述替换之后，也就是删除替换结点。这个时候删除替换结点的情景如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeDeleteSituation.png" alt="RedBlackTreeDeleteSituation"></p><h2 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B- 树和 B+ 树"></a>B- 树和 B+ 树</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><p>B- 树是一种<strong>平衡的多路查找树</strong>，它<strong>广泛的运用于文件系统（索引）中</strong>；    </p><p><strong>定义</strong>：一棵 m 阶的 B- 树，要么为空树，要么为满足下列条件的 m 叉树：</p><ul><li>树中每个结点至多有 m 棵子树；</li><li>若根节点不是叶子结点，则至少有两棵子树；</li><li>除根节点之外的所有非终端结点至少有 $\lceil m/2 \rceil$ 棵子树；</li><li>所有的非终端节点包含以下信息数据：$(n,A_0,K_1,A_1,K_2,A_2,…,K_n,A_n)$<ul><li>$K_i\ (i=1,…,n)$ 为关键字，且 $K_i&lt;K_{i+1}\ (i=1,…,n-1)$；</li><li>$A_i\ (i=1,…,n)$ 为指向子树根节点的指针，且指针 $A_{i-1}$ 所指子树中所有结点的关键字均小于 $K_i(i=1,…,n)$，$A_n$ 所指子树中所有结点的关键字均大于 $K_n$；</li><li>$n\ (\lceil m/2 \rceil-1 \leq n \leq m-1)$  </li></ul></li><li>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的节点，实际上这些结点不存在，指向这些结点的指针为空）；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-Tree.png" alt="B-Tree"></p><p><strong>查找</strong>：B- 树的查找过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程；</p><ul><li><strong>查找性能分析</strong>：B- 树通常存在磁盘上，因此查找操作的主要两步：（1）在 B- 树中找结点（磁盘）；（2）在结点中找关键字（内存）；详细来说，即：在磁盘上找到指针 p 所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找等于 K 的关键字。而磁盘上的查找更耗时，因此，在磁盘上进行查找的次数（即待查找关键字所在结点在 B- 树上的层次树）是觉得 B- 树查找效率的首要因素。<ul><li>讨论深度为 l+1 的 m 阶 B- 树所具有的最少结点数：<ul><li>B- 数第一层至少 1 个节点；第二次至少 2 个节点；由于除根节点外每个非终端节点至少有 $\lceil m/2 \rceil$ 棵子树，则第三层至少有 $2\lceil m/2 \rceil$ 个节点；……以此类推；第 l+1 层至少有 $2(\lceil m/2 \rceil)^{l-1}$ 个结点；并且，第 l+1 层的结点为叶子结点 ；</li></ul></li><li>若 m 阶 B- 树中具有 N 个关键字，则叶子结点（即查找失败）的结点为 N+1，则有：$N+1 \geq 2 \ast (\lceil m/2 \rceil)^{l-1}$，也即：<script type="math/tex">l \leq log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1</script></li><li>也即：在含有 N 个关键字的 B- 树上进行查找时，从根节点到关键字所在结点的路径上设计的结点数不超过：$log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1$</li></ul></li></ul><p><strong>插入</strong>：规则：查找，向最底层的结点插入关键字，然后判断当前结点 key 的个数是否小于等于 m-1，如果满足，直接插入即可；如果不满足，“分裂”：按节点的中间的 key 将这个节点分为左右两部分，中间的 key 放到父节点中即可；</p><ul><li>往一个 4 阶 B- 树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的动图示例：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeInsert.gif" alt="B-TreeInsert"></li></ul><p><strong>删除</strong>：首先找到该关键字所在的结点，并从中删除之，然后，对需要进行 “合并” 结点的情况进行合并。这时考虑如下几种情况（$m=5，2 \leq n \leq 4$）：</p><ul><li>删除的是叶子节点的元素，并且如果删除之后，元素数还是大于等于 $\lceil m/2 \rceil -1$，这种情况只要直接删除即可:<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete1.png" alt="B-TreeDelete1"></li><li>删除的是叶子节点的元素，并且如果删除之后，元素数不足 $\lceil m/2 \rceil -1$：<ul><li>如果，它的兄弟节点的元素大于等于 $\lceil m/2 \rceil$（即：兄弟节点的元素删掉一个后仍符合要求）：将其兄弟结点中的最小（最大）的元素上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移元素的元素下移至双亲结点中；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete2.png" alt="B-TreeDelete2"></li><li>如果与被删元素所在的结点相邻的兄弟结点中元素个数均等于 $\lceil m/2 \rceil - 1$：假设该结点有兄弟结点，且其右兄弟结点地址由双亲结点中的指针 $A_i$ 所指，则在删去元素之后，它所在结点中剩余的元素和指针，加上双亲结点中的关键字 $K_i$ 一起合并到 $A_i$ 所指兄弟结点中去（若没有右兄弟结点，则合并至左兄弟结点）。之后，如果因此使双亲结点中的元素个数不足 $\lceil m/2 \rceil-1$，则依次类推左相应处理。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete3.png" alt="B-TreeDelete3"></li></ul></li><li>对于非叶子节点的删除，则需要用后继 key 覆盖要删除的 key，然后在后继 key 所在的位置中删除该后继 key：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete4.png" alt="B-TreeDelete4"><ul><li>此时，26 所在的结点不符合要求，需要进行前面说过的向兄弟结点 “借” 的操作；</li></ul></li></ul><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是应文件系统所需而出的一种 B- 树的变种；也是 MySQL 的底层数据结构；    </p><p><strong>定义</strong>：一棵 m 阶的 B+ 树和 m 阶的 B- 树的差异在于：</p><ul><li>有 n 棵子树的节点中含有 n 个关键字；</li><li>所有的叶子结点包含了全部的关键字信息（及指向这些关键字记录的指针），且叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（的根节点）中的最大（或最小）关键字；</li><li>补充：有关结点的元素范围<ul><li>非根节点元素范围：$n\ (\lceil m/2 \rceil \leq n \leq m)$</li></ul></li></ul><p>好好与 B- 树对比体会，一棵 3 阶的 B+ 树如下所示：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B+Tree.png" alt="B+Tree">  </p><ul><li>通常，在 B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的节点；   </li></ul><p><strong>查找</strong>：根据前面所述的两个指针，查找也就可以分为两种方式：</p><ol><li>从最小关键字起顺序查找；</li><li>从根节点开始进行随机查找；<ul><li>在 B+ 树上进行这种随机查找，不管查找成功与否，每次查找都是走了一条从根到叶子结点的完整路径；</li></ul></li></ol><p><strong>插入</strong>：仅在叶子结点上进行，当结点中的关键字个数大于 m 时，要从中间分裂为两个结点（它们所含关键字个数为：$\lceil \frac{m+1}{2} \rceil$ 和 $\lfloor \frac{m+1}{2} \rfloor$），并且，它们的双亲结点中应同时含有这两个结点的最大关键字。   </p><p><strong>删除</strong>：也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端节点中的值可以作为一个 “分界关键字” 继续存在。若因删除而使结点中关键字的个数少于 $\lceil m/2 \rceil$ 时，其和兄弟结点的合并过程和 B- 树类似。</p><h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p><strong>定义</strong>：又称数字查找树（Digital Search Tree）。它是一棵高度 $\geq 2$ 的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。    </p><p>例如：如下 16 个关键字的集合。{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。逐层划分，组成一棵键树如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/KeyTree.png" alt="KeyTree"></p><ul><li>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字，叶子结点中的特殊符号 $ 表示字符的结束；</li><li>为了插入和查找的方便，会约定键树是一棵有序树，即：同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符 $ 小于任何字符；</li></ul><p><strong>两种存储结构</strong>：</p><ol><li>双链树：<ul><li>以树的孩子兄弟链表来表示键树，则每个分支结点包括 3 个域：symbol 域（存储关键字的一个字符）、first 域（存储指向第一棵子树根的指针）、next 域（存储指向右兄弟的指针），同时，叶节点的 infoptr 域（存储指向该关键字记录的指针）。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DoubleLinkTree.png" alt="DoubleLinkTree"></li></ul></li><li>Trie 树：<ul><li>以树的多重链表表示键树，则树的每个结点中应含有 d 个指针域；</li><li>若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个 “叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息；</li><li>Trie 树有两种结点：<ul><li>分支结点：含有 d 个指针域和一个指示该结点中非空指针域的个数的整数域；<ul><li>分支结点中不设数据域，每个分支结点所表示的字符均有其双亲结点中（指向该结点）的指针所在位置决定；</li></ul></li><li>叶子结点：含有关键字域和指向记录的指针域；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/TrieTree.png" alt="TrieTree"></li></ul></li></ul></li></ol><h1 id="哈希查找（Hash-Search）"><a href="#哈希查找（Hash-Search）" class="headerlink" title="哈希查找（Hash Search）"></a>哈希查找（Hash Search）</h1><p>前面介绍的各种结构（线性表、树）中，记录在结构中的相对位置时随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录就需要一系列和关键字的比较，也就是常说的基于 “比较” 的查找算法。这样往往比较耗时。    </p><h2 id="哈希表和哈希函数"><a href="#哈希表和哈希函数" class="headerlink" title="哈希表和哈希函数"></a>哈希表和哈希函数</h2><p>就是为了解决上述问题而引入的一种 <strong>“以空间换时间”</strong> 的数据结构：</p><ul><li>它利用哈希函数 $f$ 在记录的存储位置和它的关键字之间建立了一个确定的对应关系 $f$，这样就使得每个关键字和结构中一个唯一的存储位置相对应。按照这种关系记录关键字的表就是哈希表；</li><li>在查找时，只要根据这个对应关系 $f$ 找到给定值 $K$ 的像 $f(K)$。若结构中存在关键字和 $K$ 相等的记录，则必定在 $f(K)$ 的存储位置上，由此，不需要进行比较就可以直接取得所查记录。</li></ul><p><strong>定义</strong>：综上如下描述哈希表：根据给定的哈希函数 $H(key)$ 和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的 “像” 作为记录在表中的存储位置，这种表即为<strong>哈希表</strong>，这一映像过程称为<strong>哈希造表或散列</strong>，所得的存储位置称为<strong>哈希地址或散列地址</strong>。其两大特点就是：</p><ul><li>映像：哈希函数</li><li>冲突：不同的关键字映射到同一地址</li></ul><h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>首先，“好” 的哈希函数应该具有特点：对于关键字集合中的任一关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为均匀的哈希函数。     </p><p><strong>方法一：直接定址法</strong></p><ul><li>取关键字或关键字的某个线性函数值为哈希地址，即：$H(key)=key$ 或 $H(key)=a \cdot key + b$</li></ul><p><strong>方法二：数字分析法</strong></p><ul><li>假设关键字是以 r 为基的数（如：以 10 为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可 “取关键字的若干位” 组成哈希地址；</li><li>如：{313、323、333、343、353、363、373、383、393}，可取其第 2 位组成哈希地址；</li></ul><p><strong>方法三：平方取中法</strong></p><ul><li>取关键平方后的中间几位为哈希地址。这种方式比较常用；</li><li>通常在选哈希函数的时候是不一定知道所有的关键字的，因此取其中那几位也不一定合适，而一个树平方后的中间几位数和数的每一位都相关，由此可使随机分布的关键字得到的哈希地址也是随机的；</li></ul><p><strong>方法四：折叠法</strong></p><ul><li>将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后截取这几部分的叠加和（舍去进位）作为哈希地址；</li><li>适用于：关键字位数很多，而且关键字中每一位上数字分布大致均匀时；</li></ul><p><strong>方法五：除留余数法</strong></p><ul><li>取关键字被某个不大于哈希表表长 m 的数 p 除后所得余数作为哈希地址，即：$H(key)=key\ MOD\ p,\ p \leq m$</li><li>这是最简单、也最常用的方法，不仅可以直接对关键字使用 MOD，也可以在折叠、平方取中等运算之后取模；</li><li>但是需要注意 p 的选取，否则可能产生较高的冲突；而根据经验，一般选 p 为质数或不包含小于 20 的质因数的合数；</li></ul><p><strong>方法六：随机数法</strong></p><ul><li>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即：$H(key)=random(key)$；</li><li>通常适用于关键字长度不等时；</li></ul><p>针对上述提供的方法，实际工作中需要视情况采用。通常考虑的因素有：</p><ul><li>计算哈希函数所需的时间（包括硬件指令的因素）；</li><li>关键字的长度；</li><li>哈希表的大小；</li><li>关键字的分布情况；</li><li>记录的检查频率；</li></ul><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>假设哈希表的地址集为 0~(n-1)，冲突就是指有关键字得到的哈希地址为 j （$0 \leq j \leq n-1$） 的位置上已存有记录。那么冲突处理，就是为该关键字重新找的另一个 “空” 的哈希地址。在实际处理时，可能第一次冲突处理得到的地址 $H_1$ 仍旧冲突，则再进行处理得到 $H_2$，再冲突，再处理，…，这样得到了一个地址序列，最后一个地址 $H_k$ 为不发生冲突的地址；</p><p><strong>方法一：开放地址法</strong></p><ul><li>$H_i=(H(key)+d_i)\ MOD\ m,\ i=1,2,…,k\ (k \leq m-1)$</li><li>其中，$H(key)$ 为哈希函数；$m$ 为哈希表长；$d_i$ 为增量序列；</li><li>根据增量序列的取法，又可以分为如下方法：<ul><li>线性探测再散列：$d_i = 1,2,3,…,m-1$<ul><li>只要哈希表未填满，最终总能找到一个不发生冲突的地址；</li></ul></li><li>二次探测再散列：$d_i= 1^2,-1^2,2^2,-2^2,…,\pm k^2,\ (k \leq m/2)$<ul><li>只有在哈希表长 m 为形如 $4j+3$（j 为整数）的素数时才可能；</li></ul></li><li>伪随机探测再散列：$d_i = 伪随机数序列$<ul><li>取决于伪随机数列；</li></ul></li></ul></li><li>这种处理方式可能带来一个问题：二次聚集（即：原先不发生冲突的地址，却因为之前某个关键字进行了冲突处理，从而又导致了冲突）</li></ul><p><strong>方法二：再哈希法</strong></p><ul><li>$H_i=RH_i(key)\ \ i=1,2,…,k$</li><li>$RH_i$ 均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生；</li><li>这种方法不易产生 “聚集”，但增加了计算时间；</li></ul><p><strong>方法三：链地址法（拉链法）</strong></p><ul><li>将所有关键字为同义词的记录存储在同一线性链表中：<ul><li>假若某哈希函数产生的哈希地址在区间 [0,m-1] 上，则设立一个指针型变量 Chain ChainHash[m]；其每个分量的初始状态为空指针；</li><li>凡哈希地址为 i 的记录都插入到头指针为 ChainHash[i] 的链表中；</li><li>在链表中插入的位置可以是表头或表尾，也可以在中间，以保持同义词在同一线性表中按关键字有序；</li></ul></li><li>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/ChainAddressMethod.png" alt="ChainAddressMethod"></li></ul><p><strong>方法四：建立一个公共溢出区</strong></p><ul><li>假设哈希函数的值域为 [0,m-1]，则设向量 HashTable[0,m-1] 为基本表，每个分量存放一个记录，另设立向量 OverTable[0..v] 为溢出表；</li><li>所有关键字和基本表中关键字为同义的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表；</li></ul><h2 id="哈希查找分析"><a href="#哈希查找分析" class="headerlink" title="哈希查找分析"></a>哈希查找分析</h2><p><strong>查找过程</strong>：给定 K 值根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找失败；否则，比较关键字，若与给定值相等，则查找成功，否则根据造表时设定的处理冲突函数的方法找 “下一地址”，直至哈希表中某个位置为 “空” 或者表中所填记录的关键字等于给定值时为止；   </p><ul><li><mark>注意：若要在非链地址处理冲突的哈希表中删除一个记录，则需要在该记录的位置上填入一个特殊的符号，以免找不到在它之后填入的 “同义词” 的记录；</mark></li></ul><p><strong>性能分析</strong>：因为 “冲突” 使得哈希表的查找过程仍是一个 “比较” 的过程，仍需以平均查找长度作为衡量哈希表的查找效率的度量；</p><ul><li>查找过程中，比较的次数取决于三个因素：<ul><li>哈希函数：一般情况下选取的哈希函数是 “均匀的”，则产生冲突的可能性相同，所以可以不考虑它的影响因素；</li><li>冲突处理方法：线性探测再散列容易产生二次聚集，而链地址法，则可以有效避免此情况；</li><li>哈希表的装填因子：冲突处理方法相同的哈希表，其平均查找长度就依赖于哈希表的装填因子<ul><li>$哈希表的装填因子\ \alpha = \frac{表中填入的记录数}{哈希表长度}$</li><li>$\alpha$ 越小，冲突可能性越小；$\alpha$ 越大，冲突可能性越大，则查找过程中比较的次数就越多；</li></ul></li></ul></li><li>几种冲突处理方法的平均查找长度：</li></ul><div class="table-container"><table><thead><tr><th>冲突处理方法</th><th>成功时</th><th>失败时</th></tr></thead><tbody><tr><td>线性探测再散列</td><td>$S_{nl} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$</td><td>$U_{nl} \approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$</td></tr><tr><td>随机探测再散列、二次探测再散列、再哈希</td><td>$S_{nr} \approx -\frac{1}{\alpha}ln(1-\alpha)$</td><td>$U_{nr} \approx \frac{1}{1-\alpha}$</td></tr><tr><td>链地址法</td><td>$S_{nc} \approx 1+\frac{\alpha}{2}$</td><td>$U_{nc} \approx \alpha + e^{-\alpha}$</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>『<a href="https://www.cnblogs.com/magic-sea/p/11391431.html" target="_blank" rel="noopener">賣贾笔的小男孩：分块查找</a>』</li><li>『<a href="https://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="noopener">[Data Structure &amp; Algorithm] 七大查找算法</a>』</li><li>『<a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">二叉查找树BST——java实现</a>』</li><li>『<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a>』</li><li>『<a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">面试官问你B树和B+树，就把这篇文章丢给他</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-Lab Exercise</title>
    <link href="http://www.thebetterkong.cn/2020/06/11/FPGA-technology/FPGA-LabExercise/"/>
    <id>http://www.thebetterkong.cn/2020/06/11/FPGA-technology/FPGA-LabExercise/</id>
    <published>2020-06-11T08:29:36.000Z</published>
    <updated>2020-08-14T09:31:17.859Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 FPGA 具体的实验操作；</p><a id="more"></a> <h1 id="概述：FPGA-构建工具链"><a href="#概述：FPGA-构建工具链" class="headerlink" title="概述：FPGA 构建工具链"></a>概述：FPGA 构建工具链</h1><p>实验开始之前，我们应该熟悉 CAD（计算机辅助设计）工具，该工具可将 HDL（Verilog）转换为 FPGA 上的工作电路：</p><ul><li>这些工具将使您的设计经历多个阶段，每个阶段都使其更接近于具体的实现；</li><li>在过去的几年中，较旧的评估平台（ML505）使用较旧的 FPGA（Xilinx Virtex-5 LX110T）和较旧的软件套件（Xilinx ISE）；</li><li>尽管有一个 GUI，也可有 Makefiles 来调用工具链中的每个后续程序，以进行完整的综合并进行分析；</li></ul><p>Xilinx 更新后的设计软件：Vivado Design Suite</p><ul><li>Vivado 强调了其强大的集成脚本功能（使用 Tcl 语言）以及与其他高级设计工具（例如，高级综合）的集成；</li><li>它还支持等效的 Makefiles 和 Tcl 自动化；</li></ul><p>GUI 本身的缺点是使用起来非常手工：</p><ul><li>反复更改和运行参数很快变得乏味；</li><li>最终的目标是使设计过程尽可能自动化；</li><li>但是，对于学习而言，GUI 具有宝贵的属性，可以指导我们完成流程的每个步骤；</li></ul><h1 id="FPGA-设计流程"><a href="#FPGA-设计流程" class="headerlink" title="FPGA 设计流程"></a>FPGA 设计流程</h1><p><strong>① 综合 Synthesis</strong>：</p><ul><li>要在 Vivado Design Suite 中运行综合步骤（即，将 HDL 转换为组合逻辑和顺序逻辑），请在 “Flow Navigator（流导航器）” 窗格的其他左侧界面中选择 “ Run<br>Synthesis”；</li><li>如果之前已经运行过，则可以通过选择 “Open Synthesized Design” 来检查综合设计；</li></ul><p><strong>② 实现 Implementation</strong>：</p><ul><li>Vivado GUI 中的实现步骤等效于手动 pipeline 中的 translation，mapping 以及 place 和 route 步骤；</li><li>同样，这将采用先前综合的逻辑电路，并将其映射到我们特定的 FPGA 实际具有的物理逻辑设备；</li><li>在 “Flow Navigator” 中选择 “Run Implementation” 以运行它，然后选择 “Open Implementation” 以检查其输出；</li></ul><p><strong>③ Xilinx 设计约束（XDC）</strong>：</p><ul><li>我们如何将信号之一连接到物理设备？</li><li>我们如何指定电路的特殊性质，这可能对正确性和时序至关重要？</li><li>Xilinx 设计约束文件（具有 <code>.xdc</code> 扩展名）指定了设计的必要属性（就像旧的 User Constraints 文件），并且是实施阶段的关键输入。</li><li>XDC 受 Synopsis ASIC 综合工具链的启发，旨在实现某种程度的兼容性；</li><li>以 TCL 形式为 Vivado TCL 解释器编写；</li><li>例子：<code>set_property -dict{ PACKAGE_PIN L19 IOSTANDARD LVCMOS33 } [get_ports{ BUTTONS[3] }];</code><ul><li>此语法分别将属性 LACK 和 LVCMOS33 的值 PACKAGE_PIN 和 IOSTANDARD 分配给端口 BUTTONS [3]，这是我们在 Verilog 源中定义的信号。这些属性中的每一个在合成过程中都有单独的结果：</li><li>BUTTONS [3] 信号应连接到的引脚与 FPGA 封装上的物理引脚 L19 相连；</li><li>该端口的逻辑约定（最大电压，什么范围构成高低，等等）将为 LVCMOS33；</li></ul></li></ul><p><strong>④ Bitstream generation</strong>：</p><ul><li>为了生成 FPGA 可以理解的编程文件，我们在 “Flow Navigator” 中调用 “Generate Bitstream”；</li></ul><p><strong>⑤ Timing Analysis</strong>：</p><ul><li>通过展开 “Open Synthesized Design” 并选择 “Report Timing Summary”，可以在 “Flow Navigator” 中的 “Synthesis” 下生成时序分析报告；</li></ul><p><strong>⑥ Design Reports</strong>：</p><ul><li>在构建流程的每个步骤都会自动生成报告。</li><li>您应该能够在 “Flow Navigator” 的每个扩展阶段下找到它们；</li><li>“Project Summary” 窗口（在 “Window” 菜单下）显示了每个步骤生成的报告的摘要；</li></ul><p><strong>⑦ Programming the FPGA</strong>：</p><ul><li>要使用 Vivado GUI 将 bitstream 发送到 FPGA，必须使用 Hardware Manager；</li><li>可以在 “Flow Navigator” 中的 “Program and Debug” 下的 “Generate Bitstream” 下进行访问；</li><li>通过 USB JTAG 接口连接到 FPGA 后，您可以在 “Flow Navigator”（或在打开的Hardware Manager 窗格中）中选择 “Program Device” 来执行编程；</li></ul><h1 id="Verilog-基础"><a href="#Verilog-基础" class="headerlink" title="Verilog 基础"></a>Verilog 基础</h1><p><strong>基本格式</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;module_name&gt; (&lt;module_terminal_list&gt;);</span><br><span class="line">    &lt;module_terminal_definitions&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;functionality_of_module&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="简单运用举例"><a href="#简单运用举例" class="headerlink" title="简单运用举例"></a>简单运用举例</h2><p><strong>全加器</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FullAdder.png" alt="FullAdder">   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,cout,sum);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;      <span class="comment">//inputs</span></span><br><span class="line">    <span class="keyword">output</span>  cout,sum;    <span class="comment">//outputs</span></span><br><span class="line">    <span class="keyword">wire</span>    w1,w2,w3,w4;   <span class="comment">//internal nets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (w1,a,b)</span>; <span class="comment">//delay time of 10 units</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (sum,w1,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w2,a,b)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w3,a,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w4,b,cin)</span>;</span><br><span class="line">    <span class="keyword">or</span>  <span class="variable">#(10,8) (cout,w2,w3,w4); // (rise time of 10, fall 8)</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p><strong>全加器另一中实现方式（时序）</strong>：   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,sum,cout);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;</span><br><span class="line">    <span class="keyword">output</span>  cout,sum;</span><br><span class="line">    <span class="keyword">reg</span>     sum,cout;   <span class="comment">//registers retain value</span></span><br><span class="line">    <span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> cin) <span class="comment">//Any time a or b or cin change,run the process</span></span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            sum &lt;= a ^ b ^ cin;</span><br><span class="line">            cout &lt;= ( a &amp; b ) |  ( a &amp; cin ) |  ( b &amp; cin );</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>其中：两种赋值号 <code>=</code> 和 <code>&lt;=</code> 区别：<ul><li>Verilog 中的所有语句都是并发的（除非它们在顺序块中），并发表示每行中描述的操作并行进行；<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Concurrent.png" alt="Concurrent"></li><li>Nonblocking：<code>&lt;=</code>，代表按顺序执行；</li><li>Blocking：<code>=</code>，代表并发执行；</li></ul></li></ul><p><strong>纹波进位加法器（ripple carry adder）</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4-bit Adder</span></span><br><span class="line"><span class="keyword">module</span> adder4(A,B,cin,S,cout)</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>]  A,B;</span><br><span class="line">    <span class="keyword">input</span>   cin;</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] S;</span><br><span class="line">    <span class="keyword">output</span>  cout;</span><br><span class="line">    <span class="keyword">wire</span> c1,c2,c3;</span><br><span class="line">    <span class="comment">// 4 instantiated 1-bit Full Adders</span></span><br><span class="line">    FullAdder fa0(A[<span class="number">0</span>], B[<span class="number">0</span>], cin, c1, S[<span class="number">0</span>]);</span><br><span class="line">    FullAdder fa1(A[<span class="number">1</span>], B[<span class="number">1</span>], c1, c2, S[<span class="number">1</span>]);</span><br><span class="line">    FullAdder fa2(A[<span class="number">2</span>], B[<span class="number">2</span>], c2, c3, S[<span class="number">2</span>]);</span><br><span class="line">    FullAdder fa3(A[<span class="number">3</span>], B[<span class="number">3</span>], c3, cout, S[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h2><p>HDL（Hardware descrip languages）提供了一种通过使用文本文件来描述电路的方式；</p><ul><li>通过 keywords 和 expressions 来描述硬件：<ul><li>共用的形式：logic expression、truth table、functions、logic gates</li><li>任何的组合或者时序电路都可以描述；</li></ul></li><li>两个目标：<ul><li>通过计算机仿真（时序，延迟）来测试/验证；</li><li>综合：可综合的 HDL</li></ul></li><li>两种主要的硬件描述语言：VHDL、Verilog（主要）</li></ul><p><strong>HDL</strong>（verilog）：</p><ul><li>代表硬件结构和行为；</li><li>逻辑仿真：生成波形图</li></ul><p><strong>keywords 和 syntax（语法、词法）</strong>：</p><ul><li><code>//</code> 开始的表述注释；</li><li>一般有 100 个 keywords，是大小写敏感的（通常小写）；</li><li><code>module</code> 一个模块，以 <code>endmodule</code> 结束；</li><li><code>module</code> 后面跟电路名和端口（输入或输出）列表；</li></ul><p>两种基本的<strong>声明形式</strong>：</p><ul><li>Concurrent（同时）声明，常用在组合电路，执行与声明顺序无关；<ul><li>gate 实例化：<code>and (z,x,y)</code>，<code>or (c,a,b)</code>，<code>xor (S,x,y)</code>，etc</li><li>连续 assign：<code>assign Z=x&amp;y, c=a|b, S=x^y;</code></li></ul></li><li>Procedural（程序）声明，常用在时序电路，按书写的顺序执行；<ul><li><code>always @</code>：当 event 激活时连续执行</li><li><code>initial</code>：只执行一次（用在仿真里）</li><li><code>if then else</code></li></ul></li></ul><p><strong>wire</strong> 和 <strong>gate-level</strong>：</p><ul><li><code>wire</code>：定义为电路内部的连接点</li><li><code>and g1(e,A,B)</code>：一行定义一个 gate（and，or，xor），并为其指定名字，第一个参数为输出；</li></ul><p><strong>boolean 表达式</strong>；</p><ul><li>OR:<code>|</code>，AND:<code>&amp;</code>，NOT:<code>~</code></li></ul><p><strong>UDP</strong>（user defined primitives）用户自定义原语：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/UDP.png" alt="UDP"></p><p><strong>Modeling Circuit Delay</strong>：</p><ul><li>为了 simulation（不是 synthesis，synthesis 的延迟是不可控的）；</li><li>可以利用 <code>timescale 1ns/100ps</code>，定义仿真时间的单位；<ul><li><code>#(30)</code> 指示，gate 从输入到输出的延迟为 30ns；</li></ul></li></ul><p><strong>Test bench Stimulus（激励）</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/TBStimulus.png" alt="TBStimulus"></p><ul><li>然后就可以通过仿真波形图，观察电路是否满足预期要求；</li></ul><p><strong>Modiling Sequential Elements</strong>：</p><ul><li>D Latch：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DLatch.png" alt="DLatch"></li><li>D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DFlipflop.png" alt="DFlipflop"></li><li>带有同步 reset 的 D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/RDFlipflop.png" alt="RDFlipflop"></li></ul><p><strong>Assignment</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Assignment.png" alt="Assingment"></p><p><strong>Finite State Machines（有限状态机）</strong>：</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSM.png" alt="FSM"><br>利用状态图来展示：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSMStateDiagrams.png" alt="FSMStateDiagrams"></p><p>例：序列检测器 Sequence Detector</p><ul><li>电路功能：当收到 3 个连续的 1 时，输出 1；其余时候输出 0；</li><li>FSM 类型：Moore<ul><li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSequenceDetector.png" alt="MooreSequenceDetector"></li><li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSynthesizedSimulation.png" alt="MooreSynthesizedSimulation"></li></ul></li><li>FSM 类型：Mealy<ul><li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySequenceDetector.png" alt="MealySequenceDetector"></li><li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySynthesizedSimulation.png" alt="MealySynthesizedSimulation"></li></ul></li></ul><h1 id="FPGA-设计工具"><a href="#FPGA-设计工具" class="headerlink" title="FPGA 设计工具"></a>FPGA 设计工具</h1><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>下面的介绍都是在 Vivado 平台上介绍；</p><h3 id="组合电路：AND"><a href="#组合电路：AND" class="headerlink" title="组合电路：AND"></a>组合电路：AND</h3><p>① 写 Verilog 代码（comb.v）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_comb(data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//combinational circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out = data_1 &amp;&amp; data_2; <span class="comment">// binary bit-wise:&amp;, binary logic:&amp;&amp;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：</p><ul><li>Flow Navigator 里点击 <kbd>File-Project-New</kbd>，<kbd>next</kbd>；</li><li>输入 Project name, Project location，<kbd>next</kbd>；</li><li>选择 RTL Project，<kbd>next</kbd>；</li><li>选择 <kbd>Add Files</kbd>，添加 comb.v 文件，<kbd>next</kbd>；</li><li>如果需要的话，添加或者创建 Constraints Files，<kbd>next</kbd>；</li><li>选择 FPGA device，例如：xa7a12tcpg238-2l，<kbd>next</kbd>；</li><li>回顾：Project Summary，点击 <kbd>Finish</kbd>；</li></ul><p>③ 写 Verilog testbench（comb_sim.v)：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> data_1, data_2;        <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line">    and2_comb and2_comb_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span>               <span class="comment">//signal flow</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>;                  <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>④ 综合逻辑电路，并进行仿真</p><ul><li>Flow Navigator 里点击 <kbd>SYNTHESIS</kbd>，<kbd>Run Synthesis</kbd>；</li><li>之后就能得到一个 netlist，就可以以后进行 functional simulation；</li><li>在 source 窗口里，右键 Simulation Sources，选择 <kbd>Add Sources</kbd>；</li><li>选择 <kbd>Add or Create Simulation Sources</kbd>，添加编写好的 comb_sim.v 文件；</li><li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Functional Simulation</kbd></li></ul><p>⑤ 检查仿真结果</p><ul><li>仿真结束后，点击 Flow Navigator 里的 <kbd>Window</kbd> —&gt; <kbd>Waveform</kbd> 来查看波形图；</li></ul><h3 id="时序电路：AND"><a href="#时序电路：AND" class="headerlink" title="时序电路：AND"></a>时序电路：AND</h3><p>① 写 Verilog 代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_seq(clk,data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   clk,data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sequential circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out &lt;= data_1 &amp;&amp; data_2; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：</p><p>③ 写 Verilog testbench：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> clk,data_1, data_2;    <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line"></span><br><span class="line">    and2_seq and2_seq_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> <span class="comment">//signal flow</span></span><br><span class="line">        clk = <span class="number">1</span>; data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>; <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>④ 综合逻辑电路，并进行仿真</p><ul><li>综合，添加仿真文件；</li><li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Timing Simulation</kbd></li></ul><p>⑤ 检查仿真结果</p><h3 id="基于-IP-的电路：32-bit-Multiplier"><a href="#基于-IP-的电路：32-bit-Multiplier" class="headerlink" title="基于 IP 的电路：32-bit Multiplier"></a>基于 IP 的电路：32-bit Multiplier</h3><p>下面会从使用 DSP-IP 和不使用 DSP-IP 两个角度实现；   </p><p>① 写 verilog 代码（mul32.v）：   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mul32(mula,mulb,product,clk,rst);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mula;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mulb;</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulaq;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulbq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= <span class="number">0</span>;</span><br><span class="line">                    mulbq &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= mula;</span><br><span class="line">                    mulbq &lt;= mulb;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                product &lt;= <span class="number">64'h0123_4567_89ab_cdef</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                product &lt;= mulaq * mulbq;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：   </p><p>③ 写 Verilog testbench：略   </p><p>④ 综合逻辑电路：</p><ul><li>Flow Navigator 里点击 <kbd>Tools</kbd>，<kbd>Settings</kbd>；</li><li>找到 <kbd>Synthesis</kbd> 选项，设置 <kbd>max_dsp</kbd>为 -1（只用 DSP），0（不用 DSP）；</li></ul><p>⑤ 仿真：   </p><p>⑥ 检查仿真结果；   </p><p>⑦ 比较资源利用报告；</p><h2 id="执行时序分析"><a href="#执行时序分析" class="headerlink" title="执行时序分析"></a>执行时序分析</h2><p>定义时钟：</p><ul><li>在 Flow Navigator 里的 Project Manager section 里选择 <kbd>Add Source</kbd>；   </li><li>在对话框里，选择 <kbd>Add or Create Constraints</kbd>，点击 <kbd>next</kbd>；    </li><li>在接来下的对话框里，选择 <kbd>Create File</kbd>，File type：XDC，输入 File name，点击 <kbd>OK</kbd>，就会产生一个 xdc 的文件；    </li><li>在 Netlist Analysis section 下的 Flow Navigator 里找到 Implement，选择 Edit Timing Constraints；然后就会展示出一个时序约束的编辑窗口；    </li><li>双击 <kbd>Create Clock</kbd>，定义 clock：<ul><li>clock name：可以随便定义，这里定为：clk，它不会和设计中的任何成分匹配；</li><li>Source Object：点击 <kbd>…</kbd>：<ul><li>将后面的 <code>*</code> 改为 <code>*clk</code>，接着 clk 就会出现在 Find result 块里；</li><li>选择 clk，将其拖到 Selected 块里；</li></ul></li><li>OK，finish</li></ul></li><li>接来下就会返回到之前的窗口，会显示刚刚所定义的 clock 的信息；    </li><li>点击 <kbd>Save Constraints</kbd> 保存，双击 timing.xdc 文件，查看；   </li></ul><p>查看时序结果：</p><ul><li>接下来，也是在 Implement 下选择，<kbd>Report Timing Summary</kbd>，会出现一个窗口来显示之前的 timing 的定义，也可以在这里进行修改，之后点击 OK；    </li><li>会在 Design Timing Summary 里显示一些信息，例如：Worst Negative Slack，Worst Hold Slack 和 WPSN 等；    </li><li>也可以为所有的路径都产生一个 timing report：<ul><li>选择 <kbd>Tools</kbd> &gt; <kbd>Timing</kbd> &gt; <kbd>Report Timing</kbd>；</li><li>在产生的窗口里，点击 OK，就会生成一个十分详细的 timing report</li></ul></li></ul><h2 id="执行功耗分析"><a href="#执行功耗分析" class="headerlink" title="执行功耗分析"></a>执行功耗分析</h2><p>在 Synthesis 列里找到 <kbd>Report Power</kbd>，出现一个窗口显示相关的定义，可以修改一些参数等，点击 OK 后，就可以看到一个 Power Analythesis 的窗口，改窗口就显示了一些功耗信息；   </p><h1 id="设计约束与优化"><a href="#设计约束与优化" class="headerlink" title="设计约束与优化"></a>设计约束与优化</h1><p>Constraints 用于影响 FPGA 设计实现工具，包括：synthesizer 以及 place 和 route 工具；</p><ul><li>它们使设计团队可以指定设计性能要求，并指导工具满足这些要求；</li></ul><p>Implementation tools 会根据综合的优化级别，指定的时序，引脚分配以及设计团队提供给工具的逻辑分组来确定其操作的优先级；    </p><p>约束的四种主要类型包括：synthesis，I/O，timing 和 area/location 约束    </p><ul><li><strong>Synthesis constraints</strong>：影响如何将HDL代码合成为RTL的细节。 有多种综合约束，它们的上下文，格式和使用通常在不同工具之间有所不同。</li><li><strong>I/O constraints</strong>（通常也称为引脚分配）：用于将信号分配给特定的 I/O（引脚）或 I/O bank。I/O 约束还可用于为各个 I/O 和 I/O 组指定用户可配置的 I/O 特性；</li><li><strong>Timing constraints</strong>：用于指定设计的时序特性。时序约束可能会影响所有内部时序互连，逻辑和 LUT 以及触发器或寄存器之间的延迟。时间约束可以是全局约束，也可以是路径约束。</li><li><strong>Area constraints</strong>：用于将特定电路映射到 FPGA 内的一系列资源。位置约束指定相对于另一个设计元素或相对于 FPGA 中特定固定资源的位置；</li></ul><h2 id="Synthesis-Constraints"><a href="#Synthesis-Constraints" class="headerlink" title="Synthesis Constraints"></a>Synthesis Constraints</h2><p>综合约束的类型，语法和上下文通常在工具之间有所不同；   </p><p>下表列出了 Xilinx 综合工具（XST）的一些综合约束：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/XST.png" alt="XST">    </p><p>Synthesis Constraints 用于指导综合工具执行特定操作：</p><ul><li>例如，考虑综合约束 CLOCK_BUFFER。该约束用于指定时钟端口上使用的时钟缓冲区的类型；</li><li>可用于优化设计实现的两个重要综合约束是 REGISTER_BALANCING 和 INCREMENTAL_SYNTHESIS<ul><li>REGISTER_BALANCING 寄存器平衡用于优化性能</li><li>INCREMENTAL_SYNTHESIS 增量合成可减少合成时间</li></ul></li></ul><p><strong>Register balancing</strong>：用于通过跨寄存器边界移动布尔逻辑功能的位置来满足设计时序要求。</p><ul><li>寄存器平衡会增加电路时钟频率；</li><li>通过调整相对路径延迟可以获得改进的性能；</li><li>寄存器平衡分为两类，分别称为：forward 正向和 backward 反向平衡<ul><li>前向寄存器平衡旨在将位于 LUT 输入处的一组寄存器移至 LUT 输出处的单个寄存器；</li><li>后向寄存器平衡基于相反的原理，综合工具可将位于 LUT 输出处的寄存器移至 LUT 输入处的一组触发器。</li></ul></li><li>在该过程结束时，可以增加或减少设计中寄存器的总数（不确定）；</li></ul><p><strong>Incremental synthesis</strong>：的主要目的是减少编译设计所需的总时间：</p><ul><li>通过仅综合设计中已更改的部分来执行此操作；</li><li>综合工具在综合阶段可能具有不同的开关或约束，以支持此方法；</li><li>可能会严重影响综合阶段的其他两个因素包括保留已实现的设计层次结构以及正确使用设计约束；</li></ul><h2 id="Pin-Constraints"><a href="#Pin-Constraints" class="headerlink" title="Pin Constraints"></a>Pin Constraints</h2><p>重要的是要注意，引脚分配对于所有设计或设计中的所有引脚并不重要：</p><ul><li>I/O 余量较大或工作速度较慢的设计可能不需要仔细分配引脚；</li><li>但是，如果设计余量受到以下任何 FPGA 设计因素的限制，则引脚分配可能会成为关键因素：<ul><li>I/O 引脚可用性</li><li>FPGA 架构级逻辑资源</li><li>片内路由资源</li><li>所需逻辑速度与最大 FPGA 速度</li><li>所需的逻辑速度与实施设计所需的逻辑层之间的关系</li></ul></li></ul><p>设计时钟注意事项：</p><ul><li>时钟抖动影响会严重降低已实现系统的性能。时钟抖动的影响包括时序预算余量和性能的降低；</li><li>时钟偏差描述了相关信号和时钟到达时间之间的差异。信号和时钟偏斜的影响包括保持时间故障，数据错误和减少的 I/O 时序裕量；</li><li>时钟占空比失真会导致脉冲宽度减小，数据错误和电路性能不可靠；</li><li>时钟抖动，偏斜和占空比失真的影响会影响 FPGA 电路性能的所有水平，应仔细管理和控制；</li><li><strong>将 FPGA 时钟分成优先级组</strong>；<ul><li>使用约束条件来更清楚地表征设计工具的时钟。</li><li>约束可用于指定时钟速率，相位关系和占空比。</li><li>约束还可用于将高优先级时钟与其驱动的电路相关联。</li><li>时钟优先级组：<ul><li>高频率，高扇出</li><li>中频或低频，高扇出</li><li>高频率，低扇出</li><li>中频或低频，低扇出</li></ul></li></ul></li><li><strong>首先分配最高优先级的时钟</strong>。FPGA 时钟最重要的两个挑战是高速和高扇出。具有这些特征的时钟应分配给更高性能的全局资源。高性能缓冲区和路由资源的数量有限，因此应谨慎管理。</li><li><strong>分配时钟块管理资源</strong>。Xilinx’s 的数字时钟管理器（DCM）等时钟模块可以实现高级时钟电路功能，包括分频和乘法，相移，基于反馈的调整和同步时钟生成。时钟块是 FPGA 组件中有限的资源。设计团队应监视和控制如何分配这些资源。</li><li><strong>管理优先级较低的时钟</strong>。尽管较低优先级的时钟可以在完整的 FPGA 全局资源上实现（如果可用），它们也可以通过标准 FPGA 路由结构进行路由。有可能将全局时钟路由分成多个较小的高性能时钟路由。</li></ul><h2 id="Timing-Constraints"><a href="#Timing-Constraints" class="headerlink" title="Timing Constraints"></a>Timing Constraints</h2><p>时序约束可用于影响和指导设计元素的放置以及所放置元素之间的信号路径，以满足设计性能要求；   </p><p>时序约束的两种常规类型是全局约束和特定于路径的：</p><ul><li>全局时序约束涵盖了逻辑设计中的所有路径；</li><li>特定于路径的约束涵盖特定路径；</li></ul><p>指定时钟和数据信号的关系以及时序，以确保不违反内部 FPGA 寄存器的设置和保持时间要求；   </p><p>以下两个约束的时序关系为实施工具提供了最佳实施设计所需的信息：</p><ul><li>OFFSET_IN_BEFORE 约束用于定义在系统时钟的上升沿到达 FPGA 时钟引脚之前，数据信号应有效的时间；</li><li>VALID 约束用于指定系统时钟上升沿之后数据信号有效的时间量和数据信号有效的时间量；</li></ul><p>使用系统同步定时方法将信号从 FPGA 内部的寄存器发送到外部组件：</p><ul><li>了解 FPGA 对外部设备时序的要求是约束过程的第一步；</li><li>必须确定外部组件接口 I/O 标准，到外部组件的路由延迟以及 FPGA I/O 引脚的负载；</li><li>了解详细的时序值可以支持时序约束的分配，从而指定数据信号必须从内部 FPGA 寄存器的输出传播到 FPGA 输出引脚的最长时间；</li><li>FPGA 的内部延迟包括时钟路径延迟，寄存器时钟到输出时间以及从寄存器到输出引脚的数据路径延迟；</li></ul><p>基于这些约束，实现工具可以确定满足指定时序要求的路径路由。</p><h2 id="Area-Constraints"><a href="#Area-Constraints" class="headerlink" title="Area Constraints"></a>Area Constraints</h2><p>Area 限制了引导和控制布局布线工具可能将 FPGA 设计元素放置在何处：</p><ul><li>区域约束还可以定义设计元素的潜在放置区域。</li><li>区域约束的好处是可以减少布局布线工具的实施时间。</li><li>如果 block element 受区域限制，则放置和布线工具不必搜索放置 block element 的位置；</li><li>将多个设计元素块布置到目标 FPGA 架构上的过程通常称为布局规划；</li></ul><h2 id="Design-Optimization"><a href="#Design-Optimization" class="headerlink" title="Design Optimization"></a>Design Optimization</h2><p>设计优化是一个增量过程，需要增加工程量和工具计算时间来利用设计来满足时序要求。</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FPGAOptimization.png" alt="FPGAOptimization"></p><h1 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h1><p>设计练习1：组合电路 ⎯ 1 位加法器<br>设计练习2：组合电路 ⎯ 2 位乘法器<br>设计练习3：时序电路 ⎯ 1 位计数器<br>设计练习4：时序电路 ⎯ 4 位移位寄存器  </p><p>提示：在 Vivado 上执行 FPGA 设计:</p><ul><li>编写 Verilog 代码</li><li>创建项目</li><li>编写 Verilog testbench</li><li>综合逻辑电路</li><li>检查仿真结果 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 FPGA 具体的实验操作；&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-Outlook：New FPGA</title>
    <link href="http://www.thebetterkong.cn/2020/06/09/FPGA-technology/FPGA-Outlook-NewFPGA/"/>
    <id>http://www.thebetterkong.cn/2020/06/09/FPGA-technology/FPGA-Outlook-NewFPGA/</id>
    <published>2020-06-09T08:20:32.000Z</published>
    <updated>2020-08-14T09:31:27.837Z</updated>
    
    <content type="html"><![CDATA[<p>这是 FPGA 学习的最后一章。未来 FPGA 的发展也必定会迎合前沿时代的需求，例如：大数据时代的高性能计算、还有 AI 智能等等。</p><a id="more"></a> <h1 id="FPGA-高级综合（HLS）"><a href="#FPGA-高级综合（HLS）" class="headerlink" title="FPGA 高级综合（HLS）"></a>FPGA 高级综合（HLS）</h1><h2 id="HLS-发展动机"><a href="#HLS-发展动机" class="headerlink" title="HLS 发展动机"></a>HLS 发展动机</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLS.png" alt="HLS"></p><ul><li><strong>片上系统（SoC）设计</strong>复杂性的迅速增加鼓励了设计社区寻求比 RTL 更好的生产率的设计抽象； </li><li>电子系统级（ESL）设计的自动化已被广泛认为是半导体行业提高生产率的下一个推动力，HLS（例如 C 语言或 SystemC） 在其中发挥着核心作用;<ul><li>它可以实现 high-level 到 low-level 的自动综合，以在 FPGA（或 ASIC）中高效实现；</li><li>high-level 时只需 untimed 或 partially-timed 的规范，而像 RTL（寄存器传输级） 的 low-level 则需要考虑精确的时钟周期（延迟）；</li></ul></li><li>可以综合考虑特定系统的性能，功耗和成本要求来优化此综合；</li><li>这样，设计者只需利用 HLS 来设计电路，而精确的电路优化等工作就可以完全交由其他的综合软件来自动化完成，提高开发设计效率；</li></ul><h2 id="相关现状"><a href="#相关现状" class="headerlink" title="相关现状"></a>相关现状</h2><p>基于上述原因，也就迫使 FPGA 设计人员更快地采用 HLS 工具：</p><ol><li>减少正式验证的压力：<ul><li>纳米 IC 技术的 ASIC 制造成本超过 100 万美元，这就使 ASIC 设计人员要保证流片后一次成功，将承受巨大压力；</li><li>然而，要实现上述的要求，就依赖于 HLS 的正式验证工具，而这种工具的发展还不成熟，并且对于数百万 gate SOC 设计的仿真覆盖范围可能会受到限制；</li><li>这是在 ASIC 界采用 HLS 的重大障碍；</li><li>但是，对于 FPGA 设计，系统内仿真（直接在 FPGA 芯片上进行仿真，如果出现问题再进行调整，因为 FPGA 是可重配置的，所以这样的 cost 比较低）可以获得更广泛的仿真范围；</li><li><strong>设计迭代可以快速，廉价地完成，而无需付出巨大的制造成本</strong>；</li></ul></li><li>基于平台综合的理想选择：<ul><li>现代 FPGA 嵌入了许多预定义/制造的 IP 组件，例如：算术功能单元，嵌入式存储器，嵌入式处理器和嵌入式系统总线；</li><li>可以为每个 FPGA 平台提前对这些预定义的构建模块进行精确建模，并在很大程度上限制了设计空间；</li><li>因此，现代 HLS 工具可以应用基于平台的设计方法，获得更高的结果质量（QoR）</li></ul></li><li>上市时间的压力更大：<ul><li>FPGA 平台通常被选择用于十分看重上市时间的系统，以避免长时间的芯片设计和制造周期；</li><li>因此，设计人员可能会接受牺牲性能，功耗或成本，来减少设计时间；</li><li>现代的 HLS 工具将这种 tradeoff 的权利交给了设计人员，从而大大减少了设计时间，或者通过额外的努力，获得了与手写 RTL 相当的结果质量；</li></ul></li><li>加速或可重构的计算要求，需要 FPGA 可以基于 C/C ++ 进行编译/综合：<ul><li>FPGA 的最新发展使可重构计算平台，能用于加速许多高性能计算（HPC）应用程序，例如：图像和视频处理，财务分析，生物信息学和科学计算应用程序；</li><li>由于 VHDL 或 Verilog 中的 RTL 编程对于大多数应用软件开发人员来说是不可接受的，因此必须提供从 C/C++ 到 FPGA 的高度自动化的编译/综合流程；</li></ul></li></ol><h2 id="实现更高层次的设计"><a href="#实现更高层次的设计" class="headerlink" title="实现更高层次的设计"></a>实现更高层次的设计</h2><ul><li>从更高层次的描述性语言生成高质量的 RTL<ul><li>有益于功能验证和架构探索；</li><li>RTL 设计过程中不断迭代带来的时间开销可以被消除；</li><li>RTL 目标转向技术和频率；</li></ul></li><li>C++ 提供了更好的抽象级；SystemC 则可以提供时序上的设计；</li><li>许多关键应用已经开始使用 HLS 实现：<ul><li>Video Compression / Decompression (H.265/HEVC,VP9)</li><li>Image Processing ( Mobile/Ultra HD/3D)</li><li>Wireless/Wireline (5G,802.11x,Gb optical)</li></ul></li></ul><h2 id="FPGA-HLS-案例"><a href="#FPGA-HLS-案例" class="headerlink" title="FPGA HLS 案例"></a>FPGA HLS 案例</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLSExample.png" alt="HLSExamp"></p><ul><li>缺少直接的仿真工具；</li><li>在用 c/c++ 等高级语言描述时，并不是所有的语句都是可综合的，在遇到不可综合的语句时，需要我们改变语句写法；</li></ul><h1 id="面向深度神经网络（DNN）的-FPGA-设计"><a href="#面向深度神经网络（DNN）的-FPGA-设计" class="headerlink" title="面向深度神经网络（DNN）的 FPGA 设计"></a>面向深度神经网络（DNN）的 FPGA 设计</h1><p>FPGA 的主频虽然不高（不超过 1G），但是它可做大量的并行计算；</p><h2 id="FPGA-vs-GPU"><a href="#FPGA-vs-GPU" class="headerlink" title="FPGA vs. GPU"></a>FPGA vs. GPU</h2><ul><li>GPU（Graphics Processing Unit）—&gt; 通过软件编程的 ALU 阵列架构（粗粒度） —&gt; 具有统一数据类型（32位对应32位，64位对应64位）的常规计算<ul><li>功耗比较高</li></ul></li><li>FPGA —&gt; 通过硬件配置的并行数据处理架构（细粒度） —&gt; 具有自定义数据类型的常规和不规则计算（可以很好的适应神经网络中稀疏和细粒度的计算要求）<ul><li>因此，FPGA 可定制性更强，单位功耗的处理能力优于 GPU；</li></ul></li></ul><h2 id="迈向百亿分之一计算的并行性胜利"><a href="#迈向百亿分之一计算的并行性胜利" class="headerlink" title="迈向百亿分之一计算的并行性胜利"></a>迈向百亿分之一计算的并行性胜利</h2><ul><li>卷积神经网络（CNN）可在各种 AI 任务中提供最先进的准确性，但计算量大且耗能！</li><li>摩尔定律已经快到达极限，技术扩展速度变慢；</li><li>多核芯片达到了性能功耗比的上限；</li><li>处理器与内存之间的性能差距，形成了 wall；</li><li>需要去寻找高性能的计算芯片；</li><li>并行性在高性能计算中，占比越来越高；</li><li>期望通过<strong>并行性</strong>获得更多的系统性能（通过增加更多的处理核心）</li></ul><h2 id="机器学习和神经网络中的-FPGA-表现"><a href="#机器学习和神经网络中的-FPGA-表现" class="headerlink" title="机器学习和神经网络中的 FPGA 表现"></a>机器学习和神经网络中的 FPGA 表现</h2><ul><li>FPGA 是一种具有竞争性的 HPC（高性能计算）加速器技术；</li><li>FPGA 在人工智能计算中的性能比 CPU、GPU 和 ASIC 高几倍；</li><li>FPGA 实现了峰值性能的高利用率；</li><li>每瓦特的性能：FPGA 非常节能，同时非常灵活</li></ul><h2 id="why-FPGA-power-efficient"><a href="#why-FPGA-power-efficient" class="headerlink" title="why FPGA power efficient"></a>why FPGA power efficient</h2><p>为了减少能量消耗，少移动数据：</p><ul><li>数据移动会消耗更多的能量，FPGA 每次计算执行的数据移动较少；</li><li>互连消耗的能量（每毫米）的降低速度比计算消耗的能量的降低速度慢，片上数据移动消耗的能量将开始占主导地位；</li></ul><p>对于 FPGA 来说，并行性本质上是导致能量效率缩放的原因：</p><ul><li>随着工艺的先进，FPGA 的性能功耗比不断上升，而 CPU/GPU 的性能功耗比却呈下降趋势</li></ul><h2 id="解决-FPGA-设计问题的途径"><a href="#解决-FPGA-设计问题的途径" class="headerlink" title="解决 FPGA 设计问题的途径"></a>解决 FPGA 设计问题的途径</h2><p>FPGA 也需要迅速发展以拥抱新的尖端技术：</p><ul><li>计算问题：传统的 FPGA 体系结构不能很好地匹配 DNN（深度神经网络）算法的执行</li><li>需要面向 DNN 的 FPGA 数据处理架构设计</li></ul><p>CNN Algorithm：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNAlgorithm.png" alt="CNNAlgorithm"></p><ul><li>通过图层重复操作：Convolutional + Fully Connected + Pooling</li></ul><p>两种策略：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/TwoApproaches.png" alt="TwoApproaches"></p><ul><li>当前的 FPGA 综合流程并未考虑 CNN 的并行计算属性-<strong>非优化的实现</strong>（完全取决于设计人员精心设计的 Verilog 代码）</li><li>完全并行实施的资源（DSP 块和 BRAM 的数量）限制</li></ul><h2 id="目前-CNN-在-FPGA-上的实现"><a href="#目前-CNN-在-FPGA-上的实现" class="headerlink" title="目前 CNN 在 FPGA 上的实现"></a>目前 CNN 在 FPGA 上的实现</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNImplementation.png" alt="CNNImplementation">   </p><p>在 DNN 中压缩数据：</p><ul><li>量化：将浮点运算转换为定点运算</li><li>共享：分组权重</li><li>修剪：切掉小重量的树枝</li></ul><h2 id="适合-FPGA-的目标-AI-应用"><a href="#适合-FPGA-的目标-AI-应用" class="headerlink" title="适合 FPGA 的目标 AI 应用"></a>适合 FPGA 的目标 AI 应用</h2><ul><li>尺寸和能量受限的前端：<strong>边缘计算</strong></li><li>低功耗和高并行处理所需的数据中心：<strong>云计算</strong>（ 云和嵌入式系统的需求）</li></ul><h1 id="发展挑战和机遇"><a href="#发展挑战和机遇" class="headerlink" title="发展挑战和机遇"></a>发展挑战和机遇</h1><h2 id="FPGA-技术趋势"><a href="#FPGA-技术趋势" class="headerlink" title="FPGA 技术趋势"></a>FPGA 技术趋势</h2><p>四个时代的 FPGA:</p><ul><li>1984年-1991年：发明 Invention</li><li>1992年-1999年：扩张 Expansion</li><li>2000年-2007年：积累 Accumulation</li><li>2008年-2017年：融合 Fusion</li><li>2018年：可编程计算架构创新？</li></ul><h2 id="新兴技术驱动的-FPGA"><a href="#新兴技术驱动的-FPGA" class="headerlink" title="新兴技术驱动的 FPGA"></a>新兴技术驱动的 FPGA</h2><ol><li>新的可编程 brain inspired computing 体系结构—-现场可编程神经阵列(FPNA)</li><li>新的可编程 in-memory computing 体系结构</li><li>基于新设备(rRAM)的可编程计算体系结构</li></ol><h2 id="现在可能得到答案的问题"><a href="#现在可能得到答案的问题" class="headerlink" title="现在可能得到答案的问题"></a>现在可能得到答案的问题</h2><p>[ Steve Trimberger, Fellow, Xilinx Research Labs, 2014 ]：</p><ul><li>为什么 FPGA 编译时间这么长？FPGA 公司愚蠢吗？还是他们不在乎？</li><li>为什么选择 LUT？那是自然法则还是什么？</li><li>为什么动态编程的 FPGA 从来没有到过任何地方？现在可以改变吗？<ul><li>Tabula 的“时空” 3D FPGA 架构将时间作为第三维度，从而允许以高达 2 GHz 的时钟速率动态地重新配置片上逻辑，存储器和互连资源。</li></ul></li><li>为什么没有规范的 FPGA 架构？</li><li>可重构计算发生了什么？</li><li>如果处理器是新的 LUT，那么处理器阵列呢？</li><li>FPGA 的多芯片分区发生了什么？</li><li>模拟 FPGA 呢？那么异步 FPGA 呢？</li><li>为什么 FPGA 制造商不提供 ASIC 转换？</li><li>FPGA 制造商为什么要坚持拥有自己的位置和路线？他们也会接管逻辑综合吗？那么高级综合呢？</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>可编程设备的创新以非常快的速度持续进行；</li><li>在未来几年中，我们可以预期制造商将利用设计和制造技术两者的优势来继续提高 FPGA 的功能；</li><li>摩尔定律的终结可能即将到来，但是 FPGA 的用户可以期待更多代的性能和功能的提高；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 FPGA 学习的最后一章。未来 FPGA 的发展也必定会迎合前沿时代的需求，例如：大数据时代的高性能计算、还有 AI 智能等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础入门</title>
    <link href="http://www.thebetterkong.cn/2020/06/07/Git/GitStart/"/>
    <id>http://www.thebetterkong.cn/2020/06/07/Git/GitStart/</id>
    <published>2020-06-07T13:51:07.000Z</published>
    <updated>2021-03-05T07:32:43.000Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/GitStart/header.png" width="100%" alt="header.png" /> </div>   <p>使用 git 已经挺长时间了，也在网上看过不少的学习教程。但是怎么说呢，git 的操作实在是太杂了，某一种目标可能就有好多种不同的实现方式，而且这些不同的实现方式又可能产生不同的结果。以至于，每次在网上查找到的解决方案可能都不同，然后不停地往 OneNote 里记笔记，时间久了，笔记越来越乱，再加上记忆力本就不好，原先不会的现在还是不会。于是寻思着简单的梳理一下。</p><a id="more"></a><h1 id="认识-git"><a href="#认识-git" class="headerlink" title="认识 git"></a>认识 git</h1><h2 id="什么是-git？"><a href="#什么是-git？" class="headerlink" title="什么是 git？"></a>什么是 git？</h2><p>它是一个<strong>分布式版本控制系统</strong>，用于项目开发中的版本控制；</p><ul><li>从本质上来讲 Git 是一个<strong>内容寻址（content-addressable）文件系统</strong>，并在此之上提供了一个版本控制系统的用户界面；</li><li>它的核心其实就是<strong>键值对数据库（key-value data store）</strong>，</li></ul><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>git 管理下的项目的文件分为：<strong>已跟踪</strong>和<strong>未跟踪</strong>两种状态</p><ul><li>已跟踪的文件：是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区；</li><li>工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区；</li><li>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态；</li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>文件快照</strong>；</li><li>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>；</li><li>该提交对象会包含一个指向暂存内容快照的指针，但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针；</li></ul><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p><img src="http://img.thebetterkong.cn/blog/GitStart/gitmemory.png" alt="gitmemory">   </p><div class="table-container"><table><thead><tr><th>名称</th><th>区域</th><th>解释</th></tr></thead><tbody><tr><td>Workspace</td><td>工作区</td><td>当前用户操作修改的区域</td></tr><tr><td>Index/Stage</td><td>暂存区</td><td>add 后的区域</td></tr><tr><td>Repository</td><td>仓库区或本地仓库</td><td>commit 后的区域</td></tr><tr><td>Remote</td><td>远程仓库</td><td>push 后的区域</td></tr></tbody></table></div><h1 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真要说起来 git 里的难点也就是分支的使用。之前在同学的 blog 里找到了一个很好的学习 git 分支的平台：<a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">learnGitBranching</a>。与其说是学习，你更可以在无聊的时候把它当作一个 “游戏”，一边玩耍一边学习。其实最主要的，还是它能动态的帮助你理解 git 命令。</p><p><img src="http://img.thebetterkong.cn/blog/GitStart/Learngitbranching.png" alt="Learngitbranching">   </p><p>接下来的描述也会对它的一些操作进行梳理，毕竟复习或者查阅的时候，再去网站操作一遍，效率比较低。    </p><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>在正式介绍命令之前，先对 git 里常用的<strong>符号或者关键字</strong>进行说明：  </p><ul><li>分支名后带有符号 <code>*</code>：表示当前分支 </li><li><code>HEAD</code>：通常会和当前分支绑定在一起，总是指向当前分支上最近一次提交记录；<ul><li>但是也可以 <code>git checkout c1</code> 来<mark><strong>分离 HEAD</strong></mark>（c1 是某次提交记录的 hash 值，通常会很长，可以使用 <code>git log</code> 查看；当然了，也可以利用 tag 实现），使其指向某次具体的提交记录；分离之后的提交将不属于任何分支，一般的做法是在此处再创建一个新的分支，然后再 commit 进行后续的操作；</li><li>大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的；</li></ul></li><li>相对引用 <code>^</code>：向上移动一个提交记录，可叠加使用，如：HEAD^^^<ul><li>要注意：引用可以是分支名或者 HEAD，提交记录（如 c1）不算引用</li></ul></li><li>相对引用 <code>~&lt;num&gt;</code>：向上移动 num 个提交记录，如：~3</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">******************************************************</span><br><span class="line">##### git 配置</span><br><span class="line">$ git config --global user.name &quot;&lt;用户名&gt;&quot;</span><br><span class="line">$ git config --global user.email &quot;&lt;电子邮件&gt;&quot;</span><br><span class="line"></span><br><span class="line">## git 配置信息查看</span><br><span class="line">$ git config --system --list    &#x2F;&#x2F; 查看系统config</span><br><span class="line">$ git config --global  --list   &#x2F;&#x2F; 查看当前用户（global）配置</span><br><span class="line">$ git config --local  --list    &#x2F;&#x2F; 查看当前仓库配置信息</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 初始化仓库</span><br><span class="line">$ git init </span><br><span class="line">$ rm -rf .git   &#x2F;&#x2F; 删除本地仓库</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看当前缓存区状态</span><br><span class="line">$ git status    </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看历史提交记录</span><br><span class="line">$ git log</span><br><span class="line">$ git log --decorate        &#x2F;&#x2F; 显示包含标签资料的历史记录；</span><br><span class="line">$ git log --pretty&#x3D;oneline  &#x2F;&#x2F; 只看版本号和提交的版本信息</span><br><span class="line">$ git log --graph            &#x2F;&#x2F; 查看分支合并图</span><br><span class="line"></span><br><span class="line">### 查看分支图信息</span><br><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">$ git log --graph --decorate --oneline --all </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看文件的修改</span><br><span class="line">$ git diff &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 将修改添加到缓存区</span><br><span class="line">$ git add -A    &#x2F;&#x2F; 所有文件都添加，也可以使用 $ git add .</span><br><span class="line">$ git rm --cached &lt;file&gt;  &#x2F;&#x2F; 删除缓存，撤销 git add 的操作</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 提交变更</span><br><span class="line">$ git commit -m &quot;version 1.2&quot;   &#x2F;&#x2F; 引号内是本次提交的命名</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 克隆远程数据库 </span><br><span class="line">$ git clone &lt;repository&gt; &lt;directory&gt;</span><br><span class="line">  &#x2F;&#x2F; 在&lt;repository&gt;指定远程数据库的URL；</span><br><span class="line">  &#x2F;&#x2F; 在&lt;directory&gt;指定新目录的名称，省略时默认为当前目录；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 从远程数据库拉取更新至本地 </span><br><span class="line">$ git pull &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">  &#x2F;&#x2F; &lt;repository&gt; 处输入远程数据库地址；</span><br><span class="line">  &#x2F;&#x2F; &lt;refspec&gt; 处指定远程数据库的分支；</span><br><span class="line">$ git pull                &#x2F;&#x2F; github 上常用的抓取最新提交的方式</span><br><span class="line">$ git pull origin develop &#x2F;&#x2F; 从远程 origin 数据库的 develop 分支抓到本地的当前分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 将本地数据推送至远程数据库</span><br><span class="line">$ git push &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">$ git push origin master &#x2F;&#x2F; 将本地的当前分支推送至远程 origin 数据库的 master 分支</span><br><span class="line">$ git push -u origin master </span><br><span class="line">  &#x2F;&#x2F; 第一次推送 master 分支时，远程库是空的，加上了-u 参数，</span><br><span class="line">  &#x2F;&#x2F; Git 不但会把本地 master 分支内容推送至远程新的 master </span><br><span class="line">  &#x2F;&#x2F; 分支，还会把本地 master 分支和远程 master 分支关联起来，</span><br><span class="line">  &#x2F;&#x2F; 以后就可以直接 git pull &#x2F; git push 简化命令</span><br><span class="line">$ git push --set -upstream &lt;远程仓库名称&gt; &lt;远程仓库中分支名称&gt;</span><br><span class="line">  &#x2F;&#x2F; 手动将本地当前分支与远程仓库的分支关联</span><br><span class="line">$ git push -f origin master  &#x2F;&#x2F; 强制推送</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 添加远程数据库</span><br><span class="line">$ git remote add &lt;name&gt; &lt;url&gt;  </span><br><span class="line">  &#x2F;&#x2F; 添加的同时，给远程数据库命名，以后不用再输入URL；</span><br><span class="line">  &#x2F;&#x2F; 默认为：origin</span><br><span class="line">$ git remote set-url &lt;name&gt; &lt;url&gt;  &#x2F;&#x2F; 修改 git 的 remote url</span><br><span class="line">$ git config -e                    &#x2F;&#x2F; 从配置里修改 git 的 remote url</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的创建&#x2F;查看&#x2F;修改</span><br><span class="line">$ git branch                   &#x2F;&#x2F; 显示分支列表（带*的为当前分支）；</span><br><span class="line">$ git branch &lt;branchname&gt;      &#x2F;&#x2F; 创建分支并命名；</span><br><span class="line">$ git branch -d &lt;branchname&gt;   &#x2F;&#x2F; 删除本地分支；</span><br><span class="line">$ git push origin --delete &lt;branchname&gt; &#x2F;&#x2F; 删除远程分支；</span><br><span class="line">$ git branch -f master HEAD~3  &#x2F;&#x2F; 将 master 分支强制指向 HEAD 的第 3 级父提交；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的退出&#x2F;切换</span><br><span class="line">$ git checkout &lt;branchname&gt;     &#x2F;&#x2F; 退出当前分支并切换到其他分支；</span><br><span class="line">$ git checkout -b &lt;branchname&gt;  &#x2F;&#x2F; 创建分支并进行切换；</span><br><span class="line">$ git checkout commit_id&#x2F;tag    &#x2F;&#x2F; 分离 HEAD 至 commit_id&#x2F;tag 的提交处 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支合并 merge</span><br><span class="line">$ git merge &lt;branch&gt;           &#x2F;&#x2F; 将指定分支合并到当前分支</span><br><span class="line">$ git merge --squash &lt;branch&gt;  &#x2F;&#x2F; 将目标分支的所有提交压缩为一个，并添加到当前分支；</span><br><span class="line">$ git merge --abort            &#x2F;&#x2F; 取消当前合并，重建合并前状态 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支重定向 rebase（也可用来分支合并）</span><br><span class="line"> &#x2F;&#x2F; Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去；</span><br><span class="line"> &#x2F;&#x2F; 若用在分支合并，相比于 merge，可以创造更线性的提交历史</span><br><span class="line">$ git rebase &lt;branch&gt;   &#x2F;&#x2F; 把当前分支重定向到目标分支;</span><br><span class="line">$ git rebase --abort    &#x2F;&#x2F; 取消 rebase；</span><br><span class="line">$ git rebase -i HEAD~2  &#x2F;&#x2F; 编辑模式修改分支基准（修改pick，实现压缩squash&#x2F;修改edit等）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 选择重构 cherry-pick</span><br><span class="line">$ git cherry-pick &lt;commit&gt;...   &#x2F;&#x2F; 取出选择的提交并添加到当前分支</span><br><span class="line">  </span><br><span class="line">*******************************************************</span><br><span class="line">#### 还原 revert</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git revert HEAD   &#x2F;&#x2F; 取消某次提交（会新增否定的历史记录来实现）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 重置 reset</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git reset --hard HEAD^  &#x2F;&#x2F; 重置结构 &#x2F;（删除）提交等（历史记录会消失）</span><br><span class="line">$ git reset --hard commit_id</span><br><span class="line">&#x2F;&#x2F; 如果想让服务器也回退到该版本的话：$ git push origin HEAD --force</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 标签 tag</span><br><span class="line">$ git tag                       &#x2F;&#x2F; 显示标签列表；</span><br><span class="line">$ git tag -n                    &#x2F;&#x2F; 显示标签列表及注解；</span><br><span class="line">$ git tag &lt;tagname&gt; &lt;commit_id&gt; &#x2F;&#x2F; 新建一个轻标签，默认为 HEAD，也可以指定commit id</span><br><span class="line">$ git tag -am &lt;注释&gt; &lt;tagname&gt;  &#x2F;&#x2F; HEAD 指向的提交里打上注释标签；</span><br><span class="line">$ git tag -d &lt;tagname&gt;          &#x2F;&#x2F; 删除本地标签；</span><br><span class="line">$ git checkout &lt;tagname&gt;        &#x2F;&#x2F; 切换到对应标签的提交点，会分离 HEAD</span><br><span class="line">$ git push origin &lt;tagname&gt;     &#x2F;&#x2F; 想远程仓库推送一个 tag</span><br><span class="line">$ git push origin --tags        &#x2F;&#x2F; 推送全部未推送过的本地 tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt; &#x2F;&#x2F; 删除一个远程标签</span><br></pre></td></tr></table></figure><p>更多详情：『<a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git 官方手册</a>』</p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>总结常用命令，还是免不了量越来越大，变得混乱的问题。所以，再加上一个模块，记录一些可能不那么常用的组合操作；   </p><p>这一块内容以后会慢慢不断更新；</p><p>先扔一个 Git 常用操作的索引：『<a href="https://backlog.com/git-tutorial/cn/reference/" target="_blank" rel="noopener">Git 操作索引</a>』</p><h3 id="修改-commit-注释"><a href="#修改-commit-注释" class="headerlink" title="修改 commit 注释"></a>修改 commit 注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~2    &#x2F;&#x2F; 选择至所需修改的节点</span><br><span class="line">&#x2F;&#x2F; 会出现 pick: commit_id &lt;注释&gt;， 将要改的那行的 pick 改成 edit 然后退出</span><br><span class="line">&#x2F;&#x2F; 此时使用 $ git log，可以版本已经变成了你想改的那个</span><br><span class="line">&#x2F;&#x2F; 修改版本提交注释</span><br><span class="line">$ git commit --amend      &#x2F;&#x2F; 接受，保存修改，并提交</span><br><span class="line">$ git rebase --continue   &#x2F;&#x2F; 接受 rebase 的执行</span><br></pre></td></tr></table></figure><h3 id="取消-track-某一文件"><a href="#取消-track-某一文件" class="headerlink" title="取消 track 某一文件"></a>取消 track 某一文件</h3><p><code>git rm -r --cache &lt;file_name&gt;</code></p><ul><li>untrack 后，使用 commit -a 时，不会将其添加到暂存区中；</li><li>之后会在 .ignore 文件中将该 untrack 的文件添加进去，完成；</li></ul><h3 id="文件暂存（栈）"><a href="#文件暂存（栈）" class="headerlink" title="文件暂存（栈）"></a>文件暂存（栈）</h3><p>你要把现在正在工作的分支保存下来，等处理完其他的再回来接着当前分支的修改工作：</p><ol><li>将当前分支的修改暂存起来（此处不等于 add+commit）：<code>git stash</code><ul><li>备份当前的工作区的内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到 Git 栈中暂存起来。</li></ul></li><li>切换到别的分支工作，完成后切换回原来的工作分支，查看暂存列表 <code>git stash list</code>：<ul><li>显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复</li></ul></li><li>恢复暂存的修改到工作区 <code>git stash apply &lt;stash_name&gt;</code> 恢复暂存之后不删除暂存：<ul><li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容。</li></ul></li><li>或者 <code>git stash pop</code> 恢复暂存之后删除暂存：<ul><li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容；</li><li>之后 pop 会删除最新的暂存；</li></ul></li><li>删除 “暂存”：<code>git stash drop &lt;stash_name&gt;</code><ul><li>从 Git 栈删除最旧的一个暂存</li></ul></li><li>结束</li></ol><h3 id="设置-git-代理"><a href="#设置-git-代理" class="headerlink" title="设置 git 代理"></a>设置 git 代理</h3><p>有时在客户公司办公，需要上外网，临时查一下资料，设置办法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置代理:</span><br><span class="line">$ git config --global http.proxy http:&#x2F;&#x2F;IP:Port</span><br><span class="line"></span><br><span class="line"># 代理设置完成后，查看设置是否生效：</span><br><span class="line">$ git config -–get -–global http.proxy</span><br><span class="line"></span><br><span class="line"># 删除代理设置</span><br><span class="line">$ git config --global --unset http.proxy</span><br></pre></td></tr></table></figure><h1 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h1><h2 id="Branch-管理"><a href="#Branch-管理" class="headerlink" title="Branch 管理"></a>Branch 管理</h2><p>推荐使用如下 5 个分支开发管理：</p><p><img src="http://img.thebetterkong.cn/blog/GitStart/BranchManage.png" alt="BranchManage"></p><div class="table-container"><table><thead><tr><th>分支</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>master 分支</td><td>主分支(保护分支)</td><td>只负责管理发布的状态，在提交时使用标签记录发布版本号</td></tr><tr><td>develop 分支</td><td>开发分支</td><td>针对发布的日常开发分支</td></tr><tr><td>feature 分支</td><td>特性分支</td><td>- 这个分支是针对<strong>新功能的开发</strong>，在 bug 修正的时候从 develop 分支分叉出来的；<br>- 基本上不需要共享特性分支的操作，所以不需要远端控制，完成开发后，把分支合并回 develop 分支后发布；</td></tr><tr><td>release 分支</td><td>发布分支</td><td>- 一般的开发是在 develop 分支上进行的，到了可以发布的状态时再创建 release 分支，为 release 做最后的 bug 修正；<br>- 到了可以 release 的状态时，把 release 分支合并到 master 分支，并且在合并提交里添加 release 版本号的标签；<br>- 注意：要导入在 release 分支所作的修改，也要合并回 develop 分支；</td></tr><tr><td>fix 分支</td><td>bug 修复分支</td><td>需要根据实际情况对已发布的版本进行漏洞修复；</td></tr></tbody></table></div><p>详见：『<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">原文</a>』</p><h2 id="Tag-管理"><a href="#Tag-管理" class="headerlink" title="Tag 管理"></a>Tag 管理</h2><p>通常 Tag 采用三段式：<code>v版本.里程碑.序号（v2.3.1）</code></p><ul><li>架构升级或架构重大调整，修改第 1 位</li><li>新功能上线或者模块大的调整，修改第 2 位</li><li>bug 修复上线，修改第 3 位</li></ul><h2 id="Commit-管理"><a href="#Commit-管理" class="headerlink" title="Commit 管理"></a>Commit 管理</h2><p>不管采用怎样的表述方式，最终目标都是：<strong>表达清楚、格式统一、方便快速阅读和定位</strong></p><p>建议格式（type：scope：body：issue） ：</p><ul><li><code>&lt;|新功能|修改|Bug修复|重构|测试&gt;（影响模块）提交描述信息（#issue?）</code></li></ul><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>这个模块先仍在这，之前遇到的问题也没怎么记录，这篇文章已经把我总结的有点头大了。以后，再遇到问题再在这里更。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">Learngitbranching</a></li><li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的 Git</a></li><li>另，本篇文章是根据以前的笔记写的，以前的笔记也有参考网上资料，但是记不清来源了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/GitStart/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;使用 git 已经挺长时间了，也在网上看过不少的学习教程。但是怎么说呢，git 的操作实在是太杂了，某一种目标可能就有好多种不同的实现方式，而且这些不同的实现方式又可能产生不同的结果。以至于，每次在网上查找到的解决方案可能都不同，然后不停地往 OneNote 里记笔记，时间久了，笔记越来越乱，再加上记忆力本就不好，原先不会的现在还是不会。于是寻思着简单的梳理一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.thebetterkong.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.thebetterkong.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（详解 + java 实现）</title>
    <link href="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/"/>
    <id>http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/</id>
    <published>2020-06-04T06:58:23.000Z</published>
    <updated>2020-08-14T09:29:12.959Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  <p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，我们会将排序算法分为两个大类：     </p><div class="table-container"><table><thead><tr><th>类名</th><th>解释</th></tr></thead><tbody><tr><td>内部排序</td><td>（本文主要讨论的）待排序记录存放在计算机随机存储器中进行的排序过程；</td></tr><tr><td>外部排序</td><td>待排序记录的数量很大，以至于内存一次不能够容纳全部记录，在排序过程中尚需对外村进行访问的排序过程；</td></tr></tbody></table></div><p>在排序算法中，为了衡量每一种算法的性能，我们通常会提及如下概念：     </p><div class="table-container"><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>稳定排序</td><td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序；</td></tr><tr><td>非稳定排序</td><td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序；</td></tr><tr><td>原地排序</td><td>在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间来进行比较和交换，从而完成排序；</td></tr><tr><td>非原地排序</td><td>需要利用额外的数组来辅助排序；</td></tr></tbody></table></div><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ul><li><strong>依据排序原则可分为 5 大类</strong>：插入排序、交换排序、选择排序、归并排序、计数排序</li><li><strong>按算法时间分为 3 大类</strong>：简单排序 $O(n^2)$、先进排序 $O(nlogn)$、基数排序 $O(d \cdot n)$</li></ul><p>接下来介绍的各种排序算法都可以归入上述各个分类；</p><h2 id="规律总述"><a href="#规律总述" class="headerlink" title="规律总述"></a>规律总述</h2><p>排序过程中都会进行两种基本操作：</p><ol><li>比较两个关键字大小；（对大多数排序方法都是必要的）</li><li>将记录从一个位置移动到另一个位置；（可通过改变记录的存储方式来避免）</li></ol><p>待排序记录的 3 种存储方式：    </p><div class="table-container"><table><thead><tr><th>存储方式</th><th>记录之间的次序关系</th><th>排序实现方式</th></tr></thead><tbody><tr><td>地址连续的一组存储单元上（例如：线性表）</td><td>由存储位置决定</td><td>必须借助记录移动</td></tr><tr><td>（链表排序）静态链表中</td><td>指针指示</td><td>修改指针即可</td></tr><tr><td>（地址排序）记录本身存储在一组地址连续的存储单元内，同时又设一个指示各个记录存储位置的地址向量</td><td></td><td>先移动地址向量中记录的“地址”，排序结束后再按地址向量中的值调整记录的存储位置</td></tr></tbody></table></div><p>本文主要是介绍排序算法的思想，为方便讨论，默认所介绍的排序算法都是基于第一种存储方式，且待排序记录的关键字均为整数；</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>基于 “插入” 操作进行的排序方式；</p><h2 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h2><p><strong>基本操作</strong>：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</p><ul><li>整个过程可以理解为，打扑克牌时，你是怎样来捋扑克牌的顺序的？</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gInsertSort.gif" alt="InsertSort"></p><p><strong>缺点</strong>：无序数组排序时，为了插入元素，需要将其余所有元素在插入之前都向右移动一位；</p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的排序算法：直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 开始 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从当前位置向前寻找插入位置</span></span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp)</span><br><span class="line">            k--;</span><br><span class="line">        <span class="comment">//找到要插的位置 k + 1，移动元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &gt; k + <span class="number">1</span>; j--)</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        arr[k+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定排序，原地排序 </li></ul><h3 id="改进：折半插入"><a href="#改进：折半插入" class="headerlink" title="改进：折半插入"></a>改进：折半插入</h3><p><strong>基本思路</strong>：在直接插入排序的过程中，将 “搜索插入位置” 这一步骤利用 “折半查找实现”   </p><p><strong>评价</strong>：不可取，仅仅减少了直接插入排序中关键字间的比较次数，而记录的移动次数不变，时间复杂度仍为：$O(n^2)$。    </p><h3 id="改进：2-路插入"><a href="#改进：2-路插入" class="headerlink" title="改进：2-路插入"></a>改进：2-路插入</h3><p><strong>目标</strong>：减少排序过程中移动记录的次数    </p><p><strong>具体思路</strong>：</p><ul><li>假设，待排序数组为 L.r，新设一个同类型的数组 d；</li><li><code>d[0] = L.r[0]</code>，并将 <code>d[0]</code> 看做排好序的序列中处于中间位置的记录；</li><li>然后，从 <code>L.r[1]</code> 开始，依次插入到 <code>d[0]</code> 之前和之后的已排好序的有序表中</li><li>例子：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/2WayInsert.png" alt="2WayInsert"><ul><li>first 和 final 是两个指针，分别指向排序过程中得到的有序列表里第一个记录和最后一个记录在 d 中的位置；</li></ul></li></ul><p><strong>评价</strong>：不可取，带来了新的空间开销，也只是减少移动记录的次数（不能完全避免），并且如果 <code>L.r[0]</code> 就是待排序列表里最大或最小的元素，则此方法优越性完全失效；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用插入排序，那么在排序过程中就不可避免的需要移动记录，否则，只能改变其存储结构（之前提及的：链式排序、地址排序）。</p><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>又称：缩小增量排序</p><p><strong>基本思想</strong>：先将整个待排记录序列分割为若干个子序列，对子序列分别进行直接插入排序，待整个序列的记录 “基本有序” 时，再对全体记录进行一次直接插入排序。    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gShellSort.gif" alt="ShellSort"></p><p><strong>过程举例</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/ShellSort.png" alt="ShellSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//默认步长为数组长度除以2</span></span><br><span class="line">    <span class="keyword">int</span> step = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        step = step / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//确定分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            <span class="comment">//对分组数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + step; j &lt; arr.length; j = j + step) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="keyword">for</span>( k = j-step; k &gt;= <span class="number">0</span>; k = k-step)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                        arr[k+step] = arr[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k+step] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：与选取的 “增量” 序列函数直接相关，目前为止，没有人能找出最优的 “增量” 序列函数，上述算法中，复杂度为 $O(nlogn)$</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基于 “交换” 操作进行的排序方式；<strong>快排</strong>（Quick Sort）是基于<strong>冒泡排序</strong>（Bubble Sort）的一种改进排序算法。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p><strong>基本思想</strong>：第 i 趟冒泡排序，从 <code>L[0]</code> 到 <code>L[n-1-i]</code> 依次比较每个记录与其下一个记录的大小，并在 “逆序” 时交换这两个记录（最终结果是，这 n-i+1 个记录里，最大值被交换到 n-i 的位置）；完成整个排序过程，也就需要有 $k(1\leq k&lt;n)$ 趟，判断结束的条件为：某趟冒泡过程中不出现交换操作。</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBubbleSort.gif" alt="BubbleSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最优的冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j , k;</span><br><span class="line">    <span class="keyword">int</span> flag = a.length; <span class="comment">// flag记录每趟冒泡的尾边界，同时也作为算法结束的标志</span></span><br><span class="line">    <span class="comment">// 用 flag 标记算法是否结束</span></span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)&#123; </span><br><span class="line">        k = flag;   <span class="comment">// k记录某趟遍历的尾边界</span></span><br><span class="line">        flag = <span class="number">0</span>;   <span class="comment">// 只要不发生交换，就不会进行下一趟冒泡，算法结束</span></span><br><span class="line">        <span class="comment">// 冒泡开始：</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="comment">//前面的数字大于后面的数字就交换a[j-1]和a[j]</span></span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">                <span class="comment">// 发生了交换，让flag重新记录新的尾边界</span></span><br><span class="line">                flag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定排序、原地排序</li></ul><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p><strong>基本思想</strong>：通过一趟排序将待排记录分割为独立的两部分，其中一部分的关键字均比另一部分的关键字小，再分别对这两部分进行排序，已达到整个序列有序的目的；</p><ul><li>设定两个指针 low 和 high，初始时指向开头和结尾位置；枢值记录关键字 key，初始为第一个元素值；</li><li>先从 high 指示位置向前搜索，找到第一个值小于 key 的记录，和 key 交换位置；</li><li>然后从 low 位置起向后搜索，找到第一个值大于 key 的记录，和 key 交换位置；</li><li>重复上面两步，直至 low=high；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gQuickSort.gif" alt="QuickSort">  </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low &lt; index -<span class="number">1</span>)</span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>); <span class="comment">//区间左右都是闭包</span></span><br><span class="line">        <span class="keyword">if</span> (high &gt; index + <span class="number">1</span>)</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排的非递归实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//基于栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        stack.push(high);</span><br><span class="line">        stack.push(low);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> index = partition(a, l, h);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h &gt; index + <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(h);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间函数：某一趟快排的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="comment">// 将序列排列至枢纽两端</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从high向前，找第一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[high] &gt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从low向后，找第一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[low] &lt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在枢纽两端的元素位置都确定后，枢纽的位置也就确定了</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">// 返回枢纽位置，进行下一趟排序</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(logn)$</li><li>非稳定排序、原地排序</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h2><p><strong>主要思路</strong>：每一趟在 $n-i+1\ (i=1,2,…,n-1)$ 个记录中选取关键字最小的记录作为有序序列中第 i 个记录    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gSelectionSort.gif" alt="SelectionSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// 共 n-1 轮选择排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从未排序的[i，n-1]的序列中，选择最小元素</span></span><br><span class="line">        <span class="keyword">int</span> min = i;  <span class="comment">//先默认a[i]是最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span>(a[min] &gt; a[j])  <span class="comment">//找到更小的值，就更新</span></span><br><span class="line">                min = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换，使最小的元素位于a[i]位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[min];</span><br><span class="line">        a[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li></ul><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p><strong>目的</strong>：减少比较的次数</p><p><strong>理论基础</strong>：竞标赛比赛机制</p><ul><li>8 名运动员选出前 3 名，最多只需要 11 场比赛；</li><li>第一轮：7 场比赛决出冠军</li><li>第二轮：2 场比赛决出亚军</li><li>第三轮：2 场比赛决出季军</li></ul><p><strong>详情</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/TreeSelectSort.png" alt="TreeSelectSort"></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>缺点：所需的辅助空间太大、和最大值进行了多余的比较；</li><li>于是，进一步改进为：堆排序算法</li></ul><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆</strong>：一个完全二叉树里，每个结点的值都大（小）于其左右孩子（如果存在的话）节点的值，则称这样的二叉树为大（小）顶堆    </p><p><strong>堆排特点</strong>：只需要一个记录大小的辅助空间，每个待排序的记录只占有一个存储空间   </p><p><strong>基本思想</strong>：</p><ul><li>初始建堆：<ul><li>将序列按层次遍历看成是一个完全二叉树，则最后一个非终端节点是第 $\lfloor n/2 \rfloor$ 个元素；</li><li>因此，从第 $\lfloor n/2 \rfloor$ 个元素开始，往前对每个结点，反复 “下沉” 调整：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/BuildHeap.png" alt="BuildHeap"></li></ul></li><li>循环删除，下沉：<ul><li>删除堆顶，把删除的元素放在二叉树最后一个位置；</li><li>“下沉” 调整；<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/Sink.png" alt="Sink"></li></ul></li></ul><p><strong>过程展示</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gHeapSort.gif" alt="HeapSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 堆排序</span></span><br><span class="line"><span class="comment">*  下沉操作，执行删除操作相当于把最后</span></span><br><span class="line"><span class="comment">*  * 一个元素赋给根元素之后，然后对根元素执行下沉操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent 要下沉元素的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="comment">// 从最后一个非终端节点开始，不断往前下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶元素与最后一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// 把打乱的堆进行调整，恢复堆的特性</span></span><br><span class="line">        downAdjust(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆调整：下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时保存要下沉的元素</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">    <span class="comment">//定位左孩子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//开始下沉，需一直下沉至堆底</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子节点比左孩子大，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">// 如果孩子节点小于或等于父节点，则下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父节点进行下沉</span></span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">//更新孩子，继续下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp; <span class="comment">//下沉完毕，完成交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$，时间主要浪费在初始建堆和堆调整时的下沉操作上</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li><li>适用情景：对记录较少的文件并不提倡，但对 n 较大的文件还是很有效的；</li></ul><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p><strong>基本思路</strong>：（2-路归并）假设初始序列含有 n 个记录，则可以看成 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 $\lceil \frac{n}{2} \rceil$ 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止；</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gMergeSort.gif" alt="MergeSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序（递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归地对左右两边进行排序</span></span><br><span class="line">        MergeSort(arr, low, mid);</span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序（非递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 1开始分割，与递归不同的是，递归由数组长度一分为二最后到1，</span></span><br><span class="line">    <span class="comment">// 而非递归则是从1开始扩大二倍直到数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">while</span> (arr.length &gt; len) &#123;    </span><br><span class="line">        <span class="comment">// 完全二叉树一层内的遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= arr.length - <span class="number">1</span>; i += len * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> mid = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i + len * <span class="number">2</span> - <span class="number">1</span>;            </span><br><span class="line">            <span class="comment">// 防止超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; arr.length - <span class="number">1</span>)</span><br><span class="line">                right = arr.length - <span class="number">1</span>;            </span><br><span class="line">            <span class="comment">// 合并排序相同</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 下一层</span></span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间函数：merge</span></span><br><span class="line"><span class="comment">// 将两个有序数组合并成一个有序数组；</span></span><br><span class="line"><span class="comment">//    arr[low,mif]表示一个数组，arr[mid+1,high]表示一个数组</span></span><br><span class="line"><span class="comment">// 因为数组有序，合并只要维护几个指针即可；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// temp 数组用于暂存合并的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//左半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="comment">//右半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//合并后数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录由小到大地放进 temp 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">        arr[low + l] = temp[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$</li><li>稳定排序、非原地排序</li></ul><h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p><strong>适用场景</strong>：最大值和最小值的差值不是不是很大的排序</p><p><strong>基本思想</strong>：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gCountingSort.gif" alt="CountingSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中间数组，存放arr里各元素出现的次数</span></span><br><span class="line">    <span class="comment">//为节约内存空间，从0开始编号（0对应min），最后一个元素max-min（对应max）</span></span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mapPos = arr[i] - min;</span><br><span class="line">        help[mapPos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        <span class="comment">//把help某个位置对应的所有值全部输出（重复值）</span></span><br><span class="line">        <span class="keyword">while</span>(help[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++] = i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n+k)$，k 表示临时数组大小</li><li>空间复杂度：$O(k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><p><strong>基本思想</strong>：把最大值和最小值之间的数进行瓜分（例如分成 5 个区间，5 个区间对应 5 个桶），然后，把各元素放到对应区间的桶中去，再对每个桶中的数进行排序（可以采用前面提过的排序算法）。之后每个桶里面的数据就是有序的了，最后再进行合并汇总；</p><p><strong>适用场景</strong>：数据基本呈均匀分布的情况，这样才能保证各个桶里的数据量基本相同，不至于浪费 “桶” 所带来的时间和空间开销；</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBucketSort.gif" alt="BucketSort"></p><p><strong>问题</strong>：桶排序是怎样优化性能的？</p><ul><li>举个例子：<ul><li>我们假设有 100 个待排序的呈均匀分布的数，如果我们直接采用冒泡排序（时间复杂度为 $O(n^2)$），那么我们的时间开销将在 $100^2=10000$ 量级上；</li><li>现在，我们采用桶排序，划分出 10 个桶，因为数据呈均匀分布，那么每个桶里也就是 10 个数据，在每个桶里再单独进行冒泡排序，将 10 个桶都排好序的时间开销也就是  $10^2 \times 10=1000$ 量级上，即使算上桶划分、桶合并的时间，也远远低于 10000；</li></ul></li><li>经过这个例子，应该也就基本了解桶排序的优势所在，用普遍的数学公式表示：<ul><li>假设有 n 个数据，采用某种排序方式（时间复杂度为$O(n^i)$），这样直接排序的时间开销也就是：$n^i$</li><li>现在，我们分为 k 个桶进行桶排序，桶内仍然采用同样的排序算法:<ul><li>如果原数据呈均匀分布，那么时间开销也就是：$({\frac{n}{k})}^i \times k + f(k,n)= \frac{n^i}{k^{i-1}} + f(k,n)$，其中，$f(k,n)$ 为划分桶和合并桶的时间开销，它是一个和 k，n 有关的一阶函数，可以暂且忽略不考虑，将时间开销定为：$\frac{n^i}{k^{i-1}}$，对比 $n^i$，优势就很明显了；</li><li>那如果数据不呈均匀分布，我们考虑极端的情况，也就是这 n 个数据全部被分到 k 个桶里的同一个，那么现在的时间开销也就是：$n^i + f(k,n)$，对比 $n^i$，也就没了任何优势，并且还带来额外的时间、空间上的开销；</li></ul></li></ul></li></ul><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶划分</span></span><br><span class="line">    <span class="comment">// 定义桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>; </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//某个元素所属桶号</span></span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序（排序算法也可以自己定义）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//System.out.println(bucketArr.toString());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把每个桶排序好的数据进行合并汇总放回原数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer t : bucketArr.get(i)) &#123;</span><br><span class="line">            arr[k++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n+k)$，k 表示桶个数</li><li>空间复杂度：$O(n+k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>是一种借助多关键字排序的思想（“分配” 和 “收集” 两种操作）对单逻辑关键字进行排序的方法；有两种排序方式：最高位优先（MSD）、最低位优先（LSD）   </p><p><strong>基本思想</strong>：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位，最终得到的序列就是一个有序序列；</p><ul><li>在具体到某一位的排序时，是利用 “桶” 排序来实现的。数据的某一位取值情况为：0-9，需要 10 个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照 0 号桶到 9 号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gRadixSort.gif" alt="RadixSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radioSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值位数num</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每位数值从0-9，10 种取值，创建 10 个桶 </span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从个位数开始，循环，对每一位排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取每个数最后第 i 位是数组</span></span><br><span class="line">            <span class="keyword">int</span> radio = (arr[j] / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放进对应的桶里</span></span><br><span class="line">            bucketList.get(radio).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并放回原数组</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : bucketList.get(j)) &#123;</span><br><span class="line">                arr[k++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出来合并了之后把桶清光数据</span></span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(kn)$，k 表示最大数位数</li><li>空间复杂度：$O(n+k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="排序算法对比分析"><a href="#排序算法对比分析" class="headerlink" title="排序算法对比分析"></a>排序算法对比分析</h1><div class="table-container"><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>最好时间</th><th>最坏时间</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(nlogn)$</td><td></td><td></td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(logn)$</td><td>不稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table></div><p>注意：以上时间复杂度，供参考，有些算法还需要根据具体情况实际分析；</p><p><strong>总结</strong>：</p><ul><li>从平均时间性能上看，快排是最优选择，但是其最坏情况下性能不如堆排和归并排序。对后两者来说，如果 n 较大，选择归并排序更省时，但是比较废空间；</li><li>直接插入排序时最简单的排序，当记录数较少，或基本有序时，是最佳选择。因此，它也常和其他排序方式结合使用；</li><li>一般来说，排序过程中的 “比较” 在 “相邻的两个记录关键字” 间进行的排序方法是文档的；稳定性由方法本身决定，总能找出反例；如果排序按主关键字进行，那么算法稳定性不重要，但如果按次关键字进行，则需要重点考虑；</li><li>因此，排序算法没有好坏之分，要根据实际情况选择最合适的方法；</li><li>经研究表明：所有借助于 “比较” 进行排序的算法在最坏情况下能达到的最好的时间复杂度为：$O(nlogn)$</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>『<a href="https://www.cnblogs.com/kubidemanong/p/10404197.html" target="_blank" rel="noopener">十大排序算法，看这篇就够了(附完整代码/动图/优质文章)</a>』</li><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>另：文中动图均来源网络，最终出处没能找到，如原作者看到，可联系我加入参考地址</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-CAD Tools：Routing</title>
    <link href="http://www.thebetterkong.cn/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/"/>
    <id>http://www.thebetterkong.cn/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/</id>
    <published>2020-05-31T03:01:36.000Z</published>
    <updated>2020-11-02T07:54:58.257Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 FPGA 技术里 Routing 部分；</p><a id="more"></a> <h1 id="概述-FPGA-Routing"><a href="#概述-FPGA-Routing" class="headerlink" title="概述 FPGA Routing"></a>概述 FPGA Routing</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>一个过程，该过程确定应打开哪些可编程开关（Connections blocks 和 switch blocks），以连接电路所需的所有逻辑块输入和输出引脚。</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/WhatRouting.png" alt="whatrouting">    </p><p>目的：</p><ul><li>必须用设备的互连资源，使 FPGA 中的逻辑集群良好连接，从而使电路正常工作</li></ul><p>方法:</p><ul><li>路由资源图（RRG）生成</li><li>路由算法</li></ul><p>目标:</p><ul><li>减少接线（wirelength 驱动）</li><li>最大化电路速度（timing 驱动）</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>良好的路由至关重要，路由不正确会导致：</p><ul><li>导致最大运行速度降低</li><li>增加功耗</li><li>实施时间慢，甚至无法路由所有信号</li></ul><p>寻找一个好的路线是具有挑战性的：</p><ul><li>布线资源（电线和连接点）相对稀缺</li><li>信号将争夺相同的路由资源</li></ul><h2 id="Routing-结构"><a href="#Routing-结构" class="headerlink" title="Routing 结构"></a>Routing 结构</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingArchitecture.png" alt="RoutingArchitecture"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingResources.png" alt="RoutingResources"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingPath.png" alt="RoutingPath">    </p><h2 id="Routing-问题"><a href="#Routing-问题" class="headerlink" title="Routing 问题"></a>Routing 问题</h2><p>路由电路等效于在 RRG 中找到一组满足时序约束的不相交路径：</p><ul><li>路由资源图（RRG）G =（V，E）：是代表目标设备路由资源的主要数据结构</li><li>NP-complete 问题：NP 完全问题是无法以任何已知方式在多项式时间内求解</li></ul><p>相关术语：</p><ul><li>Input：<ul><li>电路里所有的 sources：$S=\{s_1,s_2,s_3,…,s_m\}$</li><li>电路里所有的 sinks：$T=\{T_1,T_2,T_3,…,T_m\}$，其中，$T_i=\{t_i^1,t_i^2,t_i^3,…,t_i^n\}$，代表了： $s_i$ 所通向的所有 sinks</li></ul></li><li>Solution：<ul><li>查找从每个 source $s_i$ 到 $T_i$ 中所有 sinks 的路径；</li><li>来自不同 source 的路径必须是不相交的（不能共享任何节点或边）；</li></ul></li></ul><p>约束关系：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Constraints.png" alt="Constraints"></p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>FPGA routing 一般经过三个步骤：RRG 生成、Global Routing、Detailed Routing  </p><ul><li>现代路由算法可以同时执行全局和详细路由；   </li></ul><p><strong>Routing Resource Graph (RRG) Generation</strong>：</p><ul><li>RRG 是表示 FPGA 全局路由架构的有向图；</li><li>在此图中，每条导线和每个逻辑块引脚成为一个节点，潜在连接变为边；</li></ul><p><strong>Global Routing</strong>：消除 congestions（拥堵）</p><ul><li>全局路由器执行<strong>粗路由</strong>，以确定每个连接必须通过的最小路由路径；</li><li>如果要路由的网络有两个以上的终端，则全局路由器会将网络分成一组两个终端的连接，并分别路由每个集合；</li><li>全局路由器为每个连接考虑多种路由方法，并选择通过最少拥塞路由路径的路由；</li><li>通过跟踪每个路由通道的使用情况，避免拥塞；并且实现了全局路由器的主要目标，即平衡路由通道的使用；</li><li>一旦所有连接都经过粗路由，就可以通过撕裂每个连接并重新路由几次来优化该解决方案；</li><li>之后，最终解决方案将传递到详细的路由器；</li></ul><p><strong>Detailed Routing</strong>：去分配 tracks/wires 和 switches</p><ul><li>细粒度</li><li>详细路由器为每两点连接，确定在全局路由器分配的路由通道中<strong>使用的特定布线段</strong>；</li><li>详细的路由算法将从路由资源中<strong>构造一个有向图</strong>，以表示 FPGA 中的 wires，C blocks，S blocks 和逻辑块之间的可用连接；</li><li>在此有向图上执行的搜索通常基于 <strong>Dijkstra 算法</strong>来找到两个节点之间的最短路径；</li><li>根据<strong>成本函数</strong>对路径进行标记，该成本函数考虑了每个线段的使用情况以及互连点的距离；</li><li>通过使用<strong>曼哈顿度量标准</strong>计算互连点边界框中的导线长度来估算距离；</li><li>大多数路由器<strong>放宽</strong>了对边界框的<strong>限制</strong>，并允许在边界框的周围路由通道中搜索可能的解决方案；<ul><li>这是为了避免，如果解决方案位于边界框的外部附近，则会导致后续的重复撕裂和重新路由；</li></ul></li></ul><h2 id="Route-结果"><a href="#Route-结果" class="headerlink" title="Route 结果"></a>Route 结果</h2><p>VTR 形式（.Route）：易读但不直观<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRForm.png" alt="VTRForm"></p><h1 id="RRG（Routing-Resource-Graph）"><a href="#RRG（Routing-Resource-Graph）" class="headerlink" title="RRG（Routing Resource Graph）"></a>RRG（Routing Resource Graph）</h1><h2 id="Circuit-到-Graph"><a href="#Circuit-到-Graph" class="headerlink" title="Circuit 到 Graph"></a>Circuit 到 Graph</h2><p>与 DAG 的 FPGA 映射不同，但也作为有向图：</p><ul><li>Node：wire / logic block pin</li><li>Edge：potential connection</li><li>Node Capacity：可以在合法路由中使用此节点的不同网络的最大数量</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/CircuitToGraph.png" alt="CircuitToGraph"></p><h2 id="LUT-的-inputs-等价"><a href="#LUT-的-inputs-等价" class="headerlink" title="LUT 的 inputs 等价"></a>LUT 的 inputs 等价</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/LUTInput.png" alt="LUTInput"></p><h2 id="软件表示"><a href="#软件表示" class="headerlink" title="软件表示"></a>软件表示</h2><h3 id="XML（eXtensible-Markup-Language）"><a href="#XML（eXtensible-Markup-Language）" class="headerlink" title="XML（eXtensible Markup Language）"></a>XML（eXtensible Markup Language）</h3><p>是在 VTR 里面使用的，一种具有可选属性的开始和结束标记的层次结构；</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/XML.png" alt="XML"></p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>YAML 不是标记语言，是另一标记语言的递归形式，易于表示和阅读：   </p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/YAML.png" alt="YAML"></p><h3 id="表示过程"><a href="#表示过程" class="headerlink" title="表示过程"></a>表示过程</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SoftwareTrans.png" alt="SoftwareTrans"></p><p>注意：每个供应商都有自己的 FPGA 架构形式和数据结构建立方法，这些形式不会向客户透露（属于公司的专有技术）</p><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><h2 id="Maze（迷宫）路由"><a href="#Maze（迷宫）路由" class="headerlink" title="Maze（迷宫）路由"></a>Maze（迷宫）路由</h2><p>迷宫路由算法：</p><ul><li>基于波前扩展技术，该技术尝试在两点之间找到最短路径，同时避免使用任何路由资源；</li><li>一个迭代过程，该过程会撕裂并重新路由某些路由，以消除拥塞的路由通道；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze1.png" alt="Maze1"></p><p>主要缺点：它进行路由时不会考虑找到的路径会阻止后续网络的路由；</p><ul><li>这意味着算法的性能取决于网络排序，并且<strong>不同的顺序将产生不同的结果</strong>；</li><li>如果颠倒了下面两个网的布线顺序，则会找到更好的解决方案；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze2.png" alt="Maze2"></li></ul><h2 id="A-搜索路由"><a href="#A-搜索路由" class="headerlink" title="$A^*$ 搜索路由"></a>$A^*$ 搜索路由</h2><ul><li>迷宫路由是 $A^*$ 路由的特例；</li><li>$A^*$ 路由允许将路径搜索从广度优先搜索算法（BFS）调整为较短的深度优先搜索算法（DFS）；<ul><li>BFS 是一种详尽的搜索，它考虑了所有可能的路径，如果有任何路径，则会找到最佳路径，但缺点是速度可能很慢；</li><li>同时，DFS 可能找不到最小的成本路径，但可能很快；</li></ul></li></ul><p>$A^*$ 路由利用 0 到 1 之间的比例因子 α 进行加权，从而将搜索从 BFS 调整为 DFS；  </p><script type="math/tex; mode=display">f_i=(1-\alpha) \times (f_{i-1}+c_i)+\alpha \times d_i</script><ul><li>cost 用于评估每个节点 i 的有向图的成本函数：<ul><li>$c_i$ 是节点 cost，表示节点的当前使用情况，用于惩罚先前路由所占用的节点； </li><li>$f_{i-1}$是前一条路径的总成本；（函数的前半部分相当于 DFS）</li><li>$d_i$ 是从节点 i 到目的地的路径的估计成本；（函数的前半部分相当于 BFS）</li></ul></li></ul><h2 id="PathFinder-路由算法"><a href="#PathFinder-路由算法" class="headerlink" title="PathFinder 路由算法"></a>PathFinder 路由算法</h2><p>顾名思义，PathFinder 可在 RRG 中的两个节点之间找到路径：</p><ul><li>消除拥塞</li><li>最小化关键路径的延迟</li><li><strong>同时</strong>进行全局和详细路由</li><li>使用广泛：对 VTR 中使用的学术路由工具，进行了深入研究</li></ul><h3 id="知识概述"><a href="#知识概述" class="headerlink" title="知识概述"></a>知识概述</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathFinderOverview.png" alt="PathFinderOverview">    </p><p>RRG 里的 BFS：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/BFSInRRG.png" alt="BFSInRRG"></p><ul><li>每个正方形代表一个节点：S-source，T-sink，Number-cost</li></ul><p>逐一（source-sink）路由所有网络：</p><ul><li>为 RRG 中的每个边（可能的连接）分配取决于当前用法和历史用法的成本；</li><li>每个网络都由 BFS 路由，目的是使成本最低；</li><li>多个网络可能在 RRG 中使用相同的节点（导线/逻辑块）（标记为拥塞）；</li><li>于是，为拥塞节点分配更高的成本；</li><li>如果一条路由必须包含一个拥塞的节点，它将与其他路由“协商”，并使其绕过（翻录和重新路由）；</li></ul><p>重复固定时间：</p><ul><li>成功：为所有网络提供不相交的路由解决方案；</li><li>失败：经过固定次数（30）的迭代后，没有找到不相交的路由解决方案；</li></ul><h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p><strong>Routability Cost Function</strong>：</p><ul><li>对于节点 n：<script type="math/tex; mode=display">Cost(n) = p(n)\ast[\ b(n)+h(n)\ ]</script></li><li>其中：<ul><li>$b(n)$：通过节点 n 进行路由的 <strong>Base Cost</strong>（基本成本）</li><li>$h(n)$：<strong>History Cost</strong>（历史成本），与通过节点 n 路由的历史成本有关（基于以前的路由器迭代）</li><li>$p(n)$：<strong>Penalty of congestion</strong>（拥塞处罚），与在当前迭代中通过节点 n 路由的网（信号）的数量有关</li></ul></li></ul><p><strong>Timing-Routability Cost Function</strong>：</p><ul><li>对每个结点 n：<script type="math/tex; mode=display">Cost(n) = Crit(i,j) \ast delay(n) + [\ 1-Crit(i,j)\ ] \ast p(n) \ast [\ b(n) + h(n)\ ]</script></li><li>其中：<ul><li>$delay(n)$：通过节点 n 的网络的延迟</li><li>$Crit(i,j) = 1- \frac{slack(i,j)}{D_{max}}$<ul><li>$Crit(i,j)$：从 source i 到 sink j 的路径的估计临界度</li><li>$D_{max}$：关键路径的延迟</li></ul></li></ul></li></ul><h3 id="Congestion"><a href="#Congestion" class="headerlink" title="Congestion"></a>Congestion</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Congestion.png" alt="Congestion"></p><h3 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathfinderPseudoCode.png" alt="PathfinderPseudoCode"></p><h1 id="路由算法：VTR-Router"><a href="#路由算法：VTR-Router" class="headerlink" title="路由算法：VTR Router"></a>路由算法：VTR Router</h1><h2 id="Routability-driven-Router"><a href="#Routability-driven-Router" class="headerlink" title="Routability-driven Router"></a>Routability-driven Router</h2><h3 id="Cost-Function-1"><a href="#Cost-Function-1" class="headerlink" title="Cost Function"></a>Cost Function</h3><script type="math/tex; mode=display">PathFinder: Cost(n) = [\ b(n) + h(n)\ ] \times p(n)</script><script type="math/tex; mode=display">VTR Router:\ Cost(n)=b(n) \times h(n) \times p(n) + BendCost(n,m)</script><ul><li>$b(n)$，$h(n)$ 和 $p(n)$ 分别是节点 n 的基本成本，历史成本和拥塞惩罚（在PathFinder 算法中定义）；</li><li>$BendCost(n，m)$ 会对弯曲的全局路线造成不利影响，因为这些路线不太可能使用长导线，从而使详细（局部）路线难以实施（更容易发生拥塞）；<ul><li>如果建立从节点 m 到节点 n 的连接会产生弯曲，则 $BendCost(n，m)= 1$；</li><li>如果执行了组合的全局详细路由，则 $BendCost(n，m)= 0$；</li></ul></li><li>将 $b(n)$ 和 $h(n)$ 相乘可消除归一化；</li></ul><h3 id="Base-Cost"><a href="#Base-Cost" class="headerlink" title="Base Cost"></a>Base Cost</h3><div class="table-container"><table><thead><tr><th>Routing Resource，n</th><th>Base Cost，b(n)</th></tr></thead><tbody><tr><td>Wire segment</td><td>1</td></tr><tr><td>Logic block output pin</td><td>1</td></tr><tr><td>Logic block input pin</td><td>0.95</td></tr><tr><td>Source</td><td>1</td></tr><tr><td>Sink</td><td>0</td></tr></tbody></table></div><ul><li>五个 $b(n)$ 值中的四个约为 1，这鼓励路由器使用尽可能少的这些资源；</li><li>将逻辑块输入引脚的成本设置为略小于 1，可以使搜索更早地到达 terminal（inputs 和 sinks）；</li><li>将 sink 的成本设置为 0，因为在 sink 中不会发生拥塞；</li><li>通过这种方式为逻辑块 inputs 和 sinks 使用较低的成本，可使路由器速度提高 1.5 到 2 倍；</li><li>实验表明，将线段的 $b(n)$ 设置为 1 可获得最佳效果；</li></ul><h3 id="Penalty-of-Congestion"><a href="#Penalty-of-Congestion" class="headerlink" title="Penalty of Congestion"></a>Penalty of Congestion</h3><script type="math/tex; mode=display">p(n) = 1 + \max(0\ ,\ [\ occupancy(n) + 1 - capacity(n)\ ] \cdot p_{fac})</script><ul><li>$occupancy(n)$：使用资源（节点）n 的网络数；</li><li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PenaltyExample.png" alt="PenaltyExample"></li><li>$p_{fac}$：routing schedule 之一；为了获得最高质量，第一次迭代时将其设置为 0.5，随后的每次迭代将其增加 1.5 倍至 2.0 倍；<ul><li>快速增加 $p_{fac}$ 会导致质量下降（想象一下，收取过多的交通拥堵费会导致没有人想要在城市开车）；</li></ul></li></ul><h3 id="History-Cost"><a href="#History-Cost" class="headerlink" title="History Cost"></a>History Cost</h3><script type="math/tex; mode=display">{h(n)}^i=\begin{cases}1,\quad i=1 \\\\{h(n)}^{i-1}+\max(0,[occupancy(n)-capacity(n)]\cdot h_{fac}),\quad i>1\end{cases}</script><ul><li>$occupancy(n)$：使用资源（节点）n 的网络数；</li><li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；</li><li>$h_{fac}$：routing schedule 之一；设置为常数，并且介于 0.2 到 1 之间的任何值都可以正常工作。</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/HistoryCostExample.png" alt="HistoryCostExample"></p><h3 id="Net-布线顺序"><a href="#Net-布线顺序" class="headerlink" title="Net 布线顺序"></a>Net 布线顺序</h3><p>按 fan-out 的降序排列网络，因为：</p><ol><li>高 fan-out 网络倾向于覆盖整个 FPGA<ul><li>在较早路由的其他网络拥塞较少的情况下，更易于路由</li></ul></li><li>低 fan-out 网络往往更局部化<ul><li>即使在某些拥挤的情况下，也相对容易布线</li></ul></li></ol><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/NetOrderExample.png" alt="NetOrderExample"></p><h3 id="算法加速：方案一"><a href="#算法加速：方案一" class="headerlink" title="算法加速：方案一"></a>算法加速：方案一</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeOneExample.png" alt="SchemeOneExample"></p><ul><li>在 source 和 sinks 周围定义一个边界框（<strong>bounding box</strong>）；</li><li>将每个网络的路由限制在边界框外不超过 3 个 channels；<ul><li>鼓励在 bounding box 里进行 routing；</li></ul></li><li>大大减少了 BFS 搜索时间（由于使用较少的 channels）；</li><li>对路由质量没有明显影响；</li></ul><h3 id="算法加速：方案二"><a href="#算法加速：方案二" class="headerlink" title="算法加速：方案二"></a>算法加速：方案二</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample.png" alt="SchemeTwoExample"><br>对于高扇出网络，重用部分路由会更有效；</p><ul><li>从波前局部的推进路由</li></ul><p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample2.png" alt="SchemeTwoExample2">   </p><h3 id="算法加速：方案三"><a href="#算法加速：方案三" class="headerlink" title="算法加速：方案三"></a>算法加速：方案三</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeThreeExample.png" alt="SchemeThreeExample"></p><h3 id="算法加速：方案四"><a href="#算法加速：方案四" class="headerlink" title="算法加速：方案四"></a>算法加速：方案四</h3><ul><li>无方向的 BFS 非常耗时；</li><li>引入了定向搜索（基于曼哈顿距离：source 到 sink 的距离）；</li></ul><p>但是，当障碍物是凹形的时：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeFourExample.png" alt="SchemeFourExample"></p><ul><li>BFS 找到最佳路线，但很费时间；</li><li>Directed Search（贪婪）可节省时间，但可能找不到最佳路线；</li></ul><p>成本函数可适当平衡 BFS 和定向搜索（贪婪）:</p><script type="math/tex; mode=display">TotalCost(n)=PathCost(n)+ \alpha \cdot ExpectedCost(n,j)</script><ul><li>$PathCost(n)$：从当前部分路由树到节点 n 的路径总成本；</li><li>$ExpectedCost(n，j)$：从当前节点 n 到目标sink j 的估计成本；</li><li>$\alpha$：<ul><li>1 导致 $A^*$ 搜索；</li><li>1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li></ul></li></ul><h2 id="Timing-driven-Router"><a href="#Timing-driven-Router" class="headerlink" title="Timing-driven Router"></a>Timing-driven Router</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>相对于 “PathFinder” 的<strong>两个主要改进</strong>：</p><ol><li>在 <strong>Elmore 延迟估计</strong>下优化延迟，而不是线性延迟（在线性延迟中，每个路由资源都具有恒定的延迟）：<ul><li>对于任何在其路由中包含 pass transistors 的 FPGA 而言，线性延迟模型都是非常不准确的；</li></ul></li><li><strong>动态改变</strong>路由资源的基本成本：<ul><li>根据要路由的<strong>网络的跨度</strong>更改<strong>长 wire segments 的成本</strong>，以使路由器偏向于使用正确的路由资源类型（buffer 或 pass transistors）；</li></ul></li></ol><h3 id="等效电路"><a href="#等效电路" class="headerlink" title="等效电路"></a>等效电路</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/EquivalentCircuits.png" alt="EquivalentCircuits"><br>便于计算延迟；</p><h3 id="Elmore-延迟"><a href="#Elmore-延迟" class="headerlink" title="Elmore 延迟"></a>Elmore 延迟</h3><p>用于分布式 RC 效果；   </p><script type="math/tex; mode=display">ElmoreDelay_{source-sink}=\sum_{i\in(source-sink\ path)} C_i\ R_{i,sink}+T_{d,i}</script><ul><li>$T_{d,i}$：节点 i（缓冲区）的固有延迟；否则为 0；</li><li>$C_i$：节点 i 处金属和寄生电容的等效电容；</li><li>$R_{i,sink}$：<strong>source 到节点 i</strong> 和 <strong>source 到不带缓冲区的 sink</strong> 之间的共享路径上的等效电阻；<ul><li>公式表示：$R_{i,sink}=\sum R_{shared}$，其中，$R_{shared}\in [\ path(source-i) \cap path(source-sink)]$</li></ul></li></ul><p>计算示例（注意：结点 2、4 也属于 source 到 sink 路径上的结点）：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ComputingElmoreDelay.png" alt="ComputingElmoreDelay">    </p><p><strong>Case1：M wire segments 通过 buffers 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByBuffers.png" alt="ByBuffers"></p><ul><li>Buffer 的固有延迟：$T_{buf,intrinsic}=125ps$</li><li>Wire 的电阻：$R_{buf}=500 \Omega$</li><li>导线的金属电容和寄生电容：$C_{total}=250fF$</li><li>则，$T_{d,buffered}=M \cdot [\ T_{buf,intrinsic}+R_{buf}\cdot C_{total}\ ]=M \cdot 250\ (ps)$</li><li>在 buffer 这种情况下，Linear 和 Elmore 延迟模型相同；</li></ul><p><strong>Case2：M wire segments 通过 pass transistors 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByPassTransistors.png" alt="ByPassTransistors"></p><ul><li>Pass transistor 的电阻：$R_{pass}=500 \Omega$</li><li>结点的电容：$C_{total}=250fF$</li><li>Linear：$T_{d,pass,linear}=M \cdot R_{pass} \cdot C_{total}=M \cdot 125(ps)$</li><li>Quadratic：$\sum^M_{i=1}\ i\cdot R_{pass} \cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot R_{pass}\cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot 125 (ps)$</li><li>在 pass transistor 的情况下，Linear 和 Elmore 延迟模型都有很大的不同；</li></ul><h3 id="具有-Elmore-延迟的-Cost-Function"><a href="#具有-Elmore-延迟的-Cost-Function" class="headerlink" title="具有 Elmore 延迟的 Cost Function"></a>具有 Elmore 延迟的 Cost Function</h3><p>考虑连接到 net i 的 sink j，包括节点 n 在内的 cost function 为：</p><script type="math/tex; mode=display">Cost(n)=Crit(i,j) \cdot T_{Elmore}(n,topology)+[\ 1-Crit(i,j)\ ]\cdot b(n)\cdot h(n)\cdot p(n)</script><p>其中：</p><ul><li>criticality 相当于一个权重因子，$Crit(i,j) = \max(\ [MaxCrit-\frac{slack(i,j)}{D_{max}}]^\eta,0\ )$<ul><li>$D_{max}$：电路关键路径的延迟</li><li>$Slack(i，j)$：网络 i 的 source 和 sink j 之间的连接松弛</li><li>$MaxCrit$ 和 $\eta$：控制松弛如何影响 拥塞-延迟 权衡的参数<ul><li>$MaxCrit = 1$ 和 $\eta= 1$：转换为 PathFinder 的情况</li><li>$\eta$ 是较大的：网络具有正松弛度，对延迟的关注较少，而对拥塞的关注更多</li><li>$MaxCrit = 1$：允许松弛为 0 的连接完全忽略拥塞</li><li>$MaxCrit = 0$：忽略延迟，使路由器完全由 routability 驱动</li><li>因此，将 MaxCrit 设置为 1 是危险的，根据经验，通常设置：$MaxCrit = 0.99，\eta= 1$</li></ul></li></ul></li><li>$b(n)$：当前结点 n 的 base cost</li><li>$h(n)$：当前结点 n 的 historical cost</li><li>$p(n)$：当前结点 n 的 congestion penalty cost</li><li>$T_{Elmore}(n，topology)$：Elmore 延迟，其中包含节点 n 以及信号向节点 n 传播的关联拓扑的函数；</li></ul><p>为了逐步计算将节点 n 添加到部分路由中而产生的 Elmore 延迟，我们需要知道上游电阻。则，定义：通过 routing switch 将其连接到节点 m 所达到的节点 n 的上游电阻为：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Upstream.png" alt="Upstream"></p><script type="math/tex; mode=display">R_{upstream}(n)=\begin{cases}R(switch)+R_{metal}(n),\quad if\ switch\ is\ a\ tri-state\ buffer \\\\R_{upstream}(m)+R(switch)+R_{metal}(n),\quad if\ a\ pass\ transistor\end{cases}</script><p>定义 Elmore 延迟作为包含的节点 n 和信号向节点 n 传播的相关拓扑的函数：   </p><script type="math/tex; mode=display">T_{Elmore}(n,topology) = T_{d,intrinsic}(switch)+[\ R_{upstream}(n)-\frac{R_{metal}(n)}{2}\ ]\cdot C_{total}(n)</script><p>其中：</p><ul><li>$T_{d,intrinsic}(switch)$：通过 partial routing 到达节点 n 的 switch 的固有延迟；（对于 non-buffers，= 0）</li><li>$R_{upstream}(n)$：partial routing 的上游电阻，是通过 pass transistor switches 链而不是通过  buffered switches 链积累的；</li><li>$R_{metal}(n)$：路由资源节点 n 的金属电阻，对于所有非布线网段节点，金属电阻为 0；</li><li>$C_{total}(n)$：节点 n 处的总电容（金属加寄生开关电容）；</li><li>从 $R_{upstream}(n)$ 中减去 $R_{metal}(n)$ 的 1/2：表示金属电阻的分布</li></ul><h3 id="算法加速方案"><a href="#算法加速方案" class="headerlink" title="算法加速方案"></a>算法加速方案</h3><p>与 routability-driven router 相同：    </p><script type="math/tex; mode=display">TotalCost(n)=PathCost(n) + \alpha \cdot ExpectedCost(n,j)</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SpeedEnhancement.png" alt="SpeedEnhancement">    </p><p>其中：</p><ul><li>$PathCost(n)$：从 source 到节点 n 的路径上每个节点的总成本，即：当 $Crit(i,j)=1$ 时，为 $T_{Elmore}(n,topology)$；</li><li>$ExpectedCost(n,j)$：从当前节点 n 到目标 sink j 的估计成本；</li><li>$\alpha$：为 1 导致 $A*$ 搜索；为 1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li></ul><h3 id="带有动态-Base-Cost-的-Cost-Function"><a href="#带有动态-Base-Cost-的-Cost-Function" class="headerlink" title="带有动态 Base Cost 的 Cost Function"></a>带有动态 Base Cost 的 Cost Function</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/DynamicBaseCostFunction.png" alt="DynamicBaseCostFunction"></p><p>完全用 pass transistors 相连的路由树：</p><ul><li>switches 往往会变得 heavily loaded，导致较大的延迟；</li></ul><p>尽可能趋向于使用  buffered switches，以便：</p><ul><li>最大化在以后的连接中重新使用其中一些接线的可能性；</li><li>最小化以后连接影响早期连接时间的可能性；</li></ul><script type="math/tex; mode=display">b_{pass\ transistor\ wires}(n)=AverageRoutingResourceDelay \cdot \sqrt{k-1}</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/KTerminals.png" alt="KTerminals"></p><ul><li>$k$：网络上的 terminals 数，$k\geq 2$； </li><li>$b_{pass\ transistor\ wires}(n)$：通过 pass transistors 连接到其他节点（线）的节点（线）n 的基本成本；<ul><li>通过 buffers：平均路由资源延迟</li><li>通过 pass transistors：延迟增加</li></ul></li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRPseudoCode.png" alt="VTRPseudoCode"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 FPGA 技术里 Routing 部分；&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>干货分享 | 网页文档不让复制？带你一起破解网页限制</title>
    <link href="http://www.thebetterkong.cn/2020/05/30/Skills/ResolveCopyProhibition/"/>
    <id>http://www.thebetterkong.cn/2020/05/30/Skills/ResolveCopyProhibition/</id>
    <published>2020-05-30T09:34:17.000Z</published>
    <updated>2020-08-14T09:34:52.119Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/header.png" width="100%" alt="header.png" /> </div>    <p>受疫情影响，现在基本都是远程上课，眼看学期末就要到了，各个课程也纷纷结课。往常的结课考试，自然也就行不通，所以大部分课程开始改为递交课程报告的形式。于是乎，现在天天就是看论文，找资料，写报告……头都大了！特别有时候，好不容易在网上找到一些资料，结果还不让我使用传统的 <kbd>Crtl C+V</kbd> 大法，有的是让你登录，更狠的直接给你禁了，你都找不到这个选项。现在版权意识越来越重，要说不让随意下载转发，尚还接受，可是，有时候我就想用一下那么几句话，亦或者做下阅读笔记，还得一字一句的打，效率太低了。然后，就开始了各种捣鼓，这里总结出了所有我知道的办法，欢迎评论补充！</p><a id="more"></a> <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>介绍具体破解方法前，我们还是有必要先弄清楚这种「复制禁用」到底是怎么实现的，只有知其然亦知其所以然，才能不变应万变；（如果你只是简单的想找个破解方法，可以跳过此章节）     </p><p>目前，绝大多数网页禁用复制功能，都可以囊括到如下三类：</p><p><strong>JavaScript 脚本的方式</strong>：</p><ul><li>也是目前最常用的方式，常用的实现方式如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'右键'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止文字选择。</span></span><br><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'文字选择'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'copy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止剪切</span></span><br><span class="line"><span class="built_in">document</span>.body.oncut = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'cut'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'paste'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用e.preventDefault()也可以禁用，但建议使用 return false 这样就不用去访问 e 和 e 的方法了;</span></span><br><span class="line"><span class="comment">// 示例中 document.body 全局都禁用了，也可以对 dom （某些区域）进行禁用。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>CSS 的方式</strong>：<br><a id="mao"></a></p><ul><li>使用 CSS 能够保证在用户禁用 JavaScript 脚本的情况下，复制功能也会被禁止；<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>:none; <span class="comment">/* Firefox私有属性 */</span></span><br><span class="line">  <span class="attribute">-webkit-user-select</span>:none; <span class="comment">/* WebKit内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-ms-user-select</span>:none; <span class="comment">/* IE私有属性(IE10及以后) */</span></span><br><span class="line">  <span class="attribute">-khtml-user-select</span>:none; <span class="comment">/* KHTML内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-o-user-select</span>:none; <span class="comment">/* Opera私有属性 */</span></span><br><span class="line">  <span class="attribute">user-select</span>:none; <span class="comment">/* CSS3属性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>HTML 属性的方式</strong>：</p><ul><li>这种方式就用的不多了；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">oncopy</span>=<span class="string">"return false"</span> <span class="attr">oncut</span>=<span class="string">"return false;"</span> <span class="attr">onselectstart</span>=<span class="string">"return false"</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>最后，还必须提一下，有些爱捣鼓的网站（很少很少）会想办法禁用开发者模式，但是这种禁用通常是不可能 100% 禁用的；   </p><p>有的只是单纯通过禁用 <kbd>F12</kbd> 按键，又或者高级一些的：  </p><blockquote><p>“利用 console.log 打印一个对象然后覆盖这个对象的 toString 方法，一旦开发者工具存在，toString 方法就会被调用。”</p></blockquote><h1 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h1><p>首先最简单最笨的办法，当然就是，百度搜索这篇文章，看看有没有别的地方可以直接复制或者下载的。这不符合本文主题，pass！</p><h2 id="利用网页打印"><a href="#利用网页打印" class="headerlink" title="利用网页打印"></a>利用网页打印</h2><p>这里说的打印，不是让你真的打印（当然，不嫌麻烦话当我没说）；    </p><p>具体做法就是：</p><ul><li>在文档上：<kbd>右键</kbd> -&gt; <kbd>打印</kbd></li><li>然后，就可以直接在弹出的打印预览页面的，愉快的复制粘贴了；</li></ul><p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/print.png" alt="print"></p><h2 id="拖拽法"><a href="#拖拽法" class="headerlink" title="拖拽法"></a>拖拽法</h2><p>选中所需要的文字，鼠标点击拖入到文本文件中；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/drag.jpg" alt="drag"></p><h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><p><kbd>F12</kbd> 进入开发者模式，在 hmtl 源码里就可以找到你所需要的文字；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/html.jpg" alt="html"></p><p>这种方法很明显有个弊端就是，我们复制的文字量比较大时，会复制到一些不必要的 <code>&lt;p&gt;</code>、<code>&lt;div&gt;</code> 这种标签，这就需要自己去手动修改了，比较麻烦；</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>前面我们知道了，网站禁用复制的实现原理，那么，只需要按照对应的原理进行破解就 OK 了；</p><h2 id="0-命令"><a href="#0-命令" class="headerlink" title="$=0 命令"></a>$=0 命令</h2><p>许多网站在复制时会弹窗，提示让你登录，或者其它信息，这些网站通常是让你复制时触发 js 代码实现；   </p><p>而在 js 中，由于受到 prototype.js（老外写的框架，用于将一些常用的函数封装，方便操作）的影响，现在很多人都<strong>用 <code>$</code> 来表示一个查找对象的函数</strong>，于是也就有了命令： <code>$=0</code>，这样就能破坏 js 代码的执行；</p><p>具体操作：</p><ul><li><kbd>F12</kbd> 进入开发者模式，点击 <kbd>Console</kbd>；</li><li>输入：<code>$=0</code>，回车执行，再返回去复制即可；</li></ul><p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/jscode.jpg" alt="jscode"></p><h2 id="禁用-js-代码"><a href="#禁用-js-代码" class="headerlink" title="禁用 js 代码"></a>禁用 js 代码</h2><p>上面提到的办法，不能保证 100% 的让 js 失效，所以接下来，我们直接设置禁用 js 代码；</p><p>以 Google 浏览器为例（其它浏览器大同小异）：</p><ul><li>进入 <kbd>设置</kbd> -&gt; <kbd>隐私设置和安全性</kbd> -&gt; <kbd>网站设置</kbd> -&gt; <kbd>JavaScript</kbd></li><li>将 <kbd>允许</kbd> 关闭，或者，将文档那个网站加入到禁止名单即可；</li><li>回去，刷新网站，就可以复制了；</li></ul><p>使用完后，别忘了将设置还原！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果，你尝试完上述所有方法依旧不管用，那就是我们之前提到过得，网站使用了 <code>user-select: none;</code> 设置 css 样式进而停用用户选择，它是不受 js 影响的。所以，此方法处理起来比较复杂；</p><p>通常，<kbd>F12</kbd> 进入开发者模式，进入 Elements 选项卡，然后取消选中 body 下面的 CSS 规则：</p><ul><li>具体规则见前文：<a href="#mao">规则查看</a></li><li>主要是：<code>user-select: none;</code> 和 <code>webkit-user-select：none;</code></li></ul><p>或者说，可以使用用户脚本来覆盖设置（<a href="https://qastack.cn/superuser/1282718/how-do-websites-block-selecting-text-and-how-do-i-unblock-that" target="_blank" rel="noopener">方法来源</a>）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Force Select</span></span><br><span class="line"><span class="comment">// @version      1.0</span></span><br><span class="line"><span class="comment">// @description  Stop sites from disabling selection of text</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        *://*/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">  style.innerHTML = <span class="string">'*&#123; user-select: auto !important; &#125;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><ul><li>如果启用此功能，则将适用于每个页面，这在所有情况下都不是理想的；</li><li>因此，可以使用 Violentmonkey，Tampermonkey 或 Greasemonkey 之类的用户脚本管理器来安装脚本，并轻松打开/关闭该脚本；</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果你能熟练掌握上述所有方法，那么基本所有的文档都能任由你复制了；    </p><p>但是，如果还非要说上面那些方法不会使用，想要更加轻松的方式，那就直接使用第三方插件吧！   </p><p>推荐几款谷歌插件：</p><ul><li>『<a href="https://chrome.google.com/webstore/detail/enable-copy/lmnganadkecefnhncokdlaohlkneihio" target="_blank" rel="noopener">Enable Copy</a>』：安装完后会在 chrome 插件栏上增加一个对勾形状按钮，以后碰到不能直接复制的网页，每次复制网页内容之前，先点此勾形按钮即可；</li><li>『<a href="https://chrome.google.com/webstore/detail/simple-allow-copy/aefehdhdciieocakfobpaaolhipkcpgc?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">simple allow copy</a>』：使用方法，和 Enable Copy 基本相同；</li></ul><p>再就是前面提到过的脚本管理器：『<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Tampermonkey</a>』</p><ul><li>你可以用该脚本管理器添加，前面提及的脚本，也可以自己在上面查找一些相关脚本；</li><li>再提供一款脚本『<a href="https://greasyfork.org/zh-CN/scripts/28497-remove-web-limits-modified" target="_blank" rel="noopener">网页限制解除（改）</a>』供选择；</li></ul><p>最后，送佛送到西，再安利一个文档下载器：</p><ul><li>『<a href="http://www.bingdian001.com/?p=30" target="_blank" rel="noopener">冰点文库下载器</a>』：可以解决常见的像百度文库这种，大部分的文档下载；</li></ul><p>最最最后，只要不嫌麻烦，<strong>包治百病的终极大法</strong>：</p><ul><li>截图 + 文字识别</li><li>至于这两个工具，直接百度，那就是一大堆了；</li></ul><p>那就再附加一个，网页内容选择性打印的脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到你所需要打印的部分的 div，这里是利用 ID 识别</span></span><br><span class="line"><span class="comment">// 你也可以利用 JSP 的 DOM（Document Object Model）的其他方式</span></span><br><span class="line"><span class="comment">// 常用的三种方法：getElementById、getElementsByName、getElementsByTagName</span></span><br><span class="line"><span class="comment">// Element.innerHTML 属性用于设置或返回指定标签之间的 HTML 内容</span></span><br><span class="line"><span class="keyword">var</span> printData = <span class="built_in">document</span>.getElementById(<span class="string">"article_content"</span>).innerHTML;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 html 里的数据复制给 body 的 html 数据 ，相当于重置了整个页面的内容</span></span><br><span class="line"><span class="built_in">window</span>.document.body.innerHTML = printData; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始打印</span></span><br><span class="line"><span class="built_in">window</span>.print();</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5b66993ee51d451924734c35#heading-6" target="_blank" rel="noopener">前端er怎样操作剪切复制以及禁止复制+破解等</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/ResolveCopyProhibition/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;    

&lt;p&gt;受疫情影响，现在基本都是远程上课，眼看学期末就要到了，各个课程也纷纷结课。往常的结课考试，自然也就行不通，所以大部分课程开始改为递交课程报告的形式。于是乎，现在天天就是看论文，找资料，写报告……头都大了！特别有时候，好不容易在网上找到一些资料，结果还不让我使用传统的 &lt;kbd&gt;Crtl C+V&lt;/kbd&gt; 大法，有的是让你登录，更狠的直接给你禁了，你都找不到这个选项。现在版权意识越来越重，要说不让随意下载转发，尚还接受，可是，有时候我就想用一下那么几句话，亦或者做下阅读笔记，还得一字一句的打，效率太低了。然后，就开始了各种捣鼓，这里总结出了所有我知道的办法，欢迎评论补充！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Skills" scheme="http://www.thebetterkong.cn/categories/Skills/"/>
    
    
      <category term="Skills" scheme="http://www.thebetterkong.cn/tags/Skills/"/>
    
  </entry>
  
  <entry>
    <title>《Morpheus:A Vulnerability-Tolerant Secure Architecture Based on EMTDs with Churn》阅读笔记</title>
    <link href="http://www.thebetterkong.cn/2020/05/25/Literature-reading-notes/Morpheus-EMTDsWithChurn/"/>
    <id>http://www.thebetterkong.cn/2020/05/25/Literature-reading-notes/Morpheus-EMTDsWithChurn/</id>
    <published>2020-05-25T08:28:21.000Z</published>
    <updated>2020-08-14T09:32:49.185Z</updated>
    
    <content type="html"><![CDATA[<p>目前，主要安全措施都是通过检测异常行为，实现被动防御。<br>而本文主要针对控制流劫持，提出了一种 Morpheus 架构的主动防御机制，它结合移动目标防御将那些正常程序不需要而攻击需要的信息进行随机化和加密处理，以此提高攻击难度，让攻击者需要更多的时间完成 probe，同时，采用一种 churn 方式进一步打乱攻击者攻击节奏。</p><a id="more"></a> <p><a href="https://dl.acm.org/doi/10.1145/3297858.3304037" target="_blank" rel="noopener">《Morpheus：A Vulnerability-Tolerant Secure Architecture Based on Ensembles of Moving Target Defenses with Churn》</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通过观察现有的许许多多的攻击例子，我们可以发现一个大致的规律：<strong>正常程序一般使用给定的程序级语义，但是恶意程序会严重依赖于未定义的语义去完成攻击</strong>。所以，可以说正是因为程序中这些未定义的语义，带来了很大的脆弱性！ </p><ul><li><strong>Undefined semantics</strong>：程序运行时，因底层实现的差异没有被明确定义的语义，比如：数据越界访问、未初始化变量、执行时间、架构共享（如：LLC）。程序员因为各种底层实现的不同，它们不会关注这些语义，但攻击者则会利用这些语义实现攻击。</li></ul><h1 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h1><p>针对这种脆弱性，作者就提出来 Morpheus 架构来主要防御针对控制流的攻击，它主要有两个特点：</p><ol><li>利用 <strong>EMTDs（ensembles of moving target defenses）</strong>，类似 ALSR 对关键性的程序数据进行<strong>随机化</strong>和<strong>加密</strong>；</li><li>采取 <strong>churn 机制</strong>，在运行中对程序进行随机化处理；</li></ol><p>具体来说：以往，ASLR 是在程序运行时完成随机化处理，但是这种一次性的处理方式，攻击者在程序运行期间可以实现类似 AnC 的攻击来获取目标值。   </p><p>对此 Morpheus 采用 EMTDs，提供了一个 504 位（熵）的随机地址空间，即随机化指针存储的位置，同时加密指针的内容。这样，攻击者就需要花费更多大量的时间和精力去 probe。<br>但这肯定还不够，于是又引入了 churn 机制，它最大的特点就是可以在程序运行期间再次进行随机化，它有两种触发方式：</p><ol><li>按初始化的周期，周期性发生（为了短于攻击者 probe 的时间，这个周期会在保证性能的情况下尽量短，文章选为 50ms）；</li><li>被一些潜在的攻击（未定义语义）触发（因为这种时候程序往往正在被攻击，例如攻击者频繁的probe），这一点得益于<strong>攻击检测器</strong>，它有两种规则：「<strong>ABORT 规则</strong>」监视特别严重的操作（明确的攻击行为），并触发终止程序的异常；「<strong>CHURN 规则</strong>」检测到可能正利用未定义行为在进行攻击，针对这些违规行为，启动更改 churn cycle。（攻击检测器逻辑图如下）：<br><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/AttackDetector.png" alt="AttackDetector"></li></ol><p>通过这两种方式来触发 churn，使得攻击者花费大量时间和精力去 probe 想要获取信息（还未获得）时，重新对关键值进行随机化和加密，于是攻击者只能重新开始攻击，但是下一次同样的情况仍会发生，最终攻击失败。这就是 Morpheus 架构的主要防御原理。见图：   </p><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/EMTDsChurn.png" alt="EMTDsChurn"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/MorpheusSecureArchitecture.png" alt="MorpheusSecureArchitecture"></p><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>EMTDs 依赖于域标记机制来精确跟踪运行时所有内存对象的域。</p><p>基于 Morpheus LLVM 的编译器收到未修改的 C 源文件。 然后，在全局变量域分析，将静态初始化的数据部分中的每个内存对象标记为数据，代码指针或数据指针（使用 2 位域标记跟踪四个不同的域：代码(C)、代码指针(CP)、数据指针(DP)、其他数据(D)），之后，生成一个带标签的二进制文件和一个域标签文件，其中包含内存对象的初始标签。   </p><p>对此，为体系结构也做出改变：所有寄存器都扩展 2 bit tags，并将 tag 附加到每个 64 位 aligned word；将 DRAM 和 cache 也搭配上 tag 域，其中，将标签集中到 DRAM 中的固定位置，以简化 churn 过程；所有 data cache blocks 都以每 64 位字扩展 2 位的方式扩展，以在每个缓存块中存储增加的域标签位。</p><h2 id="EMTDs"><a href="#EMTDs" class="headerlink" title="EMTDs"></a>EMTDs</h2><h3 id="PART1：指针移位（Pointer-Displacement）"><a href="#PART1：指针移位（Pointer-Displacement）" class="headerlink" title="PART1：指针移位（Pointer Displacement）"></a>PART1：指针移位（Pointer Displacement）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/PointerDisplacement.png" alt="PointerDisplacement"></p><p>如图所示，就是在指针原来的位置上加上了一个 $d_{CODE}(DAS_C)$ 或 $d_{DATA}(DAS_D)$ 的偏移量，并且这个偏移量是随机产生的。</p><h3 id="PART2：域加密（Domain-Encryption）"><a href="#PART2：域加密（Domain-Encryption）" class="headerlink" title="PART2：域加密（Domain Encryption）"></a>PART2：域加密（Domain Encryption）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/DomainEncryption.png" alt="DomainEncryption"></p><p>使用强密码（由域标记选择的它们自己的域密钥，分别对应 $K_C、K_{CP}、K_{DP}$，并且他们会在内存里受到保护）将内存中的代码，代码指针和数据指针的表示随机化。</p><p>如图所示，当在 L1-L2 边界之间读取内存（加载或取指令）时，将对受保护域进行解密，并在 L1-L2 边界之间写入（存储）内存时对受保护域进行加密，从而使 L2 缓存和 DRAM 保持加密状态。</p><p>由 tag 选择适当的密码密钥，密钥和物理地址通过密码进行组合，让包含相同值的内存位置不相关。对地址进行加密后，就可以使用反向模式的密码，在这种模式下，会生成密钥流，并与受保护的 value 进行 XOR 运算，以对其进行加密或解密。</p><h2 id="Churn"><a href="#Churn" class="headerlink" title="Churn"></a>Churn</h2><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Churn.png" alt="Churn"></p><p>在程序运行过程中，会周期性的经历 churn，每一次的 churn 又包含如下四个阶段：</p><ol><li>管道刷新；</li><li>新密钥生成和寄存器更新；</li><li>使用阈值寄存器来协调新位移和加密密钥下存储器中的更新值；</li><li>churn 完成时，所有域都已更新，有效地处置了攻击者先前可能已获取的任何信息；</li></ol><p>总的来说，就是 churn 会周期性的更新加密用的域秘钥（$K_C、K_{CP}、K_{DP}$）和指针移位（$d_{CODE}$、$d_{DATA}$），但是更新后的这两项会与原先的旧值产生冲突，于是引入了一个<strong>阀值寄存器</strong>来协调，它将使用新 key 和 displacement 状态记为 “clean”，而旧值的记为 “stale”，以此进行区分。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Effect.png" alt="Effect"></p><ul><li>可以防御表 4 所示的所有攻击，并且他们都能触发攻击感测器进一步提高了防御效果；</li><li>在没有加入 Morpheus 防御机制的情况下，完成 probe 穿透所需的时间就已经是 churn cycle（50ms）的很多倍（5020），所以说，在加入了EMTDs 后，完全可以保证在攻击者彻底完成 probe 穿透前，触发 churn。</li></ul><h1 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Performance.png" alt="Performance"></p><p>自古 「安全-性能」 就很难两全其美，前面看到了 Morpheus 在防御上的优势，那么这种机制对性能的影响也肯定是一个需要考量的因素。   </p><p>文中提到，将 50ms 作为正常的 churn 周期，由图一可看到，平均情况下，它对处理器性能的影响只下降了 1% 左右，这是一个很好的结果。</p><p>即使在 SPEC’06 基准测试的最坏情况下，由图二我们也能看出它仅仅只是在 403-gcc 这一项上造成了相对高的性能损耗，这也是我们能接受的范围。</p><p>所以，总的来说就是，Morpheus 采用 EMTDs 和 churn 这两种机制，以较低的性能损耗大大提高了安全性。</p><h1 id="不成熟的两个小想法"><a href="#不成熟的两个小想法" class="headerlink" title="不成熟的两个小想法"></a>不成熟的两个小想法</h1><ol><li>文中并未具体谈论到 churn cycle 初始值（50ms）如何设置，攻击者似乎可以先攻击 churn cycle，人为修改它的值？</li><li>攻击检测器的存在，会因为检测到攻击而触发 churn 或者直接中断程序，对此，如果攻击者起初的目标不是获取信息，那么他也可以利用这个性质不断地“伪造攻击”，进而不断触发攻击检测器，这样大大拖低处理器性能，甚至导致程序瘫痪。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前，主要安全措施都是通过检测异常行为，实现被动防御。&lt;br&gt;而本文主要针对控制流劫持，提出了一种 Morpheus 架构的主动防御机制，它结合移动目标防御将那些正常程序不需要而攻击需要的信息进行随机化和加密处理，以此提高攻击难度，让攻击者需要更多的时间完成 probe，同时，采用一种 churn 方式进一步打乱攻击者攻击节奏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献阅读笔记" scheme="http://www.thebetterkong.cn/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Computer Architecture" scheme="http://www.thebetterkong.cn/tags/Computer-Architecture/"/>
    
      <category term="ASLR" scheme="http://www.thebetterkong.cn/tags/ASLR/"/>
    
  </entry>
  
  <entry>
    <title>利用爬虫实现课程网站资源的批量下载</title>
    <link href="http://www.thebetterkong.cn/2020/05/22/Crawler/CrawlSEPBatchDownload/"/>
    <id>http://www.thebetterkong.cn/2020/05/22/Crawler/CrawlSEPBatchDownload/</id>
    <published>2020-05-22T09:13:12.000Z</published>
    <updated>2020-08-14T09:27:53.474Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/head.png" width="100%" alt="head.png" /> </div>   <p>现在大学上课，老师一般都是通过学校的课程网站来分享课程的课件等资源。但是，在果壳大课程网站上下载资源，总是需要一项一项的点入，再单击下载，显得十分麻烦，特别有时囤积了大量资源需要去下载，还得比对一下哪些没有下载，这对于我这种数据强迫症的人来说，十分不友好！<br>恰巧那会对爬虫挺感兴趣的，就寻思着拿这个练练手（重在学习），说做就做吧！Let’s go！</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先，得先定我的需求：</p><ol><li>可以选择课程，对该课程的所有课件实现一键下载；</li><li>鉴于我的数据强迫症，课件下载完毕后，应该能向我反馈下载的信息，主要就是新下载了哪些课件；</li><li>由于疫情的特殊原因，学校采取了网上授课的方式，但是家里网络不稳定，总是故障，考虑下载视频到本地观看，也便于课后复习；（想想以前，为了能课后复习，都是拿着电脑在上课的时候现场录的）；</li></ol><p>现在，需求以及清楚，接下来就是开始捣鼓课程网站的情况；    </p><ul><li>正常情况下，我们首先需求登录，进入教务系统主页；</li><li>然后，进入课程网站主页；</li><li>然后，在自己的选课情况中，选择课程，进入到课程主页；</li><li>然后，找到进入该课程主页的资源页面；</li><li>进入相关资源，并点击下载；</li></ul><p>Emmm，用的时候都还好，这么一捋愈发觉得麻烦了……</p><h1 id="弯路：webdriver"><a href="#弯路：webdriver" class="headerlink" title="弯路：webdriver"></a>弯路：webdriver</h1><p>果壳大的教育业务平台网址是：<a href="http://sep.ucas.ac.cn/" target="_blank" rel="noopener">http://sep.ucas.ac.cn/</a> ，要想进行后面的操作，首先，就得实现教育业务平台的自动登录；   </p><p>起初嘛，刚接触爬虫，对网络也不是特别了解。脑海里冒出来最简单的思路就是：利用 selenium 的 webdriver 模拟登录过程，然后获取 cookies，之后再利用 cookies 登录；</p><ol><li><code>pip install selenium</code> 安装 selenium；<ul><li>selenium 是 ThoughtWorks 提供的一个强大的基于浏览器的开源自动化测试工具。支持的浏览器包括 IE、Chrome 和 Firefox 等；</li></ul></li><li>到相应的官网下载浏览器驱动，我这里下载的是火狐的浏览器驱动；</li></ol><p>接下来，写段程序测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">headers = &#123;</span></span><br><span class="line"><span class="string">    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span><span class="params">( )</span>:</span></span><br><span class="line">    user = input(<span class="string">"请输入用户名："</span>)</span><br><span class="line">    password = input(<span class="string">"请输入密码："</span>)</span><br><span class="line">    driver = webdriver.Firefox()</span><br><span class="line">    driver.get(<span class="string">'http://sep.ucas.ac.cn/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#time.sleep(3)</span></span><br><span class="line">    <span class="comment"># 清空登录框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录用户名</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).send_keys(user)</span><br><span class="line">    <span class="comment"># 清空密码框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录密码</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).send_keys(password)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 点击登录按钮进行登录</span></span><br><span class="line">    driver.find_element_by_class_name(<span class="string">'loginbtn'</span>).click()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取cookies</span></span><br><span class="line">    cookie_items = driver.get_cookies()</span><br><span class="line">    cookie = [item[<span class="string">"name"</span>] + <span class="string">"="</span> + item[<span class="string">"value"</span>] <span class="keyword">for</span> item <span class="keyword">in</span> cookie_items]</span><br><span class="line">    cookie_str = <span class="string">';'</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> cookie)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'cookie.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cookie_str)</span><br><span class="line">    f.close()</span><br><span class="line">    print(<span class="string">"已获取到cookies！"</span>)</span><br><span class="line"></span><br><span class="line">    headers_cookie = &#123;</span><br><span class="line">        <span class="string">"Cookie"</span>: cookie_str  <span class="comment"># 通过接口请求时需要cookies等信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session = requests.session()</span><br><span class="line">    session.post(<span class="string">'http://sep.ucas.ac.cn/'</span>, headers=headers_cookie)</span><br><span class="line">    print(<span class="string">'登录系统成功……'</span>)</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    session = log_in()</span><br></pre></td></tr></table></figure></p><p>本以为，万事大吉，结果运行测试，emmmmm……才意识到，还得输入验证码！   </p><p>那就继续造：</p><ul><li>要用到图形处理，所以 <code>pip install pillow</code>；<ul><li>坑：安装 pillow，但是导入的时候是 PIL；</li></ul></li><li>抓取下来验证码，还不够，肯定还得识别验证码内容，选择百度文字识别的 OCR，<code>pip install baidu_api</code>；</li></ul><blockquote><p>pillow 的原身是 PIL（Python Imaging Library），PIL 是 Python 图像处理标准库，功能非常强大，API 却非常简单易用；<br>但是 PIL 仅支持到 Python 2.7，后来由志愿者在此基础上创建了兼容的版本，即：Pillow，支持最新Python 3.x，又加入了许多新特性<br>百度文字识别的OCR，即：Optical Character Recognition，光学字符识别</p></blockquote><p>然后，在上面代码的基础上，新增如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 导入下载的第三方库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 查找验证码</span></span><br><span class="line">png = driver.find_element_by_id(<span class="string">'captcha_img'</span>)  <span class="comment"># 查找验证码元素</span></span><br><span class="line">png.screenshot(<span class="string">'captcha.png'</span>)  <span class="comment"># 对验证码截图并保存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码处理</span></span><br><span class="line"><span class="comment"># 用 pillow 库对验证码进行图像处理，提高验证码的识别率；</span></span><br><span class="line"><span class="comment"># 处理方法：</span></span><br><span class="line"><span class="comment">#   1.先将图像转换成灰度模式</span></span><br><span class="line"><span class="comment">#   2.通过对阈值的调整使得多余的噪点消失</span></span><br><span class="line">img = Image.open(<span class="string">'captcha.png'</span>)</span><br><span class="line">img = img.convert(<span class="string">'L'</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">count = <span class="number">165</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; count:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line">img = img.point(table, <span class="string">'1'</span>)</span><br><span class="line">img.save(<span class="string">'captcha1.png'</span>)  <span class="comment"># 保存处理后的验证码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码识别</span></span><br><span class="line"><span class="comment"># 调用 baidu_api 的通用文字识别接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别码</span></span><br><span class="line">APP_ID = <span class="string">'***'</span></span><br><span class="line">API_KEY = <span class="string">'***'</span></span><br><span class="line">SECRET_KEY = <span class="string">'***'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化对象</span></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">image = get_file_content(<span class="string">'captcha.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数变量</span></span><br><span class="line">options = &#123;<span class="string">'language_type'</span>: <span class="string">'ENG'</span>, &#125;  <span class="comment"># 识别语言类型，默认为'CHN_ENG'中英文混合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用通用文字识别</span></span><br><span class="line">result = client.basicGeneral(image, options)  <span class="comment"># 高精度接口 basicAccurate</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> result[<span class="string">'words_result'</span>]:</span><br><span class="line">    captcha = (word[<span class="string">'words'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出，检查结果</span></span><br><span class="line">print(<span class="string">'识别结果：'</span> + captcha)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空验证码框</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).clear()</span><br><span class="line"><span class="comment"># 自动填入验证码</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).send_keys(captcha)</span><br></pre></td></tr></table></figure></p><p>至此，总算是完成了登录过程，麻不麻烦？<br>肯定麻烦啊！而且有个很大的问题，就是每次运行会启动 webdriver，把程序拖得很慢，十分影响使用体验，所以我后来才改用了其他方法；</p><p>但是也不得不说，这段弯路也让我学到了挺多东西，还是很有意义的！</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>其实说正解不太准确，只是说这个办法更加简单易行罢了；</p><p>之所以会突然又提出新的办法，是因为有一次，我发现果壳大的综合信息网（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ）也可以登录到教育业务平台，而且在这里登录<strong>不需要验证码！</strong><br>这下子，终于可以去掉上面那繁琐的验证码处理过程了。   </p><p>但是，这只解决了一个问题，还是无法让我摆脱 webdriver。于是，我寻思这么难顶的资源下载方式，难道就没有前人 “种个树”？再仔细搜了搜，还真有！</p><p>原作者的程序是一键下载课程网站<strong>所有课程所有课件</strong>，呃……，对我来说有点夸张了，毕竟几十门课程，怎么得也有个几百项资源吧？也许对于一个爬虫来说爬取这些资源不算什么，但是，还有好多资源我可能不那么需要，事后还得整理。不过无妨，程序框架在这了，修改起来也简单。     </p><p>确定修改目标：</p><ol><li>能够输出选课的课程目录，供按课程批量下载课件；</li><li>加入视频下载功能；</li></ol><p><strong>开干！！！</strong></p><h2 id="网站登录"><a href="#网站登录" class="headerlink" title="网站登录"></a>网站登录</h2><p>首先，是登录信息，这里采用了直接将登录信息保存在 txt 文本文件里，避免了我原先那样每次运行脚本都需要手动输入的尴尬。简单的文本处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#读取登录信息，第一行存账号，第二行存密码</span></span><br><span class="line">        config = open(<span class="string">"user.txt"</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        line = config.readline().split()</span><br><span class="line">        username = line[<span class="number">0</span>]</span><br><span class="line">        password = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure></p><p>重点来了，这次登录改用了 requests 库的 session 会话对象，构造 post 表单的方式实现登录，并且由于 session 对象的特性，也便于我们后续其他页面的操作；</p><blockquote><p>session 的特性体现在它的作用时间：从用户到达某个特定的 Web 页开始，到该用户离开 Web 站点，或在程序中利用代码终止某个 Session 结束。<br>引用 Session 则可以让一个用户访问多个页面，之间的切换也会保留该用户的信息；<br>说白了，就是一旦我们使用 session 成功的登录了某个网站后，则在再次使用该 session对象求求该网站的其他网页都会默认使用该 session 之前使用的 cookie 等参数；<br>详细用法参见文章：<a href="https://www.cnblogs.com/linxiyue/p/3980003.html" target="_blank" rel="noopener">Python Requests库：HTTP for Humans</a></p></blockquote><ol><li>构造请求头：<ul><li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/findheader.png" alt="findheader"></li><li><code>Accept</code>：用户代理期望的 MIME 类型列表，不用管；</li><li><code>Accept-Encoding</code>：用户代理支持的压缩方法，不用管；</li><li><code>Accept-language</code>：用户代理期望的页面语言，不用管；</li><li><code>Connection</code>：决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。因此，需要设置；</li><li><code>Cookie</code>：就不用说了，我们目标就是自动获取<strong>登录后</strong>的 cookie；</li><li><code>host</code>：指明服务器域名，需要设置；</li><li><code>upgrade-insecure-requests</code>：用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 upgrade-insecure-requests CSP 指令。</li><li><code>User-Agent</code>；指明用户代理软件的应用类型、操作系统、软件开发商以及版本号；</li><li>更多详情可见：『<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">MDN web docs</a>』</li></ul></li><li>构造 post 表单：<ul><li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式（未登录状态）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost1.jpg" alt="buildpost1"><ul><li><code>Preserve log</code>：保留 log 信息；</li><li><code>XHR</code>：（XMLHttpRequest）筛选出与服务器的交互信息；</li></ul></li><li>然后，开发者模式设置完成后，在浏览器输入信息登录（不要关闭开发窗口）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost2.jpg" alt="buildpost2"></li><li>很明显，我所需要的信息应该在 Name = 0，的那条记录里，打开这条记录；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost3.png" alt="buildpost3"></li><li>在 Form Data 里就有我们构造 post 表单所需要去构造的信息，为：用户名、密码、是否记住密码，这三个字段；</li></ul></li></ol><p>这一部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()  <span class="comment"># 创建 session 对象</span></span><br><span class="line">login_url = <span class="string">'http://onestop.ucas.ac.cn/'</span>  <span class="comment"># 更换为不需要验证码登录的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 构造请求头</span></span><br><span class="line">headers=  &#123;</span><br><span class="line">            <span class="string">'Host'</span>: <span class="string">'onestop.ucas.ac.cn'</span>,</span><br><span class="line">            <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">'http://onestop.ucas.ac.cn/home/index'</span>,</span><br><span class="line">            <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,  <span class="comment"># 指明 Ajax 请求(异步)，注意，这样返回的数据是 json 类型</span></span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">### 构造表单数据</span></span><br><span class="line">post_data = &#123; </span><br><span class="line">            <span class="string">"username"</span>: username,</span><br><span class="line">            <span class="string">"password"</span>: password,</span><br><span class="line">            <span class="string">"remember"</span>: <span class="string">'checked'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">html = session.post(login_url, data=post_data, headers=headers).text <span class="comment"># 请求，并建立 session</span></span><br><span class="line"><span class="comment"># 将返回的 json 数据转换为 html 文本保存</span></span><br><span class="line">res = json.loads(html)</span><br><span class="line">html = session.get(res[<span class="string">'msg'</span>]).text</span><br><span class="line">print(<span class="string">'登录系统成功！'</span>)</span><br><span class="line"><span class="comment"># save_html(html)  # 用来保存 html 文本做检测</span></span><br></pre></td></tr></table></figure><p>这样，我们就有了一个建立了连接的 session，以后就可以利用该 session 完成其他页面的操作；</p><h2 id="进入课程网站"><a href="#进入课程网站" class="headerlink" title="进入课程网站"></a>进入课程网站</h2><p>首先，查找进入课程网站的 url：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/tocoursesite1.jpg" alt="tocoursesite1">    </p><p>利用之前的 session 访问：<code>h_k = session.get(url)</code></p><p>这里有个注意点，在我们直接点击课程网站图标时，会进入一个跳转页面，而我们刚刚 session 访问到的就是这个跳转页面，所以实际上我们还并没有进入到课程网站页面中去；   </p><p>为了便于分析，将 session.get() 到的对象转换成文本文件存储：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    f = open(<span class="string">'test.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    f.write(html)</span><br><span class="line">    f.close</span><br><span class="line"></span><br><span class="line"><span class="comment">### 调用</span></span><br><span class="line">url = <span class="string">"http://sep.ucas.ac.cn/portal/site/16/801"</span>   <span class="comment"># 跳转页面地址</span></span><br><span class="line">h_k = session.get(url)   <span class="comment"># 访问跳转，并获取返回的对象</span></span><br><span class="line">save_html(h_k.text) <span class="comment"># 转换为文本文件保存下来</span></span><br></pre></td></tr></table></figure></p><p>打开 h_k.text，我们知道跳转页面里，提示信息会有 “点击这里跳转” 这种选项，在这个文本里 <kbd>ctrl F</kbd>，输入：“跳转”，就可以看到，确实存在一个标签，如下：<br>（当然了，也可以在跳转的时候，强制停止刷新网页，然后在跳转页面用开发者模式查找 “这里” 这个字段的 href）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row-fluid"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"span12"</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>2秒钟没有响应请点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://course.ucas.ac.cn/portal/plogin?Identity=fbd361f2-73cc-48b7-a5ec-37528b27a058&amp;roleId=801"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这里<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>直接跳转<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--//container-fluid:end--&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来，利用正则表达式，获取这个 url 里，Identity 的值（身份认证信息），重新构造 url，直接进入到课程网站页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用正则表达式找Request URL，Identity后的身份认证信息</span></span><br><span class="line">key = re.findall(<span class="string">r'"https://course.ucas.ac.cn/portal/plogin\?Identity=(.*)"'</span>, h_k.text)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 利用得到的身份认证信息，打开课程网站系统</span></span><br><span class="line">url = <span class="string">"http://course.ucas.ac.cn/portal/plogin/main/index?Identity="</span> + key</span><br><span class="line">page = session.get(url)</span><br><span class="line">print(<span class="string">'课程网站系统进入成功！'</span>)</span><br><span class="line"><span class="keyword">return</span> page</span><br></pre></td></tr></table></figure><h2 id="获取课程信息"><a href="#获取课程信息" class="headerlink" title="获取课程信息"></a>获取课程信息</h2><p>先进入主页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，找到课程网站的主页地址，并进入主页</span></span><br><span class="line">mycourseBS = BeautifulSoup(courseSite.text,<span class="string">"lxml"</span>) <span class="comment"># 利用 lxml 解析 text 文本</span></span><br><span class="line">url_mycourse = mycourseBS.find_all(<span class="string">'a'</span>,&#123;<span class="string">"class"</span>:<span class="string">'Mrphs-toolsNav__menuitem--link'</span>&#125;)[<span class="number">0</span>] <span class="comment"># 找 class 名为 xxx 的 a 标签</span></span><br><span class="line">url_mycourse = url_mycourse[<span class="string">"href"</span>] <span class="comment"># 获取 href ，即获取 url </span></span><br><span class="line">coursePage = session.get(url_mycourse)  <span class="comment"># 访问进入主页</span></span><br></pre></td></tr></table></figure><p>在我的课程里，获取课程信息：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/courseinfo.jpg" alt="courseinfo"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，在课程网站主页，寻找课程信息，并利用元组的形式记录在course_list中</span></span><br><span class="line">coursePageBS = BeautifulSoup(coursePage.text,<span class="string">"lxml"</span>) </span><br><span class="line">Course_info = coursePageBS.find_all(<span class="string">'li'</span>,&#123;<span class="string">"class"</span>:<span class="string">"fav-sites-entry"</span>&#125;)</span><br><span class="line">length = len(Course_info)   <span class="comment"># 标签数，即：课程总数</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line">print(<span class="string">"所选课程总数为："</span>,length)</span><br><span class="line">print((<span class="string">"已选课程列表："</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length<span class="number">-1</span>):</span><br><span class="line">    info = Course_info[i]</span><br><span class="line">    tag = info.div.a</span><br><span class="line">    courseName = tag[<span class="string">"title"</span>]  <span class="comment">#课程名字</span></span><br><span class="line">    print(<span class="string">"   "</span>,i,courseName)</span><br><span class="line">    courseUrl = tag[<span class="string">"href"</span>]   <span class="comment">#课程链接</span></span><br><span class="line">    course_list.append((courseName,courseUrl)) <span class="comment">#利用元组的形式保存</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line"><span class="keyword">return</span> course_list</span><br></pre></td></tr></table></figure></p><h2 id="课件下载"><a href="#课件下载" class="headerlink" title="课件下载"></a>课件下载</h2><p>后面的页面跳转等处理，其实都类似，这里只介绍一些关键点，毕竟主要的目的在于学习：    </p><p>进入课程资源页面，这里直接将关键的 BeautifulSoup 查找语句列出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 访问进入某课程后，在课程页面里，利用 “资源” 模块的 title 查找，拿到其 href，即 url</span></span><br><span class="line">url = h_bs.find_all(title=<span class="string">"资源 - 上传、下载课件，发布文档，网址等信息"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure><br>查找所有资源链接：</p><ul><li>这里文件夹的处理，涉及到 onclick()，展开文件夹，更新 html 页面，但是这里我没态弄太明白，后面再琢磨。可以的话，可以在评论区给我留言一些相关知识讲解文章；</li></ul><p>下载文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### className：文件夹名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_kj</span><span class="params">(url, fileName, className, session)</span>:</span></span><br><span class="line">    <span class="comment">### 文件名称处理</span></span><br><span class="line">    <span class="comment"># \xa0（不间断空白符&amp;nbsp）转gbk（汉字内码扩展规范）会有错，去掉；</span></span><br><span class="line">    fileName = fileName.replace(<span class="string">u"\xa0"</span>, <span class="string">" "</span>).replace(<span class="string">u"\xc2"</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="comment"># 去掉不合法的文件名字符</span></span><br><span class="line">    fileName = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, fileName)</span><br><span class="line">    className = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, className)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径构造，os.getcwd()获取当前路径</span></span><br><span class="line">    dir = os.getcwd() + <span class="string">"/"</span> + className</span><br><span class="line">    file = os.getcwd() + <span class="string">"/"</span> + className + <span class="string">"/"</span> + fileName</span><br><span class="line">    <span class="comment"># 没有课程文件夹则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="comment"># 存在该文件，返回</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">        print(<span class="string">"%s已存在，就不下载了"</span> % fileName)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    print(<span class="string">"开始下载%s..."</span> % fileName)</span><br><span class="line">    s = session.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">"wb"</span>) <span class="keyword">as</span> data:</span><br><span class="line">        data.write(s.content)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h2><p>进入课程资源页面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_bs = BeautifulSoup(h.text, <span class="string">"lxml"</span>)</span><br><span class="line">url = h_bs.find_all(title=<span class="string">"课程视频 - 课程视频"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure></p><p>又分为：课程视频（录播），直播视频（回放），这两部分处理方法一样，以第一项为例：</p><p>由于视频页可能包含多页，先抓取各个页的链接：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当时写的比较傻，采用循环加载下一页做的，其实可以直接抓取网页下面显示的页数，然后在原来 url 的基础上构造为： url+"&amp;pageNum="+i 即可；</span></span><br><span class="line">allpageURL.append(url)</span><br><span class="line">        flag =<span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> flag:</span><br><span class="line">            s = session.get(allpageURL[i])</span><br><span class="line">            page = re.search(<span class="string">'&lt;span&gt;&lt;a href="([^上]*?)"&gt;下一页&lt;/a&gt;&lt;/span&gt;'</span>,s.text, re.S)  <span class="comment"># 其实就是获取："&amp;pageNum="+i</span></span><br><span class="line">            <span class="keyword">if</span> page :</span><br><span class="line">                page = page.groups()[<span class="number">0</span>]</span><br><span class="line">                pageURL = <span class="string">'http://course.ucas.ac.cn'</span> + page</span><br><span class="line">                allpageURL.append(pageURL)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>接下来，就是循环在每页，不断的获取所有视频播放的 url，然后进入到播放页面，再找到视频源的 url 即可；    </p><p>视频下载：由于果壳大视频采用的 .m3u8 流媒体格式，我使用到了 ffmpeg（需要提前在电脑上安装）；用 subprocess 模块来产生子进程，调用 ffmpeg 完成下载；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 按照获取到的视频链接调用ffmpeg进行下载，也可以尝试多进程下载，提高下载速度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_sp</span><span class="params">(spName, spUrl)</span>:</span></span><br><span class="line">    ins = <span class="string">'ffmpeg -i '</span> + spUrl + <span class="string">' -c copy '</span> + spName +<span class="string">'.mp4'</span></span><br><span class="line">    p = subprocess.Popen(ins)</span><br><span class="line">    p.wait()</span><br><span class="line">    print(<span class="string">'下载完毕'</span>)</span><br></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实这个脚本是挺久之前弄的了，但是总觉得之前边写边学，零零碎碎，慢慢的又觉得忘的差不多了。这当然不行，于是，重新梳理总结了一下当时的编写历程。     </p><p>通过这次，主要学习到的知识点：</p><ol><li>利用 webdriver 模拟登陆，以及遇到验证码时，将验证码抓取下来处理，并完成识别；</li><li>利用 session 构造 post 表单的方式，实现网站登录；</li><li>正则表达式的使用；</li><li>BeautifulSoup 的查找方法；</li><li>subprocess 的简单使用；</li><li>等等</li></ol><p>不足：</p><ul><li>还需要学习 js 的处理方法；</li></ul><p>最后还是需要强调一下，重在学习，利用脚本下载的资源，仅供自己学习使用，请不要传播！</p><ul><li>『<a href="https://github.com/TheBetterKong/UCAS_Sep" target="_blank" rel="noopener">脚本源码</a>』</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li>『<a href="https://zhuanlan.zhihu.com/p/94402506" target="_blank" rel="noopener">python实现网站的自动登录</a>』</li><li>『<a href="https://blog.csdn.net/lusongno1/article/details/79995009" target="_blank" rel="noopener">国科大（UCAS）课件自动批量下载 python3 脚本</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/head.png&quot; width=&quot;100%&quot; alt=&quot;head.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;现在大学上课，老师一般都是通过学校的课程网站来分享课程的课件等资源。但是，在果壳大课程网站上下载资源，总是需要一项一项的点入，再单击下载，显得十分麻烦，特别有时囤积了大量资源需要去下载，还得比对一下哪些没有下载，这对于我这种数据强迫症的人来说，十分不友好！&lt;br&gt;恰巧那会对爬虫挺感兴趣的，就寻思着拿这个练练手（重在学习），说做就做吧！Let’s go！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Crawler" scheme="http://www.thebetterkong.cn/categories/Crawler/"/>
    
    
      <category term="Python" scheme="http://www.thebetterkong.cn/tags/Python/"/>
    
      <category term="Crawler" scheme="http://www.thebetterkong.cn/tags/Crawler/"/>
    
      <category term="Webdriver" scheme="http://www.thebetterkong.cn/tags/Webdriver/"/>
    
  </entry>
  
  <entry>
    <title>改进 Hexo 中 MathJax 数学公式的渲染</title>
    <link href="http://www.thebetterkong.cn/2020/05/20/Blog-Related/ImproveMathJax/"/>
    <id>http://www.thebetterkong.cn/2020/05/20/Blog-Related/ImproveMathJax/</id>
    <published>2020-05-20T09:05:14.000Z</published>
    <updated>2020-08-14T09:25:32.765Z</updated>
    
    <content type="html"><![CDATA[<p>之前，更新了一篇<a href="http://www.thebetterkong.cn/2020/04/04/Blog-Related/Markdown-Writing/">《Markdown 写作指南》</a>的博文，这次更新重点梳理了一下 MathJax 数学公式的书写。在之后 Blog 书写过程中，也就越来越多的开始依赖 MathJax 数学公式。但是，有时候，我发现我的公式书写完全正确，并且在本地 vscode 的预览也能渲染出正确结果。可是，当我部署到我的 blog 里时，公式总是出现大大小小的问题。不知道，你是否也有过这样的疑惑？</p><a id="more"></a> <p>首先，得先说一下，这里说的 MathJax 渲染出错，是你已经在主题配置文件下设置了 mathJax 为 true，依旧出现公式渲染出错；</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>经过网上一番了解。其实，造成这种现象主要原因是 Hexo 默认的渲染引擎 hexo-renderer-marked 对公式渲染时与 Mathjax 发生了一些冲突，导致了 bug；</p><blockquote><p>实际渲染中，Hexo 默认的 MarkDown 渲染引擎 hexo-renderer-marked 会调用 marked 模块的 node_modules\marked\lib\marked.js 脚本进行最终的解释，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签：</p><ul><li>在 markdown 语法中，下划线 <code>_</code> 代表斜体，会被渲染引擎处理为 <code>&lt;em&gt;</code> 标签；</li><li><code>\\</code> 也会被转义成一个 <code>\</code>；<ul><li>而 Latex 格式书写的数学公式下划线 <code>_</code> 表示角标，<code>\\</code> 表示公式换行，有特殊的含义，所以 MathJax 引擎在渲染数学公式的时候就会出错；</li><li>类似的语义冲突的符号还包括 <code>*, {, }</code> 等。</li></ul></li></ul></blockquote><p>解决思路：</p><ul><li>针对下划线的问题，markdown 的 marked.js 中有两种斜体的表示方式，因此取消 <code>_</code> 作为斜体转义，以后用 <code>*</code> 作为斜体表示即可；</li><li>针对 marked.js 与 Mathjax 对于个别字符二次转义的问题，我们只要不让 marked.js 去转义 <code>\\,\{,\}</code> 在 MathJax 中有特殊用途的字符就行了。</li></ul><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>首先，可以更换 Hexo 的 markdown 渲染引擎：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-renderer-marked --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-kramed --save</span></span><br></pre></td></tr></table></figure></p><ul><li>说明：<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级；</li><li>但是也需要注意，更换完后，可能对原先的 markdown 书写有一些影响，但是我个人觉得影响不大，如果你对此十分介意，想了解受影响的地方，可以参考该引擎官方文档；</li><li>其实你也可以直接跳过此步，按照下面的内容，直接修改上面提到过的 node_modules\marked\lib\marked.js 脚本；</li></ul><p>此时，hexo-renderer-kramed 只是修改了部分 bug，还不足以解决所有冲突，为了避免以后再出现其他问题，这里再手动进一步修改一下：</p><ul><li>到博客的根目录下，找到 node_modules\kramed\lib\rules\inline.js；</li><li>修改第 11 行的 escape 变量的值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure><ul><li>这一步是在原基础上取消了对 <code>\ , { , }</code> 的转义（escape）；</li></ul></li><li>现在在第 21 行的 em 变量也要做相应的修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line">em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure><ul><li>这一步取消了对斜体标记_的转义</li></ul></li></ul><p><strong>清除原先 hexo 缓存</strong>，重新生成部署就可以看到问题已经解决了。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>因为我们在主题配置文件中开启了 mathJax，因此，对所有的文章都会使用 mathJax 进行渲染，即使有些文章里，你根本没用上 mathJax，这样会影响你页面的访问速度。   </p><p>因此，可以考虑在文章的 Front-matter 里针对性的打开 mathjax 开关：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 改进 Hexo 中 MathJax 数学公式的渲染</span><br><span class="line">data: 2020-05-20 17:05:14  </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>Blog 相关</span><br><span class="line"></span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>Blog</span><br><span class="line"></span><br><span class="line">mathjax: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/weixin_30725467/article/details/96659102" target="_blank" rel="noopener">1:《在Hexo中渲染MathJax数学公式》</a></li><li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">2:《在Hexo中渲染MathJax数学公式》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前，更新了一篇&lt;a href=&quot;http://www.thebetterkong.cn/2020/04/04/Blog-Related/Markdown-Writing/&quot;&gt;《Markdown 写作指南》&lt;/a&gt;的博文，这次更新重点梳理了一下 MathJax 数学公式的书写。在之后 Blog 书写过程中，也就越来越多的开始依赖 MathJax 数学公式。但是，有时候，我发现我的公式书写完全正确，并且在本地 vscode 的预览也能渲染出正确结果。可是，当我部署到我的 blog 里时，公式总是出现大大小小的问题。不知道，你是否也有过这样的疑惑？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog 相关" scheme="http://www.thebetterkong.cn/categories/Blog-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Blog" scheme="http://www.thebetterkong.cn/tags/Blog/"/>
    
  </entry>
  
</feed>
