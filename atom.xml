<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheBetterKong</title>
  
  <subtitle>自律即自由</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.thebetterkong.cn/"/>
  <updated>2020-08-14T09:28:31.984Z</updated>
  <id>http://www.thebetterkong.cn/</id>
  
  <author>
    <name>TheBetterKong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 数据结构之树</title>
    <link href="http://www.thebetterkong.cn/2020/07/09/DataStructure-Algorithm/DataStructure-Tree/"/>
    <id>http://www.thebetterkong.cn/2020/07/09/DataStructure-Algorithm/DataStructure-Tree/</id>
    <published>2020-07-09T14:05:23.000Z</published>
    <updated>2020-08-14T09:28:31.984Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/header.png" width="100%" alt="header.png" /> </div>  <p><strong>树</strong>（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n （$n \geq 0$）个有限节点组成一个具有层次关系的集合。在任意一棵非空树中，它都满足如下特点：</p><div class="note warning">            <ul><li>有且仅有一个特定的称为根（Root）的结点；</li><li>当 $n &gt;1$ 时，其余结点可分为 m（$m &gt;0$）个互不相交的有限集 $T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；</li></ul>          </div><a id="more"></a> <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="Why-tree？"><a href="#Why-tree？" class="headerlink" title="Why tree？"></a>Why tree？</h2><p>我们知道两种十分常用的线性表：有序数组、链表。在实际使用中，它们都有着自己的优势与不足：</p><ul><li>在有序数组中插入数据项太慢：<ul><li>数组的特点是查找迅速，根据 <code>index</code> 可以快速定位到一个元素。但是，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。平均来讲，一个长度为 $N$ 的有序数组，插入元素要移动的元素个数为 $N/2$。有序数组的插入和删除的时间复杂度为 $O(N)$，效率很低；</li></ul></li><li>在链表中查找太慢：<ul><li>链表的插入和删除效率就很高，只要改变一些值的引用就行了，时间复杂度为 $O(1)$。但是链表的查询效率却很低，每次都要从头开始找，依次访问链表的每个数据项。平均来说，要从一个有 $N$ 个元素的链表查询一个元素，要遍历 $N/2$ 个元素，时间复杂度为 $O(N)$；</li></ul></li></ul><p>而树的存在，就很好的权衡了这两种结构，它结合了数组和链表的优点，在实际中有十分广泛的应用领域。可以说生活中几乎无处不存在树，例如：家族族谱、企业用人结构、体育竞赛组织结构、HTML 的文档对象模型（DOM），特别是操作系统的文件目录组织结构你一定不可能不知道吧！</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeTerms.png" alt="TreeTerms">  </p><div class="table-container"><table><thead><tr><th>名称</th><th>解释</th><th>例子</th></tr></thead><tbody><tr><td>根结点</td><td>树最顶层结点</td><td>结点 A</td></tr><tr><td>边</td><td>两个结点之间的连接</td><td>略</td></tr><tr><td>父节点</td><td>若一个节点含有子节点，则这个节点称为其子节点的父节点；</td><td>H 的父结点为 F；</td></tr><tr><td>子节点</td><td>一个节点含有的子树的根节点称为该节点的子节点；</td><td>C 的子节点为 F、G；</td></tr><tr><td>兄弟节点</td><td>具有相同父节点的节点互称为兄弟节点；</td><td>I 的兄弟结点为 H、J；</td></tr><tr><td>堂兄弟节点</td><td>父节点在同一层的节点互为堂兄弟；</td><td>结点 E 和 F 为堂兄弟结点；</td></tr><tr><td>节点的祖先</td><td>从根到该节点所经分支上的所有节点；</td><td>F 的祖先为 C、A；</td></tr><tr><td>子孙</td><td>以某节点为根的子树中任一节点都称为该节点的子孙；</td><td>F 的子孙为 H、I、J；</td></tr><tr><td>节点的度</td><td>一个节点含有的子树的个数称为该节点的度；</td><td>结点 C 的度为 2；</td></tr><tr><td>树的度</td><td>一棵树中，最大的节点度称为树的度；</td><td>上述树的度为 3；</td></tr><tr><td>叶节点（终端节点）</td><td>度为零的节点；</td><td>D、E、G、H、I、J；</td></tr><tr><td>分支节点（非终端节点）</td><td>度不为零的节点；</td><td>A、B、C、F；</td></tr><tr><td>节点的层次</td><td>从根开始定义起，根为第 0 层，根的子节点为第 1 层，以此类推；</td><td>见图中标注；</td></tr><tr><td>路径</td><td>从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径；</td><td>结点 A 到结点 I 的路径为：A、C、F、I；</td></tr><tr><td>深度</td><td>对于任意节点 n，n 的深度为从根到 n 的唯一路径长（经过的结点个数），根的深度为 1；</td><td>结点 F 的深度为 3；</td></tr><tr><td>高度</td><td>对于任意节点 n，n 的高度为从 n 到一片树叶的最长路径长（路径上结点个数的最大值），所有树叶的高度为 1；</td><td>结点 F 的深度为 2；</td></tr><tr><td>森林</td><td>由 m（$m \geq 0$）棵互不相交的树的集合称为森林；</td><td>见后面的讲解；</td></tr></tbody></table></div><ul><li>注意：有关高度、深度这两个概念，在不同的地方初始值的设定可能有所不同。有些地方习惯将根结点的深度定为 0，将叶结点的高度定为 0，我们没必要特别纠结于到底谁对谁错。关键还是得弄清高度和深度的含义。</li></ul><h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeCategory.png" alt="TreeCategory"></p><div class="table-container"><table><thead><tr><th>名称</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>无序树（自由树）</td><td>树中任意节点的子节点之间没有顺序关系；</td><td></td></tr><tr><td>有序树</td><td>树中任意节点的子节点之间有顺序关系；</td><td></td></tr><tr><td>二叉树</td><td>每个节点最多含有两个子树的树；</td><td></td></tr><tr><td>完全二叉树</td><td>对于一颗二叉树，假设其深度为 d（d&gt;1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</td><td>见本文二叉树部分；</td></tr><tr><td>满二叉树</td><td>所有叶节点都在最底层的完全二叉树；</td><td>见本文二叉树部分；</td></tr><tr><td>平衡二叉树（AVL 树）</td><td>当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；</td><td>参见：<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>；</td></tr><tr><td>排序二叉树（Binary Search Tree）</td><td>也称二叉搜索树、有序二叉树、二叉查找树；</td><td>也可参见上述文章；</td></tr><tr><td>B 树</td><td>一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树；</td><td>也可参见上述文章；</td></tr><tr><td>霍夫曼树（最优二叉树）</td><td>带权路径最短的二叉树；</td><td>本文后面会详细介绍；</td></tr></tbody></table></div><h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><p>树的结构定义是一个基于递归的定义（即在树的定义中又用到树的概念），这道出了树的固有特性；   </p><p>除去前面展示过的树形图外，树还有其他三种常用表示形式：</p><ul><li>以<strong>嵌套集合</strong>（即一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）的形式表示；</li><li><strong>广义表</strong>的形式，根作为由子树森林组成的表的名字写在表的左边；</li><li><strong>凹入法</strong>（类似书的目录）；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeExpression.png" alt="TreeExpression"></p><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历有两种方法：</p><ul><li>先根（次序）遍历树：先访问树的根结点，然后依次先根遍历根的每棵子树；<ul><li>上图的遍历结果为：<code>A B E K L F C G D H M I J</code></li></ul></li><li>后根（次序）遍历树：先依次后根遍历每棵子树，然后访问根结点；<ul><li>上图遍历结果为：<code>K L E F B G C M H I J D A</code></li></ul></li></ul><h2 id="树的抽象（ADT）及实现"><a href="#树的抽象（ADT）及实现" class="headerlink" title="树的抽象（ADT）及实现"></a>树的抽象（ADT）及实现</h2><p>树作为一个抽象的数据类型，它主要有基于数组、基于链表这两种实现方式；</p><h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p>使用数组实现，节点在数组中的位置对应于它在树中的位置:</p><ul><li>下标为 0 的节点是根，下标为 1 的节点是根的左子节点，依次类推，按从左到右的顺序存储树的每一层；</li><li>树中的每个位置，无论是否存在节点，都对应数组中的一个位置。把节点插入树的一个位置， 意味着要在数组的相应位置插入一个数据项。树中没有节点的位置在数组中的对应位置用 0 或 null 来表示；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeImpleBaseArray.png" alt="TreeImpleBaseArray"></p><p>在这种表示方式中，如果树是一棵二叉树（每个结点最多只有两个子节点），那么找节点的子节点和父节点就可以利用简单的算术计算它们在数组中的索引值：</p><ul><li>设节点索引值为 $index$，则节点的左子节点是：$2 \times index + 1$，它的右子节点是$2 \times index + 2$，它的父节点是 $\frac{index-1}{2}$；</li></ul><p>通过上述的定义，我们就能看出这种实现方式的优缺点如下：</p><ul><li>因为树中的每个位置都需要在数组中表示出来（不管该位置有无结点），这样树中空缺的结点或者被删除的结点都会在数组里留下 “空洞”，造成了内存浪费；</li><li>如果树中某个结点被删除后，需要调整树的结构（移动子树），那么子树对应到数组的每个元素都需要移动位置，在大型的树结构中，这一操作将十分耗时；</li><li>上述问题反映的也可以说是数组的劣势。当然了，如果某种树结构中不允许有删除操作，特别是在为结点动态分配空间比较耗时的情况下，这种实现方式也将很好的展现出它的优势；</li></ul><h3 id="基于链表实现"><a href="#基于链表实现" class="headerlink" title="基于链表实现"></a>基于链表实现</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>假设以一组<strong>连续空间</strong>存储树的结点，同时<strong>在每个结点中附设一个指示器指示其双亲结点在链表中的位置</strong>；</p><p>该结构利用的是每个结点（除根节点外）只有唯一双亲的性质。示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ParentsTree.png" alt="ParentsTree"></p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有以下两种结点格式：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildsTree.png" alt="ChildsTree"></p><ul><li>第一种结构，多重链表中的结点时同构的，其中 d 为树的度。由于树中很多结点的度小于 d，因此链表中会有很多空链表，造成空间浪费；</li><li>第二种结构，多重链表中的结点时不同构的，其中 $\overline{d}$ 是结点的度，degree 域的值同 $\overline{d}$。此时虽然节约存储空间，但操作不方便；</li></ul><p>还有一种办法：把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构（上面的树存储为如下形式）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildLinkedTree.png" alt="ChildLinkedTree"></p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>基于链表实现时采用的是 <code>父亲-长子-弟弟</code> 模型来定义，结构示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeLinkedList.png" alt="TreeLinkedList"></p><p>首先，定义树的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 树的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:25 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点中存放的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span></span>; <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 实现树接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:36 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkedList</span> <span class="keyword">implements</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object element; <span class="comment">// 树根节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeLinkedList parent, firstChild, nextSibling; <span class="comment">// 父节点、长子及最大的弟弟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">(Object object, TreeLinkedList parent, TreeLinkedList firstChild, TreeLinkedList nextSibling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = object;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.firstChild = firstChild;</span><br><span class="line">        <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前结点存放的对象元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Object bak = element;</span><br><span class="line">        element = obj;</span><br><span class="line">        <span class="keyword">return</span> bak;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>; <span class="comment">// 当前节点也是自己的后代</span></span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            size += subtree.getSize(); <span class="comment">// 累加</span></span><br><span class="line">            subtree = subtree.getNextSibling(); <span class="comment">// 所有孩子的后代数目</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size; <span class="comment">// 得到当前节点的后代总数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            height = Math.max(height, subtree.getHeight()); <span class="comment">// 在所有孩子中取最大高度</span></span><br><span class="line">            subtree = subtree.getNextSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height + <span class="number">1</span>; <span class="comment">// 每往下一行高度加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        TreeLinkedList p = parent; <span class="comment">// 从父亲开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            p = p.getParent(); <span class="comment">// 访问各个真祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth; <span class="comment">// 真祖先的数目，即为当前节点的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两颗子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。 </p><p>根据定义就能看出二叉树的 5 种基本形态如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeFiveStructure.png" alt="BinaryTreeFiveStructure">   </p><p>具有特殊形态的二叉树如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/SpecialFormBinaryTree.png" alt="SpecialFormBinaryTree"></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质 1</strong>：二叉树的第 i 层上至多有 $2^{i-1}$ 个结点（$i \geq 1$）；</p><ul><li>证明：利用归纳法<ul><li>当 $i = 1$ 时，只有一个根节点，显然成立；</li><li>假设对所有的 $j$，$1 \leq j &lt; i$，命题成立，即第 $j$ 层上至多有 $2^{j-1}$ 个结点；</li><li>由于二叉树每个结点的度至多为 2，则对于 $j+1$ 层来说：至多有 $2 \times 2^{j-1}=2^j$ 个结点，上述命题也成立；</li><li>因此，命题为真；</li></ul></li></ul><p><strong>性质 2</strong>：深度为 k 的二叉树至多有 $2^k-1$ 个结点（$k \geq1$）；</p><ul><li>证明：由性质 1，深度为 k 的二叉树的最大节点数为：<script type="math/tex">\sum^k_{i=1}\ (第\ i\ 层上的最大结点数)=\sum^k_{i=1}\ 2^{i-1}=2^k-1</script></li></ul><p><strong>性质 3</strong>：对任何一棵二叉树 T，如果其终端节点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$；</p><ul><li>证明：设 $n_1$ 为二叉树 T 中度为 1 的节点数，$n$ 为二叉树的总结点数，则：$n=n_0+n_1+n_2$；</li><li>考察二叉树的分支数。除了根节点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$；</li><li>由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_1+2\cdot n_2$；</li><li>将上述表达式联合起来也就不难推出：$n_0=n_2+1$；</li></ul><p>由于完全二叉树在实际中的运用比较多，接下来的两条性质就是围绕完全二叉树展开：   </p><p><strong>性质 4</strong>：具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n \rfloor+1$；</p><ul><li>证明：假设深度为 k，则根据性质 2 和完全二叉树的定义有：<script type="math/tex">2^{k-1}-1 < n \leq 2^k-1\ 或\ 2^{k-1} \leq n < 2^k</script>，于是 $k-1 \leq log_2n &lt; k$，因为 k 是整数，所以 $k=\lfloor log_2n \rfloor+1$；</li></ul><p><strong>性质 5</strong>：如果对一棵有 n 个结点的完全二叉树（其深度为 $\lfloor log_2n \rfloor+1$）的结点按层序编号（从第 1 层到第 $\lfloor log_2n \rfloor+1$ 层，每层从左到右），则对任一结点 i（$1\leq i \leq n$），有：</p><ol><li>如果 $i=1$，则结点 i 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲 $PARENT(i)$ 是结点 $\lfloor i/2 \rfloor$；</li><li>如果 $2i&gt;n$，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子 $LCHILD(I)$ 是结点 $2i$；</li><li>如果 $2i+1&gt;n$，则结点 i 无右孩子；否则其右孩子 $RCHILD(i)$ 是结点 $2i+1$；</li></ol><ul><li>证明：结论 1 可由结论 2 和 3 推导而出；<ul><li>对于 $i=1$ 的情况，很好推出；</li><li>对 $i&gt;1$ 分两种情况讨论：<ul><li>设第 $j（1 \leq j \leq \lfloor log_2n \rfloor）$层的第一个结点的编号为 i（由前面性质易推出 $i=2^{j-1}$）：<ul><li>则其左孩子必为第 $j+1$ 层的第一个结点，其编号为 $2^j=2(2^{j-1})=2i$，若 $2i&gt;n$，则无左孩子；</li><li>其右孩子必为第 $j+1$ 层的第二个结点，其编号为 $2i+1$，若 $2i+1&gt;n$，则无右孩子；</li></ul></li><li>假设第 $j(1 \leq j \leq \lfloor log_2n \rfloor)$ 层上某个结点的编号为 $i(2^{j-1} \leq i &lt; 2^j-1)$，且 $2i+1&lt;n$：则其左孩子为 $2i$，右孩子为 $2i+1$；<ul><li>又编号为 $i+1$ 的结点是编号为 $i$ 的结点的右兄弟或者堂兄弟，若它有左孩子，则编号必为 $2i+2=2(i+1)$，若它有右孩子，则其编号必为 $2i+3=2(i+1)+1$;</li></ul></li></ul></li><li>文字描述比较抽象，可以参照具体的完全二叉树的图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/LRChild.png" alt="LRChild"></li></ul></li></ul><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>假设用下面的图示来表示表达式：<code>a+b*(c-d)-e/f</code><br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TraverseBinaryTree.png" alt="TraverseBinaryTree"></p><div class="table-container"><table><thead><tr><th></th><th>先序遍历</th><th>中序遍历</th><th>后序遍历</th></tr></thead><tbody><tr><td>定义</td><td>先访问根结点，再访问左子树，再访问右子树；</td><td>先访问左子树，再访问根结点，再访问右子树；</td><td>先访问左子树，在访问右子树，再访问根结点；</td></tr><tr><td>遍历结果</td><td><code>-+a*b-cd/ef</code></td><td><code>a+b*c-d-e/f</code></td><td><code>abcd-*+ef/-</code></td></tr><tr><td>表达式类型</td><td>前缀表达式（波兰式）</td><td>中缀表达式</td><td>后缀表达式（逆波兰式）</td></tr></tbody></table></div><h2 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h2><p><strong>树转换为二叉树</strong>：</p><ul><li>加线：在所有的兄弟结点之间加线</li><li>去线：对树中的每一个结点，只保留它与第一个结点的连线，删除与其他孩子结点之间的连线</li><li>层次调整：调整成一颗二叉树（第一个孩子是二叉树的左孩子，兄弟转换过来是它的右孩子）</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeToBinaryTree.png" alt="TreeToBinaryTree"></p><p><strong>二叉树转换为树</strong>：就是树转换成二叉树的逆过程</p><ul><li>加线：若某结点的左孩子结点存在，则将左孩子的n个右孩子结点与此结点连接在一起</li><li>去线：删除二叉树中所有结点与其右孩子之间的连线</li><li>层次调整</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToTree.png" alt="BinaryTreeToTree"></p><h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><p>这里只是给出一种实现示例，该数据结构使用十分广泛，实际运用时可根据需求进行调整，例如：《<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>》 文章里的 『二叉搜索树』、『平衡二叉树』、 『B 树』等；</p><details>  <summary><b>二叉树的 java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> binarytree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> WWX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 二叉树的链式存储结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:07 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的节点数据结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span>  <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key=<span class="number">0</span>; <span class="comment">// 序号</span></span><br><span class="line">        <span class="keyword">private</span> String data=<span class="keyword">null</span>; <span class="comment">// 值（数据域）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isVisted=<span class="keyword">false</span>; <span class="comment">// 用来判断结点是否被访问到</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode leftChild=<span class="keyword">null</span>; <span class="comment">// 左儿子节点</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode rightChild=<span class="keyword">null</span>; <span class="comment">// 右儿子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="comment">// 默认构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 带参数构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> key,String data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.leftChild=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightChild=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode root=<span class="keyword">null</span>;  <span class="comment">// 二叉树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法</span></span><br><span class="line"><span class="comment">     * 指定根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(<span class="number">1</span>,<span class="string">"rootNode(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建一棵二叉树</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *           A</span></span><br><span class="line"><span class="comment">     *     B          C</span></span><br><span class="line"><span class="comment">     *  D     E            F</span></span><br><span class="line"><span class="comment">     *  &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode newNodeB = <span class="keyword">new</span> TreeNode(<span class="number">2</span>,<span class="string">"B"</span>);</span><br><span class="line">        TreeNode newNodeC = <span class="keyword">new</span> TreeNode(<span class="number">3</span>,<span class="string">"C"</span>);</span><br><span class="line">        TreeNode newNodeD = <span class="keyword">new</span> TreeNode(<span class="number">4</span>,<span class="string">"D"</span>);</span><br><span class="line">        TreeNode newNodeE = <span class="keyword">new</span> TreeNode(<span class="number">5</span>,<span class="string">"E"</span>);</span><br><span class="line">        TreeNode newNodeF = <span class="keyword">new</span> TreeNode(<span class="number">6</span>,<span class="string">"F"</span>);</span><br><span class="line"></span><br><span class="line">        newNodeC.rightChild = newNodeF;<span class="comment">//root.rightChild.rightChild=newNodeF;</span></span><br><span class="line">        newNodeB.leftChild = newNodeD;<span class="comment">//root.leftChild.leftChild=newNodeD;</span></span><br><span class="line">        newNodeB.rightChild = newNodeE;<span class="comment">//root.leftChild.rightChild=newNodeE;</span></span><br><span class="line"></span><br><span class="line">        root.leftChild = newNodeB;</span><br><span class="line">        root.rightChild = newNodeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断根节点是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的规模（树中结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树某个节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归结束：空树高度为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = height(subTree.leftChild);</span><br><span class="line">            <span class="keyword">int</span> j = height(subTree.rightChild);</span><br><span class="line">            <span class="keyword">return</span> (i &lt; j) ? (j + <span class="number">1</span>) : (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + size(subTree.leftChild) + size(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找某结点的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span> || root == element) ? <span class="keyword">null</span> : parent(root, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 subTree 为根的树中，element 的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode subTree,TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(subTree.leftChild == element || subTree.rightChild == element)</span><br><span class="line">            <span class="comment">//返回父结点地址</span></span><br><span class="line">            <span class="keyword">return</span> subTree;</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="comment">//现在左子树中找，如果左子树中没有找到，才到右子树去找</span></span><br><span class="line">        <span class="keyword">if</span>((p = parent(subTree.leftChild, element)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//递归在左子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//递归在右子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> parent(subTree.rightChild, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回左孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.leftChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回右孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.rightChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根为 subTree 的子树</span></span><br><span class="line">    <span class="comment">//   在释放某个结点时，该结点的左右子树都已经释放，</span></span><br><span class="line">    <span class="comment">//   所以应该采用后续遍历，当访问某个结点时将该结点的存储空间释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//删除左子树</span></span><br><span class="line">            destroy(subTree.leftChild);</span><br><span class="line">            <span class="comment">//删除右子树</span></span><br><span class="line">            destroy(subTree.rightChild);</span><br><span class="line">            <span class="comment">//删除根结点</span></span><br><span class="line">            subTree=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + subTree.key + <span class="string">"--name:"</span> + subTree.data);;</span><br><span class="line">        traverse(subTree.leftChild);</span><br><span class="line">        traverse(subTree.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            visted(subTree); <span class="comment">// 输出根节点</span></span><br><span class="line">            preOrder(subTree.leftChild); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            preOrder(subTree.rightChild); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrder(subTree.leftChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">            inOrder(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subTree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(subTree.leftChild);</span><br><span class="line">            postOrder(subTree.rightChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecPreOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node=p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                visted(node);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecInOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack =<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//存在左子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈非空</span></span><br><span class="line">            <span class="keyword">if</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                visted(node);</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noRecPostOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//左子树入栈</span></span><br><span class="line">            <span class="keyword">for</span>(;p.leftChild!=<span class="keyword">null</span>;p=p.leftChild)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前结点无右子树或右子树已经输出</span></span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;(p.rightChild==<span class="keyword">null</span>||p.rightChild==node))&#123;</span><br><span class="line">                visted(p);</span><br><span class="line">                <span class="comment">//纪录上一个已输出结点</span></span><br><span class="line">                node =p;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                p=stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理右子树</span></span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被访问到就输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visted</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        subTree.isVisted=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+subTree.key+<span class="string">"--name:"</span>+subTree.data);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree bt = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        bt.createBinTree(bt.root);</span><br><span class="line">        System.out.println(<span class="string">"the size of the tree is "</span> + bt.size());</span><br><span class="line">        System.out.println(<span class="string">"the height of the tree is "</span> + bt.height());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.preOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.inOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.postOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecPreOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecInOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.noRecPostOrder(bt.root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>线索二叉树是在二叉树的基础上新增了下列规则：</p><ul><li>若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；</li><li>若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 域指示其后继；</li></ul><p>为了避免混淆，尚需改变结点结构，增加两个标志域：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ClueBinaryTreeStruct.png" alt="ClueBinaryTreeStruct">   </p><p>由定义的结构，我们知道线索二叉树也应该分为：前序线索树、中序线索树、后序线索树。这其中在后序线索树中找结点后继较复杂，以其为例，分为 3 种情况考虑：</p><ul><li>若结点 x 是二叉树的根，则其后继为空；</li><li>若结点 x 是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；</li><li>若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点；</li></ul><p>若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作为存储结构；</p><h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><p>前面已经说过，森林是 $m（m \geq 0）$棵互不相交的树的集合；   </p><p><strong>将森林转换为二叉树</strong>：</p><ul><li>转换：把每一棵树转换成二叉树</li><li>连线：第一棵二叉树不变，从第二棵二叉树开始，依次将后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子，用线连起来</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ForestToBinaryTree.png" alt="ForestToBinaryTree"></p><p><strong>二叉树转换为森林</strong>：</p><ul><li>判断二叉树转换成森林还是树：二叉树的根节点是否有右孩子，若有是森林，否则是树</li><li>从根节点开始，若有右孩子，则把与右孩子结点的连线删除，再看分离后的二叉树，若还有右孩子连线继续删除，则到没有为止</li><li>将分离的二叉树转换成树</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToForest.png" alt="BinaryTreeToForest"></p><p><strong>森林的遍历</strong>：</p><ul><li>先序遍历：<ul><li>若森林非空，则按如下规则遍历：<ul><li>访问森林中第一棵树的根结点；</li><li>先序遍历第一棵树中根结点的子树森林；</li><li>先序遍历除去第一棵树之后剩余的树构成的森林；</li></ul></li><li>上述森林的遍历结果：<code>A B C D E F G H J I</code></li></ul></li><li>中序遍历：<ul><li>若森林非空，则按如下规则遍历：<ul><li>中序遍历森林中第一棵树的根结点的子树森林；</li><li>访问第一棵树的根结点；</li><li>中序遍历除去第一棵树之后剩余的树构成的森林；</li></ul></li><li>上述森林的遍历结果：<code>B C D A F E J H I G</code></li></ul></li></ul><h1 id="哈夫曼（Huffman）树"><a href="#哈夫曼（Huffman）树" class="headerlink" title="哈夫曼（Huffman）树"></a>哈夫曼（Huffman）树</h1><p>哈（赫）夫曼树又称最优树，它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度最小的二叉树；</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>路径与路径长</strong>：</p><ul><li><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成的部分，而分支（边）的数目就是<strong>路径长度</strong>；</li><li><strong>树的路径长度</strong>：就是从树根到每一结点的路径长度之和；</li></ul><p><strong>考虑带权的结点</strong>：</p><ul><li><strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积；</li><li><strong>树的带权路径长度 WPL</strong>（weighted path length）：树中所有叶子结点的带权路径长度之和；<ul><li>假设一个有 $n$ 个带权叶子结点的二叉树，其权值为 $\{w_1,w_2,….w_n\}$，每个叶子结点带权 $w_k$，每个叶子的路径长度为 $l_k$，则从根结点到各个叶子结点的路径长度与相应的权值的乘积之和叫做<strong>二叉树的带权路径长度</strong>，通常记作：<script type="math/tex">WPL = \sum^n_{k=1}\ w_kl_k</script></li><li>示例：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanWPL.png" alt="HuffmanWPL"></li></ul></li></ul><p>观察上述示例，（b）所示的二叉树的 WPL 最小，为哈夫曼树（最优树）；</p><ul><li>注意：由相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径。在由 n 个带权叶子结点所构成的二叉树中，满二叉树或完全二叉树不一定是最优二叉树。<strong>权值越大的结点离根结点越近的二叉树才是最优二叉树</strong>；</li></ul><h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>哈夫曼算法是用来构造二叉树的，其描述如下：</p><ul><li>根据给定的 $n$ 个叶子结点的权值 $\{w_1,w_2,….w_n\}$ 构成 $n$ 棵二叉树的集合 $F=\{T_1,T_2,…T_n\}$，其中每棵二叉树 $T_i$ 中只有一个带权为 $w_i$的根结点，其左右子树均为空;</li><li>在 $F$ 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为左右子树上根结点的权值之和；</li><li>在 $F$ 中删除这两棵树，同时将新得到的二叉树加入 $F$ 中；</li><li>重复步骤 2、3，直到 $F$ 只含一棵树为止。这棵树便是哈夫曼树；</li></ul><p>示例如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanTreeBuild.png" alt="HuffmanTreeBuild"></p><h2 id="应用：哈夫曼编码"><a href="#应用：哈夫曼编码" class="headerlink" title="应用：哈夫曼编码"></a>应用：哈夫曼编码</h2><p>在数字通信中，经常需要将传送的文字转换成由二进制字符 <code>0、1</code> 组成的二进制串，这一过程被称为<strong>编码</strong>。在传送电文时，总是希望电文代码尽可能短，采用哈夫曼编码构造的电文的总长最短。</p><ul><li>从根节点出发，每个父节点都会有分支，现在给左右分支各赋予一个数值，左分支表示 <code>0</code>，右分支表示 <code>1</code>；</li><li>当从根节点一直数到叶子结点过程中所经历的左右分支以 <code>0</code>、<code>1</code> 表示时，每个叶子结点会形成一个特定的编码，这个就是哈夫曼编码。如图所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanCode.png" alt="HuffmanCode"></li></ul><div class="note warning">            <p>来自：<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">本段来源</a><br>在电文传输中，需要将电文中出现的每个字符进行二进制编码。在设计编码时需要遵守两个原则：</p><ul><li>发送方传输的二进制编码，到接收方解码后必须具有唯一性，即解码结果与发送方发送的电文完全一样；</li><li>发送的二进制编码尽可能地短;</li></ul><p>下面我们介绍两种编码的方式。</p><ol><li><p>等长编码：</p><ul><li>这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）；</li><li>假设字符集只含有 4 个字符 A，B，C，D，用二进制两位表示的编码分别为 00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为 14 位。当接收方接收到这段电文后，将按两位一段进行译码。</li><li>这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</li></ul></li><li><p>不等长编码：</p><ul><li>在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编；</li><li>例如，可以为 A，B，C，D 四个字符分别分配 0，00，1，01，并可将上述电文用二进制序列：000011010 发送，其长度只有 9 个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面 4 个 0 是 4 个 A，1 个 B、2 个 A，还是 2 个 B，即译码不唯一，因此这种编码方法不可使用。</li><li>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即（<strong>前缀编码</strong>）在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀。<strong>这个问题可以采用哈夫曼编码解决</strong>。</li></ul></li></ol>          </div><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将一个字符串中出现的字符生成其对应的哈夫曼编码，分为以下几步：</p><ol><li>统计出现的字符及频率；</li><li>将各个字符创建为叶子结点，频率为结点的权值，用链表保存这些叶子结点；</li><li>将结点队列中的结点按权值升序排列；</li><li>取出权值最小的两个结点构建父节点（要从链表中删除取出的结点），将新生成的父节点添加到结点链表，并从新排序；</li><li>重复（4）步骤，直到只剩下一个结点；</li><li>返回最后的结点，即为哈夫曼树的根节点；</li></ol><details>  <summary><b>哈夫曼树的 java 实现</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 哈夫曼树的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 23:47 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树的结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String code = <span class="string">""</span>; <span class="comment">// 节点的哈夫曼编码</span></span><br><span class="line">        <span class="keyword">public</span> String data = <span class="string">""</span>; <span class="comment">// 节点的数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;        <span class="comment">// 节点的权值</span></span><br><span class="line">        <span class="keyword">public</span> HNode lChild;     <span class="comment">// 左孩子</span></span><br><span class="line">        <span class="keyword">public</span> HNode rChild;     <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(<span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String str;                     <span class="comment">// 最初用于压缩的字符串</span></span><br><span class="line">    <span class="keyword">private</span> HNode root;                     <span class="comment">// 哈夫曼二叉树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;                   <span class="comment">// 最新的字符是否已经存在的标签</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;CharData&gt; charList;  <span class="comment">// 存储不同字符的队列 相同字符存在同一位置</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;HNode&gt; NodeList;     <span class="comment">// 存储节点的队列</span></span><br><span class="line">    <span class="comment">// 字符类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CharData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 字符个数</span></span><br><span class="line">        <span class="keyword">char</span> c; <span class="comment">// 字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharData</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">            c = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatHfmTree</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line"></span><br><span class="line">        NodeList = <span class="keyword">new</span> LinkedList&lt;HNode&gt;();</span><br><span class="line">        charList = <span class="keyword">new</span> LinkedList&lt;CharData&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.统计字符串中字符以及字符的出现次数</span></span><br><span class="line">        <span class="comment">// 以CharData类来统计出现的字符和个数</span></span><br><span class="line">        getCharNum(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.根据第一步的结构，创建节点</span></span><br><span class="line">        creatNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对节点权值升序排序</span></span><br><span class="line">        Sort(NodeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">        <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">        creatTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.重复第四五步，就是那个while循环</span></span><br><span class="line">        <span class="comment">// 7.将最后的一个节点赋给根节点</span></span><br><span class="line">        root = NodeList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是构造哈夫曼树的子方法实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计出现的字符及其频率</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCharNum</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i); <span class="comment">// 从给定的字符串中取出字符</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charList.size(); j++) &#123; <span class="comment">// charList中存放的是已经识别出来的字符</span></span><br><span class="line">                CharData data = charList.get(j);</span><br><span class="line">                <span class="keyword">if</span>(ch == data.c)&#123; <span class="comment">// 字符对象链表中有相同字符则将个数加1</span></span><br><span class="line">                    data.num++;</span><br><span class="line">                    flag = <span class="keyword">false</span>;  <span class="comment">// 标志该字符已被识别出来不再加入 charList</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                charList.add(<span class="keyword">new</span> CharData(ch)); <span class="comment">// 字符对象链表中没有相同字符,则创建新对象加如链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将出现的字符创建成哈夫曼树单个的结点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charList.size(); i++) &#123;</span><br><span class="line">            String data = charList.get(i).c + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> count = charList.get(i).num;</span><br><span class="line">            HNode node = <span class="keyword">new</span> HNode(data, count); <span class="comment">// 创建节点对象</span></span><br><span class="line">            NodeList.add(node); <span class="comment">// 加入到节点链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (NodeList.size() &gt; <span class="number">1</span>) &#123;    <span class="comment">// 当节点数目大于一时</span></span><br><span class="line">            <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">            <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">            HNode left = NodeList.poll();</span><br><span class="line">            HNode right = NodeList.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在构建哈夫曼树时设置各个结点的哈夫曼编码</span></span><br><span class="line">            left.code = <span class="string">"0"</span>;  <span class="comment">// 左节点为 1</span></span><br><span class="line">            right.code = <span class="string">"1"</span>; <span class="comment">// 右节点为 0</span></span><br><span class="line">            setCode(left);</span><br><span class="line">            setCode(right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parentWeight = left.count + right.count; <span class="comment">// 父节点权值等于子节点权值之和</span></span><br><span class="line">            HNode parent = <span class="keyword">new</span> HNode(parentWeight, left, right);</span><br><span class="line">            NodeList.addFirst(parent); <span class="comment">// 将父节点置于首位</span></span><br><span class="line">            Sort(NodeList); <span class="comment">// 重新排序，避免新节点权值大于链表首个结点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodelist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(LinkedList&lt;HNode&gt; nodelist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodelist.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nodelist.size(); j++) &#123;</span><br><span class="line">                HNode temp;</span><br><span class="line">                <span class="keyword">if</span> (nodelist.get(i).count &gt; nodelist.get(j).count) &#123;</span><br><span class="line">                    temp = nodelist.get(i);</span><br><span class="line">                    nodelist.set(i, nodelist.get(j));</span><br><span class="line">                    nodelist.set(j, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(HNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.lChild.code = root.code + <span class="string">"0"</span>;</span><br><span class="line">            setCode(root.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.rChild.code = root.code + <span class="string">"1"</span>;</span><br><span class="line">            setCode(root.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(HNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.lChild == <span class="keyword">null</span> &amp;&amp; node.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node.data + <span class="string">": "</span> + node.code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果字符的哈夫曼编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是编解码的实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String hfmCodeStr = <span class="string">""</span>;<span class="comment">// 哈夫曼编码连接成的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHufmCode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            String c = str.charAt(i) + <span class="string">""</span>;</span><br><span class="line">            search(root, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hfmCodeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在哈夫曼树里查找字符对应的结点（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 需要生成编码的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(HNode root, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.equals(root.data)) &#123;</span><br><span class="line">                hfmCodeStr += root.code; <span class="comment">// 找到字符，将其哈夫曼编码拼接到最终返回二进制字符串的后面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.lChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.rChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存解码的字符串</span></span><br><span class="line">    String result=<span class="string">""</span>; <span class="comment">// 初始为空串</span></span><br><span class="line">    <span class="keyword">boolean</span> target = <span class="keyword">false</span>; <span class="comment">// 解码标记</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeStr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CodeToString</span><span class="params">(String codeStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt;= codeStr.length())&#123;</span><br><span class="line">            target = <span class="keyword">false</span>;</span><br><span class="line">            String s = codeStr.substring(start, end);</span><br><span class="line">            matchCode(root, s); <span class="comment">// 解码</span></span><br><span class="line">            <span class="comment">// 每解码一个字符，start向后移</span></span><br><span class="line">            <span class="keyword">if</span>(target)&#123;</span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配字符哈夫曼编码，找到对应的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 需要解码的二进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">matchCode</span><span class="params">(HNode root, String code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code.equals(root.code)) &#123;</span><br><span class="line">                result += root.data; <span class="comment">// 找到对应的字符，拼接到解码字符穿后</span></span><br><span class="line">                target = <span class="keyword">true</span>; <span class="comment">// 标志置为true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.lChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.rChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuffmanTree huff = <span class="keyword">new</span> HuffmanTree();<span class="comment">// 创建哈弗曼对象</span></span><br><span class="line">        String data = <span class="string">"我喜欢用 java 实现哈夫曼编码"</span>;</span><br><span class="line">        </span><br><span class="line">        huff.creatHfmTree(data);<span class="comment">// 构造树</span></span><br><span class="line"></span><br><span class="line">        huff.output(); <span class="comment">// 显示各个字符的哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目标字符串利用生成好的哈夫曼编码生成对应的二进制编码</span></span><br><span class="line">        String hufmCode = huff.toHufmCode(data);</span><br><span class="line">        System.out.println(<span class="string">"编码:"</span> + hufmCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上述二进制编码再翻译成字符串</span></span><br><span class="line">        System.out.println(<span class="string">"解码："</span> + huff.CodeToString(hufmCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>『<a href="https://www.jianshu.com/p/4716b2f49e8e" target="_blank" rel="noopener">数据结构：二叉树的原理及java实现</a>』</li><li>『<a href="https://blog.csdn.net/xin917480852/article/details/50503501" target="_blank" rel="noopener">树、森林与二叉树的转换总结</a>』</li><li>『<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">Java 实现哈夫曼树及简易编码解码</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-Tree/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n （$n \geq 0$）个有限节点组成一个具有层次关系的集合。在任意一棵非空树中，它都满足如下特点：&lt;/p&gt;
&lt;div class=&quot;note warning&quot;&gt;
            &lt;ul&gt;&lt;li&gt;有且仅有一个特定的称为根（Root）的结点；&lt;/li&gt;&lt;li&gt;当 $n &amp;gt;1$ 时，其余结点可分为 m（$m &amp;gt;0$）个互不相交的有限集 $T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；&lt;/li&gt;&lt;/ul&gt;
          &lt;/div&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之字符串</title>
    <link href="http://www.thebetterkong.cn/2020/07/02/DataStructure-Algorithm/DataStructure-String/"/>
    <id>http://www.thebetterkong.cn/2020/07/02/DataStructure-Algorithm/DataStructure-String/</id>
    <published>2020-07-02T10:25:36.000Z</published>
    <updated>2020-08-14T09:28:18.323Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-String/header.png" width="100%" alt="header.png" /> </div>  <p><strong>字符串</strong>（String）是由零个或多个字符（char）组成的有序序列。学过 C/C++ 的人会有一种固定的思维模式，凡是字符串都是以 <code>\0</code> 结束。但是 java 却不同，要知道 java 里始终秉承的一句话 『<strong>everything is object</strong>』，字符串也不例外，它也被作为 String 类型的对象处理。</p><a id="more"></a> <h1 id="认识-java-字符串"><a href="#认识-java-字符串" class="headerlink" title="认识 java 字符串"></a>认识 java 字符串</h1><p><code>String</code> 类表示字符串，Java 程序中的所有字符串文字（例如 <code>abc</code>）都实现为此类的实例。让我们来看一下 java 中 <code>String</code> 类的声明源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这里我们可以看出两点结论：</p><ul><li><strong><code>String</code> 类是通过 <code>char</code> 数组来保存字符串的</strong>，因此有如下关系：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">char</span> [] data = &#123;<span class="string">'a'</span>，<span class="string">'b'</span>，<span class="string">'c'</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String (data);</span><br></pre></td></tr></table></figure></li><li><strong>字符串是常量，它们的值在内存创建后则无法更改（字符串的不变性）</strong>，平常我们用到的更改实际上都只是重新创建了一个新的字符串（后面会进行详细描述），这样效率很低。因此如果需要一个可以改变的字符串，更推荐使用 <code>StringBuffer</code> 或者 <code>StringBuilder</code>；</li></ul><h1 id="创建-java-String-对象的方法"><a href="#创建-java-String-对象的方法" class="headerlink" title="创建 java String 对象的方法"></a>创建 java String 对象的方法</h1><p>在具体讲解之前，我们有必要先弄清楚 java String 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 构造方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对 jdk 源码里常用方法的总结罗列，如果有疑惑，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 注意：除非另有说明，否则将 null 参数传递给此类中的构造函数或方法将引发  NullPointerException；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空字符串，由于字符串不可变，所以它通常不会被使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>.value = <span class="string">""</span>.value;&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建参数字符串的副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;...&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新的 String，它包含参数字符数组的字符序列；</span></span><br><span class="line"><span class="comment">// 字符数组的内容被复制，字符数组的后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;...&#125;;          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这次创建的是参数数组的子数组</span></span><br><span class="line"><span class="comment">// @param offset 是子数组第一个字符的索引</span></span><br><span class="line"><span class="comment">// @param count 指定子数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 Uncode 编码数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 ascii 编码字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 通过使用指定的字符集解码指定的字节子数组，构造一个新的 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string buffer 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string buffer 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string builder 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string builder 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="comment">// 提供此构造函数可简化向 StringBuilder 的迁移；</span></span><br><span class="line"><span class="comment">// 通过 toString 方法从 StringBuilder 获取字符串可能运行得更快，通常是首选。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了共享数组的包私有构造器，但是总是期望 share == true</span></span><br><span class="line"><span class="comment">// 因为已经有一个公共 String（char []）构造函数，它可以复制给定char []，因此需要一个单独的构造函数</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;...&#125;;</span><br></pre></td></tr></table></figure><p>源码嘛，比较复杂一点，但其实我们实际使用中经常用到的也就<strong>两种形式，特别关注他们的差异</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、使用 "" 引号创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：单独使用 "" 引号创建的字符串都是常量，编译期就已经确定，存储</span></span><br><span class="line"><span class="comment">*       到 String Pool 中</span></span><br><span class="line"><span class="comment">* 具体过程：在执行到双引号包含字符串的语句时，如 String a = "123"，</span></span><br><span class="line"><span class="comment">*           JVM 会先到常量池里查找，如果有的话返回常量池里的这个实</span></span><br><span class="line"><span class="comment">*           例的引用，否则的话创建一个新实例并置入常量池里</span></span><br><span class="line"><span class="comment">* 注意：使用此方法，对象可能并没有被创建！而只是将引用指向了一个先前</span></span><br><span class="line"><span class="comment">*       已经创建的对象  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 创建一个字符串对象 imooc，引用名为 s1</span></span><br><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line"><span class="comment">// 新声明一个字符串引用，名为 s2，也指向了常量池里与上面字符串相同的字符串</span></span><br><span class="line">String s2 = <span class="string">"imooc"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二、使用 new 关键字创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：使用 new String("") 创建的对象会存储到 heap 中，是运行期新创建的；</span></span><br><span class="line"><span class="comment">* 具体过程：new 首先在堆中创建一个对象，引用 s3 指向这个对象。然后在常量池中找值</span></span><br><span class="line"><span class="comment">*          为 "immoc" 的对象：</span></span><br><span class="line"><span class="comment">*          如果没有，则进行创建，然后将这个 String 对象成员变量 char 数组</span></span><br><span class="line"><span class="comment">*          （value[]），指向值为 "immoc" 的这个对象（这时就创建了两个对象）；</span></span><br><span class="line"><span class="comment">*          如果有，则直接将 String 对象成员变量 char 数组指向这个 "immoc" 对象</span></span><br><span class="line"><span class="comment">*          即可（这时只创建了一个对象）；</span></span><br><span class="line"><span class="comment">*    </span></span><br><span class="line"><span class="comment">* 注意：此方法一定有一个新的对象被创建，至于最终有几个对象创建得分情况考虑，这也</span></span><br><span class="line"><span class="comment">*      是面试中的高频考点！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 分配内存，创建一个新的字符串对象 imooc，引用名为 s2</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 补充说明：</span></span><br><span class="line"><span class="comment">*   （1）使用只包含常量的字符串连接符如 "aa" + "aa" 创建的也是常</span></span><br><span class="line"><span class="comment">*        量，编译期就能确定，已经确定存储到 String Pool 中；</span></span><br><span class="line"><span class="comment">*   （2）使用包含变量的字符串连接符如 "aa" + s1 创建的对象是运行期</span></span><br><span class="line"><span class="comment">*        才创建的，存储在 heap 中；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>上面对这两种形式的差异解释可能有点晕，给出一段代码帮助理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"爱慕课"</span>;  </span><br><span class="line">String s2 = <span class="string">"爱慕课"</span>; </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);       <span class="comment">// 多次出现的字符常量，Java 编译程序只创建一个，所以返回 true</span></span><br><span class="line">System.out.println(s1 == s3);       <span class="comment">// s1 和 s3 是不同的对象，所以返回 false</span></span><br><span class="line">System.out.println(s3 == s4);       <span class="comment">// s3和 s4 是不同的对象，所以返回 false</span></span><br><span class="line">s1 = <span class="string">"欢迎来到："</span> + s1;</span><br><span class="line">System.out.println(s1);             <span class="comment">// 字符串 s1 被修改，指向新的内存空间，输出“欢迎来到：爱慕课”</span></span><br></pre></td></tr></table></figure></p><h1 id="java-字符串的不可变性"><a href="#java-字符串的不可变性" class="headerlink" title="java 字符串的不可变性"></a>java 字符串的不可变性</h1><p>首先，我们来认识一下，什么叫做<strong>类的不可变性</strong>：<br><div class="note warning">            <ul><li><strong>定义</strong>：简单地说，就是其实例一旦创建完成，在其整个生命周期内状态都不会发生变化。状态这个词有一些抽象，在 Java 中对象的状态是由其成员变量来表现的，那么状态不变即是成员变量不变（具体来说，基本类型变量的值不变、引用类型变量的引用地址不变）；</li><li><strong>不可变的类的好处</strong>：<ul><li>更加易于设计、实现和使用。</li><li>并发时，不容易出错，并且更加安全。</li></ul></li><li><strong>为了使类成为不可变，要遵循下面五条规则</strong>（来自《Effective Java》）：<ul><li>不提供任何会修改对象状态的方法；</li><li>保证类不能被扩展；</li><li>所有的成员变量都被 final 修饰的；</li><li>所有的成员变量都是 private 的；</li><li>确保对于任何可变组件的互斥访问。如果一个类的成员变量引用了可变对象，则必须确保外部调用类无法获取指向这些对象的引用；</li></ul></li><li>当然，所有的这些条件都是针对正常调用而言的，如果使用反射，则仅仅满足上述的条件也无法保证对象不可变；</li><li>看到这里，你就一定明白上面为什么说 java 的字符串是一个不可变的常量；</li></ul>          </div></p><p>关于 java 字符串，就需要牢记一句话：<strong><mark>String 对象一旦被创建就是固定不变的了，对 String 对象的任何改变都不影响到原对象，相关的任何 change 操作都会生成新的对象</mark></strong>；    </p><p>关于这一点结合前文所学，就有必要认识一下<strong>三个比较重要的方法</strong>：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String.intern()</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：在常量池中查找值等于（equals）当前字符串的对象，如果找到，则直接返回</span></span><br><span class="line"><span class="comment">*          这个对象的地址；如果没有找到，则将当前字符串拷贝到常量池中，然后返回</span></span><br><span class="line"><span class="comment">*          拷贝后的对象地址；    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String a = <span class="string">"123"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);                     <span class="comment">// false</span></span><br><span class="line">System.out.println(a == b.intern());            <span class="comment">// true</span></span><br><span class="line">System.out.println(c == b.intern());            <span class="comment">// false</span></span><br><span class="line">System.out.println(c.intern() == b.intern());   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equals 和 ==</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*（1）对于 ==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,</span></span><br><span class="line"><span class="comment">*     double,boolean ），则直接比较其存储的"值"是否相等；如果作用于引用类型的变</span></span><br><span class="line"><span class="comment">*     量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）；</span></span><br><span class="line"><span class="comment">*（2）equals 方法是基类 Object 中的方法，因此对于所有的继承于 Object 的类都会有</span></span><br><span class="line"><span class="comment">*    该方法。在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是</span></span><br><span class="line"><span class="comment">*    否指向同一个对象；</span></span><br><span class="line"><span class="comment">*（3）对于 equals 方法，注意：equals 方法不能作用于基本数据类型的变量。如果没有</span></span><br><span class="line"><span class="comment">*    对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而 </span></span><br><span class="line"><span class="comment">*    String 类对 equals 方法进行了重写，用来比较指向的字符串对象所存储的字符串</span></span><br><span class="line"><span class="comment">*    是否相等。其他的一些类诸如 Double，Date，Integer 等，都对 equals 方法进行</span></span><br><span class="line"><span class="comment">*    了重写用来比较指向的对象所存储的内容是否相等；   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);          <span class="comment">// true，表示 s1 和 s2 指向同一对象，它们都指向常量池中的 "hello" 对象</span></span><br><span class="line">System.out.println(s1 == s3);          <span class="comment">// flase，表示 s1 和 s3 的地址不同，即它们分别指向的是不同的对象，s1 指向常量池中的地址，s3 指向堆中的地址</span></span><br><span class="line">System.out.println(s1.equals(s3));     <span class="comment">// true，表示 s1 和 s3 所指向对象的内容相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符串的连接："+"</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：连接两个字符串</span></span><br><span class="line"><span class="comment">*    工作细节：连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符</span></span><br><span class="line"><span class="comment">*             串常量连接起来，形成新的字符串常量参与后续连接。接下来的字符串连接</span></span><br><span class="line"><span class="comment">*             是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创</span></span><br><span class="line"><span class="comment">*             建 StringBuilder 对象，然后依次对右边进行 append 操作，最后将</span></span><br><span class="line"><span class="comment">*             StringBuilder 对象通过 toString() 方法转换成 String 对象（注</span></span><br><span class="line"><span class="comment">*             意：中间的多个字符串常量不会自动拼接）。      </span></span><br><span class="line"><span class="comment">*   例如：String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程</span></span><br><span class="line"><span class="comment">*         是： String c = new StringBuilder("xxyy ").append(a).append("zz").</span></span><br><span class="line"><span class="comment">*         append("mm").append(b).toString();</span></span><br><span class="line"><span class="comment">*   结论：当使用 + 进行多个字符串连接时，实际上是产生了一个 StringBuilder 对象</span></span><br><span class="line"><span class="comment">*         和一个 String 对象。也正因如此，导致了 string 中 + 连接符效率十分低</span></span><br><span class="line"><span class="comment">*         下。因此，当经常涉及字符串的改变（拼接）时，更推荐用 StringBuffer 或 </span></span><br><span class="line"><span class="comment">*         StringBulider 对象来进行 append 操作，特别是在循环中；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;         <span class="comment">// 创建时，编译器可以进行优化，这里只创建了一个对象。变量 s 的创建等价于 String s = "abc"; </span></span><br><span class="line">String s1  =  <span class="string">"a"</span>; </span><br><span class="line">String s2  =  <span class="string">"b"</span>; </span><br><span class="line">String s3  =  <span class="string">"c"</span>; </span><br><span class="line">String s4  =  s1  +  s2  +  s3;</span><br><span class="line"><span class="comment">// s4 不能在编译期进行优化，其对象创建相当于：</span></span><br><span class="line"><span class="comment">// StringBuilder temp = new StringBuilder();   </span></span><br><span class="line"><span class="comment">// temp.append(a).append(b).append(c);   </span></span><br><span class="line"><span class="comment">// String s = temp.toString();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   最后再来一段代码加深理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="string">"12"</span>;</span><br><span class="line">String s1 = <span class="string">"34"</span>;</span><br><span class="line">String s2 = s + s1;</span><br><span class="line">String s3 = <span class="string">"1234"</span>;</span><br><span class="line">String s4 = <span class="string">"12"</span> + <span class="string">"34"</span>;</span><br><span class="line">String s5 = s + <span class="string">"34"</span>;</span><br><span class="line">String s6 = <span class="string">"12"</span> + <span class="keyword">new</span> String(<span class="string">"34"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s4);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="String-的方法"><a href="#String-的方法" class="headerlink" title="String 的方法"></a>String 的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//*********************** 基础方法 **************************************</span></span><br><span class="line"><span class="function">String <span class="title">intern</span><span class="params">()</span></span>;        <span class="comment">// 在常量池中查找值等于（equals）当前字符串的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;                            <span class="comment">// 返回当前字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                          <span class="comment">// 判断字符串是否为空（length == 0）</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 获取字符串中指定位置的字符</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;           <span class="comment">// 是否包含</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;            <span class="comment">// 返回去除了前后空格的字符串</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>;                  <span class="comment">// 将指定字符串连接到此字符串的结尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;     <span class="comment">// 返回字符串的 hashcode，计算方式：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 转换 ************************************</span></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span></span>;  <span class="comment">// 指定转换规则</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 其他类型转换为 string</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;      <span class="comment">// 它本身就是一个 srtring，所以返回他自身</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回 Object 参数的字符串表示形式，null 或者 obj.toString()</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;    <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>; <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>; <span class="comment">// 返回 b 代表的 "true" 或者 "false"</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### string 转换为其他类型</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray();   <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;    </span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到 dst 中从 dstBegin 开的位置（无范围检查）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;  </span><br><span class="line">    <span class="comment">// 将字符串 srcBegin 到 srcEnd-1 的字符复制到 dst 中从 dstBegin 开的位置（有范围检查）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] getBytes();      <span class="comment">// 将该字符串本身转化为 byte 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">byte</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;</span><br><span class="line"><span class="comment">// 将该字符串指定位置的内容转换至 byte 数组指定位置</span></span><br><span class="line"><span class="comment">// 每个字节接收相应字符的8个低位，每个字符的八个高位不被复制，也不以任何方式参与传输（汉子占两个字节，英文字符一个字节）</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName)；   <span class="comment">// 指定字符串转化为 bytes 数组，返回这个数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 比较方法 **************************************</span></span><br><span class="line"><span class="comment">//（1）比较是否完全相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>;            <span class="comment">// 将该字符串与指定对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span></span>;     <span class="comment">// 将该字符串与指定 StringBuffer 对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>；    <span class="comment">// 两个 String 比较，不考虑大小写</span></span></span><br><span class="line"><span class="function"><span class="comment">//（2）按字典序从头至尾对比（不一定完全相等）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>;    <span class="comment">// 从左至右挨个字符对比（只比较公共长度的部分）</span></span><br><span class="line">    <span class="comment">// 如果参数字符串等于此字符串，则值为 0；</span></span><br><span class="line">    <span class="comment">// 如果此字符串在字典上小于字符串参数，则小于 0的值；</span></span><br><span class="line">    <span class="comment">// 如果该字符串在字典上大于字符串参数，则该值大于 0；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;    <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">//（3）匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span>;  <span class="comment">// 告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="comment">// 将该字符串从 toffset 开始的 len 个字符与 other 字符串从 ooffset 开始的 len 个字符进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 拼接 **************************************</span></span><br><span class="line"><span class="comment">// 用 delimiter 作为分割符，将后面的序列拼接起来</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  String message = String.join("-", "Java", "is", "cool"); </span></span><br><span class="line"><span class="comment">//  message returned is:"Java-is-cool"</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  List&lt;String&gt; strings = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//  strings.add("Java");strings.add("is");</span></span><br><span class="line"><span class="comment">//  strings.add("cool");</span></span><br><span class="line"><span class="comment">//  String message = String.join(" ", strings);</span></span><br><span class="line"><span class="comment">//  message returned is: "Java is cool"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 分割 aplit ************************************</span></span><br><span class="line"><span class="comment">// 将字符串按正则规则分割为子字符串，返回字符串数组</span></span><br><span class="line">String[] aplit(String regex,<span class="keyword">int</span> limit); </span><br><span class="line"><span class="comment">// limit 参数控制应用模式的次数，因此会影响结果数组的长度：</span></span><br><span class="line"><span class="comment">// - 如果限制 n 大于零，则将最多应用 n-1 次该模式，该数组的长度将不大于 n，并且该数组的最后一个条目将包含除最后一个匹配的定界符之外的所有输入;</span></span><br><span class="line"><span class="comment">// - 如果 n 为非正数，则该模式将被尽可能多地应用，并且数组可以具有任何长度；</span></span><br><span class="line"><span class="comment">// - 如果 n 为零，则该模式将被尽可能多地应用，该数组可以具有任何长度，并且尾随的空字符串将被丢弃</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// Regex    Limit   Result</span></span><br><span class="line"><span class="comment">// :    2       &#123;@code &#123; "boo", "and:foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :    5    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :    -2    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    5    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    -2    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o    0    &#123;@code &#123; "b", "", ":and:f" &#125;&#125;</span></span><br><span class="line">String[] split(String regex);   <span class="comment">// 相当于 limit=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 替换 replace ************************************</span></span><br><span class="line"><span class="comment">// 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的第一个子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的所有子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>;   </span><br><span class="line"><span class="comment">// 用指定的文字替换序列替换该字符串中与文字目标序列匹配的每个子字符串。 替换从字符串的开头到结尾进行，例如，在字符串“ aaa”中将“ aa”替换为“ b”将得到“ ba”而不是“ ab”</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//********************* 索引 index ************************************</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;            <span class="comment">// 查找 ch 字符在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>; <span class="comment">// 指定从字符串的 fromIndex 处开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;            <span class="comment">// 查找 str 字符串在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;            <span class="comment">// 查找 ch 字符在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;    <span class="comment">// 查找 str 字符串在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="comment">// 处理（罕见）带有补充字符的 indexOf 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 AbstractStringBuilder 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 StringBuffer 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 子字符串 **************************************</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span></span>; <span class="comment">// 测试此字符串的子字符串是否从指定的索引开始，并以指定的前缀开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>;               <span class="comment">// 获取从 beginIndex 位置开始到结束的子字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span>;  <span class="comment">// 获取从 beginIndex 位置开始到 endIndex-1 位置的子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 格式化字符串 ************************************</span></span><br><span class="line"><span class="comment">// 字符串的格式化内容较多，还需另外具体学习</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(String format, Object... args)</span></span>;   </span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 不常用方法 **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                         <span class="comment">// 返回指定位置的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 返回指定位置的前一个字符的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;   <span class="comment">// 返回从 beginIndex 到 endIndex-1 范围内的 Unicode code 数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span></span>; <span class="comment">// 返回从 index 开始，偏移 codePointOffset 的索引</span></span><br></pre></td></tr></table></figure><h1 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h1><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 不同于 <code>String</code> 的地方在于：它们在修改时会改变对象自身，每次结果都会对他们对象的本身进行操作；而不是像 string 那样生成新的对象，再改变对象引用。</p><p>这三者的区别如下：</p><div class="table-container"><table><thead><tr><th>类型</th><th>可变性</th><th>线程安全性</th></tr></thead><tbody><tr><td>String</td><td>字符串常量, 内容不可变</td><td>线程安全, 可多线程使用</td></tr><tr><td>StringBuffer</td><td>字符串变量</td><td>线程安全, 可多线程使用</td></tr><tr><td>StringBuilder</td><td>字符串变量</td><td>非线程安全, 单线程使用，单线程效率优于 StringBuffer</td></tr></tbody></table></div><p>大多数方法和 String 都相同，需要重点关注的如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append：将任何数据类型的字符串表示，拼接到调用的对象的末尾</span></span><br><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">s.append(<span class="string">" World"</span>);</span><br><span class="line">s.append(<span class="string">" !"</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// 输出字符串 “Hello World !”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(int index，String str); 将一个字符串插入到另一个字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse(); 颠倒 StringBuffer 对象中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete(int startIndex,int endIndex); 调用对象中删除一串字符</span></span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>体会：写之前我是怎么也没想到这个点的内容量如此之多，很多细节知识都需要好好体会。所以说，在平时的学习过程中真的不能小瞧任何一个知识点，要保持敢钻的态度！</p><ul><li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li><li>『 jdk1.8.0_231 源码 』</li><li>『 <a href="https://blog.csdn.net/xialei199023/article/details/63251366" target="_blank" rel="noopener">重新认识Java——字符串（String）</a> 』</li><li>『 <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">深入理解Java中的String</a> 』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-String/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;字符串&lt;/strong&gt;（String）是由零个或多个字符（char）组成的有序序列。学过 C/C++ 的人会有一种固定的思维模式，凡是字符串都是以 &lt;code&gt;\0&lt;/code&gt; 结束。但是 java 却不同，要知道 java 里始终秉承的一句话 『&lt;strong&gt;everything is object&lt;/strong&gt;』，字符串也不例外，它也被作为 String 类型的对象处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内核设计 | （1）从开机到 main 函数执行</title>
    <link href="http://www.thebetterkong.cn/2020/06/29/Linux/LinuxKernelDesign-1.PowerOnToMainFunction/"/>
    <id>http://www.thebetterkong.cn/2020/06/29/Linux/LinuxKernelDesign-1.PowerOnToMainFunction/</id>
    <published>2020-06-29T08:04:25.000Z</published>
    <updated>2020-08-14T09:32:26.816Z</updated>
    
    <content type="html"><![CDATA[<p>这里提到的 linux 版本是 0.11，在当时，操作系统都是存在软盘里的，而 CPU 的逻辑电路被设计为只能运行内存中的程序。电路刚通电时，内存（RAM）里什么都没有，那么计算机是怎样将操作系统运行起来的呢？</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里约定的计算机是基于 IA-32 系列 CPU，安装了标准单色显示器、标准键盘、一个软盘、一块硬盘、16 MB 内存，在内存中开辟了 2 MB 内存作为虚拟盘，并在 BIOS 中设置软驱为启动设备。    </p><p>为什么选 Linux 0.11 内核？</p><ul><li>Linux 0.11 内核代码虽然只有约两万行，但却实实在在的撑起了一个现代OS，更便于初学者学习理解；</li><li>它是 Linux 其他后续版本的鼻祖，这样我们能更容易的看清设计者最初的、最根本的设计意图和设计指导思想；</li></ul><p>系列参考资料：</p><ul><li>《Linux 内核设计的艺术-图解 Linux 操作系统架构设计与实现原理（第 2 版）》</li><li>《IA-32-3》</li><li>《Linux 内核完全注释》- 内核版本0.11 - 赵炯</li></ul><p>说明：该系列是本人结合国科大相关课程总结的笔记心得，按书籍教程主要分为三大部分：</p><ol><li>分析从开机加电到 OS 启动完成并进入怠速状态的整个过程：<ul><li>开机加电启动 BIOS，通过 BIOS 加载操作系统程序，对主机的初始化，打开保护模式和分页，调用 main 函数，创建进程 0、进程 1、进程 2 以及 shell 进程，并且具备用文件的形式与外设交互。</li></ul></li><li>OS 进入系统怠速后，在执行用户程序的过程中，OS 和用户进程的实际运行过程和状态：<ul><li>利用几个设计好的简单的又具有代表性的应用程序，以其执行作为引导，详细讲解安装文件系统、文件操作、用户进程与内存管理、多个进程对文件的操作以及进程间的通信。</li></ul></li><li>整个 Linux 的设计指导思想，从微观到宏观的回归分析：<ul><li>重点部分：详细阐述主奴机制以及实现主奴机制的三项关键技术（保护和分页、特权级、中断），分析保障主奴机制实现的决定性因素—先机，详细讲解缓冲区、共享页面、信号、管道的设计指导思想。（作者尝试从操作系统设计者的视角讲解操作系统的设计指导思想。希望帮助读者用体系的思想理解、把握、驾驭整个操作系统以及背后的设计思想和设计意图）</li></ul></li></ol><h1 id="BIOS-启动"><a href="#BIOS-启动" class="headerlink" title="BIOS 启动"></a>BIOS 启动</h1><p>前面说到 CPU 只能执行内存里的程序，而刚通电时，计算机内存为空，OS 处在软盘。那么，自然就需要由某个部分将 OS 加载到内存，而完成这项工作的就是 <strong>BIOS</strong>。    </p><p>问题就来了，BIOS 自身也是一段程序，那它最开始又是如何执行的呢？      </p><p>这一过程得益于硬件 CPU 强制执行 BIOS。CPU 都被设计为<strong>加电即进入 16 位实模式状态运行</strong>，其硬件逻辑在加电瞬间就会设置 CS（<code>0xF000</code>）和 IP（<code>0xFFF0</code>），这样 CS:IP 也就指向 <strong><code>0xFFFF0</code></strong> 这个地址，而这里就处在 BIOS 中，是 <strong>BIOS 程序的入口地址</strong>。    </p><div class="note warning">            <ul><li>CPU 将要执行的指令的内存地址是由 IP（偏移）和 CS（段基址）组合来指定。实模式下该地址为绝对地址，指令指针为 16 位；保护模式下为线性地址，指令指针为 32 位，即 EIP。    </li><li>BIOS 是固化在计算机主板上一块很小的 ROM 芯片里的程序。不同主板会有所不同，这里的 BIOS 是 8KB，所占地址段为 <code>0xFE000 ~ 0xFFFFF</code>。</li></ul>          </div><h1 id="BIOS-执行"><a href="#BIOS-执行" class="headerlink" title="BIOS 执行"></a>BIOS 执行</h1><p>BIOS 启动后，开始执行一系列 BIOS 代码，完成自检等操作。检测显卡、内存等，并在屏幕上显示这些机器系统数据（显卡信息、内存信息等）。而这个过程需要重点说的就是：<strong>BIOS 在内存里建立中断向量表和中断服务程序</strong>。     </p><p>具体来说就是：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Mem-BIOS.png" alt="Mem-BIOS"></p><ul><li>在 <code>0x00000 ~ 0x003FF</code> 这 1 KB 的内存空间里构建<strong>中断向量表</strong>；<ul><li>一共有 256 个中断向量，每个占 4 B（2 B 为 CS 的值，2 B 为 IP 的值）；</li></ul></li><li>在紧接着的 <code>0x00400 ~ 0x004FF</code> 这 256 B 的内存空间里构建 <strong>BIOS 数据区</strong>（存放机器系统数据）；</li><li>在接着大约 57 KB 之后的位置 <code>0x0E05B</code> 处加载了 8 KB 左右的与中断向量表相对应的<strong>中断服务程序</strong>；</li></ul><p>在上述自检过程完成后，计算机硬件（体系结构的设计）和 BIOS 一同产生一个 <strong><code>int 0x19</code></strong> 中断。CPU 收到此中断后，查找中断向量表，并找到 <code>int 0x19 中断向量</code>。这个中断向量就将 CPU 指向 <strong><code>0x0E6F2</code></strong> 这个地址执行（<code>int 0x19</code> 对应的中断服务程序的入口地址）。这个中断服务程序是 BIOS 事先设计好的（代码固定，与 OS 无关），它的工作就是：<strong>把软盘第一扇区中的程序 <code>bootsect.s</code>（512 B，因此两个扇区为 1 KB）加载到内存指定位置（<code>0x07C00</code>）</strong>。    </p><div class="note warning">            <p>这个过程就需要 OS 设计者和 BIOS 的设计者完成一种两头约定：   </p><ul><li>操作系统：必须把最开始执行的程序 “定位” 在启动扇区（软盘中的 0 盘面 0 磁道 1 扇区）；   </li><li>BIOS：“约定” 接到启动操作系统的命令，就 “定位识别” 只从启动扇区把代码加载到 <code>0x7C00</code>（BOOTSEG）这个位置；</li></ul>          </div><h1 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h1><p>在实模式下，指令指针 CS 和 IP 都是 16 位的，它们组合的内存寻址最大范围为 1 MB（20 位）。而 <strong>bootsect.s 首先的工作就是对这 1 MB 的内存空间进行规划</strong>，来确保后续代码的加载与已加载的代码互不干扰，并且都有足够大的内存空间可用；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemPlanning-bootsect.png" alt="MemPlanning-bootsect"></p><ul><li>bootsect.s 的开头会设定一段代码来设置相应的内存位置：<ul><li>将要加载的 setup 程序的扇区数（<code>SETUPLEN</code>）以及它要被加载到的位置（<code>SETUPSEG</code>）；</li><li>启动扇区 bootsect 被 BIOS 重新加载的位置（<code>BOOTSEG</code>）及将要移动到的新位置（<code>INITSEG</code>）；</li><li>内核（kernel）被加载的位置（<code>SYSSEG</code>）、内核的末尾位置（<code>ENDSEG</code>）；</li><li>根文件系统设备号（<code>BOOT_DEV</code>）；    </li></ul></li></ul><p>接着，booesect 按之前的内存规划将自己全部（512 B）的内容从 <code>0x07C00</code>（<code>BOOTSEG</code>） <strong>拷贝到新的内存位置</strong> <code>0x90000</code>（<code>INITSEG</code>）。    </p><ul><li>由于之前说过的 OS 设计和 BIOS 设计的约定，才会在开始时 bootsect 被迫被加载到 <code>0x07C00</code> 的位置。现在将自身拷贝的 <code>0x90000</code> 处，则说明 OS 已经开始根据自身需要安排内存了；</li></ul><p>拷贝完成后，但是 CPU 的 CS 还在原先的 <code>0x07C0</code>（BOOTSEG）处，于是需要<strong>修改 CS</strong> 值为 <code>0x9000</code>（INITSEG），并<strong>修改 IP</strong> 偏移值至下一条指令。这样，使程序在新的地方接着原先的过程执行。此时，代码整体位置改变，代码中的各个段也会随之改变，所以还需要<strong>设置 DS、ES、SS、SP 的值</strong>。这也是个分水岭，至此，程序可以开始执行更为复杂的数据运算类指令。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/JumpAndSSSPDSES-bootsect.png" alt="JumpAndSSSPDSES-bootsect">   </p><p>接下来，bootsect 还需要负责<strong>将 os 剩余的代码（<code>setup.s</code> 和 <code>system 模块</code>）拷贝进内存中</strong>。整个拷贝过程分两次进行：</p><ul><li>拷贝 <code>setup.s</code>：<ul><li><strong>传参</strong>：事先将指定的扇区、加载的内存位置等信息传递给服务程序；</li><li>参数传递完毕后，<strong>执行 <code>int 0x13</code> 指令</strong>，产生 <code>int 0x13</code> 中断，通过中断向量表找到对应的中断服务程序（<code>0x0E6FE</code>），将软盘<strong>第二个扇区开始的 4 个扇区（setup.s，2 KB）加载至内存的 SETUPSEG（0x90200）处</strong>，紧挨着重新拷贝后的 bootset.s；（注意：它还不足以影响到栈的内存空间）；</li></ul></li><li>拷贝 <code>system 模块</code>（包括 head.s 和 main 函数开始的 os 内核程序）：<ul><li>bootsect 同样借助 BIOS 的 <code>int 0x13</code> 中断，<strong>调用 <code>read_it</code> 子程序</strong>，将软盘第六扇区开始的 <strong>240 个扇区</strong>的 sysytem 模块加载至内存的 <strong>SYSSEG（0x10000）处</strong>往后的 <strong>120 KB 空间</strong>中；</li><li>整个加载过程时间较长，所以也会有一段用汇编编写的程序，使显示器显示 “Loading system…”，也涉及到其他 BIOS 中断；</li></ul></li></ul><div class="note warning">            <ul><li><strong>system 模块</strong>是整个 OS 的核心部分，它由两部分构成：head.s 和 main 函数。</li><li><strong>head.s</strong> 同之前加载的 bootsect.s 和 setup.s 一样，是由汇编代码生成的程序，它处在 system 的开头位置，在内存中占有 25 KB + 184 B 的空间；</li><li><strong>main 函数</strong>紧接着 head.s 存在，它是由 c 语言编写的内核程序，可以说它才是真正的操作系统，在它之前执行的 bootsect.s、setup.s 和 head.s 都是为它做准备的；</li><li>这种特殊性，也让 syetem 模块和 bootsect.s、setup.s 的加载方式不同。<strong>大致的过程</strong>是：先将 head.s 汇编成目标代码，将用 c 语言编写的内核程序编译成目标代码，然后再将它们链接成 system 模块。</li></ul>          </div><p>至此，<mark>整个 OS 的代码都已被加载进内存</mark>。最后，由 bootsect 确认根设备号。根据开始处假设的计算机组成，这里经过一系列检测后，会确认计算机中实际安装的软盘驱动器为根设备，并将此信息写入机器系统数据。    </p><p>bootsect.s 的工作已全部完成。</p><h1 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h1><p>在 bootsect.s 完成它所有的任务后，会<strong>执行 <code>jmpi 0,SETUPSEG</code> 跳转</strong>至 <code>0x90200</code> 处（setup.s 所在的位置），也即 CS:IP 指向 setup 程序的第一条指令，<strong>setup.s 开始执行</strong>。</p><p>首先，setup.s 会利用 BIOS 提供的中断服务从设备上<strong>提取内核运行所需的机器系统数据 510 B</strong>（注意这里加载的不是 BIOS 数据区里的），并将这些数据加载到内存的 <code>0x90000 ~ 0x901FC</code> 位置。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/LoadMachineSystemData-setup.png" alt="LoadMachineSystemData-setup"></p><ul><li>注意：加载的这部分机器系统数据是覆盖了原先已经执行完的 512 B 的 bootsect.s，只有 2 B 未被覆盖，这样很好的利用了内存空间，使内存利用率更高；</li></ul><p>至此，<mark>整个操作系统内核程序所需的加载工作都已完成，通过内存中的这些代码数据，将开始实现从实模式到保护模式的转变</mark>。</p><p>之前，我们所有用到的中断服务都是由 BIOS 提供，而之后 OS 会接管整个系统，它自身也会提供一套的中断服务系统。为了完全这个转变，不让接下来的工作出错，此时就得<strong>先关中断（cli）</strong>。即：<strong>将 CPU 的标志寄存器（EFLAGS）中的中断允许标志（IF）置 0</strong>；</p><div class="note warning">            <ul><li>关中断（cli）和开中断（sti）它们在 OS 里总是成对出现的，目的就是为了防止中断在某个过程中介入；   </li><li>此处，即将进行的是实模式下中断向量表和保护模式下中断描述符表（IDT）的交接。如果在此期间，用户不小心碰到键盘等引入了中断，就会导致不可预估的后果；</li></ul>          </div><p>接下来，setup 程序会<strong>将位于 <code>0x10000</code> 的内核程序复制至内存的起始地址 <code>0x00000</code> 处</strong>（由 DS 和 ES 配合完成）。</p><ul><li>这个过程也就意味着，原先 BIOS 提供的中断向量表、BIOS 数据区以及相应的中断服务程序都完全被覆盖，旧的中断体系已经失效，系统准备向 32 位的保护模式转变；</li></ul><p>然后，setup 程序利用自身提供的数据信息<strong>对中断描述符表寄存器（IDTR）和全局描述符表寄存器（GDTR）进行初始化设置</strong>，进而完成<strong>中断描述符比表（IDT）和全局描述符表（GDT）的初始化</strong>；   </p><div class="note ">            <ul><li><strong>GDT（全局描述符表）</strong>：是一个存放段寄存器内容（段描述符）的数组，用来配合程序进行保护模式下的段寻址。在 OS 中进程切换具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务（task）局部描述符表（LDT）地址和任务状态段（TSS）地址，完成进程中各段的寻址、现场保护与现场恢复；   </li><li><strong>GDTR（GDT 基址寄存器）</strong>：GDT 可以存放在内存中任意位置，而 GDTR 的内容就是标识 GDT 的入口地址；</li><li><strong>IDT（中断描述符表）</strong>：保存保护模式下所有中断服务程序的入口地址；</li><li><strong>IDTR（IDT 基址寄存器）</strong>：保存 IDT 起始地址；</li></ul>          </div><ul><li>这个过程可以理解为：内核设计时，已经将两个表（包括所需的初始数据）写好，随着 OS 代码一起已经被加载到了内存，之后程序通过 <code>lidt</code> 和 <code>lgdt</code> 指令将两个专用寄存器指向这两个表（即 idt_48 和 gdt_48 对应的标号处）即可；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetGDTRAndIDTR.png" alt="SetGDTRAndIDTR"><ul><li>由图可以看到：IDTR 指向了 <code>0x00000</code> 位置（IDT 基址），此时出于关中断状态，IDT 还是一张空表；</li><li>GDTR 指向了 <code>0x90200+</code> 位置（现在创建的 GDT 基址），此时内核还未运行没有进程，GDT 的内容也就如图所示，其余项全为空；</li></ul></li></ul><p>接下来的工作就是：<strong>打开 A20</strong>，<strong>这也就意味着 CPU 可以进行 32 位寻址，最大寻址空间为 4 GB</strong>。下图显示了此时内存寻址空间的变化（注意区别）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemAddressingChange.png" alt="MemAddressingChange"></p><ul><li>此时，物理地址空间虽然受限于 16 MB，但是其线性地址空间已经变成了 4 GB；</li><li>实模式下，CPU 寻址范围为 <code>0 ~ 0xFFFFF</code>，共 1 MB，需要 0 ~ 19 号（20 根）地址线。进入保护模式，使用 32 位寻址，自然也就需要打开剩余的 20 ~ 31 号地址线；</li><li>实模式下，CS 和 IP 的最大值都为 <code>0xFFFF</code>，这两者组合而成的最大绝对地址为 <code>0x10FFEF</code>（16*CS+IP），而此时 CPU 最大寻址为 <code>0xFFFFF</code>。对于超出的这 16 KB 地址，CPU 会将其 “回滚” 至内存起始处寻址。而启用 A20 后，相当于关闭了 CPU 在实模式下的 “回滚” 机制，也就正好可以利用这个特点验证 A20 地址线是否已经打开；</li></ul><p>为了建立保护模式下的中断机制，setup 开始<strong>对可编程中断控制器 8259A 进行重新编程</strong>；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Pragram8259A.png" alt="Pragram8259A">    </p><p>之后，setup 还需要<strong>将 CR0（0 号 32 位控制寄存器，存放系统控制标志）寄存器的第 0 位（PE）置 1</strong>，即开启 CPU 的工作方式为保护模式；此后，寻址方式变化如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/ChangeToAddressing.png" alt="ChangeToAddressing">    </p><p>至此，setup 的工作全部完成，它还有最后一行<strong>代码 <code>jmpi 0,8</code>，跳转至 head 程序起始地址开始执行</strong>；</p><ul><li>关于 <code>0,8</code>，对应到二进制也就为：<code>0000,1000</code>：<ul><li>最后两位 <code>00</code>：表示内核特权级，对应的 <code>11</code> 就是用户特权级，其他形式无效；</li><li>第三位 <code>0</code>：表示 GDT，如果为 <code>1</code> 则表示 LDT；</li><li>再接下来的 <code>1</code>：表示所选的表（GDT）的 1 项（GDT 表项从 0 开始）；</li><li>由这些信息就可以推算出：<strong>内核代码段（0x08）、内核数据段（0x10）、用户代码段（0x17）、用户数据段（0x0F）</strong>；</li></ul></li><li>再对整个的跳转指令寻址进行解读：<ul><li><code>jmpi 0,8</code>：它是处在内核级，会选择 GDT 的 1 项（代码段），这一项的解读如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/GDT1item.png" alt="GDT1item"></li><li>由此确定段基址为 <code>0x00000000</code>，偏移为 0，也即 head 程序的起始位置处；</li></ul></li></ul><h1 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h1><p>经过前面一连串的准备工作，这里终于进入到了 system 模块，但是这并不意味着就进入到了 main 函数的执行。前面加载时说过，在 system 模块的开头还有一段叫做 head.s 的代码。此时的 system 在内存的分布情况如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SystemInMem.png" alt="SystemInMem">      </p><p>head 程序的除了<strong>做一些调用 main 函数的准备工作</strong>之外，还会<strong>用程序自身的代码在程序自身所在的内存空间创建内核分页机制</strong>，即在 <code>0x000000</code> 的位置创建页目录表、页表、缓冲区、GDT、IDT，并将 head 程序已经执行过的代码所占内存空间覆盖（自身边执行，边自我覆盖）。具体过程如下：</p><p><strong>标号 <code>_pg_dir</code></strong> 标识内核分页机制完成后的内核起始位置，即物理内存起始位置 <code>0x000000</code>；</p><p>前面的 <code>jmpi 0,8</code>，已经使得 CS 和 GDT 第二项关联（CS 不再是代码段基址而是代码段选择符），并且使代码段基址指向 <code>0x000000</code>。相应的，也需要<strong>修改 DS、ES、FS 和 GS 的值为 0x10</strong>（内核数据段）；具体内容如下图：<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS-head.png" alt="DSESFSGS-head"></p><p><strong>SS</strong> 也需要变为栈段选择符（也是 <code>0x10</code>），栈顶指针也由 16 位的 SP 变为 32 位的 <strong>ESP</strong>（并且起始位置大概在 <code>0x1E25C</code>）<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SSESP-head.png" alt="SSESP-head">   </p><p><strong>设置 IDT，搭建中断机制的整体框架</strong>，具体内容如下：</p><ul><li>IDT 有 256 个表项，每个表项占 64 位，因此其大小为 2 KB。每个表项（中断描述符）结构如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/InterruptDescriptor.png" alt="InterruptDescriptor"></li><li>设置相关的 IDT 寄存器：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/IDT-head.png" alt="IDT-head"></li><li>让所有的中断描述符默认指向 ignore_int 这个位置（将来 main 函数再让中断描述符对应到具体的中断服务程序），即此时所有的中断服务程序都是指向同一段只显示一行提示信息就返回的服务程序（这样，既可以避免无意中覆盖代码数据，也可给开发过程中的误操提供提示）；</li></ul><p><strong>废除旧的 GDT，并在内核新的位置重新创建 GDT</strong>：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/RebuildGDT-head.png" alt="RebuildGDT-head"></p><ul><li>重新设置一方面是设置新的位置，另一方面是修改段限长，这样做的目的也明显：旧 GDT 由 setup.s 设置，处在 <code>0x90200+</code> 的位置，而现在它已经执行完毕，未来它所处的内存位置必然会被替换为别的用途（缓冲区），这样只好重新将它放在 head.s 已经执行完的位置最好，物尽其用。</li></ul><p>段限长被修改了，那么相应的 <strong>DS、ES、FS、GS 及 SS</strong> 的段选择符也需要重新设置（再来一遍 <code>0x10</code>，重新加载 GDT 相应表项，这只是在原有基础上将<strong>段限长扩大为 16 MB</strong>，其他内容并未发生改变）；ESP 不需要；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS2-head.png" alt="DSESFSGS2-head">    </p><p><strong>检验 A20 地址线是否打开</strong>，检验方法就是之前提及的 “回滚法”，具体如下：</p><ul><li>通过在内存 <code>0x000000</code> 位置写入一个数据，然后比较此处和 1 MB（<code>0x100000</code>，已超过实模式寻址范围）处数据是否一致；</li></ul><p>head 程序如果检测到数学协处理器，则将其设置为保护模式工作状态；</p><ul><li>486 处理器以前，为弥补 CPU 浮点运算不足设置的外置可选芯片。486 处理器之后，CPU 就都基本内置了协处理器，也就不需要此步；</li></ul><p>接下来，就是 head.s <strong>为调用 main 函数做最后的准备工作</strong>：</p><ul><li><strong>将 envp、argv、argc 压栈：将 L6 标号（也就是 main 函数异常退出后返回的执行位置）和 main 函数入口地址压栈</strong>。此时，栈顶为 main 函数的入口地址，这样在 head.s 执行完毕后，就可以直接通过 ret 指令执行 main 函数；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PushForMain.png" alt="PushForMain"></li><li>压栈完成后，head.s 跳转至 <code>setup_paging:</code> 执行，开始<strong>创建分页机制</strong>（下面创建的 4 个页表是内核专属页表，将来每个用户进程也会有它们自己的专属页表）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetPageTable.png" alt="SetPageTable"></li><li>页表设置完毕，但分页机制还没完全建立，还需要<strong>设置页目录表基址寄存器 CR3</strong>（3 号 32 位控制寄存器，高 20 位存放页目录表基址，当 CR0 的 PG=1 时，CPU 使用 CR3 指向的页目录表和页表进行虚拟地址到物理地址的映射）<strong>使之指向页目录表</strong>，再将 <strong>CR0 寄存器的最高位（PG</strong>，分页机制控制位，它必须在 PE=1 的保护模式下才能开启）<strong>置 1</strong>。此时分页机制完成后，总体状态如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PageTableStatus.png" alt="PageTableStatus"><ul><li>注意：标号 pg_dir 标识的 <code>0x0000</code> 这个位置是内核通过分页机制能够实现线性地址等于物理地址的唯一起始位置；</li></ul></li><li>此时的内存分布情况如下（注意 head.s 的大小和内存分布的情况）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemDistribution-head.png" alt="MemDistribution-head"></li></ul><p>现在，就是 head.s 的最后一步，<strong>通过 ret 指令，将压入栈的 main 函数的执行入口地址弹出给 EIP</strong>，跳入 main 函数开始执行；</p><ul><li>这里需要说明一下，OS 的 main 函数和其他普通函数的调用过程不太一样；</li><li>通常函数：都是通过 call 指令调用，它会将 EIP 的值自动压栈，保护返回现场，然后执行被调函数的程序。等到执行被调函数的 ret 指令时，自动出栈给 EIP 并还原现场，继续执行 call 的下一条执行；</li><li>而操作系统则不同，它是用 ret 实现的调用操作系统的 main 函数。事先由 OS 的设计者手工编写代码压栈（压栈的 EIP 值为 main 函数的入口地址）和跳转，来模仿 call 的全部动作，进而去调用 <code>setup_paging</code> 函数。然后，当 <code>setup_paging</code> 函数执行到 ret 时，从栈中将 main 函数的入口地址 _main 弹出给 EIP，构成 CS:EIP，这也就等价于 CPU 开始执行 main 函数程序；</li></ul><p>之后，操作系统 main 函数开始执行，但是注意：此时仍然是关中断的状态！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里提到的 linux 版本是 0.11，在当时，操作系统都是存在软盘里的，而 CPU 的逻辑电路被设计为只能运行内存中的程序。电路刚通电时，内存（RAM）里什么都没有，那么计算机是怎样将操作系统运行起来的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.thebetterkong.cn/categories/Linux/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux Kernel" scheme="http://www.thebetterkong.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>java 数据结构之线性表</title>
    <link href="http://www.thebetterkong.cn/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/"/>
    <id>http://www.thebetterkong.cn/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/</id>
    <published>2020-06-27T06:23:33.000Z</published>
    <updated>2020-08-14T09:28:07.995Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/header.png" width="100%" alt="header.png" /> </div>  <p><strong>线性表</strong>（Linear List）是最简单也是最常用的一种数据结构。简言之，线性表是 n 个数据元素的有限序列。每个数据元素可以使一个数或一个符号，也可以是一页书，甚至其他更加复杂的信息。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>依据数据元素之间的关系，线性表主要有两种实现方式：<strong>顺序存储</strong>、<strong>链式存储</strong></p><ul><li>顺序存储结构：是依靠<strong>元素在存储器中的相对位置</strong>来表示数据元素之间的逻辑关系；</li><li>链式存储结构：是<strong>依靠指针</strong>（Java 为引用）来表现数据元素之间的逻辑关系；</li></ul><p><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/TwoStructure.png" alt="TwoStructure"></p><p>接着，我们来看一下线性表在 java 集合里的对应部分：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinearListInJavaSet.png" alt="LinearListInJavaSet">   </p><p>图中阴影部分就是和线性表相关的接口和类，其中红色标明的是重点。</p><h1 id="顺序表（ArrayList）"><a href="#顺序表（ArrayList）" class="headerlink" title="顺序表（ArrayList）"></a>顺序表（ArrayList）</h1><p>顺序表中的<strong>数据元素存储是连续的</strong>，<strong>内存划分的区域也是连续的</strong>。其存储结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/SequenceTableExample.png" alt="SequenceTableExample">      </p><p>而顺序表对应到 java 中的实现就是：<strong>ArrayList 类</strong></p><ul><li>它是利用<strong>大小可变的数组</strong>来实现的 <strong>List 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li><li>此类<strong>与 Vector 大致等效</strong>，但它是<strong>不同步</strong>的；</li><li><code>size</code>、<code>isEmpty</code>、<code>get</code>、<code>set</code>、<code>iterator</code> 和 <code>listIterator</code> 操作在恒定时间内运行。加法运算以固定的固定时间运行，即添加 n 个元素需要 $O(n)$ 时间。所有其他操作均以线性时间运行（大致而言）。与 LinkedList 实现相比，常数因子较低；</li><li>每个 ArrayList 实例都有一个<strong>容量</strong>；<ul><li>容量:是用于在列表中存储元素的数组的大小,它总是至少与列表大小一样大；</li><li>将元素添加到 ArrayList 时，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定增长策略的详细信息；</li><li>应用程序可以使用 <code>ensureCapacity</code> 操作在添加大量元素之前增加 ArrayList 实例的容量。这可以减少增量重新分配的数量；</li></ul></li><li>此类是 Java Collections Framework 的成员；</li><li><strong>擅长随机访问</strong>，查找速度快，添加删除操作慢；</li></ul><p>ArrayList 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ArrayList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;...&#125;     <span class="comment">// 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;...&#125;                        <span class="comment">// 构造一个初始容量为 10 的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;   <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>;              <span class="comment">// 将此 ArrayList 实例的容量调整为列表的当前大小。应用程序可以使用此操作来最小化 ArrayList 实例的存储。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>;   <span class="comment">// 手动增加此 ArrayList 实例的容量，以确保它至少可以容纳最小容量参数指定的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回动态数组里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;              <span class="comment">// 动态数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 动态数组是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 设定指定位置的元素值，执行完毕会返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向动态数组的末尾添加元素（实现时，先用 ensureCapacityInternal 函数扩容，再添加）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向动态数组的指定位置添加元素，index 位置元素和其后面所有元素后移一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 将指定集合中的所有元素按指定集合的Iterator返回的顺序追加到此列表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此列表</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 删除指定位置的元素，并且该位置后面的元素全部左移一个位置，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 删除首次出现的对象 o，如果不存在，则不进行任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除指定集合中包含的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除所有未包含在指定集合中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 清空动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回动态数组里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回动态数组里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;                 <span class="comment">// 返回动态数组实例的拷贝，数组里的元素没有被复制</span></span><br><span class="line"></span><br><span class="line">Object[] toArray();             <span class="comment">// 分配一个新数组来（按原顺序）存储该动态数组里的所有元素，调用者可以随意修改返回的数组</span></span><br><span class="line">T[] toArray(T[] a);             <span class="comment">// 转化到指定数组，但是该数组必须足够大，否则会分配一个新的数组</span></span><br></pre></td></tr></table></figure></p><h1 id="链表（LinkedList）"><a href="#链表（LinkedList）" class="headerlink" title="链表（LinkedList）"></a>链表（LinkedList）</h1><p>链表的特点是用一组<strong>任意的存储单元存储线性表的数据元素</strong>（这组存储单元可以是连续的，也可以不连续）。链表的结点通常包含：<strong>数据域、指针域</strong>，数据域用来存储数据信息，指针域则负责将这些结点串接成一个链式结构。   </p><p>链表又通常有三种表示结构，如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinkedListExample.png" alt="LinkedListExample">    </p><p>链表对应到 java 里的实现就是：<strong>LinkedList 类</strong></p><ul><li>它是利用<strong>双链表</strong>实现的 <strong>List 和 Deque 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li><li>所有操作都执行双链表所期望的操作：索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的位置为准；</li><li>此实现<strong>未同步</strong>；</li></ul><p>LinkedList 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;       <span class="comment">// 构造一个空链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;  <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回链表里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 链表是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回链表里指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;                   <span class="comment">// 返回链表里第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;                    <span class="comment">// 返回链表里最后一个元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 用指定元素取代链表里指定位置的元素，并返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;                <span class="comment">// 移除并返回链表第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;                 <span class="comment">// 移除并返回链表最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 移除链表里指定元素首次出现的结点，如果没有，链表不变</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 移除并返回指定位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;             <span class="comment">// 向链表开头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;              <span class="comment">// 向链表末尾插入指定元素，等效于 add 方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向链表指定位置插入指定元素，该位置和后续元素会被后移</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 移除链表里所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回链表里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回链表里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 下面的函数是用来实现栈和队列时所用；</span></span><br><span class="line"><span class="comment">* 这里可以先不关注，在后面讲解栈和队列时再回来查看</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue operations.</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 移除并返回队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 移除并返回队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列末尾添加指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;        <span class="comment">// 向双端队列头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;         <span class="comment">// 向双端队列尾插入指定元素</span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;                  <span class="comment">// 返回但不删除双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;                   <span class="comment">// 返回但不删除双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;                  <span class="comment">// 移除并返回双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;                   <span class="comment">// 移除并返回双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack operations</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;                 <span class="comment">// 用链表实现，元素入栈</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>;                        <span class="comment">// 用链表实现，元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure></p><h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p>栈是一种特殊（操作受限）的线性表。它仅允许在线性表的尾部进行添加和删除操作，这一端被称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。向一个栈添加新元素叫<strong>压栈</strong>，删除元素又称为<strong>出栈</strong>。<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/StackExample.png" alt="StackExample">    </p><p>栈对应到 java 里的实现就是：<strong>Stack 类</strong></p><ul><li>Stack 类表示对象的后进先出（<strong>LIFO</strong>）堆栈；</li><li>它通过五个操作<strong>扩展了 Vector 类</strong>，这些操作允许将 Vector 视为 Stack：<ul><li>提供了通常的 push 和 pop 操作；</li><li>peek 堆栈顶部元素的方法；</li><li>用于测试堆栈是否为空的方法；</li><li>用于在堆栈中搜索元素并发现其距顶部距离的方法；</li></ul></li><li>首次创建堆栈时，它不包含任何项目；</li><li><code>{@link Deque}</code> 接口及其实现提供了一组更完整和一致的 LIFO 堆栈操作，应优先使用此类。 例如：<code>{@code Deque stack = new ArrayDeque（）;}</code></li></ul><p>Stack 常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Stack</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造一个空栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span></span>;          <span class="comment">// 向栈顶压入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span>;    <span class="comment">// 将栈顶元素弹出并返回该对象，栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span></span>;   <span class="comment">// 返回栈顶元素（不删除），栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>;         <span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>;   <span class="comment">// 返回该元素距离栈顶的位置（栈顶元素返回 1）；如果栈里不存在该元素返回 -1</span></span><br></pre></td></tr></table></figure></p><h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列也是一种操作受限制的线性表。只能从<strong>队头</strong>取出（删除）元素，从<strong>队尾</strong>添加元素，其结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueExample.png" alt="QueueExample"></p><p>它在 java 中比较特殊，只是一个接口：<strong>Queue</strong></p><ul><li>它只是一个<strong>接口</strong>，代表了我们通常理解的 <strong>FIFO 队列</strong>（通常利用 LinkedList 实现），但这不是绝对的，例外情况包括：<strong>优先级队列</strong>（根据提供的比较器对元素进行排序或元素的自然排序）和 <strong>LIFO 队列</strong>（或堆栈）；<ul><li>无论使用哪种顺序，队列的开头都是该元素，可以通过调用 <code>remove()</code> 或 <code>poll()</code> 来删除该元素。在 FIFO 队列中，所有新元素都插入队列的尾部。其他种类的队列可能使用不同的放置规则；</li><li>每个 Queue 实现都必须指定其排序属性；</li></ul></li><li>Queue 实现<strong>通常不允许插入 <code>null</code> 元素</strong>，尽管某些实现（例如：<code>LinkedList</code>）不禁止插入 <code>null</code>；<ul><li>即使在允许的实现中，也不应将 <code>null</code> 插入 Queue 中，因为 <code>poll</code> 方法将 <code>null</code> 用作特殊的返回值，以指示队列不包含任何元素；</li></ul></li><li>Queue 实现通常不定义方法 <code>equals</code> 和 <code>hashCode</code> 的基于元素的版本，而是从类 <code>Object</code> 继承基于身份的版本，因为基于元素的相等性并不总是对于元素相同但排序属性不同的队列，定义明确。</li><li>该接口是 Java Collections Framework 的成员。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queue</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们通常用的 FIFO 队列是基于 LinkedList 实现的</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> LinkedList(); <span class="comment">// 相关方法的实现可见 LinkedList 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************接口声明的方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，可能抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，此方法更可取</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 返回并删除此队列的头，如果此队列为空，它将引发异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 返回并删除此队列的头，队列为空时，返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队头，如果队列为空，抛异常</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队头，如果队列为空，返回 null</span></span><br></pre></td></tr></table></figure><p>java 里 Queue 的家族还是很大的，但是很多我们也不常用，我做了个简单的整理如下（图片较乱）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueStructure.png" alt="QueueStructure"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li><li>『 jdk1.8.0_231 源码 』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/DataStructure-LinearList/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;线性表&lt;/strong&gt;（Linear List）是最简单也是最常用的一种数据结构。简言之，线性表是 n 个数据元素的有限序列。每个数据元素可以使一个数或一个符号，也可以是一页书，甚至其他更加复杂的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="DataStructure" scheme="http://www.thebetterkong.cn/tags/DataStructure/"/>
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>查找算法（详解 + java 实现）</title>
    <link href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/"/>
    <id>http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/</id>
    <published>2020-06-15T04:53:23.000Z</published>
    <updated>2020-08-14T09:29:03.045Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  <p><strong>查找</strong>（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>查找表是由同一类型的数据元素（或记录）构成的集合。由于 “集合” 中的元素之间存在着完全松散的关系，因此它是一种非常灵便的数据结构。     </p><p>针对查找表，常涉及的操作如下：</p><ul><li>查询某个 “特点的” 数据元素是否在查找表中；</li><li>检索某个 “特定的” 数据源是的各种属性；</li><li>在查找表中插入或删除一个数据元素；</li></ul><h2 id="查找算法的分类"><a href="#查找算法的分类" class="headerlink" title="查找算法的分类"></a>查找算法的分类</h2><ul><li><strong>静态查找</strong>：对查找表的操作只涉及前两种 “查找” 操作；</li><li><strong>动态查找</strong>：在查找的过程中同时会涉及插入和删除操作；</li><li><strong>有序查找</strong>：被查找的数据元素必须有序；</li><li><strong>无序查找</strong>：被查找的数据元素有序无序均可；</li></ul><p>下面是常见查找算法的分类情况：</p><ol><li>静态查找：<ul><li>顺序表的查找：顺序查找、分块查找（索引顺序查找）</li><li>有序表的查找：折半查找（二分查找）、斐波那契查找、插值查找</li></ul></li><li>动态查找：<ul><li>二叉排序树和平衡二叉树查找</li><li>B- 树和 B+ 树查找</li><li>键树查找</li></ul></li><li>哈希查找：</li></ol><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>平均查找长度</strong>（Average Search Length）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度；    </p><p>对于含有 n 个记录的表，查找成功时的平均查找长度为：   </p><script type="math/tex; mode=display">ASL\ =\ \sum^n_{i=1}\ P_iC_i</script><p>其中：</p><ul><li>$P_i$ 为查找表中第 i 个记录的概率，且 $\sum^n_{i=1}\ P_i=1$；</li><li>$C_i$ 为找到表中期关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。它随查找过程不同而不同；</li></ul><h1 id="静态线性表查找"><a href="#静态线性表查找" class="headerlink" title="静态线性表查找"></a>静态线性表查找</h1><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DataStructure.png" alt="DataStructure"> </p><p>线性表中的元素一旦有序，就可以称为有序表；</p><h2 id="顺序查找（Sequential-Search）"><a href="#顺序查找（Sequential-Search）" class="headerlink" title="顺序查找（Sequential Search）"></a>顺序查找（Sequential Search）</h2><p>也称线形查找，属于无序查找算法；</p><p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；   </p><p><strong>基本思想</strong>：从表中开头或结尾元素开始，逐个进行记录的关键字和给定值比较，若某记录的关键字和给定值比较相等，则查找成功；反之，若直至线性表的另一端，都未发现某记录的关键字和给定值比较相等，则查找失败；   </p><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找（Sequential Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：</p><ul><li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） $ASL = \frac{1}{n \times (1+2+3+…+n)} = \frac{n+1}{2}$;</li><li>查找不成功时，需要 $n+1$ 次比较;</li><li>时间复杂度为 $O(n)$</li></ul><h3 id="分块查找（Block-Search）"><a href="#分块查找（Block-Search）" class="headerlink" title="分块查找（Block Search）"></a>分块查找（Block Search）</h3><p>又称：索引顺序查找，是对顺序查找的改进；    </p><p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；  </p><p><strong>基本思想</strong>：对需要查找的顺序表进行分块，保证 “分块有序”，然后在此基础上进行查找：</p><ul><li>除待查找表本身外，新建一个 “索引表”：<ul><li><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/IndexTable.png" alt="IndexTable"> </li><li>上图中，将 18 个记录分为了 3 个子表：$(R_1,R_2,…,R_6)$、$(R_7,R_8,…,R_{12})$、$(R_{13},R_{14},…,R_{18})$；</li><li>对每个子表（块）建立一个索引项，其包括两个内容：最大关键字（子表内的最大关键字）、指针项（指示该子表的第一个记录在表中的位置）；</li><li>索引表按关键字有序，则表要么有序要么分块有序（是指：第二个子表中所有记录的关键字均大于第一个子表中的关键字，依次类推…）</li></ul></li><li>接下来的查找过程分为两部分：<ul><li>先确定待查记录所在的块（子表），这里是有序的，可以采用顺序查找或者插入查找算法；</li><li>然后在块中顺序查找；</li></ul></li></ul><details>  <summary><b>分块查找 java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分块查找算法</span></span><br><span class="line"><span class="comment">// 只是展示分块查找的思想，具体实现时，需要根据具体情况灵活运用此思想；</span></span><br><span class="line"><span class="comment">// 算法来源：参考 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexItem</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index; <span class="comment">//值比较的索引</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start; <span class="comment">//开始位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;<span class="comment">//块元素长度(非空)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexItem</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... getter and setter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引查找算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexSearch</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem indexItem = <span class="keyword">null</span>; <span class="comment">// 目标子表</span></span><br><span class="line">        <span class="comment">//建立索引规则：</span></span><br><span class="line">        <span class="comment">// 以 100 作为划分，每 100 项一组，子表存储范围分别为：</span></span><br><span class="line">        <span class="comment">//  indexItemList[0]：0-99</span></span><br><span class="line">        <span class="comment">//  indexItemList[1]：100-199</span></span><br><span class="line">        <span class="comment">//  ......</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//遍历索引表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找到索引项</span></span><br><span class="line">            <span class="keyword">if</span>(indexItemList[i].index == index) &#123;</span><br><span class="line">                indexItem = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span>(indexItem == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据索引项，在主表中查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainList[i] == key)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem item = <span class="keyword">null</span>; <span class="comment">// 用来保存查找的子表</span></span><br><span class="line">        <span class="comment">// 按索引规则，映射为索引</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历索引表，找到对应的索引项</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexItemList[i].index == index) &#123;</span><br><span class="line">                item = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引项将值插入到主表中</span></span><br><span class="line">        mainList[item.start + item.length] = key;</span><br><span class="line">        <span class="comment">// 更新索引表长度</span></span><br><span class="line">        indexItemList[i].length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示开始 ********"</span>);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 每10个数换行一次</span></span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示结束 ********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个主表，size=30</span></span><br><span class="line">        <span class="keyword">int</span>[] mainList = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">301</span>, <span class="number">302</span>, <span class="number">303</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照前面所述的索引规则，声明一个索引表</span></span><br><span class="line">        IndexItem[] indexItemList = <span class="keyword">new</span> IndexItem[]&#123;</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"******** 索引查找 ********"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始数据："</span>);</span><br><span class="line">        display(mainList);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">203</span>;</span><br><span class="line">        System.out.println(<span class="string">"元素"</span> + key + <span class="string">"列表中的位置为："</span> + indexSearch(key,indexItemList,mainList) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按规则插入数据并查找</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">106</span>;</span><br><span class="line">        System.out.println(<span class="string">"插入数据："</span> + value);</span><br><span class="line">        <span class="comment">// 如果插入成功，则查找插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (insert(value,indexItemList,mainList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"插入后的主表："</span>);</span><br><span class="line">            display(mainList);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"元素"</span> + value + <span class="string">"在列表中的位置为："</span> + indexSearch(value,indexItemList,mainList));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>       <p><strong>性能分析</strong>：</p><ul><li>平均查找长度为：$ASL_{bs}=L_b+L_w$<ul><li>$L_b$：为查找索引表确定所在快的平均查找长度；</li><li>$L_w$：为在块中查找元素的平均查找长度；</li></ul></li><li>一般，可将长度为 n 的表均匀分为 b 块，每块含有 s 个记录（$b=\lceil n/s \rceil$）；再假定表中每个记录的查找概率相等，则每块查找的概率为 $1/b$，块中每个记录的查找概率为 $1/s$；<ul><li><mark>当 $s=\sqrt{n}$ 时，$ASL_{bs}$ 取最小值 $\sqrt{n}+1$；</mark></li></ul></li><li>若用顺序查找确定所在块，则分块查找的平均长度为：<ul><li>$ASL_{bs}=L_b+L_w=\frac{1}{b}\sum^b_{j=1}j+\frac{1}{s}\sum^s_{i=1}i=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}(\frac{n}{s}+s)+1$</li></ul></li><li>若用折半查找确定所在块，则分块查找的平均长度为：<ul><li>$ASL_{bs}\approx log_2(\frac{n}{s}+1)+\frac{s}{2}$</li></ul></li></ul><h2 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h2><p>也称二分查找，属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li></ul><p><strong>基本思想</strong>：先确定待查记录所在的范围（区间），然后逐渐缩小范围，直至找到或找不到该记录为止；   </p><ul><li>维护两个指针 <code>low</code> 和 <code>high</code>，他们指向线性表两端；然后再引入一个指针 <code>mid</code>，指示区间的中间位置；</li><li>将给定值 <code>key</code> 和 <code>mid</code> 所指示元素比较：<ul><li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li><li>若 <code>key &gt; mid</code>，把 <code>low</code> 指向 <code>mid+1</code> 位置，查找区间改为 <code>[ low(mid+1), high ]</code>；</li><li>若 <code>key &lt; mid</code>，把 <code>high</code> 指向 <code>mid-1</code> 位置，查找区间改为 <code>[ low, high(mid-1) ]</code>；</li></ul></li><li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找（Binary Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BinarySearchTreeEx.png" alt="BinarySearchTreeEx"><br>假设有如图所示的一棵深度为 h 的满二叉树，用来描述一个长度 $n=2^h-1$ 的有序表的二分查找过程。其中，层次为 h 的结点有 $2^{h-1}$ 个。 并且，假设各个节点的查找概率相等（$P_i=\frac{1}{n}$）。   </p><p>则，查找成功时折半查找的平均查找长度为：   </p><script type="math/tex; mode=display">\begin{aligned}ASL_{bs}&=\sum^n_{i=1}\ P_iC_i=\frac{1}{n}\ \sum^h_{j=1}\ j \cdot 2^{j-1}\\\\&=\frac{1}{n}(\ \sum^{h-1}_{i=0}2^i+2\sum^{h-2}_{i=0}2^i+...+2^{h-1}\sum^{h-1}_{i=0}2^i\ )\\\\&=\frac{1}{n}\ [h \cdot 2^h -(2^0+2^1+...+2^{h-1})]=\frac{1}{n}\ [(h-1)2^h+1]\\\\&= \frac{1}{n}\ [\ (n+1)(log_2(n+1)-1)+1\ ]\\\\&=\frac{n+1}{n}log_2(n+1)-1\end{aligned}</script><p>当 n 较大时 (&gt;50)，可以近似为：$ASL_{bs}=log_2(n+1)-1$</p><h3 id="插值查找（Insertion-Search）"><a href="#插值查找（Insertion-Search）" class="headerlink" title="插值查找（Insertion Search）"></a>插值查找（Insertion Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li><li>需要关键字均匀分布的表；</li></ul><p><strong>基本思想</strong>：折半查找中，每次都是从中间位置开始，而插值查找就是为了避免这种 “傻瓜” 式的搜索，希望将比例因子改为自适应的，即：根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，进而间接地减少比较次数；</p><ul><li>新的 mid 求法：$mid=low+\frac{key-a[low]}{a[high]-a[low]}\ast(high-low)$</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertionSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：   </p><ul><li>查找成功或者失败的时间复杂度均为 $O(log(logn))$；</li><li>分布均匀，且表长较大时，平均性能优于折半查找；</li></ul><h3 id="斐波拉契查找（Fibonacci-Search）"><a href="#斐波拉契查找（Fibonacci-Search）" class="headerlink" title="斐波拉契查找（Fibonacci Search）"></a>斐波拉契查找（Fibonacci Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p><p><strong>适用场景</strong>：</p><ul><li>元素有序的线性表（线性链表不适用）；</li><li>静态查找（动态查找时，要维护有序会带来很大的工作量）； </li></ul><p><strong>基本思想</strong>：类似二分查找，根据斐波那契序列的特点对有序表进行分割；它要求开始时，表中记录的个数为某个斐波那契数减 1，及 $n=F(k)-1$；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/FibonacciSegmentation.png" alt="FibonacciSegmentation"></p><ul><li>同样，维护三个指针，初始时，<code>low</code> 和 <code>high</code> 指向线性表两端，将 <code>key</code> 与第 <code>F(k-1)</code> 位置的记录进行比较（即：<code>mid=low+F(k-1)-1</code>）：<ul><li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li><li>若 <code>key &gt; mid</code>，则更新：<code>low=mid+1,k-=2</code>；查找区间更新为 <code>[mid+1,high]</code>，<code>k-=2</code> 说明新的查找区间内元素个数为：$n-F(k-1)= F(k)-1-F(k-1)=F(k-2)-1$；</li><li>若 <code>key &lt; mid</code>，则更新：<code>high=mid-1,k-=1</code>；查找区间更新为 <code>[low,mid-1]</code>，<code>k-=1</code> 说明新的查找区间内元素个数为：$F(k-1)-1$；</li></ul></li><li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li></ul><p><strong>java 实现源码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>; <span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波拉契查找（Fibonacci Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 斐波那契分割数值的下标</span></span><br><span class="line">    <span class="keyword">int</span> f[] = fib(); <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    <span class="comment">// 计算获取，斐波那契分割数值的下标</span></span><br><span class="line">    <span class="comment">//  f(k) 是大于数组长度的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f[k] 值可能大于 arr 的长度，则构造一个新的数组 temp[]，该方法不足的部分会使用 0 填充</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">// 但是，实际上需求使用 arr 数组最后的数填充 temp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        temp[i] = arr[high];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环进行查找</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//值过小，从左半部分继续</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">//值过大，从右半部分继续</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//查找成功，但是因为前面扩充了数组，则需要确定，返回的是哪个下标</span></span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= arr.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.length-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能分析</strong>：</p><ul><li>平均复杂度为：$O(longn)$，最坏情况下的时间复杂度也是 $O(longn)$；</li><li>平均性能优于折半查找，但最坏情况下的性能（虽然仍是 $O(longn)$）却比折半查找差；</li><li>另一个优势：分割时只需要进行加减运算；</li></ul><h1 id="动态树表查找"><a href="#动态树表查找" class="headerlink" title="动态树表查找"></a>动态树表查找</h1><h2 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h2><p><strong>“二叉排序树”</strong>（也称 “二叉查找树” 或者 “二叉搜索树”）：它或者是一棵空树，或者是具有下列性质的二叉树：（左小右大）</p><ul><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ul><p>根据其定义，也就可以看出，二叉排序树具有如下<strong>性质</strong>：</p><ul><li>中序遍历的结果是一个有序序列；</li></ul><p><strong>二叉排序树查找算法基本思想</strong>：</p><ul><li><p><strong>建树</strong>：从一棵空树开始，将被查找序列的数据不断插入树中，生成一棵二叉排序树<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTBuild.png" alt="BSTBuild"></p><ul><li><strong>插入</strong>：新插入的节点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点；<ul><li>若当前的二叉查找树为空，则插入的元素为根节点；</li><li>若插入的元素值小于根节点值，则将元素插入到左子树中；</li><li>若插入的元素值不小于根节点值，则将元素插入到右子树中；</li><li>总结来说就是：首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败；</li></ul></li><li><strong>删除</strong>：分三种情况进行处理：<ol><li>p 为叶子节点：直接删除该节点（不会破坏树的整体结构），再修改其父节点的指针（注意分是根节点和不是根节点），如图 a；</li><li>p 为单支节点（即只有左子树或右子树）：让 p 的子树与 p 的父亲节点相连，删除 p 即可（也不会破坏树的整体结构）（注意分是根节点和不是根节点），如图 b；</li><li>有两个孩子的情况：当前结点与左子树中最大的元素交换，然后删除当前结点。左子树最大的元素至多只有一个左子节点，交换后，删除就可以参考上面两种的情况。另一种方法是，当前结点与右子树中最小的元素交换，然后删除当前结点。如图 c（删除 z 结点）；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTDelete.png" alt="BSTDelete"></li></ol></li></ul></li><li><p><strong>查找</strong>：树非空时，将给定值与根节点比较，若相等则查找成功；否则，根据给定值与根节点的大小关系，分别在左子树或右子树上继续查找；迭代进行，直至查找成功，或者不再存在左右子树时查找失败；</p></li></ul><details>  <summary><b>java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树数据结构*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value, TreeNode parent, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这部分是树里面的一些操作，详细可见二叉树的操作*/</span></span><br><span class="line">    <span class="comment">// 求 BST 的最小值，即最左边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 BST 的最大值，即最右边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中中序遍历的某节点的前驱节点，即查找数据值小于该结点的最大结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">preNode</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMax(x.left);</span><br><span class="line">        <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则"x的前驱结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的右儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.left == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中某节点的后继节点.即查找数据值大于该结点的最小结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">postNode</span><span class="params">(TreeNode x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在右孩子，则"x的后继结点"为"以其右孩子为根的子树的最小结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMin(x.right);</span><br><span class="line">        <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则"x的后继结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的查找算法*/</span></span><br><span class="line">    <span class="comment">// 查找值为val的节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">searchRec</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找值为 val 的节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">search</span><span class="params">(TreeNode root ,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点插入算法*/</span></span><br><span class="line">    <span class="comment">//BST 插入节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insertRec</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left,  x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right,  x);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BST 插入节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root = x;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>; <span class="comment">//需要记录父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位插入的位置</span></span><br><span class="line">            p = root; <span class="comment">//记录父节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        x.parent = p;<span class="comment">//定位到合适的叶节点的空白处后，根据和父节点的大小比较插入合适的位置</span></span><br><span class="line">        <span class="keyword">if</span>(x.value &lt; p.value)</span><br><span class="line">            p.left = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; p.value)</span><br><span class="line">            p.right = x;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点删除算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位到需要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//找到了，root指向待删结点，p指向root的父结点</span></span><br><span class="line">                <span class="comment">// 情景一：待删除的是 叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)</span><br><span class="line">                            p.left = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有左孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>)<span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.left;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.left;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有右孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.right;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景三：待删除节点同时拥有左右孩子</span></span><br><span class="line">                <span class="comment">//  方法：得到待删除节点右子树的最小值，该最小值与待删除节点进行“ 值 ”交换，删除该最小值位置处的节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此情况就不需要考虑被删结点是不是根节点了，操作都相同</span></span><br><span class="line">                    TreeNode rMin = root.right; <span class="comment">// 待删除节点的右孩子的最小值(找到的后继节点肯定没有左孩子！！！)</span></span><br><span class="line">                    TreeNode rMinP = root;<span class="comment">// 因为需要删除后继节点位置，所以需要记录父节点</span></span><br><span class="line">                    <span class="keyword">while</span>(rMin.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        rMinP=rMin;</span><br><span class="line">                        rMin = rMin.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> rootVtemp = root.value;<span class="comment">//值交换</span></span><br><span class="line">                    root.value = rMin.value;</span><br><span class="line">                    rMin.value = rootVtemp;</span><br><span class="line">                    <span class="comment">//删除rMin位置的节点，此时此位置的值已是待删节点的值</span></span><br><span class="line">                    <span class="keyword">if</span>(rMinP.left == rMin)</span><br><span class="line">                        rMinP.left = rMin.right;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rMinP.right == rMin) <span class="comment">// 待删结点root的右孩子结点就是其右子树的最小值</span></span><br><span class="line">                        rMinP.right = rMin.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到后删了后就跳出while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的不完全测试模块：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node45 = <span class="keyword">new</span> TreeNode(<span class="number">45</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node24 = <span class="keyword">new</span> TreeNode(<span class="number">24</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node53 = <span class="keyword">new</span> TreeNode(<span class="number">53</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node12 = <span class="keyword">new</span> TreeNode(<span class="number">12</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node37 = <span class="keyword">new</span> TreeNode(<span class="number">37</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node93 = <span class="keyword">new</span> TreeNode(<span class="number">93</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        insert(node45,node24);</span><br><span class="line">        insert(node45,node53);</span><br><span class="line">        insert(node45,node12);</span><br><span class="line">        insert(node45,node37);</span><br><span class="line">        insert(node45,node93);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以写个中序遍历的函数，遍历一遍</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"查找45结果："</span>);</span><br><span class="line">        TreeNode out1 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out1 +<span class="string">":"</span>+ out1.value);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"删除45后，再次查询结果："</span>);</span><br><span class="line">        delete(node45,node45);</span><br><span class="line">        TreeNode out2 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out2);</span><br><span class="line"></span><br><span class="line">        System.out.println(node45.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>性能分析</strong>：</p><ul><li>含有 n 个节点的二叉排序树的平均查找长度和树的形态有关；</li><li>和二分查找一样，插入和查找的时间复杂度均为 $O(logn)$，但是在最坏的情况下仍然会有 $O(n)$ 的时间复杂度；</li><li>最坏情况时，树形结构为每层一个结点，这样算法会退化为顺序查找，于是，平衡二叉查找树应运而生；</li></ul><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p><strong>来历</strong>：前面介绍，最坏情况下，如果连续插入已经排好序的键到二叉查找树，二叉查找树会变成了一个链表，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BadBST.png" alt="BadBST"><br>这样，相应的查找算法也就退化为了顺序查找，时间复杂度变为了 $O(n)$。而平衡二叉树就是为了避免这种情况。    </p><p><strong>平衡二叉树</strong>（Balance Binary Tree，Height-Balance Tree，AVL 树）：它或者是一棵空树，或者具有以下性质：</p><ul><li>首先，它是一棵二叉查找树；</li><li>它的左右子树也构成一棵平衡二叉树；</li><li>并且，左右子树的深度之差的绝对值不超过 1；</li></ul><p>若将二叉树上结点的<strong>平衡因子 BF</strong>（Balance Factor）定义为：该结点的左子树深度减去它的右子树深度，则平衡二叉树上所有结点的 BF 只可能取值为：-1、0、1，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/AVLExample.png" alt="AVLExample">   </p><p>在一个平衡二叉树上插入结点，就可能导致失去平衡，此时仅需对最小不平衡子树进行平衡旋转处理即可。现假设由于二叉排序树上插入结点而失去平衡的最小子树根节点指针为 a（即：a 是离插入结点最近，且平衡因子绝对值超过 1 的祖先结点），则<strong>失去平衡后进行调整（旋转） 的规律</strong>可归结为以下四种情况：   </p><ul><li><strong>LL 型：单向右旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LLRotate.png" alt="LLRotate"><ul><li>由于在 A 结点的左子树根节点的左子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如上图；</li></ul></li><li><strong>RR 型：单向左旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RRRotate.png" alt="RRRotate"><ul><li>由于在 A 结点的右子树根节点的右子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需进行一次向左的逆时针旋转操作，如上图；</li></ul></li><li><strong>LR 型：双向旋转（先左后右）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LRRotate.png" alt="LRRotate"><ul><li>由于在 A 结点的左子树根节点的右子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先左旋转再右旋转），如上图；</li></ul></li><li><strong>RL 型：双向旋转（先右后左）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RLRotate.png" alt="RLRotate"><ul><li>由于在 A 结点的右子树根节点的左子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先右旋转再左旋转），如上图；</li></ul></li></ul><p>以上旋转操作的正确性容易由 “保持二叉排序树的特性：中序遍历所得关键字序列自小而大有序” 证明。    </p><p><strong>插入和删除</strong>：与二叉查找树类似，只是额外加入了平衡操作。下面以插入算法思想来进行分类讨论：</p><ul><li>若 BBST 为空树，则插入一个数据元素为 e 的新结点作为 BBST 的根节点，树的深度增 1；</li><li>若 e == BBST 的根节点，则不进行插入；</li><li>若 e &lt; BBST 的根结点，并且 BBST 的左子树中不存和 e 相等的结点，则将 e 插入至 BBST 的左子树上，并且在插入之后的左子树深度增加（+1）时，分别就以下情况进行处理：<ul><li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li><li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 1，BBST 深度增 1；</li><li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：<ul><li>若 BBST 的左子树根结点的平衡因子为 1：则需要进行 LL 型（单向右旋）平衡处理，并且在右旋处理之后，将根节点和其右子树根结点的平衡因子改为 0，树的深度不变；</li><li>若 BBST 的左子树根结点的平衡因子为 -1：则需进行 LR 型（先左后右）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li></ul></li></ul></li><li>若 e &gt; BBST 的根结点，并且 BBST 的右子树中不存和 e 相等的结点，则将 e 插入至 BBST 的右子树上，并且在插入之后的右子树深度增加（+1）时，分别就以下情况进行处理：<ul><li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li><li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 -1，BBST 深度增 1；</li><li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：<ul><li>若 BBST 的右子树根结点的平衡因子为 -1：则需要进行 RR 型（单向左旋）平衡处理，并且在左旋处理之后，将根节点和其左子树根结点的平衡因子改为 0，树的深度不变；</li><li>若 BBST 的右子树根结点的平衡因子为 1：则需进行 RL 型（先右后左）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li></ul></li></ul></li></ul><details>  <summary><b>java 实现示例</b></summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 具体的实现依赖于前面的 二叉排序树 */</span></span><br><span class="line"><span class="comment">/** 下面给出里面的几个核心函数：BBST 的辅助旋转算法 */</span></span><br><span class="line"><span class="comment">// 其中，bf 是添加在树节点里的成员变量，代表节点的平衡因子（左子树高度-右子树高度）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的左子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.left; <span class="comment">// p 指向 root 的左子树的根结点</span></span><br><span class="line">    root.left = p.right; <span class="comment">// p 的右子树挂载至 root 的左子树</span></span><br><span class="line">    p.right = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的右子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.right; <span class="comment">// p 指向 root 的右子树的根结点</span></span><br><span class="line">    root.right = p.left; <span class="comment">// p 的左子树挂载至 root 的右子树</span></span><br><span class="line">    p.left = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在上述两种基础上，完成平衡二叉树的左右平衡处理</span></span><br><span class="line"><span class="comment">// 左平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode rl = root.left;</span><br><span class="line">    <span class="keyword">switch</span> (rl.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的左孩子的左子树上，做单向右旋处理</span></span><br><span class="line">            root.bf = rl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的左孩子的右子树上，做双旋（先左后右）处理</span></span><br><span class="line">            TreeNode rlr = rl.right;</span><br><span class="line">            <span class="keyword">switch</span> (rlr.bf)&#123; <span class="comment">// 修改 root 及其左孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = -<span class="number">1</span>; rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">0</span>; rl.bf = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rlr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root.left); <span class="comment">// 对 root 的左子树作左旋处理</span></span><br><span class="line">            rRotate(root); <span class="comment">// 对 root 做右旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected value: "</span> + rl.bf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode rr = root.right;</span><br><span class="line">    <span class="keyword">switch</span> (rr.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的右孩子的右子树上，做单向左旋处理</span></span><br><span class="line">            root.bf = rr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的右孩子的左子树上，做双旋（先右后左）处理</span></span><br><span class="line">            TreeNode rrl = rr.left;</span><br><span class="line">            <span class="keyword">switch</span> (rrl.bf)&#123; <span class="comment">// 修改 root 及其右孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = <span class="number">0</span>; rr.bf = -<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">1</span>; rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rrl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root.right); <span class="comment">// 对 root 的左子树作右旋处理</span></span><br><span class="line">            lRotate(root); <span class="comment">// 对 root 做左旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p><strong>性能分析</strong>：</p><ul><li>在平衡二叉树上进行查找的时间复杂度为：$O(logn)$，注意，它一种动态查找算法，在树形维护上的时间复杂度还是相对较高的；</li></ul><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>对比说明</strong>：</p><div class="table-container"><table><thead><tr><th>名称</th><th>简介</th><th>局限性</th><th>应用</th></tr></thead><tbody><tr><td>AVL 树</td><td>严格的平衡二叉树，平衡条件必须满足：所有节点的左右子树高度差不超过 1；</td><td>① 平衡调整时的旋转操作十分耗时，因此，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多；更多的地方是用追求局部而不是非常严格整体平衡的红黑树;<br>② 也就更适合用于插入与删除次数比较少，但查找多的情况；</td><td>windows 对进程地址空间的管理；</td></tr><tr><td>红黑树</td><td>弱平衡二叉树，相同的节点情况下，AVL 树的高度低于红黑树；</td><td>旋转操作更少，更适用于搜索、插入、删除等操作较多的情况；<br>但相应的，相同情况下其查找次数会略高于 AVL 树；</td><td>① 著名的 linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块；<br>② epoll 在内核中的实现，用红黑树管理事件块；<br>③ nginx 中，用红黑树管理 timer 等；<br>④ Java 的 TreeMap 实现；</td></tr></tbody></table></div><p><strong>红黑树的定义</strong>：</p><ul><li>每个结点非黑即红；</li><li>根结点是黑色；</li><li>每个叶子结点都是黑色的空结点（NIL 结点）；</li><li>每个红色结点的两个子结点都是黑色;<ul><li>可推出：从每个叶子到根的所有路径上不能有两个连续的红色结点；</li></ul></li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；<ul><li>可推出：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul></li></ul><p>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTree.png" alt="RedBlackTree">     </p><p><strong>红黑树总是通过 “旋转” 和 “变色” 达到自平衡</strong>：</p><p><strong>红黑树插入</strong>：同样与二叉树类似，也分为两部分：1.查找插入的位置；2.插入后自平衡</p><p>查找流程：注意，插入的位置一定是叶子结点<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackSearch.png" alt="RedBlackSearch">      </p><p>接下来，就是将待插结点以 “红色” 插入，此时一共有 8 中情景，如下：</p><ul><li>“红色” 原因：如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡；并且，如果选择红色，在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作，也可以进一步减少平衡操作；   </li></ul><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeInsertSituation.png" alt="RedBlackTreeInsertSituation">   </p><p><strong>红黑树删除</strong>：同样也分为两部分：1.查找删除的位置；2.删除后自平衡    </p><p>查找流程：直接用前述的过程替代，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除目标结点，若目标结点存在子结点，还需找到结点进行替代，之后还得进行自平衡处理；     </p><p>结点删除的第一步，找替代结点分为以下 3 种情景：</p><ul><li>情景 1：若删除结点无子结点，直接删除</li><li>情景 2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景 3：若删除结点有两个子结点，用中序遍历的后继结点（大于删除结点的最小结点，也即：删除结点右子树的最左边的结点）替换删除结点；</li></ul><p>经过上述替换之后，也就是删除替换结点。这个时候删除替换结点的情景如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeDeleteSituation.png" alt="RedBlackTreeDeleteSituation"></p><h2 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B- 树和 B+ 树"></a>B- 树和 B+ 树</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><p>B- 树是一种<strong>平衡的多路查找树</strong>，它<strong>广泛的运用于文件系统（索引）中</strong>；    </p><p><strong>定义</strong>：一棵 m 阶的 B- 树，要么为空树，要么为满足下列条件的 m 叉树：</p><ul><li>树中每个结点至多有 m 棵子树；</li><li>若根节点不是叶子结点，则至少有两棵子树；</li><li>除根节点之外的所有非终端结点至少有 $\lceil m/2 \rceil$ 棵子树；</li><li>所有的非终端节点包含以下信息数据：$(n,A_0,K_1,A_1,K_2,A_2,…,K_n,A_n)$<ul><li>$K_i\ (i=1,…,n)$ 为关键字，且 $K_i&lt;K_{i+1}\ (i=1,…,n-1)$；</li><li>$A_i\ (i=1,…,n)$ 为指向子树根节点的指针，且指针 $A_{i-1}$ 所指子树中所有结点的关键字均小于 $K_i(i=1,…,n)$，$A_n$ 所指子树中所有结点的关键字均大于 $K_n$；</li><li>$n\ (\lceil m/2 \rceil-1 \leq n \leq m-1)$  </li></ul></li><li>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的节点，实际上这些结点不存在，指向这些结点的指针为空）；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-Tree.png" alt="B-Tree"></p><p><strong>查找</strong>：B- 树的查找过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程；</p><ul><li><strong>查找性能分析</strong>：B- 树通常存在磁盘上，因此查找操作的主要两步：（1）在 B- 树中找结点（磁盘）；（2）在结点中找关键字（内存）；详细来说，即：在磁盘上找到指针 p 所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找等于 K 的关键字。而磁盘上的查找更耗时，因此，在磁盘上进行查找的次数（即待查找关键字所在结点在 B- 树上的层次树）是觉得 B- 树查找效率的首要因素。<ul><li>讨论深度为 l+1 的 m 阶 B- 树所具有的最少结点数：<ul><li>B- 数第一层至少 1 个节点；第二次至少 2 个节点；由于除根节点外每个非终端节点至少有 $\lceil m/2 \rceil$ 棵子树，则第三层至少有 $2\lceil m/2 \rceil$ 个节点；……以此类推；第 l+1 层至少有 $2(\lceil m/2 \rceil)^{l-1}$ 个结点；并且，第 l+1 层的结点为叶子结点 ；</li></ul></li><li>若 m 阶 B- 树中具有 N 个关键字，则叶子结点（即查找失败）的结点为 N+1，则有：$N+1 \geq 2 \ast (\lceil m/2 \rceil)^{l-1}$，也即：<script type="math/tex">l \leq log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1</script></li><li>也即：在含有 N 个关键字的 B- 树上进行查找时，从根节点到关键字所在结点的路径上设计的结点数不超过：$log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1$</li></ul></li></ul><p><strong>插入</strong>：规则：查找，向最底层的结点插入关键字，然后判断当前结点 key 的个数是否小于等于 m-1，如果满足，直接插入即可；如果不满足，“分裂”：按节点的中间的 key 将这个节点分为左右两部分，中间的 key 放到父节点中即可；</p><ul><li>往一个 4 阶 B- 树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的动图示例：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeInsert.gif" alt="B-TreeInsert"></li></ul><p><strong>删除</strong>：首先找到该关键字所在的结点，并从中删除之，然后，对需要进行 “合并” 结点的情况进行合并。这时考虑如下几种情况（$m=5，2 \leq n \leq 4$）：</p><ul><li>删除的是叶子节点的元素，并且如果删除之后，元素数还是大于等于 $\lceil m/2 \rceil -1$，这种情况只要直接删除即可:<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete1.png" alt="B-TreeDelete1"></li><li>删除的是叶子节点的元素，并且如果删除之后，元素数不足 $\lceil m/2 \rceil -1$：<ul><li>如果，它的兄弟节点的元素大于等于 $\lceil m/2 \rceil$（即：兄弟节点的元素删掉一个后仍符合要求）：将其兄弟结点中的最小（最大）的元素上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移元素的元素下移至双亲结点中；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete2.png" alt="B-TreeDelete2"></li><li>如果与被删元素所在的结点相邻的兄弟结点中元素个数均等于 $\lceil m/2 \rceil - 1$：假设该结点有兄弟结点，且其右兄弟结点地址由双亲结点中的指针 $A_i$ 所指，则在删去元素之后，它所在结点中剩余的元素和指针，加上双亲结点中的关键字 $K_i$ 一起合并到 $A_i$ 所指兄弟结点中去（若没有右兄弟结点，则合并至左兄弟结点）。之后，如果因此使双亲结点中的元素个数不足 $\lceil m/2 \rceil-1$，则依次类推左相应处理。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete3.png" alt="B-TreeDelete3"></li></ul></li><li>对于非叶子节点的删除，则需要用后继 key 覆盖要删除的 key，然后在后继 key 所在的位置中删除该后继 key：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete4.png" alt="B-TreeDelete4"><ul><li>此时，26 所在的结点不符合要求，需要进行前面说过的向兄弟结点 “借” 的操作；</li></ul></li></ul><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是应文件系统所需而出的一种 B- 树的变种；也是 MySQL 的底层数据结构；    </p><p><strong>定义</strong>：一棵 m 阶的 B+ 树和 m 阶的 B- 树的差异在于：</p><ul><li>有 n 棵子树的节点中含有 n 个关键字；</li><li>所有的叶子结点包含了全部的关键字信息（及指向这些关键字记录的指针），且叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（的根节点）中的最大（或最小）关键字；</li><li>补充：有关结点的元素范围<ul><li>非根节点元素范围：$n\ (\lceil m/2 \rceil \leq n \leq m)$</li></ul></li></ul><p>好好与 B- 树对比体会，一棵 3 阶的 B+ 树如下所示：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B+Tree.png" alt="B+Tree">  </p><ul><li>通常，在 B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的节点；   </li></ul><p><strong>查找</strong>：根据前面所述的两个指针，查找也就可以分为两种方式：</p><ol><li>从最小关键字起顺序查找；</li><li>从根节点开始进行随机查找；<ul><li>在 B+ 树上进行这种随机查找，不管查找成功与否，每次查找都是走了一条从根到叶子结点的完整路径；</li></ul></li></ol><p><strong>插入</strong>：仅在叶子结点上进行，当结点中的关键字个数大于 m 时，要从中间分裂为两个结点（它们所含关键字个数为：$\lceil \frac{m+1}{2} \rceil$ 和 $\lfloor \frac{m+1}{2} \rfloor$），并且，它们的双亲结点中应同时含有这两个结点的最大关键字。   </p><p><strong>删除</strong>：也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端节点中的值可以作为一个 “分界关键字” 继续存在。若因删除而使结点中关键字的个数少于 $\lceil m/2 \rceil$ 时，其和兄弟结点的合并过程和 B- 树类似。</p><h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p><strong>定义</strong>：又称数字查找树（Digital Search Tree）。它是一棵高度 $\geq 2$ 的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。    </p><p>例如：如下 16 个关键字的集合。{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。逐层划分，组成一棵键树如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/KeyTree.png" alt="KeyTree"></p><ul><li>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字，叶子结点中的特殊符号 $ 表示字符的结束；</li><li>为了插入和查找的方便，会约定键树是一棵有序树，即：同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符 $ 小于任何字符；</li></ul><p><strong>两种存储结构</strong>：</p><ol><li>双链树：<ul><li>以树的孩子兄弟链表来表示键树，则每个分支结点包括 3 个域：symbol 域（存储关键字的一个字符）、first 域（存储指向第一棵子树根的指针）、next 域（存储指向右兄弟的指针），同时，叶节点的 infoptr 域（存储指向该关键字记录的指针）。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DoubleLinkTree.png" alt="DoubleLinkTree"></li></ul></li><li>Trie 树：<ul><li>以树的多重链表表示键树，则树的每个结点中应含有 d 个指针域；</li><li>若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个 “叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息；</li><li>Trie 树有两种结点：<ul><li>分支结点：含有 d 个指针域和一个指示该结点中非空指针域的个数的整数域；<ul><li>分支结点中不设数据域，每个分支结点所表示的字符均有其双亲结点中（指向该结点）的指针所在位置决定；</li></ul></li><li>叶子结点：含有关键字域和指向记录的指针域；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/TrieTree.png" alt="TrieTree"></li></ul></li></ul></li></ol><h1 id="哈希查找（Hash-Search）"><a href="#哈希查找（Hash-Search）" class="headerlink" title="哈希查找（Hash Search）"></a>哈希查找（Hash Search）</h1><p>前面介绍的各种结构（线性表、树）中，记录在结构中的相对位置时随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录就需要一系列和关键字的比较，也就是常说的基于 “比较” 的查找算法。这样往往比较耗时。    </p><h2 id="哈希表和哈希函数"><a href="#哈希表和哈希函数" class="headerlink" title="哈希表和哈希函数"></a>哈希表和哈希函数</h2><p>就是为了解决上述问题而引入的一种 <strong>“以空间换时间”</strong> 的数据结构：</p><ul><li>它利用哈希函数 $f$ 在记录的存储位置和它的关键字之间建立了一个确定的对应关系 $f$，这样就使得每个关键字和结构中一个唯一的存储位置相对应。按照这种关系记录关键字的表就是哈希表；</li><li>在查找时，只要根据这个对应关系 $f$ 找到给定值 $K$ 的像 $f(K)$。若结构中存在关键字和 $K$ 相等的记录，则必定在 $f(K)$ 的存储位置上，由此，不需要进行比较就可以直接取得所查记录。</li></ul><p><strong>定义</strong>：综上如下描述哈希表：根据给定的哈希函数 $H(key)$ 和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的 “像” 作为记录在表中的存储位置，这种表即为<strong>哈希表</strong>，这一映像过程称为<strong>哈希造表或散列</strong>，所得的存储位置称为<strong>哈希地址或散列地址</strong>。其两大特点就是：</p><ul><li>映像：哈希函数</li><li>冲突：不同的关键字映射到同一地址</li></ul><h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>首先，“好” 的哈希函数应该具有特点：对于关键字集合中的任一关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为均匀的哈希函数。     </p><p><strong>方法一：直接定址法</strong></p><ul><li>取关键字或关键字的某个线性函数值为哈希地址，即：$H(key)=key$ 或 $H(key)=a \cdot key + b$</li></ul><p><strong>方法二：数字分析法</strong></p><ul><li>假设关键字是以 r 为基的数（如：以 10 为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可 “取关键字的若干位” 组成哈希地址；</li><li>如：{313、323、333、343、353、363、373、383、393}，可取其第 2 位组成哈希地址；</li></ul><p><strong>方法三：平方取中法</strong></p><ul><li>取关键平方后的中间几位为哈希地址。这种方式比较常用；</li><li>通常在选哈希函数的时候是不一定知道所有的关键字的，因此取其中那几位也不一定合适，而一个树平方后的中间几位数和数的每一位都相关，由此可使随机分布的关键字得到的哈希地址也是随机的；</li></ul><p><strong>方法四：折叠法</strong></p><ul><li>将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后截取这几部分的叠加和（舍去进位）作为哈希地址；</li><li>适用于：关键字位数很多，而且关键字中每一位上数字分布大致均匀时；</li></ul><p><strong>方法五：除留余数法</strong></p><ul><li>取关键字被某个不大于哈希表表长 m 的数 p 除后所得余数作为哈希地址，即：$H(key)=key\ MOD\ p,\ p \leq m$</li><li>这是最简单、也最常用的方法，不仅可以直接对关键字使用 MOD，也可以在折叠、平方取中等运算之后取模；</li><li>但是需要注意 p 的选取，否则可能产生较高的冲突；而根据经验，一般选 p 为质数或不包含小于 20 的质因数的合数；</li></ul><p><strong>方法六：随机数法</strong></p><ul><li>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即：$H(key)=random(key)$；</li><li>通常适用于关键字长度不等时；</li></ul><p>针对上述提供的方法，实际工作中需要视情况采用。通常考虑的因素有：</p><ul><li>计算哈希函数所需的时间（包括硬件指令的因素）；</li><li>关键字的长度；</li><li>哈希表的大小；</li><li>关键字的分布情况；</li><li>记录的检查频率；</li></ul><h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>假设哈希表的地址集为 0~(n-1)，冲突就是指有关键字得到的哈希地址为 j （$0 \leq j \leq n-1$） 的位置上已存有记录。那么冲突处理，就是为该关键字重新找的另一个 “空” 的哈希地址。在实际处理时，可能第一次冲突处理得到的地址 $H_1$ 仍旧冲突，则再进行处理得到 $H_2$，再冲突，再处理，…，这样得到了一个地址序列，最后一个地址 $H_k$ 为不发生冲突的地址；</p><p><strong>方法一：开放地址法</strong></p><ul><li>$H_i=(H(key)+d_i)\ MOD\ m,\ i=1,2,…,k\ (k \leq m-1)$</li><li>其中，$H(key)$ 为哈希函数；$m$ 为哈希表长；$d_i$ 为增量序列；</li><li>根据增量序列的取法，又可以分为如下方法：<ul><li>线性探测再散列：$d_i = 1,2,3,…,m-1$<ul><li>只要哈希表未填满，最终总能找到一个不发生冲突的地址；</li></ul></li><li>二次探测再散列：$d_i= 1^2,-1^2,2^2,-2^2,…,\pm k^2,\ (k \leq m/2)$<ul><li>只有在哈希表长 m 为形如 $4j+3$（j 为整数）的素数时才可能；</li></ul></li><li>伪随机探测再散列：$d_i = 伪随机数序列$<ul><li>取决于伪随机数列；</li></ul></li></ul></li><li>这种处理方式可能带来一个问题：二次聚集（即：原先不发生冲突的地址，却因为之前某个关键字进行了冲突处理，从而又导致了冲突）</li></ul><p><strong>方法二：再哈希法</strong></p><ul><li>$H_i=RH_i(key)\ \ i=1,2,…,k$</li><li>$RH_i$ 均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生；</li><li>这种方法不易产生 “聚集”，但增加了计算时间；</li></ul><p><strong>方法三：链地址法（拉链法）</strong></p><ul><li>将所有关键字为同义词的记录存储在同一线性链表中：<ul><li>假若某哈希函数产生的哈希地址在区间 [0,m-1] 上，则设立一个指针型变量 Chain ChainHash[m]；其每个分量的初始状态为空指针；</li><li>凡哈希地址为 i 的记录都插入到头指针为 ChainHash[i] 的链表中；</li><li>在链表中插入的位置可以是表头或表尾，也可以在中间，以保持同义词在同一线性表中按关键字有序；</li></ul></li><li>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/ChainAddressMethod.png" alt="ChainAddressMethod"></li></ul><p><strong>方法四：建立一个公共溢出区</strong></p><ul><li>假设哈希函数的值域为 [0,m-1]，则设向量 HashTable[0,m-1] 为基本表，每个分量存放一个记录，另设立向量 OverTable[0..v] 为溢出表；</li><li>所有关键字和基本表中关键字为同义的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表；</li></ul><h2 id="哈希查找分析"><a href="#哈希查找分析" class="headerlink" title="哈希查找分析"></a>哈希查找分析</h2><p><strong>查找过程</strong>：给定 K 值根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找失败；否则，比较关键字，若与给定值相等，则查找成功，否则根据造表时设定的处理冲突函数的方法找 “下一地址”，直至哈希表中某个位置为 “空” 或者表中所填记录的关键字等于给定值时为止；   </p><ul><li><mark>注意：若要在非链地址处理冲突的哈希表中删除一个记录，则需要在该记录的位置上填入一个特殊的符号，以免找不到在它之后填入的 “同义词” 的记录；</mark></li></ul><p><strong>性能分析</strong>：因为 “冲突” 使得哈希表的查找过程仍是一个 “比较” 的过程，仍需以平均查找长度作为衡量哈希表的查找效率的度量；</p><ul><li>查找过程中，比较的次数取决于三个因素：<ul><li>哈希函数：一般情况下选取的哈希函数是 “均匀的”，则产生冲突的可能性相同，所以可以不考虑它的影响因素；</li><li>冲突处理方法：线性探测再散列容易产生二次聚集，而链地址法，则可以有效避免此情况；</li><li>哈希表的装填因子：冲突处理方法相同的哈希表，其平均查找长度就依赖于哈希表的装填因子<ul><li>$哈希表的装填因子\ \alpha = \frac{表中填入的记录数}{哈希表长度}$</li><li>$\alpha$ 越小，冲突可能性越小；$\alpha$ 越大，冲突可能性越大，则查找过程中比较的次数就越多；</li></ul></li></ul></li><li>几种冲突处理方法的平均查找长度：</li></ul><div class="table-container"><table><thead><tr><th>冲突处理方法</th><th>成功时</th><th>失败时</th></tr></thead><tbody><tr><td>线性探测再散列</td><td>$S_{nl} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$</td><td>$U_{nl} \approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$</td></tr><tr><td>随机探测再散列、二次探测再散列、再哈希</td><td>$S_{nr} \approx -\frac{1}{\alpha}ln(1-\alpha)$</td><td>$U_{nr} \approx \frac{1}{1-\alpha}$</td></tr><tr><td>链地址法</td><td>$S_{nc} \approx 1+\frac{\alpha}{2}$</td><td>$U_{nc} \approx \alpha + e^{-\alpha}$</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>『<a href="https://www.cnblogs.com/magic-sea/p/11391431.html" target="_blank" rel="noopener">賣贾笔的小男孩：分块查找</a>』</li><li>『<a href="https://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="noopener">[Data Structure &amp; Algorithm] 七大查找算法</a>』</li><li>『<a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">二叉查找树BST——java实现</a>』</li><li>『<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a>』</li><li>『<a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">面试官问你B树和B+树，就把这篇文章丢给他</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;查找&lt;/strong&gt;（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-Lab Exercise</title>
    <link href="http://www.thebetterkong.cn/2020/06/11/FPGA-technology/FPGA-LabExercise/"/>
    <id>http://www.thebetterkong.cn/2020/06/11/FPGA-technology/FPGA-LabExercise/</id>
    <published>2020-06-11T08:29:36.000Z</published>
    <updated>2020-08-14T09:31:17.859Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 FPGA 具体的实验操作；</p><a id="more"></a> <h1 id="概述：FPGA-构建工具链"><a href="#概述：FPGA-构建工具链" class="headerlink" title="概述：FPGA 构建工具链"></a>概述：FPGA 构建工具链</h1><p>实验开始之前，我们应该熟悉 CAD（计算机辅助设计）工具，该工具可将 HDL（Verilog）转换为 FPGA 上的工作电路：</p><ul><li>这些工具将使您的设计经历多个阶段，每个阶段都使其更接近于具体的实现；</li><li>在过去的几年中，较旧的评估平台（ML505）使用较旧的 FPGA（Xilinx Virtex-5 LX110T）和较旧的软件套件（Xilinx ISE）；</li><li>尽管有一个 GUI，也可有 Makefiles 来调用工具链中的每个后续程序，以进行完整的综合并进行分析；</li></ul><p>Xilinx 更新后的设计软件：Vivado Design Suite</p><ul><li>Vivado 强调了其强大的集成脚本功能（使用 Tcl 语言）以及与其他高级设计工具（例如，高级综合）的集成；</li><li>它还支持等效的 Makefiles 和 Tcl 自动化；</li></ul><p>GUI 本身的缺点是使用起来非常手工：</p><ul><li>反复更改和运行参数很快变得乏味；</li><li>最终的目标是使设计过程尽可能自动化；</li><li>但是，对于学习而言，GUI 具有宝贵的属性，可以指导我们完成流程的每个步骤；</li></ul><h1 id="FPGA-设计流程"><a href="#FPGA-设计流程" class="headerlink" title="FPGA 设计流程"></a>FPGA 设计流程</h1><p><strong>① 综合 Synthesis</strong>：</p><ul><li>要在 Vivado Design Suite 中运行综合步骤（即，将 HDL 转换为组合逻辑和顺序逻辑），请在 “Flow Navigator（流导航器）” 窗格的其他左侧界面中选择 “ Run<br>Synthesis”；</li><li>如果之前已经运行过，则可以通过选择 “Open Synthesized Design” 来检查综合设计；</li></ul><p><strong>② 实现 Implementation</strong>：</p><ul><li>Vivado GUI 中的实现步骤等效于手动 pipeline 中的 translation，mapping 以及 place 和 route 步骤；</li><li>同样，这将采用先前综合的逻辑电路，并将其映射到我们特定的 FPGA 实际具有的物理逻辑设备；</li><li>在 “Flow Navigator” 中选择 “Run Implementation” 以运行它，然后选择 “Open Implementation” 以检查其输出；</li></ul><p><strong>③ Xilinx 设计约束（XDC）</strong>：</p><ul><li>我们如何将信号之一连接到物理设备？</li><li>我们如何指定电路的特殊性质，这可能对正确性和时序至关重要？</li><li>Xilinx 设计约束文件（具有 <code>.xdc</code> 扩展名）指定了设计的必要属性（就像旧的 User Constraints 文件），并且是实施阶段的关键输入。</li><li>XDC 受 Synopsis ASIC 综合工具链的启发，旨在实现某种程度的兼容性；</li><li>以 TCL 形式为 Vivado TCL 解释器编写；</li><li>例子：<code>set_property -dict{ PACKAGE_PIN L19 IOSTANDARD LVCMOS33 } [get_ports{ BUTTONS[3] }];</code><ul><li>此语法分别将属性 LACK 和 LVCMOS33 的值 PACKAGE_PIN 和 IOSTANDARD 分配给端口 BUTTONS [3]，这是我们在 Verilog 源中定义的信号。这些属性中的每一个在合成过程中都有单独的结果：</li><li>BUTTONS [3] 信号应连接到的引脚与 FPGA 封装上的物理引脚 L19 相连；</li><li>该端口的逻辑约定（最大电压，什么范围构成高低，等等）将为 LVCMOS33；</li></ul></li></ul><p><strong>④ Bitstream generation</strong>：</p><ul><li>为了生成 FPGA 可以理解的编程文件，我们在 “Flow Navigator” 中调用 “Generate Bitstream”；</li></ul><p><strong>⑤ Timing Analysis</strong>：</p><ul><li>通过展开 “Open Synthesized Design” 并选择 “Report Timing Summary”，可以在 “Flow Navigator” 中的 “Synthesis” 下生成时序分析报告；</li></ul><p><strong>⑥ Design Reports</strong>：</p><ul><li>在构建流程的每个步骤都会自动生成报告。</li><li>您应该能够在 “Flow Navigator” 的每个扩展阶段下找到它们；</li><li>“Project Summary” 窗口（在 “Window” 菜单下）显示了每个步骤生成的报告的摘要；</li></ul><p><strong>⑦ Programming the FPGA</strong>：</p><ul><li>要使用 Vivado GUI 将 bitstream 发送到 FPGA，必须使用 Hardware Manager；</li><li>可以在 “Flow Navigator” 中的 “Program and Debug” 下的 “Generate Bitstream” 下进行访问；</li><li>通过 USB JTAG 接口连接到 FPGA 后，您可以在 “Flow Navigator”（或在打开的Hardware Manager 窗格中）中选择 “Program Device” 来执行编程；</li></ul><h1 id="Verilog-基础"><a href="#Verilog-基础" class="headerlink" title="Verilog 基础"></a>Verilog 基础</h1><p><strong>基本格式</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;module_name&gt; (&lt;module_terminal_list&gt;);</span><br><span class="line">    &lt;module_terminal_definitions&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;functionality_of_module&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="简单运用举例"><a href="#简单运用举例" class="headerlink" title="简单运用举例"></a>简单运用举例</h2><p><strong>全加器</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FullAdder.png" alt="FullAdder">   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,cout,sum);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;      <span class="comment">//inputs</span></span><br><span class="line">    <span class="keyword">output</span>  cout,sum;    <span class="comment">//outputs</span></span><br><span class="line">    <span class="keyword">wire</span>    w1,w2,w3,w4;   <span class="comment">//internal nets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (w1,a,b)</span>; <span class="comment">//delay time of 10 units</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (sum,w1,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w2,a,b)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w3,a,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w4,b,cin)</span>;</span><br><span class="line">    <span class="keyword">or</span>  <span class="variable">#(10,8) (cout,w2,w3,w4); // (rise time of 10, fall 8)</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p><strong>全加器另一中实现方式（时序）</strong>：   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,sum,cout);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;</span><br><span class="line">    <span class="keyword">output</span>  cout,sum;</span><br><span class="line">    <span class="keyword">reg</span>     sum,cout;   <span class="comment">//registers retain value</span></span><br><span class="line">    <span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> cin) <span class="comment">//Any time a or b or cin change,run the process</span></span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            sum &lt;= a ^ b ^ cin;</span><br><span class="line">            cout &lt;= ( a &amp; b ) |  ( a &amp; cin ) |  ( b &amp; cin );</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>其中：两种赋值号 <code>=</code> 和 <code>&lt;=</code> 区别：<ul><li>Verilog 中的所有语句都是并发的（除非它们在顺序块中），并发表示每行中描述的操作并行进行；<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Concurrent.png" alt="Concurrent"></li><li>Nonblocking：<code>&lt;=</code>，代表按顺序执行；</li><li>Blocking：<code>=</code>，代表并发执行；</li></ul></li></ul><p><strong>纹波进位加法器（ripple carry adder）</strong>：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4-bit Adder</span></span><br><span class="line"><span class="keyword">module</span> adder4(A,B,cin,S,cout)</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>]  A,B;</span><br><span class="line">    <span class="keyword">input</span>   cin;</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] S;</span><br><span class="line">    <span class="keyword">output</span>  cout;</span><br><span class="line">    <span class="keyword">wire</span> c1,c2,c3;</span><br><span class="line">    <span class="comment">// 4 instantiated 1-bit Full Adders</span></span><br><span class="line">    FullAdder fa0(A[<span class="number">0</span>], B[<span class="number">0</span>], cin, c1, S[<span class="number">0</span>]);</span><br><span class="line">    FullAdder fa1(A[<span class="number">1</span>], B[<span class="number">1</span>], c1, c2, S[<span class="number">1</span>]);</span><br><span class="line">    FullAdder fa2(A[<span class="number">2</span>], B[<span class="number">2</span>], c2, c3, S[<span class="number">2</span>]);</span><br><span class="line">    FullAdder fa3(A[<span class="number">3</span>], B[<span class="number">3</span>], c3, cout, S[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h2><p>HDL（Hardware descrip languages）提供了一种通过使用文本文件来描述电路的方式；</p><ul><li>通过 keywords 和 expressions 来描述硬件：<ul><li>共用的形式：logic expression、truth table、functions、logic gates</li><li>任何的组合或者时序电路都可以描述；</li></ul></li><li>两个目标：<ul><li>通过计算机仿真（时序，延迟）来测试/验证；</li><li>综合：可综合的 HDL</li></ul></li><li>两种主要的硬件描述语言：VHDL、Verilog（主要）</li></ul><p><strong>HDL</strong>（verilog）：</p><ul><li>代表硬件结构和行为；</li><li>逻辑仿真：生成波形图</li></ul><p><strong>keywords 和 syntax（语法、词法）</strong>：</p><ul><li><code>//</code> 开始的表述注释；</li><li>一般有 100 个 keywords，是大小写敏感的（通常小写）；</li><li><code>module</code> 一个模块，以 <code>endmodule</code> 结束；</li><li><code>module</code> 后面跟电路名和端口（输入或输出）列表；</li></ul><p>两种基本的<strong>声明形式</strong>：</p><ul><li>Concurrent（同时）声明，常用在组合电路，执行与声明顺序无关；<ul><li>gate 实例化：<code>and (z,x,y)</code>，<code>or (c,a,b)</code>，<code>xor (S,x,y)</code>，etc</li><li>连续 assign：<code>assign Z=x&amp;y, c=a|b, S=x^y;</code></li></ul></li><li>Procedural（程序）声明，常用在时序电路，按书写的顺序执行；<ul><li><code>always @</code>：当 event 激活时连续执行</li><li><code>initial</code>：只执行一次（用在仿真里）</li><li><code>if then else</code></li></ul></li></ul><p><strong>wire</strong> 和 <strong>gate-level</strong>：</p><ul><li><code>wire</code>：定义为电路内部的连接点</li><li><code>and g1(e,A,B)</code>：一行定义一个 gate（and，or，xor），并为其指定名字，第一个参数为输出；</li></ul><p><strong>boolean 表达式</strong>；</p><ul><li>OR:<code>|</code>，AND:<code>&amp;</code>，NOT:<code>~</code></li></ul><p><strong>UDP</strong>（user defined primitives）用户自定义原语：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/UDP.png" alt="UDP"></p><p><strong>Modeling Circuit Delay</strong>：</p><ul><li>为了 simulation（不是 synthesis，synthesis 的延迟是不可控的）；</li><li>可以利用 <code>timescale 1ns/100ps</code>，定义仿真时间的单位；<ul><li><code>#(30)</code> 指示，gate 从输入到输出的延迟为 30ns；</li></ul></li></ul><p><strong>Test bench Stimulus（激励）</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/TBStimulus.png" alt="TBStimulus"></p><ul><li>然后就可以通过仿真波形图，观察电路是否满足预期要求；</li></ul><p><strong>Modiling Sequential Elements</strong>：</p><ul><li>D Latch：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DLatch.png" alt="DLatch"></li><li>D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DFlipflop.png" alt="DFlipflop"></li><li>带有同步 reset 的 D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/RDFlipflop.png" alt="RDFlipflop"></li></ul><p><strong>Assignment</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Assignment.png" alt="Assingment"></p><p><strong>Finite State Machines（有限状态机）</strong>：</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSM.png" alt="FSM"><br>利用状态图来展示：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSMStateDiagrams.png" alt="FSMStateDiagrams"></p><p>例：序列检测器 Sequence Detector</p><ul><li>电路功能：当收到 3 个连续的 1 时，输出 1；其余时候输出 0；</li><li>FSM 类型：Moore<ul><li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSequenceDetector.png" alt="MooreSequenceDetector"></li><li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSynthesizedSimulation.png" alt="MooreSynthesizedSimulation"></li></ul></li><li>FSM 类型：Mealy<ul><li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySequenceDetector.png" alt="MealySequenceDetector"></li><li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySynthesizedSimulation.png" alt="MealySynthesizedSimulation"></li></ul></li></ul><h1 id="FPGA-设计工具"><a href="#FPGA-设计工具" class="headerlink" title="FPGA 设计工具"></a>FPGA 设计工具</h1><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>下面的介绍都是在 Vivado 平台上介绍；</p><h3 id="组合电路：AND"><a href="#组合电路：AND" class="headerlink" title="组合电路：AND"></a>组合电路：AND</h3><p>① 写 Verilog 代码（comb.v）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_comb(data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//combinational circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out = data_1 &amp;&amp; data_2; <span class="comment">// binary bit-wise:&amp;, binary logic:&amp;&amp;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：</p><ul><li>Flow Navigator 里点击 <kbd>File-Project-New</kbd>，<kbd>next</kbd>；</li><li>输入 Project name, Project location，<kbd>next</kbd>；</li><li>选择 RTL Project，<kbd>next</kbd>；</li><li>选择 <kbd>Add Files</kbd>，添加 comb.v 文件，<kbd>next</kbd>；</li><li>如果需要的话，添加或者创建 Constraints Files，<kbd>next</kbd>；</li><li>选择 FPGA device，例如：xa7a12tcpg238-2l，<kbd>next</kbd>；</li><li>回顾：Project Summary，点击 <kbd>Finish</kbd>；</li></ul><p>③ 写 Verilog testbench（comb_sim.v)：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> data_1, data_2;        <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line">    and2_comb and2_comb_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span>               <span class="comment">//signal flow</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>;                  <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>④ 综合逻辑电路，并进行仿真</p><ul><li>Flow Navigator 里点击 <kbd>SYNTHESIS</kbd>，<kbd>Run Synthesis</kbd>；</li><li>之后就能得到一个 netlist，就可以以后进行 functional simulation；</li><li>在 source 窗口里，右键 Simulation Sources，选择 <kbd>Add Sources</kbd>；</li><li>选择 <kbd>Add or Create Simulation Sources</kbd>，添加编写好的 comb_sim.v 文件；</li><li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Functional Simulation</kbd></li></ul><p>⑤ 检查仿真结果</p><ul><li>仿真结束后，点击 Flow Navigator 里的 <kbd>Window</kbd> —&gt; <kbd>Waveform</kbd> 来查看波形图；</li></ul><h3 id="时序电路：AND"><a href="#时序电路：AND" class="headerlink" title="时序电路：AND"></a>时序电路：AND</h3><p>① 写 Verilog 代码：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_seq(clk,data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   clk,data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sequential circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out &lt;= data_1 &amp;&amp; data_2; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：</p><p>③ 写 Verilog testbench：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> clk,data_1, data_2;    <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line"></span><br><span class="line">    and2_seq and2_seq_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> <span class="comment">//signal flow</span></span><br><span class="line">        clk = <span class="number">1</span>; data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>; <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>④ 综合逻辑电路，并进行仿真</p><ul><li>综合，添加仿真文件；</li><li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Timing Simulation</kbd></li></ul><p>⑤ 检查仿真结果</p><h3 id="基于-IP-的电路：32-bit-Multiplier"><a href="#基于-IP-的电路：32-bit-Multiplier" class="headerlink" title="基于 IP 的电路：32-bit Multiplier"></a>基于 IP 的电路：32-bit Multiplier</h3><p>下面会从使用 DSP-IP 和不使用 DSP-IP 两个角度实现；   </p><p>① 写 verilog 代码（mul32.v）：   </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mul32(mula,mulb,product,clk,rst);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mula;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mulb;</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulaq;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulbq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= <span class="number">0</span>;</span><br><span class="line">                    mulbq &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= mula;</span><br><span class="line">                    mulbq &lt;= mulb;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                product &lt;= <span class="number">64'h0123_4567_89ab_cdef</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                product &lt;= mulaq * mulbq;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>② 创建 project：   </p><p>③ 写 Verilog testbench：略   </p><p>④ 综合逻辑电路：</p><ul><li>Flow Navigator 里点击 <kbd>Tools</kbd>，<kbd>Settings</kbd>；</li><li>找到 <kbd>Synthesis</kbd> 选项，设置 <kbd>max_dsp</kbd>为 -1（只用 DSP），0（不用 DSP）；</li></ul><p>⑤ 仿真：   </p><p>⑥ 检查仿真结果；   </p><p>⑦ 比较资源利用报告；</p><h2 id="执行时序分析"><a href="#执行时序分析" class="headerlink" title="执行时序分析"></a>执行时序分析</h2><p>定义时钟：</p><ul><li>在 Flow Navigator 里的 Project Manager section 里选择 <kbd>Add Source</kbd>；   </li><li>在对话框里，选择 <kbd>Add or Create Constraints</kbd>，点击 <kbd>next</kbd>；    </li><li>在接来下的对话框里，选择 <kbd>Create File</kbd>，File type：XDC，输入 File name，点击 <kbd>OK</kbd>，就会产生一个 xdc 的文件；    </li><li>在 Netlist Analysis section 下的 Flow Navigator 里找到 Implement，选择 Edit Timing Constraints；然后就会展示出一个时序约束的编辑窗口；    </li><li>双击 <kbd>Create Clock</kbd>，定义 clock：<ul><li>clock name：可以随便定义，这里定为：clk，它不会和设计中的任何成分匹配；</li><li>Source Object：点击 <kbd>…</kbd>：<ul><li>将后面的 <code>*</code> 改为 <code>*clk</code>，接着 clk 就会出现在 Find result 块里；</li><li>选择 clk，将其拖到 Selected 块里；</li></ul></li><li>OK，finish</li></ul></li><li>接来下就会返回到之前的窗口，会显示刚刚所定义的 clock 的信息；    </li><li>点击 <kbd>Save Constraints</kbd> 保存，双击 timing.xdc 文件，查看；   </li></ul><p>查看时序结果：</p><ul><li>接下来，也是在 Implement 下选择，<kbd>Report Timing Summary</kbd>，会出现一个窗口来显示之前的 timing 的定义，也可以在这里进行修改，之后点击 OK；    </li><li>会在 Design Timing Summary 里显示一些信息，例如：Worst Negative Slack，Worst Hold Slack 和 WPSN 等；    </li><li>也可以为所有的路径都产生一个 timing report：<ul><li>选择 <kbd>Tools</kbd> &gt; <kbd>Timing</kbd> &gt; <kbd>Report Timing</kbd>；</li><li>在产生的窗口里，点击 OK，就会生成一个十分详细的 timing report</li></ul></li></ul><h2 id="执行功耗分析"><a href="#执行功耗分析" class="headerlink" title="执行功耗分析"></a>执行功耗分析</h2><p>在 Synthesis 列里找到 <kbd>Report Power</kbd>，出现一个窗口显示相关的定义，可以修改一些参数等，点击 OK 后，就可以看到一个 Power Analythesis 的窗口，改窗口就显示了一些功耗信息；   </p><h1 id="设计约束与优化"><a href="#设计约束与优化" class="headerlink" title="设计约束与优化"></a>设计约束与优化</h1><p>Constraints 用于影响 FPGA 设计实现工具，包括：synthesizer 以及 place 和 route 工具；</p><ul><li>它们使设计团队可以指定设计性能要求，并指导工具满足这些要求；</li></ul><p>Implementation tools 会根据综合的优化级别，指定的时序，引脚分配以及设计团队提供给工具的逻辑分组来确定其操作的优先级；    </p><p>约束的四种主要类型包括：synthesis，I/O，timing 和 area/location 约束    </p><ul><li><strong>Synthesis constraints</strong>：影响如何将HDL代码合成为RTL的细节。 有多种综合约束，它们的上下文，格式和使用通常在不同工具之间有所不同。</li><li><strong>I/O constraints</strong>（通常也称为引脚分配）：用于将信号分配给特定的 I/O（引脚）或 I/O bank。I/O 约束还可用于为各个 I/O 和 I/O 组指定用户可配置的 I/O 特性；</li><li><strong>Timing constraints</strong>：用于指定设计的时序特性。时序约束可能会影响所有内部时序互连，逻辑和 LUT 以及触发器或寄存器之间的延迟。时间约束可以是全局约束，也可以是路径约束。</li><li><strong>Area constraints</strong>：用于将特定电路映射到 FPGA 内的一系列资源。位置约束指定相对于另一个设计元素或相对于 FPGA 中特定固定资源的位置；</li></ul><h2 id="Synthesis-Constraints"><a href="#Synthesis-Constraints" class="headerlink" title="Synthesis Constraints"></a>Synthesis Constraints</h2><p>综合约束的类型，语法和上下文通常在工具之间有所不同；   </p><p>下表列出了 Xilinx 综合工具（XST）的一些综合约束：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/XST.png" alt="XST">    </p><p>Synthesis Constraints 用于指导综合工具执行特定操作：</p><ul><li>例如，考虑综合约束 CLOCK_BUFFER。该约束用于指定时钟端口上使用的时钟缓冲区的类型；</li><li>可用于优化设计实现的两个重要综合约束是 REGISTER_BALANCING 和 INCREMENTAL_SYNTHESIS<ul><li>REGISTER_BALANCING 寄存器平衡用于优化性能</li><li>INCREMENTAL_SYNTHESIS 增量合成可减少合成时间</li></ul></li></ul><p><strong>Register balancing</strong>：用于通过跨寄存器边界移动布尔逻辑功能的位置来满足设计时序要求。</p><ul><li>寄存器平衡会增加电路时钟频率；</li><li>通过调整相对路径延迟可以获得改进的性能；</li><li>寄存器平衡分为两类，分别称为：forward 正向和 backward 反向平衡<ul><li>前向寄存器平衡旨在将位于 LUT 输入处的一组寄存器移至 LUT 输出处的单个寄存器；</li><li>后向寄存器平衡基于相反的原理，综合工具可将位于 LUT 输出处的寄存器移至 LUT 输入处的一组触发器。</li></ul></li><li>在该过程结束时，可以增加或减少设计中寄存器的总数（不确定）；</li></ul><p><strong>Incremental synthesis</strong>：的主要目的是减少编译设计所需的总时间：</p><ul><li>通过仅综合设计中已更改的部分来执行此操作；</li><li>综合工具在综合阶段可能具有不同的开关或约束，以支持此方法；</li><li>可能会严重影响综合阶段的其他两个因素包括保留已实现的设计层次结构以及正确使用设计约束；</li></ul><h2 id="Pin-Constraints"><a href="#Pin-Constraints" class="headerlink" title="Pin Constraints"></a>Pin Constraints</h2><p>重要的是要注意，引脚分配对于所有设计或设计中的所有引脚并不重要：</p><ul><li>I/O 余量较大或工作速度较慢的设计可能不需要仔细分配引脚；</li><li>但是，如果设计余量受到以下任何 FPGA 设计因素的限制，则引脚分配可能会成为关键因素：<ul><li>I/O 引脚可用性</li><li>FPGA 架构级逻辑资源</li><li>片内路由资源</li><li>所需逻辑速度与最大 FPGA 速度</li><li>所需的逻辑速度与实施设计所需的逻辑层之间的关系</li></ul></li></ul><p>设计时钟注意事项：</p><ul><li>时钟抖动影响会严重降低已实现系统的性能。时钟抖动的影响包括时序预算余量和性能的降低；</li><li>时钟偏差描述了相关信号和时钟到达时间之间的差异。信号和时钟偏斜的影响包括保持时间故障，数据错误和减少的 I/O 时序裕量；</li><li>时钟占空比失真会导致脉冲宽度减小，数据错误和电路性能不可靠；</li><li>时钟抖动，偏斜和占空比失真的影响会影响 FPGA 电路性能的所有水平，应仔细管理和控制；</li><li><strong>将 FPGA 时钟分成优先级组</strong>；<ul><li>使用约束条件来更清楚地表征设计工具的时钟。</li><li>约束可用于指定时钟速率，相位关系和占空比。</li><li>约束还可用于将高优先级时钟与其驱动的电路相关联。</li><li>时钟优先级组：<ul><li>高频率，高扇出</li><li>中频或低频，高扇出</li><li>高频率，低扇出</li><li>中频或低频，低扇出</li></ul></li></ul></li><li><strong>首先分配最高优先级的时钟</strong>。FPGA 时钟最重要的两个挑战是高速和高扇出。具有这些特征的时钟应分配给更高性能的全局资源。高性能缓冲区和路由资源的数量有限，因此应谨慎管理。</li><li><strong>分配时钟块管理资源</strong>。Xilinx’s 的数字时钟管理器（DCM）等时钟模块可以实现高级时钟电路功能，包括分频和乘法，相移，基于反馈的调整和同步时钟生成。时钟块是 FPGA 组件中有限的资源。设计团队应监视和控制如何分配这些资源。</li><li><strong>管理优先级较低的时钟</strong>。尽管较低优先级的时钟可以在完整的 FPGA 全局资源上实现（如果可用），它们也可以通过标准 FPGA 路由结构进行路由。有可能将全局时钟路由分成多个较小的高性能时钟路由。</li></ul><h2 id="Timing-Constraints"><a href="#Timing-Constraints" class="headerlink" title="Timing Constraints"></a>Timing Constraints</h2><p>时序约束可用于影响和指导设计元素的放置以及所放置元素之间的信号路径，以满足设计性能要求；   </p><p>时序约束的两种常规类型是全局约束和特定于路径的：</p><ul><li>全局时序约束涵盖了逻辑设计中的所有路径；</li><li>特定于路径的约束涵盖特定路径；</li></ul><p>指定时钟和数据信号的关系以及时序，以确保不违反内部 FPGA 寄存器的设置和保持时间要求；   </p><p>以下两个约束的时序关系为实施工具提供了最佳实施设计所需的信息：</p><ul><li>OFFSET_IN_BEFORE 约束用于定义在系统时钟的上升沿到达 FPGA 时钟引脚之前，数据信号应有效的时间；</li><li>VALID 约束用于指定系统时钟上升沿之后数据信号有效的时间量和数据信号有效的时间量；</li></ul><p>使用系统同步定时方法将信号从 FPGA 内部的寄存器发送到外部组件：</p><ul><li>了解 FPGA 对外部设备时序的要求是约束过程的第一步；</li><li>必须确定外部组件接口 I/O 标准，到外部组件的路由延迟以及 FPGA I/O 引脚的负载；</li><li>了解详细的时序值可以支持时序约束的分配，从而指定数据信号必须从内部 FPGA 寄存器的输出传播到 FPGA 输出引脚的最长时间；</li><li>FPGA 的内部延迟包括时钟路径延迟，寄存器时钟到输出时间以及从寄存器到输出引脚的数据路径延迟；</li></ul><p>基于这些约束，实现工具可以确定满足指定时序要求的路径路由。</p><h2 id="Area-Constraints"><a href="#Area-Constraints" class="headerlink" title="Area Constraints"></a>Area Constraints</h2><p>Area 限制了引导和控制布局布线工具可能将 FPGA 设计元素放置在何处：</p><ul><li>区域约束还可以定义设计元素的潜在放置区域。</li><li>区域约束的好处是可以减少布局布线工具的实施时间。</li><li>如果 block element 受区域限制，则放置和布线工具不必搜索放置 block element 的位置；</li><li>将多个设计元素块布置到目标 FPGA 架构上的过程通常称为布局规划；</li></ul><h2 id="Design-Optimization"><a href="#Design-Optimization" class="headerlink" title="Design Optimization"></a>Design Optimization</h2><p>设计优化是一个增量过程，需要增加工程量和工具计算时间来利用设计来满足时序要求。</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FPGAOptimization.png" alt="FPGAOptimization"></p><h1 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h1><p>设计练习1：组合电路 ⎯ 1 位加法器<br>设计练习2：组合电路 ⎯ 2 位乘法器<br>设计练习3：时序电路 ⎯ 1 位计数器<br>设计练习4：时序电路 ⎯ 4 位移位寄存器  </p><p>提示：在 Vivado 上执行 FPGA 设计:</p><ul><li>编写 Verilog 代码</li><li>创建项目</li><li>编写 Verilog testbench</li><li>综合逻辑电路</li><li>检查仿真结果 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 FPGA 具体的实验操作；&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-Outlook：New FPGA</title>
    <link href="http://www.thebetterkong.cn/2020/06/09/FPGA-technology/FPGA-Outlook-NewFPGA/"/>
    <id>http://www.thebetterkong.cn/2020/06/09/FPGA-technology/FPGA-Outlook-NewFPGA/</id>
    <published>2020-06-09T08:20:32.000Z</published>
    <updated>2020-08-14T09:31:27.837Z</updated>
    
    <content type="html"><![CDATA[<p>这是 FPGA 学习的最后一章。未来 FPGA 的发展也必定会迎合前沿时代的需求，例如：大数据时代的高性能计算、还有 AI 智能等等。</p><a id="more"></a> <h1 id="FPGA-高级综合（HLS）"><a href="#FPGA-高级综合（HLS）" class="headerlink" title="FPGA 高级综合（HLS）"></a>FPGA 高级综合（HLS）</h1><h2 id="HLS-发展动机"><a href="#HLS-发展动机" class="headerlink" title="HLS 发展动机"></a>HLS 发展动机</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLS.png" alt="HLS"></p><ul><li><strong>片上系统（SoC）设计</strong>复杂性的迅速增加鼓励了设计社区寻求比 RTL 更好的生产率的设计抽象； </li><li>电子系统级（ESL）设计的自动化已被广泛认为是半导体行业提高生产率的下一个推动力，HLS（例如 C 语言或 SystemC） 在其中发挥着核心作用;<ul><li>它可以实现 high-level 到 low-level 的自动综合，以在 FPGA（或 ASIC）中高效实现；</li><li>high-level 时只需 untimed 或 partially-timed 的规范，而像 RTL（寄存器传输级） 的 low-level 则需要考虑精确的时钟周期（延迟）；</li></ul></li><li>可以综合考虑特定系统的性能，功耗和成本要求来优化此综合；</li><li>这样，设计者只需利用 HLS 来设计电路，而精确的电路优化等工作就可以完全交由其他的综合软件来自动化完成，提高开发设计效率；</li></ul><h2 id="相关现状"><a href="#相关现状" class="headerlink" title="相关现状"></a>相关现状</h2><p>基于上述原因，也就迫使 FPGA 设计人员更快地采用 HLS 工具：</p><ol><li>减少正式验证的压力：<ul><li>纳米 IC 技术的 ASIC 制造成本超过 100 万美元，这就使 ASIC 设计人员要保证流片后一次成功，将承受巨大压力；</li><li>然而，要实现上述的要求，就依赖于 HLS 的正式验证工具，而这种工具的发展还不成熟，并且对于数百万 gate SOC 设计的仿真覆盖范围可能会受到限制；</li><li>这是在 ASIC 界采用 HLS 的重大障碍；</li><li>但是，对于 FPGA 设计，系统内仿真（直接在 FPGA 芯片上进行仿真，如果出现问题再进行调整，因为 FPGA 是可重配置的，所以这样的 cost 比较低）可以获得更广泛的仿真范围；</li><li><strong>设计迭代可以快速，廉价地完成，而无需付出巨大的制造成本</strong>；</li></ul></li><li>基于平台综合的理想选择：<ul><li>现代 FPGA 嵌入了许多预定义/制造的 IP 组件，例如：算术功能单元，嵌入式存储器，嵌入式处理器和嵌入式系统总线；</li><li>可以为每个 FPGA 平台提前对这些预定义的构建模块进行精确建模，并在很大程度上限制了设计空间；</li><li>因此，现代 HLS 工具可以应用基于平台的设计方法，获得更高的结果质量（QoR）</li></ul></li><li>上市时间的压力更大：<ul><li>FPGA 平台通常被选择用于十分看重上市时间的系统，以避免长时间的芯片设计和制造周期；</li><li>因此，设计人员可能会接受牺牲性能，功耗或成本，来减少设计时间；</li><li>现代的 HLS 工具将这种 tradeoff 的权利交给了设计人员，从而大大减少了设计时间，或者通过额外的努力，获得了与手写 RTL 相当的结果质量；</li></ul></li><li>加速或可重构的计算要求，需要 FPGA 可以基于 C/C ++ 进行编译/综合：<ul><li>FPGA 的最新发展使可重构计算平台，能用于加速许多高性能计算（HPC）应用程序，例如：图像和视频处理，财务分析，生物信息学和科学计算应用程序；</li><li>由于 VHDL 或 Verilog 中的 RTL 编程对于大多数应用软件开发人员来说是不可接受的，因此必须提供从 C/C++ 到 FPGA 的高度自动化的编译/综合流程；</li></ul></li></ol><h2 id="实现更高层次的设计"><a href="#实现更高层次的设计" class="headerlink" title="实现更高层次的设计"></a>实现更高层次的设计</h2><ul><li>从更高层次的描述性语言生成高质量的 RTL<ul><li>有益于功能验证和架构探索；</li><li>RTL 设计过程中不断迭代带来的时间开销可以被消除；</li><li>RTL 目标转向技术和频率；</li></ul></li><li>C++ 提供了更好的抽象级；SystemC 则可以提供时序上的设计；</li><li>许多关键应用已经开始使用 HLS 实现：<ul><li>Video Compression / Decompression (H.265/HEVC,VP9)</li><li>Image Processing ( Mobile/Ultra HD/3D)</li><li>Wireless/Wireline (5G,802.11x,Gb optical)</li></ul></li></ul><h2 id="FPGA-HLS-案例"><a href="#FPGA-HLS-案例" class="headerlink" title="FPGA HLS 案例"></a>FPGA HLS 案例</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLSExample.png" alt="HLSExamp"></p><ul><li>缺少直接的仿真工具；</li><li>在用 c/c++ 等高级语言描述时，并不是所有的语句都是可综合的，在遇到不可综合的语句时，需要我们改变语句写法；</li></ul><h1 id="面向深度神经网络（DNN）的-FPGA-设计"><a href="#面向深度神经网络（DNN）的-FPGA-设计" class="headerlink" title="面向深度神经网络（DNN）的 FPGA 设计"></a>面向深度神经网络（DNN）的 FPGA 设计</h1><p>FPGA 的主频虽然不高（不超过 1G），但是它可做大量的并行计算；</p><h2 id="FPGA-vs-GPU"><a href="#FPGA-vs-GPU" class="headerlink" title="FPGA vs. GPU"></a>FPGA vs. GPU</h2><ul><li>GPU（Graphics Processing Unit）—&gt; 通过软件编程的 ALU 阵列架构（粗粒度） —&gt; 具有统一数据类型（32位对应32位，64位对应64位）的常规计算<ul><li>功耗比较高</li></ul></li><li>FPGA —&gt; 通过硬件配置的并行数据处理架构（细粒度） —&gt; 具有自定义数据类型的常规和不规则计算（可以很好的适应神经网络中稀疏和细粒度的计算要求）<ul><li>因此，FPGA 可定制性更强，单位功耗的处理能力优于 GPU；</li></ul></li></ul><h2 id="迈向百亿分之一计算的并行性胜利"><a href="#迈向百亿分之一计算的并行性胜利" class="headerlink" title="迈向百亿分之一计算的并行性胜利"></a>迈向百亿分之一计算的并行性胜利</h2><ul><li>卷积神经网络（CNN）可在各种 AI 任务中提供最先进的准确性，但计算量大且耗能！</li><li>摩尔定律已经快到达极限，技术扩展速度变慢；</li><li>多核芯片达到了性能功耗比的上限；</li><li>处理器与内存之间的性能差距，形成了 wall；</li><li>需要去寻找高性能的计算芯片；</li><li>并行性在高性能计算中，占比越来越高；</li><li>期望通过<strong>并行性</strong>获得更多的系统性能（通过增加更多的处理核心）</li></ul><h2 id="机器学习和神经网络中的-FPGA-表现"><a href="#机器学习和神经网络中的-FPGA-表现" class="headerlink" title="机器学习和神经网络中的 FPGA 表现"></a>机器学习和神经网络中的 FPGA 表现</h2><ul><li>FPGA 是一种具有竞争性的 HPC（高性能计算）加速器技术；</li><li>FPGA 在人工智能计算中的性能比 CPU、GPU 和 ASIC 高几倍；</li><li>FPGA 实现了峰值性能的高利用率；</li><li>每瓦特的性能：FPGA 非常节能，同时非常灵活</li></ul><h2 id="why-FPGA-power-efficient"><a href="#why-FPGA-power-efficient" class="headerlink" title="why FPGA power efficient"></a>why FPGA power efficient</h2><p>为了减少能量消耗，少移动数据：</p><ul><li>数据移动会消耗更多的能量，FPGA 每次计算执行的数据移动较少；</li><li>互连消耗的能量（每毫米）的降低速度比计算消耗的能量的降低速度慢，片上数据移动消耗的能量将开始占主导地位；</li></ul><p>对于 FPGA 来说，并行性本质上是导致能量效率缩放的原因：</p><ul><li>随着工艺的先进，FPGA 的性能功耗比不断上升，而 CPU/GPU 的性能功耗比却呈下降趋势</li></ul><h2 id="解决-FPGA-设计问题的途径"><a href="#解决-FPGA-设计问题的途径" class="headerlink" title="解决 FPGA 设计问题的途径"></a>解决 FPGA 设计问题的途径</h2><p>FPGA 也需要迅速发展以拥抱新的尖端技术：</p><ul><li>计算问题：传统的 FPGA 体系结构不能很好地匹配 DNN（深度神经网络）算法的执行</li><li>需要面向 DNN 的 FPGA 数据处理架构设计</li></ul><p>CNN Algorithm：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNAlgorithm.png" alt="CNNAlgorithm"></p><ul><li>通过图层重复操作：Convolutional + Fully Connected + Pooling</li></ul><p>两种策略：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/TwoApproaches.png" alt="TwoApproaches"></p><ul><li>当前的 FPGA 综合流程并未考虑 CNN 的并行计算属性-<strong>非优化的实现</strong>（完全取决于设计人员精心设计的 Verilog 代码）</li><li>完全并行实施的资源（DSP 块和 BRAM 的数量）限制</li></ul><h2 id="目前-CNN-在-FPGA-上的实现"><a href="#目前-CNN-在-FPGA-上的实现" class="headerlink" title="目前 CNN 在 FPGA 上的实现"></a>目前 CNN 在 FPGA 上的实现</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNImplementation.png" alt="CNNImplementation">   </p><p>在 DNN 中压缩数据：</p><ul><li>量化：将浮点运算转换为定点运算</li><li>共享：分组权重</li><li>修剪：切掉小重量的树枝</li></ul><h2 id="适合-FPGA-的目标-AI-应用"><a href="#适合-FPGA-的目标-AI-应用" class="headerlink" title="适合 FPGA 的目标 AI 应用"></a>适合 FPGA 的目标 AI 应用</h2><ul><li>尺寸和能量受限的前端：<strong>边缘计算</strong></li><li>低功耗和高并行处理所需的数据中心：<strong>云计算</strong>（ 云和嵌入式系统的需求）</li></ul><h1 id="发展挑战和机遇"><a href="#发展挑战和机遇" class="headerlink" title="发展挑战和机遇"></a>发展挑战和机遇</h1><h2 id="FPGA-技术趋势"><a href="#FPGA-技术趋势" class="headerlink" title="FPGA 技术趋势"></a>FPGA 技术趋势</h2><p>四个时代的 FPGA:</p><ul><li>1984年-1991年：发明 Invention</li><li>1992年-1999年：扩张 Expansion</li><li>2000年-2007年：积累 Accumulation</li><li>2008年-2017年：融合 Fusion</li><li>2018年：可编程计算架构创新？</li></ul><h2 id="新兴技术驱动的-FPGA"><a href="#新兴技术驱动的-FPGA" class="headerlink" title="新兴技术驱动的 FPGA"></a>新兴技术驱动的 FPGA</h2><ol><li>新的可编程 brain inspired computing 体系结构—-现场可编程神经阵列(FPNA)</li><li>新的可编程 in-memory computing 体系结构</li><li>基于新设备(rRAM)的可编程计算体系结构</li></ol><h2 id="现在可能得到答案的问题"><a href="#现在可能得到答案的问题" class="headerlink" title="现在可能得到答案的问题"></a>现在可能得到答案的问题</h2><p>[ Steve Trimberger, Fellow, Xilinx Research Labs, 2014 ]：</p><ul><li>为什么 FPGA 编译时间这么长？FPGA 公司愚蠢吗？还是他们不在乎？</li><li>为什么选择 LUT？那是自然法则还是什么？</li><li>为什么动态编程的 FPGA 从来没有到过任何地方？现在可以改变吗？<ul><li>Tabula 的“时空” 3D FPGA 架构将时间作为第三维度，从而允许以高达 2 GHz 的时钟速率动态地重新配置片上逻辑，存储器和互连资源。</li></ul></li><li>为什么没有规范的 FPGA 架构？</li><li>可重构计算发生了什么？</li><li>如果处理器是新的 LUT，那么处理器阵列呢？</li><li>FPGA 的多芯片分区发生了什么？</li><li>模拟 FPGA 呢？那么异步 FPGA 呢？</li><li>为什么 FPGA 制造商不提供 ASIC 转换？</li><li>FPGA 制造商为什么要坚持拥有自己的位置和路线？他们也会接管逻辑综合吗？那么高级综合呢？</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>可编程设备的创新以非常快的速度持续进行；</li><li>在未来几年中，我们可以预期制造商将利用设计和制造技术两者的优势来继续提高 FPGA 的功能；</li><li>摩尔定律的终结可能即将到来，但是 FPGA 的用户可以期待更多代的性能和功能的提高；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是 FPGA 学习的最后一章。未来 FPGA 的发展也必定会迎合前沿时代的需求，例如：大数据时代的高性能计算、还有 AI 智能等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础入门</title>
    <link href="http://www.thebetterkong.cn/2020/06/07/Git/GitStart/"/>
    <id>http://www.thebetterkong.cn/2020/06/07/Git/GitStart/</id>
    <published>2020-06-07T13:51:07.000Z</published>
    <updated>2020-08-14T09:12:29.605Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/GitStart/header.png" width="100%" alt="header.png" /> </div>   <p>使用 git 已经挺长时间了，也在网上看过不少的学习教程。但是怎么说呢，git 的操作实在是太杂了，某一种目标可能就有好多种不同的实现方式，而且这些不同的实现方式又可能产生不同的结果。以至于，每次在网上查找到的解决方案可能都不同，然后不停地往 OneNote 里记笔记，时间久了，笔记越来越乱，再加上记忆力本就不好，原先不会的现在还是不会。于是寻思着简单的梳理一下。</p><a id="more"></a><h1 id="认识-git"><a href="#认识-git" class="headerlink" title="认识 git"></a>认识 git</h1><h2 id="什么是-git？"><a href="#什么是-git？" class="headerlink" title="什么是 git？"></a>什么是 git？</h2><p>它是一个<strong>分布式版本控制系统</strong>，用于项目开发中的版本控制；</p><ul><li>从本质上来讲 Git 是一个<strong>内容寻址（content-addressable）文件系统</strong>，并在此之上提供了一个版本控制系统的用户界面；</li><li>它的核心其实就是<strong>键值对数据库（key-value data store）</strong>，</li></ul><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>git 管理下的项目的文件分为：<strong>已跟踪</strong>和<strong>未跟踪</strong>两种状态</p><ul><li>已跟踪的文件：是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区；</li><li>工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区；</li><li>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态；</li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul><li>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>文件快照</strong>；</li><li>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>；</li><li>该提交对象会包含一个指向暂存内容快照的指针，但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针；</li></ul><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p><img src="http://img.thebetterkong.cn/blog/GitStart/gitmemory.png" alt="gitmemory">   </p><div class="table-container"><table><thead><tr><th>名称</th><th>区域</th><th>解释</th></tr></thead><tbody><tr><td>Workspace</td><td>工作区</td><td>当前用户操作修改的区域</td></tr><tr><td>Index/Stage</td><td>暂存区</td><td>add 后的区域</td></tr><tr><td>Repository</td><td>仓库区或本地仓库</td><td>commit 后的区域</td></tr><tr><td>Remote</td><td>远程仓库</td><td>push 后的区域</td></tr></tbody></table></div><h1 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真要说起来 git 里的难点也就是分支的使用。之前在同学的 blog 里找到了一个很好的学习 git 分支的平台：<a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">learnGitBranching</a>。与其说是学习，你更可以在无聊的时候把它当作一个 “游戏”，一边玩耍一边学习。其实最主要的，还是它能动态的帮助你理解 git 命令。</p><p><img src="http://img.thebetterkong.cn/blog/GitStart/Learngitbranching.png" alt="Learngitbranching">   </p><p>接下来的描述也会对它的一些操作进行梳理，毕竟复习或者查阅的时候，再去网站操作一遍，效率比较低。    </p><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>在正式介绍命令之前，先对 git 里常用的<strong>符号或者关键字</strong>进行说明：  </p><ul><li>分支名后带有符号 <code>*</code>：表示当前分支 </li><li><code>HEAD</code>：通常会和当前分支绑定在一起，总是指向当前分支上最近一次提交记录；<ul><li>但是也可以 <code>git checkout c1</code> 来<mark><strong>分离 HEAD</strong></mark>（c1 是某次提交记录的 hash 值，通常会很长，可以使用 <code>git log</code> 查看；当然了，也可以利用 tag 实现），使其指向某次具体的提交记录；分离之后的提交将不属于任何分支，一般的做法是在此处再创建一个新的分支，然后再 commit 进行后续的操作；</li><li>大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的；</li></ul></li><li>相对引用 <code>^</code>：向上移动一个提交记录，可叠加使用，如：HEAD^^^<ul><li>要注意：引用可以是分支名或者 HEAD，提交记录（如 c1）不算引用</li></ul></li><li>相对引用 <code>~&lt;num&gt;</code>：向上移动 num 个提交记录，如：~3</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">******************************************************</span><br><span class="line">##### git 配置</span><br><span class="line">$ git config --global user.name &quot;&lt;用户名&gt;&quot;</span><br><span class="line">$ git config --global user.email &quot;&lt;电子邮件&gt;&quot;</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 初始化仓库</span><br><span class="line">$ git init </span><br><span class="line">$ rm -rf .git   &#x2F;&#x2F; 删除本地仓库</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看当前缓存区状态</span><br><span class="line">$ git status    </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看历史提交记录</span><br><span class="line">$ git log</span><br><span class="line">$ git log --decorate        &#x2F;&#x2F; 显示包含标签资料的历史记录；</span><br><span class="line">$ git log --pretty&#x3D;oneline  &#x2F;&#x2F; 只看版本号和提交的版本信息</span><br><span class="line">$ git log --graph            &#x2F;&#x2F; 查看分支合并图</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看文件的修改</span><br><span class="line">$ git diff &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 将修改添加到缓存区</span><br><span class="line">$ git add -A    &#x2F;&#x2F; 所有文件都添加，也可以使用 $ git add .</span><br><span class="line">$ git rm --cached &lt;file&gt;  &#x2F;&#x2F; 删除缓存，撤销 git add 的操作</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 提交变更</span><br><span class="line">$ git commit -m &quot;version 1.2&quot;   &#x2F;&#x2F; 引号内是本次提交的命名</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 克隆远程数据库 </span><br><span class="line">$ git clone &lt;repository&gt; &lt;directory&gt;</span><br><span class="line">  &#x2F;&#x2F; 在&lt;repository&gt;指定远程数据库的URL；</span><br><span class="line">  &#x2F;&#x2F; 在&lt;directory&gt;指定新目录的名称，省略时默认为当前目录；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 从远程数据库拉取更新至本地 </span><br><span class="line">$ git pull &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">  &#x2F;&#x2F; &lt;repository&gt; 处输入远程数据库地址；</span><br><span class="line">  &#x2F;&#x2F; &lt;refspec&gt; 处指定远程数据库的分支；</span><br><span class="line">$ git pull                &#x2F;&#x2F; github 上常用的抓取最新提交的方式</span><br><span class="line">$ git pull origin develop &#x2F;&#x2F; 从远程 origin 数据库的 develop 分支抓到本地的当前分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 将本地数据推送至远程数据库</span><br><span class="line">$ git push &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">$ git push origin master &#x2F;&#x2F; 将本地的当前分支推送至远程 origin 数据库的 master 分支</span><br><span class="line">$ git push -u origin master </span><br><span class="line">  &#x2F;&#x2F; 第一次推送 master 分支时，远程库是空的，加上了-u 参数，</span><br><span class="line">  &#x2F;&#x2F; Git 不但会把本地 master 分支内容推送至远程新的 master </span><br><span class="line">  &#x2F;&#x2F; 分支，还会把本地 master 分支和远程 master 分支关联起来，</span><br><span class="line">  &#x2F;&#x2F; 以后就可以直接 git pull &#x2F; git push 简化命令</span><br><span class="line">$ git push --set -upstream &lt;远程仓库名称&gt; &lt;远程仓库中分支名称&gt;</span><br><span class="line">  &#x2F;&#x2F; 手动将本地当前分支与远程仓库的分支关联</span><br><span class="line">$ git push -f origin master  &#x2F;&#x2F; 强制推送</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 添加远程数据库</span><br><span class="line">$ git remote add &lt;name&gt; &lt;url&gt;  </span><br><span class="line">  &#x2F;&#x2F; 添加的同时，给远程数据库命名，以后不用再输入URL；</span><br><span class="line">  &#x2F;&#x2F; 默认为：origin</span><br><span class="line">$ git remote set-url &lt;name&gt; &lt;url&gt;  &#x2F;&#x2F; 修改 git 的 remote url</span><br><span class="line">$ git config -e                    &#x2F;&#x2F; 从配置里修改 git 的 remote url</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的创建&#x2F;查看&#x2F;修改</span><br><span class="line">$ git branch                   &#x2F;&#x2F; 显示分支列表（带*的为当前分支）；</span><br><span class="line">$ git branch &lt;branchname&gt;      &#x2F;&#x2F; 创建分支并命名；</span><br><span class="line">$ git branch -d &lt;branchname&gt;   &#x2F;&#x2F; 删除本地分支；</span><br><span class="line">$ git push origin --delete &lt;branchname&gt; &#x2F;&#x2F; 删除远程分支；</span><br><span class="line">$ git branch -f master HEAD~3  &#x2F;&#x2F; 将 master 分支强制指向 HEAD 的第 3 级父提交；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的退出&#x2F;切换</span><br><span class="line">$ git checkout &lt;branchname&gt;     &#x2F;&#x2F; 退出当前分支并切换到其他分支；</span><br><span class="line">$ git checkout -b &lt;branchname&gt;  &#x2F;&#x2F; 创建分支并进行切换；</span><br><span class="line">$ git checkout commit_id&#x2F;tag    &#x2F;&#x2F; 分离 HEAD 至 commit_id&#x2F;tag 的提交处 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支合并 merge</span><br><span class="line">$ git merge &lt;branch&gt;           &#x2F;&#x2F; 将指定分支合并到当前分支</span><br><span class="line">$ git merge --squash &lt;branch&gt;  &#x2F;&#x2F; 将目标分支的所有提交压缩为一个，并添加到当前分支；</span><br><span class="line">$ git merge --abort            &#x2F;&#x2F; 取消当前合并，重建合并前状态 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支重定向 rebase（也可用来分支合并）</span><br><span class="line"> &#x2F;&#x2F; Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去；</span><br><span class="line"> &#x2F;&#x2F; 若用在分支合并，相比于 merge，可以创造更线性的提交历史</span><br><span class="line">$ git rebase &lt;branch&gt;   &#x2F;&#x2F; 把当前分支重定向到目标分支;</span><br><span class="line">$ git rebase --abort    &#x2F;&#x2F; 取消 rebase；</span><br><span class="line">$ git rebase -i HEAD~2  &#x2F;&#x2F; 编辑模式修改分支基准（修改pick，实现压缩squash&#x2F;修改edit等）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 选择重构 cherry-pick</span><br><span class="line">$ git cherry-pick &lt;commit&gt;...   &#x2F;&#x2F; 取出选择的提交并添加到当前分支</span><br><span class="line">  </span><br><span class="line">*******************************************************</span><br><span class="line">#### 还原 revert</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git revert HEAD   &#x2F;&#x2F; 取消某次提交（会新增否定的历史记录来实现）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 重置 reset</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git reset --hard HEAD^  &#x2F;&#x2F; 重置结构 &#x2F;（删除）提交等（历史记录会消失）</span><br><span class="line">$ git reset --hard commit_id</span><br><span class="line">&#x2F;&#x2F; 如果想让服务器也回退到该版本的话：$ git push origin HEAD --force</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 标签 tag</span><br><span class="line">$ git tag                       &#x2F;&#x2F; 显示标签列表；</span><br><span class="line">$ git tag -n                    &#x2F;&#x2F; 显示标签列表及注解；</span><br><span class="line">$ git tag &lt;tagname&gt; &lt;commit_id&gt; &#x2F;&#x2F; 新建一个轻标签，默认为 HEAD，也可以指定commit id</span><br><span class="line">$ git tag -am &lt;注释&gt; &lt;tagname&gt;  &#x2F;&#x2F; HEAD 指向的提交里打上注释标签；</span><br><span class="line">$ git tag -d &lt;tagname&gt;          &#x2F;&#x2F; 删除本地标签；</span><br><span class="line">$ git checkout &lt;tagname&gt;        &#x2F;&#x2F; 切换到对应标签的提交点，会分离 HEAD</span><br><span class="line">$ git push origin &lt;tagname&gt;     &#x2F;&#x2F; 想远程仓库推送一个 tag</span><br><span class="line">$ git push origin --tags        &#x2F;&#x2F; 推送全部未推送过的本地 tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt; &#x2F;&#x2F; 删除一个远程标签</span><br></pre></td></tr></table></figure><p>更多详情：『<a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git 官方手册</a>』</p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>总结常用命令，还是免不了量越来越大，变得混乱的问题。所以，再加上一个模块，记录一些可能不那么常用的组合操作；   </p><p>这一块内容以后会慢慢不断更新；</p><p>先扔一个 Git 常用操作的索引：『<a href="https://backlog.com/git-tutorial/cn/reference/" target="_blank" rel="noopener">Git 操作索引</a>』</p><h3 id="修改-commit-注释"><a href="#修改-commit-注释" class="headerlink" title="修改 commit 注释"></a>修改 commit 注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~2    &#x2F;&#x2F; 选择至所需修改的节点</span><br><span class="line">&#x2F;&#x2F; 会出现 pick: commit_id &lt;注释&gt;， 将要改的那行的 pick 改成 edit 然后退出</span><br><span class="line">&#x2F;&#x2F; 此时使用 $ git log，可以版本已经变成了你想改的那个</span><br><span class="line">&#x2F;&#x2F; 修改版本提交注释</span><br><span class="line">$ git commit --amend      &#x2F;&#x2F; 接受，保存修改，并提交</span><br><span class="line">$ git rebase --continue   &#x2F;&#x2F; 接受 rebase 的执行</span><br></pre></td></tr></table></figure><h3 id="取消-track-某一文件"><a href="#取消-track-某一文件" class="headerlink" title="取消 track 某一文件"></a>取消 track 某一文件</h3><p><code>git rm -r --cache &lt;file_name&gt;</code></p><ul><li>untrack 后，使用 commit -a 时，不会将其添加到暂存区中；</li><li>之后会在 .ignore 文件中将该 untrack 的文件添加进去，完成；</li></ul><h3 id="文件暂存（栈）"><a href="#文件暂存（栈）" class="headerlink" title="文件暂存（栈）"></a>文件暂存（栈）</h3><p>你要把现在正在工作的分支保存下来，等处理完其他的再回来接着当前分支的修改工作：</p><ol><li>将当前分支的修改暂存起来（此处不等于 add+commit）：<code>git stash</code><ul><li>备份当前的工作区的内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到 Git 栈中暂存起来。</li></ul></li><li>切换到别的分支工作，完成后切换回原来的工作分支，查看暂存列表 <code>git stash list</code>：<ul><li>显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复</li></ul></li><li>恢复暂存的修改到工作区 <code>git stash apply &lt;stash_name&gt;</code> 恢复暂存之后不删除暂存：<ul><li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容。</li></ul></li><li>或者 <code>git stash pop</code> 恢复暂存之后删除暂存：<ul><li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容；</li><li>之后 pop 会删除最新的暂存；</li></ul></li><li>删除 “暂存”：<code>git stash drop &lt;stash_name&gt;</code><ul><li>从 Git 栈删除最旧的一个暂存</li></ul></li><li>结束</li></ol><h1 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h1><h2 id="Branch-管理"><a href="#Branch-管理" class="headerlink" title="Branch 管理"></a>Branch 管理</h2><p>推荐使用如下 5 个分支开发管理：</p><p><img src="http://img.thebetterkong.cn/blog/GitStart/BranchManage.png" alt="BranchManage"></p><div class="table-container"><table><thead><tr><th>分支</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>master 分支</td><td>主分支(保护分支)</td><td>只负责管理发布的状态，在提交时使用标签记录发布版本号</td></tr><tr><td>develop 分支</td><td>开发分支</td><td>针对发布的日常开发分支</td></tr><tr><td>feature 分支</td><td>特性分支</td><td>- 这个分支是针对<strong>新功能的开发</strong>，在 bug 修正的时候从 develop 分支分叉出来的；<br>- 基本上不需要共享特性分支的操作，所以不需要远端控制，完成开发后，把分支合并回 develop 分支后发布；</td></tr><tr><td>release 分支</td><td>发布分支</td><td>- 一般的开发是在 develop 分支上进行的，到了可以发布的状态时再创建 release 分支，为 release 做最后的 bug 修正；<br>- 到了可以 release 的状态时，把 release 分支合并到 master 分支，并且在合并提交里添加 release 版本号的标签；<br>- 注意：要导入在 release 分支所作的修改，也要合并回 develop 分支；</td></tr><tr><td>fix 分支</td><td>bug 修复分支</td><td>需要根据实际情况对已发布的版本进行漏洞修复；</td></tr></tbody></table></div><p>详见：『<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">原文</a>』</p><h2 id="Tag-管理"><a href="#Tag-管理" class="headerlink" title="Tag 管理"></a>Tag 管理</h2><p>通常 Tag 采用三段式：<code>v版本.里程碑.序号（v2.3.1）</code></p><ul><li>架构升级或架构重大调整，修改第 1 位</li><li>新功能上线或者模块大的调整，修改第 2 位</li><li>bug 修复上线，修改第 3 位</li></ul><h2 id="Commit-管理"><a href="#Commit-管理" class="headerlink" title="Commit 管理"></a>Commit 管理</h2><p>不管采用怎样的表述方式，最终目标都是：<strong>表达清楚、格式统一、方便快速阅读和定位</strong></p><p>建议格式（type：scope：body：issue） ：</p><ul><li><code>&lt;|新功能|修改|Bug修复|重构|测试&gt;（影响模块）提交描述信息（#issue?）</code></li></ul><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>这个模块先仍在这，之前遇到的问题也没怎么记录，这篇文章已经把我总结的有点头大了。以后，再遇到问题再在这里更。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">Learngitbranching</a></li><li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的 Git</a></li><li>另，本篇文章是根据以前的笔记写的，以前的笔记也有参考网上资料，但是记不清来源了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/GitStart/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;使用 git 已经挺长时间了，也在网上看过不少的学习教程。但是怎么说呢，git 的操作实在是太杂了，某一种目标可能就有好多种不同的实现方式，而且这些不同的实现方式又可能产生不同的结果。以至于，每次在网上查找到的解决方案可能都不同，然后不停地往 OneNote 里记笔记，时间久了，笔记越来越乱，再加上记忆力本就不好，原先不会的现在还是不会。于是寻思着简单的梳理一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.thebetterkong.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.thebetterkong.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（详解 + java 实现）</title>
    <link href="http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/"/>
    <id>http://www.thebetterkong.cn/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/</id>
    <published>2020-06-04T06:58:23.000Z</published>
    <updated>2020-08-14T09:29:12.959Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  <p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。</p><a id="more"></a> <h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，我们会将排序算法分为两个大类：     </p><div class="table-container"><table><thead><tr><th>类名</th><th>解释</th></tr></thead><tbody><tr><td>内部排序</td><td>（本文主要讨论的）待排序记录存放在计算机随机存储器中进行的排序过程；</td></tr><tr><td>外部排序</td><td>待排序记录的数量很大，以至于内存一次不能够容纳全部记录，在排序过程中尚需对外村进行访问的排序过程；</td></tr></tbody></table></div><p>在排序算法中，为了衡量每一种算法的性能，我们通常会提及如下概念：     </p><div class="table-container"><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>稳定排序</td><td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序；</td></tr><tr><td>非稳定排序</td><td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序；</td></tr><tr><td>原地排序</td><td>在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间来进行比较和交换，从而完成排序；</td></tr><tr><td>非原地排序</td><td>需要利用额外的数组来辅助排序；</td></tr></tbody></table></div><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ul><li><strong>依据排序原则可分为 5 大类</strong>：插入排序、交换排序、选择排序、归并排序、计数排序</li><li><strong>按算法时间分为 3 大类</strong>：简单排序 $O(n^2)$、先进排序 $O(nlogn)$、基数排序 $O(d \cdot n)$</li></ul><p>接下来介绍的各种排序算法都可以归入上述各个分类；</p><h2 id="规律总述"><a href="#规律总述" class="headerlink" title="规律总述"></a>规律总述</h2><p>排序过程中都会进行两种基本操作：</p><ol><li>比较两个关键字大小；（对大多数排序方法都是必要的）</li><li>将记录从一个位置移动到另一个位置；（可通过改变记录的存储方式来避免）</li></ol><p>待排序记录的 3 种存储方式：    </p><div class="table-container"><table><thead><tr><th>存储方式</th><th>记录之间的次序关系</th><th>排序实现方式</th></tr></thead><tbody><tr><td>地址连续的一组存储单元上（例如：线性表）</td><td>由存储位置决定</td><td>必须借助记录移动</td></tr><tr><td>（链表排序）静态链表中</td><td>指针指示</td><td>修改指针即可</td></tr><tr><td>（地址排序）记录本身存储在一组地址连续的存储单元内，同时又设一个指示各个记录存储位置的地址向量</td><td></td><td>先移动地址向量中记录的“地址”，排序结束后再按地址向量中的值调整记录的存储位置</td></tr></tbody></table></div><p>本文主要是介绍排序算法的思想，为方便讨论，默认所介绍的排序算法都是基于第一种存储方式，且待排序记录的关键字均为整数；</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>基于 “插入” 操作进行的排序方式；</p><h2 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h2><p><strong>基本操作</strong>：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</p><ul><li>整个过程可以理解为，打扑克牌时，你是怎样来捋扑克牌的顺序的？</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gInsertSort.gif" alt="InsertSort"></p><p><strong>缺点</strong>：无序数组排序时，为了插入元素，需要将其余所有元素在插入之前都向右移动一位；</p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的排序算法：直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 开始 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从当前位置向前寻找插入位置</span></span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp)</span><br><span class="line">            k--;</span><br><span class="line">        <span class="comment">//找到要插的位置 k + 1，移动元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &gt; k + <span class="number">1</span>; j--)</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        arr[k+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定排序，原地排序 </li></ul><h3 id="改进：折半插入"><a href="#改进：折半插入" class="headerlink" title="改进：折半插入"></a>改进：折半插入</h3><p><strong>基本思路</strong>：在直接插入排序的过程中，将 “搜索插入位置” 这一步骤利用 “折半查找实现”   </p><p><strong>评价</strong>：不可取，仅仅减少了直接插入排序中关键字间的比较次数，而记录的移动次数不变，时间复杂度仍为：$O(n^2)$。    </p><h3 id="改进：2-路插入"><a href="#改进：2-路插入" class="headerlink" title="改进：2-路插入"></a>改进：2-路插入</h3><p><strong>目标</strong>：减少排序过程中移动记录的次数    </p><p><strong>具体思路</strong>：</p><ul><li>假设，待排序数组为 L.r，新设一个同类型的数组 d；</li><li><code>d[0] = L.r[0]</code>，并将 <code>d[0]</code> 看做排好序的序列中处于中间位置的记录；</li><li>然后，从 <code>L.r[1]</code> 开始，依次插入到 <code>d[0]</code> 之前和之后的已排好序的有序表中</li><li>例子：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/2WayInsert.png" alt="2WayInsert"><ul><li>first 和 final 是两个指针，分别指向排序过程中得到的有序列表里第一个记录和最后一个记录在 d 中的位置；</li></ul></li></ul><p><strong>评价</strong>：不可取，带来了新的空间开销，也只是减少移动记录的次数（不能完全避免），并且如果 <code>L.r[0]</code> 就是待排序列表里最大或最小的元素，则此方法优越性完全失效；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用插入排序，那么在排序过程中就不可避免的需要移动记录，否则，只能改变其存储结构（之前提及的：链式排序、地址排序）。</p><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>又称：缩小增量排序</p><p><strong>基本思想</strong>：先将整个待排记录序列分割为若干个子序列，对子序列分别进行直接插入排序，待整个序列的记录 “基本有序” 时，再对全体记录进行一次直接插入排序。    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gShellSort.gif" alt="ShellSort"></p><p><strong>过程举例</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/ShellSort.png" alt="ShellSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//默认步长为数组长度除以2</span></span><br><span class="line">    <span class="keyword">int</span> step = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        step = step / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//确定分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            <span class="comment">//对分组数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + step; j &lt; arr.length; j = j + step) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="keyword">for</span>( k = j-step; k &gt;= <span class="number">0</span>; k = k-step)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                        arr[k+step] = arr[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k+step] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：与选取的 “增量” 序列函数直接相关，目前为止，没有人能找出最优的 “增量” 序列函数，上述算法中，复杂度为 $O(nlogn)$</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基于 “交换” 操作进行的排序方式；<strong>快排</strong>（Quick Sort）是基于<strong>冒泡排序</strong>（Bubble Sort）的一种改进排序算法。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p><strong>基本思想</strong>：第 i 趟冒泡排序，从 <code>L[0]</code> 到 <code>L[n-1-i]</code> 依次比较每个记录与其下一个记录的大小，并在 “逆序” 时交换这两个记录（最终结果是，这 n-i+1 个记录里，最大值被交换到 n-i 的位置）；完成整个排序过程，也就需要有 $k(1\leq k&lt;n)$ 趟，判断结束的条件为：某趟冒泡过程中不出现交换操作。</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBubbleSort.gif" alt="BubbleSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最优的冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j , k;</span><br><span class="line">    <span class="keyword">int</span> flag = a.length; <span class="comment">// flag记录每趟冒泡的尾边界，同时也作为算法结束的标志</span></span><br><span class="line">    <span class="comment">// 用 flag 标记算法是否结束</span></span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)&#123; </span><br><span class="line">        k = flag;   <span class="comment">// k记录某趟遍历的尾边界</span></span><br><span class="line">        flag = <span class="number">0</span>;   <span class="comment">// 只要不发生交换，就不会进行下一趟冒泡，算法结束</span></span><br><span class="line">        <span class="comment">// 冒泡开始：</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="comment">//前面的数字大于后面的数字就交换a[j-1]和a[j]</span></span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">                <span class="comment">// 发生了交换，让flag重新记录新的尾边界</span></span><br><span class="line">                flag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>稳定排序、原地排序</li></ul><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p><strong>基本思想</strong>：通过一趟排序将待排记录分割为独立的两部分，其中一部分的关键字均比另一部分的关键字小，再分别对这两部分进行排序，已达到整个序列有序的目的；</p><ul><li>设定两个指针 low 和 high，初始时指向开头和结尾位置；枢值记录关键字 key，初始为第一个元素值；</li><li>先从 high 指示位置向前搜索，找到第一个值小于 key 的记录，和 key 交换位置；</li><li>然后从 low 位置起向后搜索，找到第一个值大于 key 的记录，和 key 交换位置；</li><li>重复上面两步，直至 low=high；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gQuickSort.gif" alt="QuickSort">  </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low &lt; index -<span class="number">1</span>)</span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>); <span class="comment">//区间左右都是闭包</span></span><br><span class="line">        <span class="keyword">if</span> (high &gt; index + <span class="number">1</span>)</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排的非递归实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//基于栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        stack.push(high);</span><br><span class="line">        stack.push(low);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> index = partition(a, l, h);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h &gt; index + <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(h);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间函数：某一趟快排的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="comment">// 将序列排列至枢纽两端</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从high向前，找第一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[high] &gt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从low向后，找第一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[low] &lt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在枢纽两端的元素位置都确定后，枢纽的位置也就确定了</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">// 返回枢纽位置，进行下一趟排序</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(logn)$</li><li>非稳定排序、原地排序</li></ul><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h2><p><strong>主要思路</strong>：每一趟在 $n-i+1\ (i=1,2,…,n-1)$ 个记录中选取关键字最小的记录作为有序序列中第 i 个记录    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gSelectionSort.gif" alt="SelectionSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// 共 n-1 轮选择排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从未排序的[i，n-1]的序列中，选择最小元素</span></span><br><span class="line">        <span class="keyword">int</span> min = i;  <span class="comment">//先默认a[i]是最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span>(a[min] &gt; a[j])  <span class="comment">//找到更小的值，就更新</span></span><br><span class="line">                min = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换，使最小的元素位于a[i]位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[min];</span><br><span class="line">        a[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n^2)$</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li></ul><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p><strong>目的</strong>：减少比较的次数</p><p><strong>理论基础</strong>：竞标赛比赛机制</p><ul><li>8 名运动员选出前 3 名，最多只需要 11 场比赛；</li><li>第一轮：7 场比赛决出冠军</li><li>第二轮：2 场比赛决出亚军</li><li>第三轮：2 场比赛决出季军</li></ul><p><strong>详情</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/TreeSelectSort.png" alt="TreeSelectSort"></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>缺点：所需的辅助空间太大、和最大值进行了多余的比较；</li><li>于是，进一步改进为：堆排序算法</li></ul><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆</strong>：一个完全二叉树里，每个结点的值都大（小）于其左右孩子（如果存在的话）节点的值，则称这样的二叉树为大（小）顶堆    </p><p><strong>堆排特点</strong>：只需要一个记录大小的辅助空间，每个待排序的记录只占有一个存储空间   </p><p><strong>基本思想</strong>：</p><ul><li>初始建堆：<ul><li>将序列按层次遍历看成是一个完全二叉树，则最后一个非终端节点是第 $\lfloor n/2 \rfloor$ 个元素；</li><li>因此，从第 $\lfloor n/2 \rfloor$ 个元素开始，往前对每个结点，反复 “下沉” 调整：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/BuildHeap.png" alt="BuildHeap"></li></ul></li><li>循环删除，下沉：<ul><li>删除堆顶，把删除的元素放在二叉树最后一个位置；</li><li>“下沉” 调整；<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/Sink.png" alt="Sink"></li></ul></li></ul><p><strong>过程展示</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gHeapSort.gif" alt="HeapSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 堆排序</span></span><br><span class="line"><span class="comment">*  下沉操作，执行删除操作相当于把最后</span></span><br><span class="line"><span class="comment">*  * 一个元素赋给根元素之后，然后对根元素执行下沉操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent 要下沉元素的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="comment">// 从最后一个非终端节点开始，不断往前下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶元素与最后一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// 把打乱的堆进行调整，恢复堆的特性</span></span><br><span class="line">        downAdjust(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆调整：下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时保存要下沉的元素</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">    <span class="comment">//定位左孩子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//开始下沉，需一直下沉至堆底</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子节点比左孩子大，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">// 如果孩子节点小于或等于父节点，则下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父节点进行下沉</span></span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">//更新孩子，继续下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp; <span class="comment">//下沉完毕，完成交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$，时间主要浪费在初始建堆和堆调整时的下沉操作上</li><li>空间复杂度：$O(1)$</li><li>非稳定排序、原地排序</li><li>适用情景：对记录较少的文件并不提倡，但对 n 较大的文件还是很有效的；</li></ul><h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p><strong>基本思路</strong>：（2-路归并）假设初始序列含有 n 个记录，则可以看成 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 $\lceil \frac{n}{2} \rceil$ 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止；</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gMergeSort.gif" alt="MergeSort">   </p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序（递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归地对左右两边进行排序</span></span><br><span class="line">        MergeSort(arr, low, mid);</span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序（非递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 1开始分割，与递归不同的是，递归由数组长度一分为二最后到1，</span></span><br><span class="line">    <span class="comment">// 而非递归则是从1开始扩大二倍直到数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">while</span> (arr.length &gt; len) &#123;    </span><br><span class="line">        <span class="comment">// 完全二叉树一层内的遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= arr.length - <span class="number">1</span>; i += len * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> mid = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i + len * <span class="number">2</span> - <span class="number">1</span>;            </span><br><span class="line">            <span class="comment">// 防止超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; arr.length - <span class="number">1</span>)</span><br><span class="line">                right = arr.length - <span class="number">1</span>;            </span><br><span class="line">            <span class="comment">// 合并排序相同</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 下一层</span></span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间函数：merge</span></span><br><span class="line"><span class="comment">// 将两个有序数组合并成一个有序数组；</span></span><br><span class="line"><span class="comment">//    arr[low,mif]表示一个数组，arr[mid+1,high]表示一个数组</span></span><br><span class="line"><span class="comment">// 因为数组有序，合并只要维护几个指针即可；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// temp 数组用于暂存合并的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//左半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="comment">//右半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//合并后数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录由小到大地放进 temp 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">        arr[low + l] = temp[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(nlogn)$</li><li>空间复杂度：$O(n)$</li><li>稳定排序、非原地排序</li></ul><h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p><strong>适用场景</strong>：最大值和最小值的差值不是不是很大的排序</p><p><strong>基本思想</strong>：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。    </p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gCountingSort.gif" alt="CountingSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中间数组，存放arr里各元素出现的次数</span></span><br><span class="line">    <span class="comment">//为节约内存空间，从0开始编号（0对应min），最后一个元素max-min（对应max）</span></span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mapPos = arr[i] - min;</span><br><span class="line">        help[mapPos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        <span class="comment">//把help某个位置对应的所有值全部输出（重复值）</span></span><br><span class="line">        <span class="keyword">while</span>(help[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++] = i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n+k)$，k 表示临时数组大小</li><li>空间复杂度：$O(k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><p><strong>基本思想</strong>：把最大值和最小值之间的数进行瓜分（例如分成 5 个区间，5 个区间对应 5 个桶），然后，把各元素放到对应区间的桶中去，再对每个桶中的数进行排序（可以采用前面提过的排序算法）。之后每个桶里面的数据就是有序的了，最后再进行合并汇总；</p><p><strong>适用场景</strong>：数据基本呈均匀分布的情况，这样才能保证各个桶里的数据量基本相同，不至于浪费 “桶” 所带来的时间和空间开销；</p><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBucketSort.gif" alt="BucketSort"></p><p><strong>问题</strong>：桶排序是怎样优化性能的？</p><ul><li>举个例子：<ul><li>我们假设有 100 个待排序的呈均匀分布的数，如果我们直接采用冒泡排序（时间复杂度为 $O(n^2)$），那么我们的时间开销将在 $100^2=10000$ 量级上；</li><li>现在，我们采用桶排序，划分出 10 个桶，因为数据呈均匀分布，那么每个桶里也就是 10 个数据，在每个桶里再单独进行冒泡排序，将 10 个桶都排好序的时间开销也就是  $10^2 \times 10=1000$ 量级上，即使算上桶划分、桶合并的时间，也远远低于 10000；</li></ul></li><li>经过这个例子，应该也就基本了解桶排序的优势所在，用普遍的数学公式表示：<ul><li>假设有 n 个数据，采用某种排序方式（时间复杂度为$O(n^i)$），这样直接排序的时间开销也就是：$n^i$</li><li>现在，我们分为 k 个桶进行桶排序，桶内仍然采用同样的排序算法:<ul><li>如果原数据呈均匀分布，那么时间开销也就是：$({\frac{n}{k})}^i \times k + f(k,n)= \frac{n^i}{k^{i-1}} + f(k,n)$，其中，$f(k,n)$ 为划分桶和合并桶的时间开销，它是一个和 k，n 有关的一阶函数，可以暂且忽略不考虑，将时间开销定为：$\frac{n^i}{k^{i-1}}$，对比 $n^i$，优势就很明显了；</li><li>那如果数据不呈均匀分布，我们考虑极端的情况，也就是这 n 个数据全部被分到 k 个桶里的同一个，那么现在的时间开销也就是：$n^i + f(k,n)$，对比 $n^i$，也就没了任何优势，并且还带来额外的时间、空间上的开销；</li></ul></li></ul></li></ul><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶划分</span></span><br><span class="line">    <span class="comment">// 定义桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>; </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//某个元素所属桶号</span></span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序（排序算法也可以自己定义）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//System.out.println(bucketArr.toString());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把每个桶排序好的数据进行合并汇总放回原数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer t : bucketArr.get(i)) &#123;</span><br><span class="line">            arr[k++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(n+k)$，k 表示桶个数</li><li>空间复杂度：$O(n+k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>是一种借助多关键字排序的思想（“分配” 和 “收集” 两种操作）对单逻辑关键字进行排序的方法；有两种排序方式：最高位优先（MSD）、最低位优先（LSD）   </p><p><strong>基本思想</strong>：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位，最终得到的序列就是一个有序序列；</p><ul><li>在具体到某一位的排序时，是利用 “桶” 排序来实现的。数据的某一位取值情况为：0-9，需要 10 个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照 0 号桶到 9 号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了；</li></ul><p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gRadixSort.gif" alt="RadixSort"></p><p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radioSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值位数num</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每位数值从0-9，10 种取值，创建 10 个桶 </span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从个位数开始，循环，对每一位排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取每个数最后第 i 位是数组</span></span><br><span class="line">            <span class="keyword">int</span> radio = (arr[j] / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放进对应的桶里</span></span><br><span class="line">            bucketList.get(radio).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并放回原数组</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : bucketList.get(j)) &#123;</span><br><span class="line">                arr[k++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出来合并了之后把桶清光数据</span></span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>评价</strong>：</p><ul><li>时间复杂度：$O(kn)$，k 表示最大数位数</li><li>空间复杂度：$O(n+k)$</li><li>稳定排序、非原地排序</li></ul><h1 id="排序算法对比分析"><a href="#排序算法对比分析" class="headerlink" title="排序算法对比分析"></a>排序算法对比分析</h1><div class="table-container"><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>最好时间</th><th>最坏时间</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(nlogn)$</td><td></td><td></td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n^2)$</td><td>$O(logn)$</td><td>不稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table></div><p>注意：以上时间复杂度，供参考，有些算法还需要根据具体情况实际分析；</p><p><strong>总结</strong>：</p><ul><li>从平均时间性能上看，快排是最优选择，但是其最坏情况下性能不如堆排和归并排序。对后两者来说，如果 n 较大，选择归并排序更省时，但是比较废空间；</li><li>直接插入排序时最简单的排序，当记录数较少，或基本有序时，是最佳选择。因此，它也常和其他排序方式结合使用；</li><li>一般来说，排序过程中的 “比较” 在 “相邻的两个记录关键字” 间进行的排序方法是文档的；稳定性由方法本身决定，总能找出反例；如果排序按主关键字进行，那么算法稳定性不重要，但如果按次关键字进行，则需要重点考虑；</li><li>因此，排序算法没有好坏之分，要根据实际情况选择最合适的方法；</li><li>经研究表明：所有借助于 “比较” 进行排序的算法在最坏情况下能达到的最好的时间复杂度为：$O(nlogn)$</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>『<a href="https://www.cnblogs.com/kubidemanong/p/10404197.html" target="_blank" rel="noopener">十大排序算法，看这篇就够了(附完整代码/动图/优质文章)</a>』</li><li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li><li>另：文中动图均来源网络，最终出处没能找到，如原作者看到，可联系我加入参考地址</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;  

&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DataStructure &amp; Algorithm" scheme="http://www.thebetterkong.cn/categories/DataStructure-Algorithm/"/>
    
    
      <category term="java" scheme="http://www.thebetterkong.cn/tags/java/"/>
    
      <category term="Algorithm" scheme="http://www.thebetterkong.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-CAD Tools：Placement</title>
    <link href="http://www.thebetterkong.cn/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/"/>
    <id>http://www.thebetterkong.cn/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/</id>
    <published>2020-05-31T03:01:36.000Z</published>
    <updated>2020-08-14T09:30:05.357Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 FPGA 技术里 Routing 部分；</p><a id="more"></a> <h1 id="概述-FPGA-Routing"><a href="#概述-FPGA-Routing" class="headerlink" title="概述 FPGA Routing"></a>概述 FPGA Routing</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>一个过程，该过程确定应打开哪些可编程开关（Connections blocks 和 switch blocks），以连接电路所需的所有逻辑块输入和输出引脚。</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/WhatRouting.png" alt="whatrouting">    </p><p>目的：</p><ul><li>必须用设备的互连资源，使 FPGA 中的逻辑集群良好连接，从而使电路正常工作</li></ul><p>方法:</p><ul><li>路由资源图（RRG）生成</li><li>路由算法</li></ul><p>目标:</p><ul><li>减少接线（wirelength 驱动）</li><li>最大化电路速度（timing 驱动）</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>良好的路由至关重要，路由不正确会导致：</p><ul><li>导致最大运行速度降低</li><li>增加功耗</li><li>实施时间慢，甚至无法路由所有信号</li></ul><p>寻找一个好的路线是具有挑战性的：</p><ul><li>布线资源（电线和连接点）相对稀缺</li><li>信号将争夺相同的路由资源</li></ul><h2 id="Routing-结构"><a href="#Routing-结构" class="headerlink" title="Routing 结构"></a>Routing 结构</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingArchitecture.png" alt="RoutingArchitecture"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingResources.png" alt="RoutingResources"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingPath.png" alt="RoutingPath">    </p><h2 id="Routing-问题"><a href="#Routing-问题" class="headerlink" title="Routing 问题"></a>Routing 问题</h2><p>路由电路等效于在 RRG 中找到一组满足时序约束的不相交路径：</p><ul><li>路由资源图（RRG）G =（V，E）：是代表目标设备路由资源的主要数据结构</li><li>NP-complete 问题：NP 完全问题是无法以任何已知方式在多项式时间内求解</li></ul><p>相关术语：</p><ul><li>Input：<ul><li>电路里所有的 sources：$S=\{s_1,s_2,s_3,…,s_m\}$</li><li>电路里所有的 sinks：$T=\{T_1,T_2,T_3,…,T_m\}$，其中，$T_i=\{t_i^1,t_i^2,t_i^3,…,t_i^n\}$，代表了： $s_i$ 所通向的所有 sinks</li></ul></li><li>Solution：<ul><li>查找从每个 source $s_i$ 到 $T_i$ 中所有 sinks 的路径；</li><li>来自不同 source 的路径必须是不相交的（不能共享任何节点或边）；</li></ul></li></ul><p>约束关系：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Constraints.png" alt="Constraints"></p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>FPGA routing 一般经过三个步骤：RRG 生成、Global Routing、Detailed Routing  </p><ul><li>现代路由算法可以同时执行全局和详细路由；   </li></ul><p><strong>Routing Resource Graph (RRG) Generation</strong>：</p><ul><li>RRG 是表示 FPGA 全局路由架构的有向图；</li><li>在此图中，每条导线和每个逻辑块引脚成为一个节点，潜在连接变为边；</li></ul><p><strong>Global Routing</strong>：消除 congestions（拥堵）</p><ul><li>全局路由器执行<strong>粗路由</strong>，以确定每个连接必须通过的最小路由路径；</li><li>如果要路由的网络有两个以上的终端，则全局路由器会将网络分成一组两个终端的连接，并分别路由每个集合；</li><li>全局路由器为每个连接考虑多种路由方法，并选择通过最少拥塞路由路径的路由；</li><li>通过跟踪每个路由通道的使用情况，避免拥塞；并且实现了全局路由器的主要目标，即平衡路由通道的使用；</li><li>一旦所有连接都经过粗路由，就可以通过撕裂每个连接并重新路由几次来优化该解决方案；</li><li>之后，最终解决方案将传递到详细的路由器；</li></ul><p><strong>Detailed Routing</strong>：去分配 tracks/wires 和 switches</p><ul><li>细粒度</li><li>详细路由器为每两点连接，确定在全局路由器分配的路由通道中<strong>使用的特定布线段</strong>；</li><li>详细的路由算法将从路由资源中<strong>构造一个有向图</strong>，以表示 FPGA 中的 wires，C blocks，S blocks 和逻辑块之间的可用连接；</li><li>在此有向图上执行的搜索通常基于 <strong>Dijkstra 算法</strong>来找到两个节点之间的最短路径；</li><li>根据<strong>成本函数</strong>对路径进行标记，该成本函数考虑了每个线段的使用情况以及互连点的距离；</li><li>通过使用<strong>曼哈顿度量标准</strong>计算互连点边界框中的导线长度来估算距离；</li><li>大多数路由器<strong>放宽</strong>了对边界框的<strong>限制</strong>，并允许在边界框的周围路由通道中搜索可能的解决方案；<ul><li>这是为了避免，如果解决方案位于边界框的外部附近，则会导致后续的重复撕裂和重新路由；</li></ul></li></ul><h2 id="Route-结果"><a href="#Route-结果" class="headerlink" title="Route 结果"></a>Route 结果</h2><p>VTR 形式（.Route）：易读但不直观<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRForm.png" alt="VTRForm"></p><h1 id="RRG（Routing-Resource-Graph）"><a href="#RRG（Routing-Resource-Graph）" class="headerlink" title="RRG（Routing Resource Graph）"></a>RRG（Routing Resource Graph）</h1><h2 id="Circuit-到-Graph"><a href="#Circuit-到-Graph" class="headerlink" title="Circuit 到 Graph"></a>Circuit 到 Graph</h2><p>与 DAG 的 FPGA 映射不同，但也作为有向图：</p><ul><li>Node：wire / logic block pin</li><li>Edge：potential connection</li><li>Node Capacity：可以在合法路由中使用此节点的不同网络的最大数量</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/CircuitToGraph.png" alt="CircuitToGraph"></p><h2 id="LUT-的-inputs-等价"><a href="#LUT-的-inputs-等价" class="headerlink" title="LUT 的 inputs 等价"></a>LUT 的 inputs 等价</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/LUTInput.png" alt="LUTInput"></p><h2 id="软件表示"><a href="#软件表示" class="headerlink" title="软件表示"></a>软件表示</h2><h3 id="XML（eXtensible-Markup-Language）"><a href="#XML（eXtensible-Markup-Language）" class="headerlink" title="XML（eXtensible Markup Language）"></a>XML（eXtensible Markup Language）</h3><p>是在 VTR 里面使用的，一种具有可选属性的开始和结束标记的层次结构；</p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/XML.png" alt="XML"></p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>YAML 不是标记语言，是另一标记语言的递归形式，易于表示和阅读：   </p><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/YAML.png" alt="YAML"></p><h3 id="表示过程"><a href="#表示过程" class="headerlink" title="表示过程"></a>表示过程</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SoftwareTrans.png" alt="SoftwareTrans"></p><p>注意：每个供应商都有自己的 FPGA 架构形式和数据结构建立方法，这些形式不会向客户透露（属于公司的专有技术）</p><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><h2 id="Maze（迷宫）路由"><a href="#Maze（迷宫）路由" class="headerlink" title="Maze（迷宫）路由"></a>Maze（迷宫）路由</h2><p>迷宫路由算法：</p><ul><li>基于波前扩展技术，该技术尝试在两点之间找到最短路径，同时避免使用任何路由资源；</li><li>一个迭代过程，该过程会撕裂并重新路由某些路由，以消除拥塞的路由通道；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze1.png" alt="Maze1"></p><p>主要缺点：它进行路由时不会考虑找到的路径会阻止后续网络的路由；</p><ul><li>这意味着算法的性能取决于网络排序，并且<strong>不同的顺序将产生不同的结果</strong>；</li><li>如果颠倒了下面两个网的布线顺序，则会找到更好的解决方案；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze2.png" alt="Maze2"></li></ul><h2 id="A-搜索路由"><a href="#A-搜索路由" class="headerlink" title="$A^*$ 搜索路由"></a>$A^*$ 搜索路由</h2><ul><li>迷宫路由是 $A^*$ 路由的特例；</li><li>$A^*$ 路由允许将路径搜索从广度优先搜索算法（BFS）调整为较短的深度优先搜索算法（DFS）；<ul><li>BFS 是一种详尽的搜索，它考虑了所有可能的路径，如果有任何路径，则会找到最佳路径，但缺点是速度可能很慢；</li><li>同时，DFS 可能找不到最小的成本路径，但可能很快；</li></ul></li></ul><p>$A^*$ 路由利用 0 到 1 之间的比例因子 α 进行加权，从而将搜索从 BFS 调整为 DFS；  </p><script type="math/tex; mode=display">f_i=(1-\alpha) \times (f_{i-1}+c_i)+\alpha \times d_i</script><ul><li>cost 用于评估每个节点 i 的有向图的成本函数：<ul><li>$c_i$ 是节点 cost，表示节点的当前使用情况，用于惩罚先前路由所占用的节点； </li><li>$f_{i-1}$是前一条路径的总成本；（函数的前半部分相当于 DFS）</li><li>$d_i$ 是从节点 i 到目的地的路径的估计成本；（函数的前半部分相当于 BFS）</li></ul></li></ul><h2 id="PathFinder-路由算法"><a href="#PathFinder-路由算法" class="headerlink" title="PathFinder 路由算法"></a>PathFinder 路由算法</h2><p>顾名思义，PathFinder 可在 RRG 中的两个节点之间找到路径：</p><ul><li>消除拥塞</li><li>最小化关键路径的延迟</li><li><strong>同时</strong>进行全局和详细路由</li><li>使用广泛：对 VTR 中使用的学术路由工具，进行了深入研究</li></ul><h3 id="知识概述"><a href="#知识概述" class="headerlink" title="知识概述"></a>知识概述</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathFinderOverview.png" alt="PathFinderOverview">    </p><p>RRG 里的 BFS：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/BFSInRRG.png" alt="BFSInRRG"></p><ul><li>每个正方形代表一个节点：S-source，T-sink，Number-cost</li></ul><p>逐一（source-sink）路由所有网络：</p><ul><li>为 RRG 中的每个边（可能的连接）分配取决于当前用法和历史用法的成本；</li><li>每个网络都由 BFS 路由，目的是使成本最低；</li><li>多个网络可能在 RRG 中使用相同的节点（导线/逻辑块）（标记为拥塞）；</li><li>于是，为拥塞节点分配更高的成本；</li><li>如果一条路由必须包含一个拥塞的节点，它将与其他路由“协商”，并使其绕过（翻录和重新路由）；</li></ul><p>重复固定时间：</p><ul><li>成功：为所有网络提供不相交的路由解决方案；</li><li>失败：经过固定次数（30）的迭代后，没有找到不相交的路由解决方案；</li></ul><h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p><strong>Routability Cost Function</strong>：</p><ul><li>对于节点 n：<script type="math/tex; mode=display">Cost(n) = p(n)\ast[\ b(n)+h(n)\ ]</script></li><li>其中：<ul><li>$b(n)$：通过节点 n 进行路由的 <strong>Base Cost</strong>（基本成本）</li><li>$h(n)$：<strong>History Cost</strong>（历史成本），与通过节点 n 路由的历史成本有关（基于以前的路由器迭代）</li><li>$p(n)$：<strong>Penalty of congestion</strong>（拥塞处罚），与在当前迭代中通过节点 n 路由的网（信号）的数量有关</li></ul></li></ul><p><strong>Timing-Routability Cost Function</strong>：</p><ul><li>对每个结点 n：<script type="math/tex; mode=display">Cost(n) = Crit(i,j) \ast delay(n) + [\ 1-Crit(i,j)\ ] \ast p(n) \ast [\ b(n) + h(n)\ ]</script></li><li>其中：<ul><li>$delay(n)$：通过节点 n 的网络的延迟</li><li>$Crit(i,j) = 1- \frac{slack(i,j)}{D_{max}}$<ul><li>$Crit(i,j)$：从 source i 到 sink j 的路径的估计临界度</li><li>$D_{max}$：关键路径的延迟</li></ul></li></ul></li></ul><h3 id="Congestion"><a href="#Congestion" class="headerlink" title="Congestion"></a>Congestion</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Congestion.png" alt="Congestion"></p><h3 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathfinderPseudoCode.png" alt="PathfinderPseudoCode"></p><h1 id="路由算法：VTR-Router"><a href="#路由算法：VTR-Router" class="headerlink" title="路由算法：VTR Router"></a>路由算法：VTR Router</h1><h2 id="Routability-driven-Router"><a href="#Routability-driven-Router" class="headerlink" title="Routability-driven Router"></a>Routability-driven Router</h2><h3 id="Cost-Function-1"><a href="#Cost-Function-1" class="headerlink" title="Cost Function"></a>Cost Function</h3><script type="math/tex; mode=display">PathFinder: Cost(n) = [\ b(n) + h(n)\ ] \times p(n)</script><script type="math/tex; mode=display">VTR Router:\ Cost(n)=b(n) \times h(n) \times p(n) + BendCost(n,m)</script><ul><li>$b(n)$，$h(n)$ 和 $p(n)$ 分别是节点 n 的基本成本，历史成本和拥塞惩罚（在PathFinder 算法中定义）；</li><li>$BendCost(n，m)$ 会对弯曲的全局路线造成不利影响，因为这些路线不太可能使用长导线，从而使详细（局部）路线难以实施（更容易发生拥塞）；<ul><li>如果建立从节点 m 到节点 n 的连接会产生弯曲，则 $BendCost(n，m)= 1$；</li><li>如果执行了组合的全局详细路由，则 $BendCost(n，m)= 0$；</li></ul></li><li>将 $b(n)$ 和 $h(n)$ 相乘可消除归一化；</li></ul><h3 id="Base-Cost"><a href="#Base-Cost" class="headerlink" title="Base Cost"></a>Base Cost</h3><div class="table-container"><table><thead><tr><th>Routing Resource，n</th><th>Base Cost，b(n)</th></tr></thead><tbody><tr><td>Wire segment</td><td>1</td></tr><tr><td>Logic block output pin</td><td>1</td></tr><tr><td>Logic block input pin</td><td>0.95</td></tr><tr><td>Source</td><td>1</td></tr><tr><td>Sink</td><td>0</td></tr></tbody></table></div><ul><li>五个 $b(n)$ 值中的四个约为 1，这鼓励路由器使用尽可能少的这些资源；</li><li>将逻辑块输入引脚的成本设置为略小于 1，可以使搜索更早地到达 terminal（inputs 和 sinks）；</li><li>将 sink 的成本设置为 0，因为在 sink 中不会发生拥塞；</li><li>通过这种方式为逻辑块 inputs 和 sinks 使用较低的成本，可使路由器速度提高 1.5 到 2 倍；</li><li>实验表明，将线段的 $b(n)$ 设置为 1 可获得最佳效果；</li></ul><h3 id="Penalty-of-Congestion"><a href="#Penalty-of-Congestion" class="headerlink" title="Penalty of Congestion"></a>Penalty of Congestion</h3><script type="math/tex; mode=display">p(n) = 1 + \max(0\ ,\ [\ occupancy(n) + 1 - capacity(n)\ ] \cdot p_{fac})</script><ul><li>$occupancy(n)$：使用资源（节点）n 的网络数；</li><li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PenaltyExample.png" alt="PenaltyExample"></li><li>$p_{fac}$：routing schedule 之一；为了获得最高质量，第一次迭代时将其设置为 0.5，随后的每次迭代将其增加 1.5 倍至 2.0 倍；<ul><li>快速增加 $p_{fac}$ 会导致质量下降（想象一下，收取过多的交通拥堵费会导致没有人想要在城市开车）；</li></ul></li></ul><h3 id="History-Cost"><a href="#History-Cost" class="headerlink" title="History Cost"></a>History Cost</h3><script type="math/tex; mode=display">{h(n)}^i=\begin{cases}1,\quad i=1 \\\\{h(n)}^{i-1}+\max(0,[occupancy(n)-capacity(n)]\cdot h_{fac}),\quad i>1\end{cases}</script><ul><li>$occupancy(n)$：使用资源（节点）n 的网络数；</li><li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；</li><li>$h_{fac}$：routing schedule 之一；设置为常数，并且介于 0.2 到 1 之间的任何值都可以正常工作。</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/HistoryCostExample.png" alt="HistoryCostExample"></p><h3 id="Net-布线顺序"><a href="#Net-布线顺序" class="headerlink" title="Net 布线顺序"></a>Net 布线顺序</h3><p>按 fan-out 的降序排列网络，因为：</p><ol><li>高 fan-out 网络倾向于覆盖整个 FPGA<ul><li>在较早路由的其他网络拥塞较少的情况下，更易于路由</li></ul></li><li>低 fan-out 网络往往更局部化<ul><li>即使在某些拥挤的情况下，也相对容易布线</li></ul></li></ol><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/NetOrderExample.png" alt="NetOrderExample"></p><h3 id="算法加速：方案一"><a href="#算法加速：方案一" class="headerlink" title="算法加速：方案一"></a>算法加速：方案一</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeOneExample.png" alt="SchemeOneExample"></p><ul><li>在 source 和 sinks 周围定义一个边界框（<strong>bounding box</strong>）；</li><li>将每个网络的路由限制在边界框外不超过 3 个 channels；<ul><li>鼓励在 bounding box 里进行 routing；</li></ul></li><li>大大减少了 BFS 搜索时间（由于使用较少的 channels）；</li><li>对路由质量没有明显影响；</li></ul><h3 id="算法加速：方案二"><a href="#算法加速：方案二" class="headerlink" title="算法加速：方案二"></a>算法加速：方案二</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample.png" alt="SchemeTwoExample"><br>对于高扇出网络，重用部分路由会更有效；</p><ul><li>从波前局部的推进路由</li></ul><p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample2.png" alt="SchemeTwoExample2">   </p><h3 id="算法加速：方案三"><a href="#算法加速：方案三" class="headerlink" title="算法加速：方案三"></a>算法加速：方案三</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeThreeExample.png" alt="SchemeThreeExample"></p><h3 id="算法加速：方案四"><a href="#算法加速：方案四" class="headerlink" title="算法加速：方案四"></a>算法加速：方案四</h3><ul><li>无方向的 BFS 非常耗时；</li><li>引入了定向搜索（基于曼哈顿距离：source 到 sink 的距离）；</li></ul><p>但是，当障碍物是凹形的时：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeFourExample.png" alt="SchemeFourExample"></p><ul><li>BFS 找到最佳路线，但很费时间；</li><li>Directed Search（贪婪）可节省时间，但可能找不到最佳路线；</li></ul><p>成本函数可适当平衡 BFS 和定向搜索（贪婪）:</p><script type="math/tex; mode=display">TotalCost(n)=PathCost(n)+ \alpha \cdot ExpectedCost(n,j)</script><ul><li>$PathCost(n)$：从当前部分路由树到节点 n 的路径总成本；</li><li>$ExpectedCost(n，j)$：从当前节点 n 到目标sink j 的估计成本；</li><li>$\alpha$：<ul><li>1 导致 $A^*$ 搜索；</li><li>1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li></ul></li></ul><h2 id="Timing-driven-Router"><a href="#Timing-driven-Router" class="headerlink" title="Timing-driven Router"></a>Timing-driven Router</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>相对于 “PathFinder” 的<strong>两个主要改进</strong>：</p><ol><li>在 <strong>Elmore 延迟估计</strong>下优化延迟，而不是线性延迟（在线性延迟中，每个路由资源都具有恒定的延迟）：<ul><li>对于任何在其路由中包含 pass transistors 的 FPGA 而言，线性延迟模型都是非常不准确的；</li></ul></li><li><strong>动态改变</strong>路由资源的基本成本：<ul><li>根据要路由的<strong>网络的跨度</strong>更改<strong>长 wire segments 的成本</strong>，以使路由器偏向于使用正确的路由资源类型（buffer 或 pass transistors）；</li></ul></li></ol><h3 id="等效电路"><a href="#等效电路" class="headerlink" title="等效电路"></a>等效电路</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/EquivalentCircuits.png" alt="EquivalentCircuits"><br>便于计算延迟；</p><h3 id="Elmore-延迟"><a href="#Elmore-延迟" class="headerlink" title="Elmore 延迟"></a>Elmore 延迟</h3><p>用于分布式 RC 效果；   </p><script type="math/tex; mode=display">ElmoreDelay_{source-sink}=\sum_{i\in(source-sink\ path)} C_i\ R_{i,sink}+T_{d,i}</script><ul><li>$T_{d,i}$：节点 i（缓冲区）的固有延迟；否则为 0；</li><li>$C_i$：节点 i 处金属和寄生电容的等效电容；</li><li>$R_{i,sink}$：<strong>source 到节点 i</strong> 和 <strong>source 到不带缓冲区的 sink</strong> 之间的共享路径上的等效电阻；<ul><li>公式表示：$R_{i,sink}=\sum R_{shared}$，其中，$R_{shared}\in [\ path(source-i) \cap path(source-sink)]$</li></ul></li></ul><p>计算示例（注意：结点 2、4 也属于 source 到 sink 路径上的结点）：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ComputingElmoreDelay.png" alt="ComputingElmoreDelay">    </p><p><strong>Case1：M wire segments 通过 buffers 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByBuffers.png" alt="ByBuffers"></p><ul><li>Buffer 的固有延迟：$T_{buf,intrinsic}=125ps$</li><li>Wire 的电阻：$R_{buf}=500 \Omega$</li><li>导线的金属电容和寄生电容：$C_{total}=250fF$</li><li>则，$T_{d,buffered}=M \cdot [\ T_{buf,intrinsic}+R_{buf}\cdot C_{total}\ ]=M \cdot 250\ (ps)$</li><li>在 buffer 这种情况下，Linear 和 Elmore 延迟模型相同；</li></ul><p><strong>Case2：M wire segments 通过 pass transistors 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByPassTransistors.png" alt="ByPassTransistors"></p><ul><li>Pass transistor 的电阻：$R_{pass}=500 \Omega$</li><li>结点的电容：$C_{total}=250fF$</li><li>Linear：$T_{d,pass,linear}=M \cdot R_{pass} \cdot C_{total}=M \cdot 125(ps)$</li><li>Quadratic：$\sum^M_{i=1}\ i\cdot R_{pass} \cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot R_{pass}\cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot 125 (ps)$</li><li>在 pass transistor 的情况下，Linear 和 Elmore 延迟模型都有很大的不同；</li></ul><h3 id="具有-Elmore-延迟的-Cost-Function"><a href="#具有-Elmore-延迟的-Cost-Function" class="headerlink" title="具有 Elmore 延迟的 Cost Function"></a>具有 Elmore 延迟的 Cost Function</h3><p>考虑连接到 net i 的 sink j，包括节点 n 在内的 cost function 为：</p><script type="math/tex; mode=display">Cost(n)=Crit(i,j) \cdot T_{Elmore}(n,topology)+[\ 1-Crit(i,j)\ ]\cdot b(n)\cdot h(n)\cdot p(n)</script><p>其中：</p><ul><li>criticality 相当于一个权重因子，$Crit(i,j) = \max(\ [MaxCrit-\frac{slack(i,j)}{D_{max}}]^\eta,0\ )$<ul><li>$D_{max}$：电路关键路径的延迟</li><li>$Slack(i，j)$：网络 i 的 source 和 sink j 之间的连接松弛</li><li>$MaxCrit$ 和 $\eta$：控制松弛如何影响 拥塞-延迟 权衡的参数<ul><li>$MaxCrit = 1$ 和 $\eta= 1$：转换为 PathFinder 的情况</li><li>$\eta$ 是较大的：网络具有正松弛度，对延迟的关注较少，而对拥塞的关注更多</li><li>$MaxCrit = 1$：允许松弛为 0 的连接完全忽略拥塞</li><li>$MaxCrit = 0$：忽略延迟，使路由器完全由 routability 驱动</li><li>因此，将 MaxCrit 设置为 1 是危险的，根据经验，通常设置：$MaxCrit = 0.99，\eta= 1$</li></ul></li></ul></li><li>$b(n)$：当前结点 n 的 base cost</li><li>$h(n)$：当前结点 n 的 historical cost</li><li>$p(n)$：当前结点 n 的 congestion penalty cost</li><li>$T_{Elmore}(n，topology)$：Elmore 延迟，其中包含节点 n 以及信号向节点 n 传播的关联拓扑的函数；</li></ul><p>为了逐步计算将节点 n 添加到部分路由中而产生的 Elmore 延迟，我们需要知道上游电阻。则，定义：通过 routing switch 将其连接到节点 m 所达到的节点 n 的上游电阻为：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Upstream.png" alt="Upstream"></p><script type="math/tex; mode=display">R_{upstream}(n)=\begin{cases}R(switch)+R_{metal}(n),\quad if\ switch\ is\ a\ tri-state\ buffer \\\\R_{upstream}(m)+R(switch)+R_{metal}(n),\quad if\ a\ pass\ transistor\end{cases}</script><p>定义 Elmore 延迟作为包含的节点 n 和信号向节点 n 传播的相关拓扑的函数：   </p><script type="math/tex; mode=display">T_{Elmore}(n,topology) = T_{d,intrinsic}(switch)+[\ R_{upstream}(n)-\frac{R_{metal}(n)}{2}\ ]\cdot C_{total}(n)</script><p>其中：</p><ul><li>$T_{d,intrinsic}(switch)$：通过 partial routing 到达节点 n 的 switch 的固有延迟；（对于 non-buffers，= 0）</li><li>$R_{upstream}(n)$：partial routing 的上游电阻，是通过 pass transistor switches 链而不是通过  buffered switches 链积累的；</li><li>$R_{metal}(n)$：路由资源节点 n 的金属电阻，对于所有非布线网段节点，金属电阻为 0；</li><li>$C_{total}(n)$：节点 n 处的总电容（金属加寄生开关电容）；</li><li>从 $R_{upstream}(n)$ 中减去 $R_{metal}(n)$ 的 1/2：表示金属电阻的分布</li></ul><h3 id="算法加速方案"><a href="#算法加速方案" class="headerlink" title="算法加速方案"></a>算法加速方案</h3><p>与 routability-driven router 相同：    </p><script type="math/tex; mode=display">TotalCost(n)=PathCost(n) + \alpha \cdot ExpectedCost(n,j)</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SpeedEnhancement.png" alt="SpeedEnhancement">    </p><p>其中：</p><ul><li>$PathCost(n)$：从 source 到节点 n 的路径上每个节点的总成本，即：当 $Crit(i,j)=1$ 时，为 $T_{Elmore}(n,topology)$；</li><li>$ExpectedCost(n,j)$：从当前节点 n 到目标 sink j 的估计成本；</li><li>$\alpha$：为 1 导致 $A*$ 搜索；为 1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li></ul><h3 id="带有动态-Base-Cost-的-Cost-Function"><a href="#带有动态-Base-Cost-的-Cost-Function" class="headerlink" title="带有动态 Base Cost 的 Cost Function"></a>带有动态 Base Cost 的 Cost Function</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/DynamicBaseCostFunction.png" alt="DynamicBaseCostFunction"></p><p>完全用 pass transistors 相连的路由树：</p><ul><li>switches 往往会变得 heavily loaded，导致较大的延迟；</li></ul><p>尽可能趋向于使用  buffered switches，以便：</p><ul><li>最大化在以后的连接中重新使用其中一些接线的可能性；</li><li>最小化以后连接影响早期连接时间的可能性；</li></ul><script type="math/tex; mode=display">b_{pass\ transistor\ wires}(n)=AverageRoutingResourceDelay \cdot \sqrt{k-1}</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/KTerminals.png" alt="KTerminals"></p><ul><li>$k$：网络上的 terminals 数，$k\geq 2$； </li><li>$b_{pass\ transistor\ wires}(n)$：通过 pass transistors 连接到其他节点（线）的节点（线）n 的基本成本；<ul><li>通过 buffers：平均路由资源延迟</li><li>通过 pass transistors：延迟增加</li></ul></li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRPseudoCode.png" alt="VTRPseudoCode"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 FPGA 技术里 Routing 部分；&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>干货分享 | 网页文档不让复制？带你一起破解网页限制</title>
    <link href="http://www.thebetterkong.cn/2020/05/30/Skills/ResolveCopyProhibition/"/>
    <id>http://www.thebetterkong.cn/2020/05/30/Skills/ResolveCopyProhibition/</id>
    <published>2020-05-30T09:34:17.000Z</published>
    <updated>2020-08-14T09:34:52.119Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/header.png" width="100%" alt="header.png" /> </div>    <p>受疫情影响，现在基本都是远程上课，眼看学期末就要到了，各个课程也纷纷结课。往常的结课考试，自然也就行不通，所以大部分课程开始改为递交课程报告的形式。于是乎，现在天天就是看论文，找资料，写报告……头都大了！特别有时候，好不容易在网上找到一些资料，结果还不让我使用传统的 <kbd>Crtl C+V</kbd> 大法，有的是让你登录，更狠的直接给你禁了，你都找不到这个选项。现在版权意识越来越重，要说不让随意下载转发，尚还接受，可是，有时候我就想用一下那么几句话，亦或者做下阅读笔记，还得一字一句的打，效率太低了。然后，就开始了各种捣鼓，这里总结出了所有我知道的办法，欢迎评论补充！</p><a id="more"></a> <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>介绍具体破解方法前，我们还是有必要先弄清楚这种「复制禁用」到底是怎么实现的，只有知其然亦知其所以然，才能不变应万变；（如果你只是简单的想找个破解方法，可以跳过此章节）     </p><p>目前，绝大多数网页禁用复制功能，都可以囊括到如下三类：</p><p><strong>JavaScript 脚本的方式</strong>：</p><ul><li>也是目前最常用的方式，常用的实现方式如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'右键'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止文字选择。</span></span><br><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'文字选择'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'copy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止剪切</span></span><br><span class="line"><span class="built_in">document</span>.body.oncut = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'cut'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'paste'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用e.preventDefault()也可以禁用，但建议使用 return false 这样就不用去访问 e 和 e 的方法了;</span></span><br><span class="line"><span class="comment">// 示例中 document.body 全局都禁用了，也可以对 dom （某些区域）进行禁用。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>CSS 的方式</strong>：<br><a id="mao"></a></p><ul><li>使用 CSS 能够保证在用户禁用 JavaScript 脚本的情况下，复制功能也会被禁止；<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>:none; <span class="comment">/* Firefox私有属性 */</span></span><br><span class="line">  <span class="attribute">-webkit-user-select</span>:none; <span class="comment">/* WebKit内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-ms-user-select</span>:none; <span class="comment">/* IE私有属性(IE10及以后) */</span></span><br><span class="line">  <span class="attribute">-khtml-user-select</span>:none; <span class="comment">/* KHTML内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-o-user-select</span>:none; <span class="comment">/* Opera私有属性 */</span></span><br><span class="line">  <span class="attribute">user-select</span>:none; <span class="comment">/* CSS3属性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>HTML 属性的方式</strong>：</p><ul><li>这种方式就用的不多了；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">oncopy</span>=<span class="string">"return false"</span> <span class="attr">oncut</span>=<span class="string">"return false;"</span> <span class="attr">onselectstart</span>=<span class="string">"return false"</span> &gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>最后，还必须提一下，有些爱捣鼓的网站（很少很少）会想办法禁用开发者模式，但是这种禁用通常是不可能 100% 禁用的；   </p><p>有的只是单纯通过禁用 <kbd>F12</kbd> 按键，又或者高级一些的：  </p><blockquote><p>“利用 console.log 打印一个对象然后覆盖这个对象的 toString 方法，一旦开发者工具存在，toString 方法就会被调用。”</p></blockquote><h1 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h1><p>首先最简单最笨的办法，当然就是，百度搜索这篇文章，看看有没有别的地方可以直接复制或者下载的。这不符合本文主题，pass！</p><h2 id="利用网页打印"><a href="#利用网页打印" class="headerlink" title="利用网页打印"></a>利用网页打印</h2><p>这里说的打印，不是让你真的打印（当然，不嫌麻烦话当我没说）；    </p><p>具体做法就是：</p><ul><li>在文档上：<kbd>右键</kbd> -&gt; <kbd>打印</kbd></li><li>然后，就可以直接在弹出的打印预览页面的，愉快的复制粘贴了；</li></ul><p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/print.png" alt="print"></p><h2 id="拖拽法"><a href="#拖拽法" class="headerlink" title="拖拽法"></a>拖拽法</h2><p>选中所需要的文字，鼠标点击拖入到文本文件中；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/drag.jpg" alt="drag"></p><h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><p><kbd>F12</kbd> 进入开发者模式，在 hmtl 源码里就可以找到你所需要的文字；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/html.jpg" alt="html"></p><p>这种方法很明显有个弊端就是，我们复制的文字量比较大时，会复制到一些不必要的 <code>&lt;p&gt;</code>、<code>&lt;div&gt;</code> 这种标签，这就需要自己去手动修改了，比较麻烦；</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>前面我们知道了，网站禁用复制的实现原理，那么，只需要按照对应的原理进行破解就 OK 了；</p><h2 id="0-命令"><a href="#0-命令" class="headerlink" title="$=0 命令"></a>$=0 命令</h2><p>许多网站在复制时会弹窗，提示让你登录，或者其它信息，这些网站通常是让你复制时触发 js 代码实现；   </p><p>而在 js 中，由于受到 prototype.js（老外写的框架，用于将一些常用的函数封装，方便操作）的影响，现在很多人都<strong>用 <code>$</code> 来表示一个查找对象的函数</strong>，于是也就有了命令： <code>$=0</code>，这样就能破坏 js 代码的执行；</p><p>具体操作：</p><ul><li><kbd>F12</kbd> 进入开发者模式，点击 <kbd>Console</kbd>；</li><li>输入：<code>$=0</code>，回车执行，再返回去复制即可；</li></ul><p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/jscode.jpg" alt="jscode"></p><h2 id="禁用-js-代码"><a href="#禁用-js-代码" class="headerlink" title="禁用 js 代码"></a>禁用 js 代码</h2><p>上面提到的办法，不能保证 100% 的让 js 失效，所以接下来，我们直接设置禁用 js 代码；</p><p>以 Google 浏览器为例（其它浏览器大同小异）：</p><ul><li>进入 <kbd>设置</kbd> -&gt; <kbd>隐私设置和安全性</kbd> -&gt; <kbd>网站设置</kbd> -&gt; <kbd>JavaScript</kbd></li><li>将 <kbd>允许</kbd> 关闭，或者，将文档那个网站加入到禁止名单即可；</li><li>回去，刷新网站，就可以复制了；</li></ul><p>使用完后，别忘了将设置还原！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果，你尝试完上述所有方法依旧不管用，那就是我们之前提到过得，网站使用了 <code>user-select: none;</code> 设置 css 样式进而停用用户选择，它是不受 js 影响的。所以，此方法处理起来比较复杂；</p><p>通常，<kbd>F12</kbd> 进入开发者模式，进入 Elements 选项卡，然后取消选中 body 下面的 CSS 规则：</p><ul><li>具体规则见前文：<a href="#mao">规则查看</a></li><li>主要是：<code>user-select: none;</code> 和 <code>webkit-user-select：none;</code></li></ul><p>或者说，可以使用用户脚本来覆盖设置（<a href="https://qastack.cn/superuser/1282718/how-do-websites-block-selecting-text-and-how-do-i-unblock-that" target="_blank" rel="noopener">方法来源</a>）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Force Select</span></span><br><span class="line"><span class="comment">// @version      1.0</span></span><br><span class="line"><span class="comment">// @description  Stop sites from disabling selection of text</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        *://*/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">  style.innerHTML = <span class="string">'*&#123; user-select: auto !important; &#125;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><ul><li>如果启用此功能，则将适用于每个页面，这在所有情况下都不是理想的；</li><li>因此，可以使用 Violentmonkey，Tampermonkey 或 Greasemonkey 之类的用户脚本管理器来安装脚本，并轻松打开/关闭该脚本；</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果你能熟练掌握上述所有方法，那么基本所有的文档都能任由你复制了；    </p><p>但是，如果还非要说上面那些方法不会使用，想要更加轻松的方式，那就直接使用第三方插件吧！   </p><p>推荐几款谷歌插件：</p><ul><li>『<a href="https://chrome.google.com/webstore/detail/enable-copy/lmnganadkecefnhncokdlaohlkneihio" target="_blank" rel="noopener">Enable Copy</a>』：安装完后会在 chrome 插件栏上增加一个对勾形状按钮，以后碰到不能直接复制的网页，每次复制网页内容之前，先点此勾形按钮即可；</li><li>『<a href="https://chrome.google.com/webstore/detail/simple-allow-copy/aefehdhdciieocakfobpaaolhipkcpgc?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">simple allow copy</a>』：使用方法，和 Enable Copy 基本相同；</li></ul><p>再就是前面提到过的脚本管理器：『<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Tampermonkey</a>』</p><ul><li>你可以用该脚本管理器添加，前面提及的脚本，也可以自己在上面查找一些相关脚本；</li><li>再提供一款脚本『<a href="https://greasyfork.org/zh-CN/scripts/28497-remove-web-limits-modified" target="_blank" rel="noopener">网页限制解除（改）</a>』供选择；</li></ul><p>最后，送佛送到西，再安利一个文档下载器：</p><ul><li>『<a href="http://www.bingdian001.com/?p=30" target="_blank" rel="noopener">冰点文库下载器</a>』：可以解决常见的像百度文库这种，大部分的文档下载；</li></ul><p>最最最后，只要不嫌麻烦，<strong>包治百病的终极大法</strong>：</p><ul><li>截图 + 文字识别</li><li>至于这两个工具，直接百度，那就是一大堆了；</li></ul><p>那就再附加一个，网页内容选择性打印的脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到你所需要打印的部分的 div，这里是利用 ID 识别</span></span><br><span class="line"><span class="comment">// 你也可以利用 JSP 的 DOM（Document Object Model）的其他方式</span></span><br><span class="line"><span class="comment">// 常用的三种方法：getElementById、getElementsByName、getElementsByTagName</span></span><br><span class="line"><span class="comment">// Element.innerHTML 属性用于设置或返回指定标签之间的 HTML 内容</span></span><br><span class="line"><span class="keyword">var</span> printData = <span class="built_in">document</span>.getElementById(<span class="string">"article_content"</span>).innerHTML;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 html 里的数据复制给 body 的 html 数据 ，相当于重置了整个页面的内容</span></span><br><span class="line"><span class="built_in">window</span>.document.body.innerHTML = printData; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始打印</span></span><br><span class="line"><span class="built_in">window</span>.print();</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5b66993ee51d451924734c35#heading-6" target="_blank" rel="noopener">前端er怎样操作剪切复制以及禁止复制+破解等</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/ResolveCopyProhibition/header.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;    

&lt;p&gt;受疫情影响，现在基本都是远程上课，眼看学期末就要到了，各个课程也纷纷结课。往常的结课考试，自然也就行不通，所以大部分课程开始改为递交课程报告的形式。于是乎，现在天天就是看论文，找资料，写报告……头都大了！特别有时候，好不容易在网上找到一些资料，结果还不让我使用传统的 &lt;kbd&gt;Crtl C+V&lt;/kbd&gt; 大法，有的是让你登录，更狠的直接给你禁了，你都找不到这个选项。现在版权意识越来越重，要说不让随意下载转发，尚还接受，可是，有时候我就想用一下那么几句话，亦或者做下阅读笔记，还得一字一句的打，效率太低了。然后，就开始了各种捣鼓，这里总结出了所有我知道的办法，欢迎评论补充！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Skills" scheme="http://www.thebetterkong.cn/categories/Skills/"/>
    
    
      <category term="Skills" scheme="http://www.thebetterkong.cn/tags/Skills/"/>
    
  </entry>
  
  <entry>
    <title>《Morpheus:A Vulnerability-Tolerant Secure Architecture Based on EMTDs with Churn》阅读笔记</title>
    <link href="http://www.thebetterkong.cn/2020/05/25/Literature-reading-notes/Morpheus-EMTDsWithChurn/"/>
    <id>http://www.thebetterkong.cn/2020/05/25/Literature-reading-notes/Morpheus-EMTDsWithChurn/</id>
    <published>2020-05-25T08:28:21.000Z</published>
    <updated>2020-08-14T09:32:49.185Z</updated>
    
    <content type="html"><![CDATA[<p>目前，主要安全措施都是通过检测异常行为，实现被动防御。<br>而本文主要针对控制流劫持，提出了一种 Morpheus 架构的主动防御机制，它结合移动目标防御将那些正常程序不需要而攻击需要的信息进行随机化和加密处理，以此提高攻击难度，让攻击者需要更多的时间完成 probe，同时，采用一种 churn 方式进一步打乱攻击者攻击节奏。</p><a id="more"></a> <p><a href="https://dl.acm.org/doi/10.1145/3297858.3304037" target="_blank" rel="noopener">《Morpheus：A Vulnerability-Tolerant Secure Architecture Based on Ensembles of Moving Target Defenses with Churn》</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通过观察现有的许许多多的攻击例子，我们可以发现一个大致的规律：<strong>正常程序一般使用给定的程序级语义，但是恶意程序会严重依赖于未定义的语义去完成攻击</strong>。所以，可以说正是因为程序中这些未定义的语义，带来了很大的脆弱性！ </p><ul><li><strong>Undefined semantics</strong>：程序运行时，因底层实现的差异没有被明确定义的语义，比如：数据越界访问、未初始化变量、执行时间、架构共享（如：LLC）。程序员因为各种底层实现的不同，它们不会关注这些语义，但攻击者则会利用这些语义实现攻击。</li></ul><h1 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h1><p>针对这种脆弱性，作者就提出来 Morpheus 架构来主要防御针对控制流的攻击，它主要有两个特点：</p><ol><li>利用 <strong>EMTDs（ensembles of moving target defenses）</strong>，类似 ALSR 对关键性的程序数据进行<strong>随机化</strong>和<strong>加密</strong>；</li><li>采取 <strong>churn 机制</strong>，在运行中对程序进行随机化处理；</li></ol><p>具体来说：以往，ASLR 是在程序运行时完成随机化处理，但是这种一次性的处理方式，攻击者在程序运行期间可以实现类似 AnC 的攻击来获取目标值。   </p><p>对此 Morpheus 采用 EMTDs，提供了一个 504 位（熵）的随机地址空间，即随机化指针存储的位置，同时加密指针的内容。这样，攻击者就需要花费更多大量的时间和精力去 probe。<br>但这肯定还不够，于是又引入了 churn 机制，它最大的特点就是可以在程序运行期间再次进行随机化，它有两种触发方式：</p><ol><li>按初始化的周期，周期性发生（为了短于攻击者 probe 的时间，这个周期会在保证性能的情况下尽量短，文章选为 50ms）；</li><li>被一些潜在的攻击（未定义语义）触发（因为这种时候程序往往正在被攻击，例如攻击者频繁的probe），这一点得益于<strong>攻击检测器</strong>，它有两种规则：「<strong>ABORT 规则</strong>」监视特别严重的操作（明确的攻击行为），并触发终止程序的异常；「<strong>CHURN 规则</strong>」检测到可能正利用未定义行为在进行攻击，针对这些违规行为，启动更改 churn cycle。（攻击检测器逻辑图如下）：<br><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/AttackDetector.png" alt="AttackDetector"></li></ol><p>通过这两种方式来触发 churn，使得攻击者花费大量时间和精力去 probe 想要获取信息（还未获得）时，重新对关键值进行随机化和加密，于是攻击者只能重新开始攻击，但是下一次同样的情况仍会发生，最终攻击失败。这就是 Morpheus 架构的主要防御原理。见图：   </p><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/EMTDsChurn.png" alt="EMTDsChurn"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/MorpheusSecureArchitecture.png" alt="MorpheusSecureArchitecture"></p><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>EMTDs 依赖于域标记机制来精确跟踪运行时所有内存对象的域。</p><p>基于 Morpheus LLVM 的编译器收到未修改的 C 源文件。 然后，在全局变量域分析，将静态初始化的数据部分中的每个内存对象标记为数据，代码指针或数据指针（使用 2 位域标记跟踪四个不同的域：代码(C)、代码指针(CP)、数据指针(DP)、其他数据(D)），之后，生成一个带标签的二进制文件和一个域标签文件，其中包含内存对象的初始标签。   </p><p>对此，为体系结构也做出改变：所有寄存器都扩展 2 bit tags，并将 tag 附加到每个 64 位 aligned word；将 DRAM 和 cache 也搭配上 tag 域，其中，将标签集中到 DRAM 中的固定位置，以简化 churn 过程；所有 data cache blocks 都以每 64 位字扩展 2 位的方式扩展，以在每个缓存块中存储增加的域标签位。</p><h2 id="EMTDs"><a href="#EMTDs" class="headerlink" title="EMTDs"></a>EMTDs</h2><h3 id="PART1：指针移位（Pointer-Displacement）"><a href="#PART1：指针移位（Pointer-Displacement）" class="headerlink" title="PART1：指针移位（Pointer Displacement）"></a>PART1：指针移位（Pointer Displacement）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/PointerDisplacement.png" alt="PointerDisplacement"></p><p>如图所示，就是在指针原来的位置上加上了一个 $d_{CODE}(DAS_C)$ 或 $d_{DATA}(DAS_D)$ 的偏移量，并且这个偏移量是随机产生的。</p><h3 id="PART2：域加密（Domain-Encryption）"><a href="#PART2：域加密（Domain-Encryption）" class="headerlink" title="PART2：域加密（Domain Encryption）"></a>PART2：域加密（Domain Encryption）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/DomainEncryption.png" alt="DomainEncryption"></p><p>使用强密码（由域标记选择的它们自己的域密钥，分别对应 $K_C、K_{CP}、K_{DP}$，并且他们会在内存里受到保护）将内存中的代码，代码指针和数据指针的表示随机化。</p><p>如图所示，当在 L1-L2 边界之间读取内存（加载或取指令）时，将对受保护域进行解密，并在 L1-L2 边界之间写入（存储）内存时对受保护域进行加密，从而使 L2 缓存和 DRAM 保持加密状态。</p><p>由 tag 选择适当的密码密钥，密钥和物理地址通过密码进行组合，让包含相同值的内存位置不相关。对地址进行加密后，就可以使用反向模式的密码，在这种模式下，会生成密钥流，并与受保护的 value 进行 XOR 运算，以对其进行加密或解密。</p><h2 id="Churn"><a href="#Churn" class="headerlink" title="Churn"></a>Churn</h2><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Churn.png" alt="Churn"></p><p>在程序运行过程中，会周期性的经历 churn，每一次的 churn 又包含如下四个阶段：</p><ol><li>管道刷新；</li><li>新密钥生成和寄存器更新；</li><li>使用阈值寄存器来协调新位移和加密密钥下存储器中的更新值；</li><li>churn 完成时，所有域都已更新，有效地处置了攻击者先前可能已获取的任何信息；</li></ol><p>总的来说，就是 churn 会周期性的更新加密用的域秘钥（$K_C、K_{CP}、K_{DP}$）和指针移位（$d_{CODE}$、$d_{DATA}$），但是更新后的这两项会与原先的旧值产生冲突，于是引入了一个<strong>阀值寄存器</strong>来协调，它将使用新 key 和 displacement 状态记为 “clean”，而旧值的记为 “stale”，以此进行区分。</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Effect.png" alt="Effect"></p><ul><li>可以防御表 4 所示的所有攻击，并且他们都能触发攻击感测器进一步提高了防御效果；</li><li>在没有加入 Morpheus 防御机制的情况下，完成 probe 穿透所需的时间就已经是 churn cycle（50ms）的很多倍（5020），所以说，在加入了EMTDs 后，完全可以保证在攻击者彻底完成 probe 穿透前，触发 churn。</li></ul><h1 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Performance.png" alt="Performance"></p><p>自古 「安全-性能」 就很难两全其美，前面看到了 Morpheus 在防御上的优势，那么这种机制对性能的影响也肯定是一个需要考量的因素。   </p><p>文中提到，将 50ms 作为正常的 churn 周期，由图一可看到，平均情况下，它对处理器性能的影响只下降了 1% 左右，这是一个很好的结果。</p><p>即使在 SPEC’06 基准测试的最坏情况下，由图二我们也能看出它仅仅只是在 403-gcc 这一项上造成了相对高的性能损耗，这也是我们能接受的范围。</p><p>所以，总的来说就是，Morpheus 采用 EMTDs 和 churn 这两种机制，以较低的性能损耗大大提高了安全性。</p><h1 id="不成熟的两个小想法"><a href="#不成熟的两个小想法" class="headerlink" title="不成熟的两个小想法"></a>不成熟的两个小想法</h1><ol><li>文中并未具体谈论到 churn cycle 初始值（50ms）如何设置，攻击者似乎可以先攻击 churn cycle，人为修改它的值？</li><li>攻击检测器的存在，会因为检测到攻击而触发 churn 或者直接中断程序，对此，如果攻击者起初的目标不是获取信息，那么他也可以利用这个性质不断地“伪造攻击”，进而不断触发攻击检测器，这样大大拖低处理器性能，甚至导致程序瘫痪。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前，主要安全措施都是通过检测异常行为，实现被动防御。&lt;br&gt;而本文主要针对控制流劫持，提出了一种 Morpheus 架构的主动防御机制，它结合移动目标防御将那些正常程序不需要而攻击需要的信息进行随机化和加密处理，以此提高攻击难度，让攻击者需要更多的时间完成 probe，同时，采用一种 churn 方式进一步打乱攻击者攻击节奏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文献阅读笔记" scheme="http://www.thebetterkong.cn/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Computer Architecture" scheme="http://www.thebetterkong.cn/tags/Computer-Architecture/"/>
    
      <category term="ASLR" scheme="http://www.thebetterkong.cn/tags/ASLR/"/>
    
  </entry>
  
  <entry>
    <title>利用爬虫实现课程网站资源的批量下载</title>
    <link href="http://www.thebetterkong.cn/2020/05/22/Crawler/CrawlSEPBatchDownload/"/>
    <id>http://www.thebetterkong.cn/2020/05/22/Crawler/CrawlSEPBatchDownload/</id>
    <published>2020-05-22T09:13:12.000Z</published>
    <updated>2020-08-14T09:27:53.474Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/head.png" width="100%" alt="head.png" /> </div>   <p>现在大学上课，老师一般都是通过学校的课程网站来分享课程的课件等资源。但是，在果壳大课程网站上下载资源，总是需要一项一项的点入，再单击下载，显得十分麻烦，特别有时囤积了大量资源需要去下载，还得比对一下哪些没有下载，这对于我这种数据强迫症的人来说，十分不友好！<br>恰巧那会对爬虫挺感兴趣的，就寻思着拿这个练练手（重在学习），说做就做吧！Let’s go！</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先，得先定我的需求：</p><ol><li>可以选择课程，对该课程的所有课件实现一键下载；</li><li>鉴于我的数据强迫症，课件下载完毕后，应该能向我反馈下载的信息，主要就是新下载了哪些课件；</li><li>由于疫情的特殊原因，学校采取了网上授课的方式，但是家里网络不稳定，总是故障，考虑下载视频到本地观看，也便于课后复习；（想想以前，为了能课后复习，都是拿着电脑在上课的时候现场录的）；</li></ol><p>现在，需求以及清楚，接下来就是开始捣鼓课程网站的情况；    </p><ul><li>正常情况下，我们首先需求登录，进入教务系统主页；</li><li>然后，进入课程网站主页；</li><li>然后，在自己的选课情况中，选择课程，进入到课程主页；</li><li>然后，找到进入该课程主页的资源页面；</li><li>进入相关资源，并点击下载；</li></ul><p>Emmm，用的时候都还好，这么一捋愈发觉得麻烦了……</p><h1 id="弯路：webdriver"><a href="#弯路：webdriver" class="headerlink" title="弯路：webdriver"></a>弯路：webdriver</h1><p>果壳大的教育业务平台网址是：<a href="http://sep.ucas.ac.cn/" target="_blank" rel="noopener">http://sep.ucas.ac.cn/</a> ，要想进行后面的操作，首先，就得实现教育业务平台的自动登录；   </p><p>起初嘛，刚接触爬虫，对网络也不是特别了解。脑海里冒出来最简单的思路就是：利用 selenium 的 webdriver 模拟登录过程，然后获取 cookies，之后再利用 cookies 登录；</p><ol><li><code>pip install selenium</code> 安装 selenium；<ul><li>selenium 是 ThoughtWorks 提供的一个强大的基于浏览器的开源自动化测试工具。支持的浏览器包括 IE、Chrome 和 Firefox 等；</li></ul></li><li>到相应的官网下载浏览器驱动，我这里下载的是火狐的浏览器驱动；</li></ol><p>接下来，写段程序测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">headers = &#123;</span></span><br><span class="line"><span class="string">    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span><span class="params">( )</span>:</span></span><br><span class="line">    user = input(<span class="string">"请输入用户名："</span>)</span><br><span class="line">    password = input(<span class="string">"请输入密码："</span>)</span><br><span class="line">    driver = webdriver.Firefox()</span><br><span class="line">    driver.get(<span class="string">'http://sep.ucas.ac.cn/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#time.sleep(3)</span></span><br><span class="line">    <span class="comment"># 清空登录框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录用户名</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).send_keys(user)</span><br><span class="line">    <span class="comment"># 清空密码框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录密码</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).send_keys(password)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 点击登录按钮进行登录</span></span><br><span class="line">    driver.find_element_by_class_name(<span class="string">'loginbtn'</span>).click()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取cookies</span></span><br><span class="line">    cookie_items = driver.get_cookies()</span><br><span class="line">    cookie = [item[<span class="string">"name"</span>] + <span class="string">"="</span> + item[<span class="string">"value"</span>] <span class="keyword">for</span> item <span class="keyword">in</span> cookie_items]</span><br><span class="line">    cookie_str = <span class="string">';'</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> cookie)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'cookie.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cookie_str)</span><br><span class="line">    f.close()</span><br><span class="line">    print(<span class="string">"已获取到cookies！"</span>)</span><br><span class="line"></span><br><span class="line">    headers_cookie = &#123;</span><br><span class="line">        <span class="string">"Cookie"</span>: cookie_str  <span class="comment"># 通过接口请求时需要cookies等信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session = requests.session()</span><br><span class="line">    session.post(<span class="string">'http://sep.ucas.ac.cn/'</span>, headers=headers_cookie)</span><br><span class="line">    print(<span class="string">'登录系统成功……'</span>)</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    session = log_in()</span><br></pre></td></tr></table></figure></p><p>本以为，万事大吉，结果运行测试，emmmmm……才意识到，还得输入验证码！   </p><p>那就继续造：</p><ul><li>要用到图形处理，所以 <code>pip install pillow</code>；<ul><li>坑：安装 pillow，但是导入的时候是 PIL；</li></ul></li><li>抓取下来验证码，还不够，肯定还得识别验证码内容，选择百度文字识别的 OCR，<code>pip install baidu_api</code>；</li></ul><blockquote><p>pillow 的原身是 PIL（Python Imaging Library），PIL 是 Python 图像处理标准库，功能非常强大，API 却非常简单易用；<br>但是 PIL 仅支持到 Python 2.7，后来由志愿者在此基础上创建了兼容的版本，即：Pillow，支持最新Python 3.x，又加入了许多新特性<br>百度文字识别的OCR，即：Optical Character Recognition，光学字符识别</p></blockquote><p>然后，在上面代码的基础上，新增如下内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 导入下载的第三方库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 查找验证码</span></span><br><span class="line">png = driver.find_element_by_id(<span class="string">'captcha_img'</span>)  <span class="comment"># 查找验证码元素</span></span><br><span class="line">png.screenshot(<span class="string">'captcha.png'</span>)  <span class="comment"># 对验证码截图并保存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码处理</span></span><br><span class="line"><span class="comment"># 用 pillow 库对验证码进行图像处理，提高验证码的识别率；</span></span><br><span class="line"><span class="comment"># 处理方法：</span></span><br><span class="line"><span class="comment">#   1.先将图像转换成灰度模式</span></span><br><span class="line"><span class="comment">#   2.通过对阈值的调整使得多余的噪点消失</span></span><br><span class="line">img = Image.open(<span class="string">'captcha.png'</span>)</span><br><span class="line">img = img.convert(<span class="string">'L'</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">count = <span class="number">165</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; count:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line">img = img.point(table, <span class="string">'1'</span>)</span><br><span class="line">img.save(<span class="string">'captcha1.png'</span>)  <span class="comment"># 保存处理后的验证码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码识别</span></span><br><span class="line"><span class="comment"># 调用 baidu_api 的通用文字识别接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别码</span></span><br><span class="line">APP_ID = <span class="string">'***'</span></span><br><span class="line">API_KEY = <span class="string">'***'</span></span><br><span class="line">SECRET_KEY = <span class="string">'***'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化对象</span></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">image = get_file_content(<span class="string">'captcha.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数变量</span></span><br><span class="line">options = &#123;<span class="string">'language_type'</span>: <span class="string">'ENG'</span>, &#125;  <span class="comment"># 识别语言类型，默认为'CHN_ENG'中英文混合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用通用文字识别</span></span><br><span class="line">result = client.basicGeneral(image, options)  <span class="comment"># 高精度接口 basicAccurate</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> result[<span class="string">'words_result'</span>]:</span><br><span class="line">    captcha = (word[<span class="string">'words'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出，检查结果</span></span><br><span class="line">print(<span class="string">'识别结果：'</span> + captcha)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空验证码框</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).clear()</span><br><span class="line"><span class="comment"># 自动填入验证码</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).send_keys(captcha)</span><br></pre></td></tr></table></figure></p><p>至此，总算是完成了登录过程，麻不麻烦？<br>肯定麻烦啊！而且有个很大的问题，就是每次运行会启动 webdriver，把程序拖得很慢，十分影响使用体验，所以我后来才改用了其他方法；</p><p>但是也不得不说，这段弯路也让我学到了挺多东西，还是很有意义的！</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>其实说正解不太准确，只是说这个办法更加简单易行罢了；</p><p>之所以会突然又提出新的办法，是因为有一次，我发现果壳大的综合信息网（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ）也可以登录到教育业务平台，而且在这里登录<strong>不需要验证码！</strong><br>这下子，终于可以去掉上面那繁琐的验证码处理过程了。   </p><p>但是，这只解决了一个问题，还是无法让我摆脱 webdriver。于是，我寻思这么难顶的资源下载方式，难道就没有前人 “种个树”？再仔细搜了搜，还真有！</p><p>原作者的程序是一键下载课程网站<strong>所有课程所有课件</strong>，呃……，对我来说有点夸张了，毕竟几十门课程，怎么得也有个几百项资源吧？也许对于一个爬虫来说爬取这些资源不算什么，但是，还有好多资源我可能不那么需要，事后还得整理。不过无妨，程序框架在这了，修改起来也简单。     </p><p>确定修改目标：</p><ol><li>能够输出选课的课程目录，供按课程批量下载课件；</li><li>加入视频下载功能；</li></ol><p><strong>开干！！！</strong></p><h2 id="网站登录"><a href="#网站登录" class="headerlink" title="网站登录"></a>网站登录</h2><p>首先，是登录信息，这里采用了直接将登录信息保存在 txt 文本文件里，避免了我原先那样每次运行脚本都需要手动输入的尴尬。简单的文本处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#读取登录信息，第一行存账号，第二行存密码</span></span><br><span class="line">        config = open(<span class="string">"user.txt"</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        line = config.readline().split()</span><br><span class="line">        username = line[<span class="number">0</span>]</span><br><span class="line">        password = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure></p><p>重点来了，这次登录改用了 requests 库的 session 会话对象，构造 post 表单的方式实现登录，并且由于 session 对象的特性，也便于我们后续其他页面的操作；</p><blockquote><p>session 的特性体现在它的作用时间：从用户到达某个特定的 Web 页开始，到该用户离开 Web 站点，或在程序中利用代码终止某个 Session 结束。<br>引用 Session 则可以让一个用户访问多个页面，之间的切换也会保留该用户的信息；<br>说白了，就是一旦我们使用 session 成功的登录了某个网站后，则在再次使用该 session对象求求该网站的其他网页都会默认使用该 session 之前使用的 cookie 等参数；<br>详细用法参见文章：<a href="https://www.cnblogs.com/linxiyue/p/3980003.html" target="_blank" rel="noopener">Python Requests库：HTTP for Humans</a></p></blockquote><ol><li>构造请求头：<ul><li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/findheader.png" alt="findheader"></li><li><code>Accept</code>：用户代理期望的 MIME 类型列表，不用管；</li><li><code>Accept-Encoding</code>：用户代理支持的压缩方法，不用管；</li><li><code>Accept-language</code>：用户代理期望的页面语言，不用管；</li><li><code>Connection</code>：决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。因此，需要设置；</li><li><code>Cookie</code>：就不用说了，我们目标就是自动获取<strong>登录后</strong>的 cookie；</li><li><code>host</code>：指明服务器域名，需要设置；</li><li><code>upgrade-insecure-requests</code>：用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 upgrade-insecure-requests CSP 指令。</li><li><code>User-Agent</code>；指明用户代理软件的应用类型、操作系统、软件开发商以及版本号；</li><li>更多详情可见：『<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">MDN web docs</a>』</li></ul></li><li>构造 post 表单：<ul><li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式（未登录状态）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost1.jpg" alt="buildpost1"><ul><li><code>Preserve log</code>：保留 log 信息；</li><li><code>XHR</code>：（XMLHttpRequest）筛选出与服务器的交互信息；</li></ul></li><li>然后，开发者模式设置完成后，在浏览器输入信息登录（不要关闭开发窗口）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost2.jpg" alt="buildpost2"></li><li>很明显，我所需要的信息应该在 Name = 0，的那条记录里，打开这条记录；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost3.png" alt="buildpost3"></li><li>在 Form Data 里就有我们构造 post 表单所需要去构造的信息，为：用户名、密码、是否记住密码，这三个字段；</li></ul></li></ol><p>这一部分代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()  <span class="comment"># 创建 session 对象</span></span><br><span class="line">login_url = <span class="string">'http://onestop.ucas.ac.cn/'</span>  <span class="comment"># 更换为不需要验证码登录的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 构造请求头</span></span><br><span class="line">headers=  &#123;</span><br><span class="line">            <span class="string">'Host'</span>: <span class="string">'onestop.ucas.ac.cn'</span>,</span><br><span class="line">            <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">'http://onestop.ucas.ac.cn/home/index'</span>,</span><br><span class="line">            <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,  <span class="comment"># 指明 Ajax 请求(异步)，注意，这样返回的数据是 json 类型</span></span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">### 构造表单数据</span></span><br><span class="line">post_data = &#123; </span><br><span class="line">            <span class="string">"username"</span>: username,</span><br><span class="line">            <span class="string">"password"</span>: password,</span><br><span class="line">            <span class="string">"remember"</span>: <span class="string">'checked'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">html = session.post(login_url, data=post_data, headers=headers).text <span class="comment"># 请求，并建立 session</span></span><br><span class="line"><span class="comment"># 将返回的 json 数据转换为 html 文本保存</span></span><br><span class="line">res = json.loads(html)</span><br><span class="line">html = session.get(res[<span class="string">'msg'</span>]).text</span><br><span class="line">print(<span class="string">'登录系统成功！'</span>)</span><br><span class="line"><span class="comment"># save_html(html)  # 用来保存 html 文本做检测</span></span><br></pre></td></tr></table></figure><p>这样，我们就有了一个建立了连接的 session，以后就可以利用该 session 完成其他页面的操作；</p><h2 id="进入课程网站"><a href="#进入课程网站" class="headerlink" title="进入课程网站"></a>进入课程网站</h2><p>首先，查找进入课程网站的 url：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/tocoursesite1.jpg" alt="tocoursesite1">    </p><p>利用之前的 session 访问：<code>h_k = session.get(url)</code></p><p>这里有个注意点，在我们直接点击课程网站图标时，会进入一个跳转页面，而我们刚刚 session 访问到的就是这个跳转页面，所以实际上我们还并没有进入到课程网站页面中去；   </p><p>为了便于分析，将 session.get() 到的对象转换成文本文件存储：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    f = open(<span class="string">'test.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    f.write(html)</span><br><span class="line">    f.close</span><br><span class="line"></span><br><span class="line"><span class="comment">### 调用</span></span><br><span class="line">url = <span class="string">"http://sep.ucas.ac.cn/portal/site/16/801"</span>   <span class="comment"># 跳转页面地址</span></span><br><span class="line">h_k = session.get(url)   <span class="comment"># 访问跳转，并获取返回的对象</span></span><br><span class="line">save_html(h_k.text) <span class="comment"># 转换为文本文件保存下来</span></span><br></pre></td></tr></table></figure></p><p>打开 h_k.text，我们知道跳转页面里，提示信息会有 “点击这里跳转” 这种选项，在这个文本里 <kbd>ctrl F</kbd>，输入：“跳转”，就可以看到，确实存在一个标签，如下：<br>（当然了，也可以在跳转的时候，强制停止刷新网页，然后在跳转页面用开发者模式查找 “这里” 这个字段的 href）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row-fluid"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"span12"</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>2秒钟没有响应请点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://course.ucas.ac.cn/portal/plogin?Identity=fbd361f2-73cc-48b7-a5ec-37528b27a058&amp;roleId=801"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这里<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>直接跳转<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--//container-fluid:end--&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来，利用正则表达式，获取这个 url 里，Identity 的值（身份认证信息），重新构造 url，直接进入到课程网站页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用正则表达式找Request URL，Identity后的身份认证信息</span></span><br><span class="line">key = re.findall(<span class="string">r'"https://course.ucas.ac.cn/portal/plogin\?Identity=(.*)"'</span>, h_k.text)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 利用得到的身份认证信息，打开课程网站系统</span></span><br><span class="line">url = <span class="string">"http://course.ucas.ac.cn/portal/plogin/main/index?Identity="</span> + key</span><br><span class="line">page = session.get(url)</span><br><span class="line">print(<span class="string">'课程网站系统进入成功！'</span>)</span><br><span class="line"><span class="keyword">return</span> page</span><br></pre></td></tr></table></figure><h2 id="获取课程信息"><a href="#获取课程信息" class="headerlink" title="获取课程信息"></a>获取课程信息</h2><p>先进入主页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，找到课程网站的主页地址，并进入主页</span></span><br><span class="line">mycourseBS = BeautifulSoup(courseSite.text,<span class="string">"lxml"</span>) <span class="comment"># 利用 lxml 解析 text 文本</span></span><br><span class="line">url_mycourse = mycourseBS.find_all(<span class="string">'a'</span>,&#123;<span class="string">"class"</span>:<span class="string">'Mrphs-toolsNav__menuitem--link'</span>&#125;)[<span class="number">0</span>] <span class="comment"># 找 class 名为 xxx 的 a 标签</span></span><br><span class="line">url_mycourse = url_mycourse[<span class="string">"href"</span>] <span class="comment"># 获取 href ，即获取 url </span></span><br><span class="line">coursePage = session.get(url_mycourse)  <span class="comment"># 访问进入主页</span></span><br></pre></td></tr></table></figure><p>在我的课程里，获取课程信息：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/courseinfo.jpg" alt="courseinfo"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，在课程网站主页，寻找课程信息，并利用元组的形式记录在course_list中</span></span><br><span class="line">coursePageBS = BeautifulSoup(coursePage.text,<span class="string">"lxml"</span>) </span><br><span class="line">Course_info = coursePageBS.find_all(<span class="string">'li'</span>,&#123;<span class="string">"class"</span>:<span class="string">"fav-sites-entry"</span>&#125;)</span><br><span class="line">length = len(Course_info)   <span class="comment"># 标签数，即：课程总数</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line">print(<span class="string">"所选课程总数为："</span>,length)</span><br><span class="line">print((<span class="string">"已选课程列表："</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length<span class="number">-1</span>):</span><br><span class="line">    info = Course_info[i]</span><br><span class="line">    tag = info.div.a</span><br><span class="line">    courseName = tag[<span class="string">"title"</span>]  <span class="comment">#课程名字</span></span><br><span class="line">    print(<span class="string">"   "</span>,i,courseName)</span><br><span class="line">    courseUrl = tag[<span class="string">"href"</span>]   <span class="comment">#课程链接</span></span><br><span class="line">    course_list.append((courseName,courseUrl)) <span class="comment">#利用元组的形式保存</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line"><span class="keyword">return</span> course_list</span><br></pre></td></tr></table></figure></p><h2 id="课件下载"><a href="#课件下载" class="headerlink" title="课件下载"></a>课件下载</h2><p>后面的页面跳转等处理，其实都类似，这里只介绍一些关键点，毕竟主要的目的在于学习：    </p><p>进入课程资源页面，这里直接将关键的 BeautifulSoup 查找语句列出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 访问进入某课程后，在课程页面里，利用 “资源” 模块的 title 查找，拿到其 href，即 url</span></span><br><span class="line">url = h_bs.find_all(title=<span class="string">"资源 - 上传、下载课件，发布文档，网址等信息"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure><br>查找所有资源链接：</p><ul><li>这里文件夹的处理，涉及到 onclick()，展开文件夹，更新 html 页面，但是这里我没态弄太明白，后面再琢磨。可以的话，可以在评论区给我留言一些相关知识讲解文章；</li></ul><p>下载文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### className：文件夹名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_kj</span><span class="params">(url, fileName, className, session)</span>:</span></span><br><span class="line">    <span class="comment">### 文件名称处理</span></span><br><span class="line">    <span class="comment"># \xa0（不间断空白符&amp;nbsp）转gbk（汉字内码扩展规范）会有错，去掉；</span></span><br><span class="line">    fileName = fileName.replace(<span class="string">u"\xa0"</span>, <span class="string">" "</span>).replace(<span class="string">u"\xc2"</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="comment"># 去掉不合法的文件名字符</span></span><br><span class="line">    fileName = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, fileName)</span><br><span class="line">    className = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, className)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径构造，os.getcwd()获取当前路径</span></span><br><span class="line">    dir = os.getcwd() + <span class="string">"/"</span> + className</span><br><span class="line">    file = os.getcwd() + <span class="string">"/"</span> + className + <span class="string">"/"</span> + fileName</span><br><span class="line">    <span class="comment"># 没有课程文件夹则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="comment"># 存在该文件，返回</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">        print(<span class="string">"%s已存在，就不下载了"</span> % fileName)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    print(<span class="string">"开始下载%s..."</span> % fileName)</span><br><span class="line">    s = session.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">"wb"</span>) <span class="keyword">as</span> data:</span><br><span class="line">        data.write(s.content)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h2><p>进入课程资源页面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_bs = BeautifulSoup(h.text, <span class="string">"lxml"</span>)</span><br><span class="line">url = h_bs.find_all(title=<span class="string">"课程视频 - 课程视频"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure></p><p>又分为：课程视频（录播），直播视频（回放），这两部分处理方法一样，以第一项为例：</p><p>由于视频页可能包含多页，先抓取各个页的链接：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当时写的比较傻，采用循环加载下一页做的，其实可以直接抓取网页下面显示的页数，然后在原来 url 的基础上构造为： url+"&amp;pageNum="+i 即可；</span></span><br><span class="line">allpageURL.append(url)</span><br><span class="line">        flag =<span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> flag:</span><br><span class="line">            s = session.get(allpageURL[i])</span><br><span class="line">            page = re.search(<span class="string">'&lt;span&gt;&lt;a href="([^上]*?)"&gt;下一页&lt;/a&gt;&lt;/span&gt;'</span>,s.text, re.S)  <span class="comment"># 其实就是获取："&amp;pageNum="+i</span></span><br><span class="line">            <span class="keyword">if</span> page :</span><br><span class="line">                page = page.groups()[<span class="number">0</span>]</span><br><span class="line">                pageURL = <span class="string">'http://course.ucas.ac.cn'</span> + page</span><br><span class="line">                allpageURL.append(pageURL)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>接下来，就是循环在每页，不断的获取所有视频播放的 url，然后进入到播放页面，再找到视频源的 url 即可；    </p><p>视频下载：由于果壳大视频采用的 .m3u8 流媒体格式，我使用到了 ffmpeg（需要提前在电脑上安装）；用 subprocess 模块来产生子进程，调用 ffmpeg 完成下载；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 按照获取到的视频链接调用ffmpeg进行下载，也可以尝试多进程下载，提高下载速度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_sp</span><span class="params">(spName, spUrl)</span>:</span></span><br><span class="line">    ins = <span class="string">'ffmpeg -i '</span> + spUrl + <span class="string">' -c copy '</span> + spName +<span class="string">'.mp4'</span></span><br><span class="line">    p = subprocess.Popen(ins)</span><br><span class="line">    p.wait()</span><br><span class="line">    print(<span class="string">'下载完毕'</span>)</span><br></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实这个脚本是挺久之前弄的了，但是总觉得之前边写边学，零零碎碎，慢慢的又觉得忘的差不多了。这当然不行，于是，重新梳理总结了一下当时的编写历程。     </p><p>通过这次，主要学习到的知识点：</p><ol><li>利用 webdriver 模拟登陆，以及遇到验证码时，将验证码抓取下来处理，并完成识别；</li><li>利用 session 构造 post 表单的方式，实现网站登录；</li><li>正则表达式的使用；</li><li>BeautifulSoup 的查找方法；</li><li>subprocess 的简单使用；</li><li>等等</li></ol><p>不足：</p><ul><li>还需要学习 js 的处理方法；</li></ul><p>最后还是需要强调一下，重在学习，利用脚本下载的资源，仅供自己学习使用，请不要传播！</p><ul><li>『<a href="https://github.com/TheBetterKong/UCAS_Sep" target="_blank" rel="noopener">脚本源码</a>』</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li>『<a href="https://zhuanlan.zhihu.com/p/94402506" target="_blank" rel="noopener">python实现网站的自动登录</a>』</li><li>『<a href="https://blog.csdn.net/lusongno1/article/details/79995009" target="_blank" rel="noopener">国科大（UCAS）课件自动批量下载 python3 脚本</a>』</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/head.png&quot; width=&quot;100%&quot; alt=&quot;head.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;现在大学上课，老师一般都是通过学校的课程网站来分享课程的课件等资源。但是，在果壳大课程网站上下载资源，总是需要一项一项的点入，再单击下载，显得十分麻烦，特别有时囤积了大量资源需要去下载，还得比对一下哪些没有下载，这对于我这种数据强迫症的人来说，十分不友好！&lt;br&gt;恰巧那会对爬虫挺感兴趣的，就寻思着拿这个练练手（重在学习），说做就做吧！Let’s go！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Crawler" scheme="http://www.thebetterkong.cn/categories/Crawler/"/>
    
    
      <category term="Python" scheme="http://www.thebetterkong.cn/tags/Python/"/>
    
      <category term="Crawler" scheme="http://www.thebetterkong.cn/tags/Crawler/"/>
    
      <category term="Webdriver" scheme="http://www.thebetterkong.cn/tags/Webdriver/"/>
    
  </entry>
  
  <entry>
    <title>改进 Hexo 中 MathJax 数学公式的渲染</title>
    <link href="http://www.thebetterkong.cn/2020/05/20/Blog-Related/ImproveMathJax/"/>
    <id>http://www.thebetterkong.cn/2020/05/20/Blog-Related/ImproveMathJax/</id>
    <published>2020-05-20T09:05:14.000Z</published>
    <updated>2020-08-14T09:25:32.765Z</updated>
    
    <content type="html"><![CDATA[<p>之前，更新了一篇<a href="http://www.thebetterkong.cn/2020/04/04/Blog-Related/Markdown-Writing/">《Markdown 写作指南》</a>的博文，这次更新重点梳理了一下 MathJax 数学公式的书写。在之后 Blog 书写过程中，也就越来越多的开始依赖 MathJax 数学公式。但是，有时候，我发现我的公式书写完全正确，并且在本地 vscode 的预览也能渲染出正确结果。可是，当我部署到我的 blog 里时，公式总是出现大大小小的问题。不知道，你是否也有过这样的疑惑？</p><a id="more"></a> <p>首先，得先说一下，这里说的 MathJax 渲染出错，是你已经在主题配置文件下设置了 mathJax 为 true，依旧出现公式渲染出错；</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>经过网上一番了解。其实，造成这种现象主要原因是 Hexo 默认的渲染引擎 hexo-renderer-marked 对公式渲染时与 Mathjax 发生了一些冲突，导致了 bug；</p><blockquote><p>实际渲染中，Hexo 默认的 MarkDown 渲染引擎 hexo-renderer-marked 会调用 marked 模块的 node_modules\marked\lib\marked.js 脚本进行最终的解释，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签：</p><ul><li>在 markdown 语法中，下划线 <code>_</code> 代表斜体，会被渲染引擎处理为 <code>&lt;em&gt;</code> 标签；</li><li><code>\\</code> 也会被转义成一个 <code>\</code>；<ul><li>而 Latex 格式书写的数学公式下划线 <code>_</code> 表示角标，<code>\\</code> 表示公式换行，有特殊的含义，所以 MathJax 引擎在渲染数学公式的时候就会出错；</li><li>类似的语义冲突的符号还包括 <code>*, {, }</code> 等。</li></ul></li></ul></blockquote><p>解决思路：</p><ul><li>针对下划线的问题，markdown 的 marked.js 中有两种斜体的表示方式，因此取消 <code>_</code> 作为斜体转义，以后用 <code>*</code> 作为斜体表示即可；</li><li>针对 marked.js 与 Mathjax 对于个别字符二次转义的问题，我们只要不让 marked.js 去转义 <code>\\,\{,\}</code> 在 MathJax 中有特殊用途的字符就行了。</li></ul><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>首先，可以更换 Hexo 的 markdown 渲染引擎：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-renderer-marked --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-kramed --save</span></span><br></pre></td></tr></table></figure></p><ul><li>说明：<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级；</li><li>但是也需要注意，更换完后，可能对原先的 markdown 书写有一些影响，但是我个人觉得影响不大，如果你对此十分介意，想了解受影响的地方，可以参考该引擎官方文档；</li><li>其实你也可以直接跳过此步，按照下面的内容，直接修改上面提到过的 node_modules\marked\lib\marked.js 脚本；</li></ul><p>此时，hexo-renderer-kramed 只是修改了部分 bug，还不足以解决所有冲突，为了避免以后再出现其他问题，这里再手动进一步修改一下：</p><ul><li>到博客的根目录下，找到 node_modules\kramed\lib\rules\inline.js；</li><li>修改第 11 行的 escape 变量的值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure><ul><li>这一步是在原基础上取消了对 <code>\ , { , }</code> 的转义（escape）；</li></ul></li><li>现在在第 21 行的 em 变量也要做相应的修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line">em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure><ul><li>这一步取消了对斜体标记_的转义</li></ul></li></ul><p><strong>清除原先 hexo 缓存</strong>，重新生成部署就可以看到问题已经解决了。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>因为我们在主题配置文件中开启了 mathJax，因此，对所有的文章都会使用 mathJax 进行渲染，即使有些文章里，你根本没用上 mathJax，这样会影响你页面的访问速度。   </p><p>因此，可以考虑在文章的 Front-matter 里针对性的打开 mathjax 开关：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 改进 Hexo 中 MathJax 数学公式的渲染</span><br><span class="line">data: 2020-05-20 17:05:14  </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>Blog 相关</span><br><span class="line"></span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>Blog</span><br><span class="line"></span><br><span class="line">mathjax: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/weixin_30725467/article/details/96659102" target="_blank" rel="noopener">1:《在Hexo中渲染MathJax数学公式》</a></li><li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">2:《在Hexo中渲染MathJax数学公式》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前，更新了一篇&lt;a href=&quot;http://www.thebetterkong.cn/2020/04/04/Blog-Related/Markdown-Writing/&quot;&gt;《Markdown 写作指南》&lt;/a&gt;的博文，这次更新重点梳理了一下 MathJax 数学公式的书写。在之后 Blog 书写过程中，也就越来越多的开始依赖 MathJax 数学公式。但是，有时候，我发现我的公式书写完全正确，并且在本地 vscode 的预览也能渲染出正确结果。可是，当我部署到我的 blog 里时，公式总是出现大大小小的问题。不知道，你是否也有过这样的疑惑？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog 相关" scheme="http://www.thebetterkong.cn/categories/Blog-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Blog" scheme="http://www.thebetterkong.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>FPGA-CAD Tools：Placement</title>
    <link href="http://www.thebetterkong.cn/2020/05/13/FPGA-technology/FPGA-CADTools-Placement/"/>
    <id>http://www.thebetterkong.cn/2020/05/13/FPGA-technology/FPGA-CADTools-Placement/</id>
    <published>2020-05-13T08:24:36.000Z</published>
    <updated>2020-08-14T09:29:55.388Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍 FPGA 技术里 placement 部分；</p><a id="more"></a> <h1 id="概述：FPGA-Placement"><a href="#概述：FPGA-Placement" class="headerlink" title="概述：FPGA Placement"></a>概述：FPGA Placement</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>涉及电路块网表（就逻辑集群而言）的过程，该电路表要分配到 FPGA 上的某些物理位置：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/WhatPlacement.png" alt="WhatPlacement"></p><ul><li>在 routing 之前，任何 FPGA placement 的主要目标是产生一个可以使用 FPGA 提供的<strong>有限布线资源成功进行布线</strong>的布置；<ul><li>利用 placement algorithms，对 CLB 进行 Placement，以便路由信号所需的互连最小化，这一步对 FPGA 的性能影响很大；</li></ul></li><li>布局是 FPGA 设计流程中的关键部分，大约需要一半的 “编译” 时间；</li></ul><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>好的 placement 非常重要：</p><ul><li>设置可路由性的条件；</li><li>即使电路能布通，放置不良也会导致最大工作速度降低并增加功耗；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/GoodandBadPlacement.png" alt="GoodandBadPlacement"></p><p>寻找一个好的 placement 是一个挑战：</p><ul><li>大型商用 FPGA 包含超过 500,000 个功能块，这意味着它有 $500,000!$ 个可能的placements，因此不可能进行详尽的评估；</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这三个目标互相影响，很难同时对三个目标都达到最优，所以往往会进行综合考虑，不同的目标导致不同的性能表现结果：</p><ol><li>减少所需的接线：Wirelength-driven 的放置<ul><li>两个箱子之间有互连关系，就尽量把它们放在一起；</li></ul></li><li>平衡布线密度：Routability-driven 的放置<ul><li>有关电路 connection 的拥塞；</li></ul></li><li>最大化电路速度：Timing-driven 的放置<ul><li>延迟最小，即关键路径尽量短；</li></ul></li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol><li>Accommodation Limit（住宿限制）<ul><li>RAM 块必须放置在 RAM 位置，CLB 必须放置在 CLB 位置，依此类推；</li></ul></li><li>Specific Group（特定群体）<ul><li>构成进位链的算术逻辑簇必须按照进位结构要求的顺序彼此相邻放置；</li></ul></li><li>Routing Congestion（路由拥塞）<ul><li>当互连超出了 FPGA 某些部分的装配布线能力时；</li></ul></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>在放置 placement 期间，placer 尝试寻找合法的解决方案，以便将所有块都分配给目标 FPGA 芯片上的有效位置；</li><li>它针对<strong>多个设计目标进行了优化</strong>，例如：线长，电路延迟，布线拥塞和功耗；</li><li>由于<strong>块的位置通常在放置 placement 阶段之后是固定的</strong>，并且 placement 对布线质量有很大的影响，因此，放置试探法能够产生高质量的解决方案非常重要。</li><li>大多数 FPGA 布局算法可分为三种类型：<strong>Simulated Annealing(模拟退火)</strong>、<strong>Analytical(分析)</strong> 和 <strong>Partitioning-Based(基于分区)</strong>；<ul><li>“模拟退火”可能是使用最广泛的。</li></ul></li></ul><h1 id="Simulated-Annealing-Algorithm"><a href="#Simulated-Annealing-Algorithm" class="headerlink" title="Simulated Annealing Algorithm"></a>Simulated Annealing Algorithm</h1><h2 id="Physical-Annealing"><a href="#Physical-Annealing" class="headerlink" title="Physical Annealing"></a>Physical Annealing</h2><p>Annealing：一种<strong>热处理</strong>，可改变材料的物理和化学性质，以<strong>增加其延展性</strong>并<strong>降低其硬度</strong>，从而使其更易加工：</p><ul><li>Annealing(退火)：冷却热分子以形成良好的晶体结构</li><li>从高温开始，分子随机移动</li><li>按照特定的冷却时间表进行冷却，要求留出足够的时间使分子形成晶格   </li></ul><p>属于<strong>热力学问题</strong>：由于原子在固体材料中的扩散而发生，因此材料向其平衡状态发展。   </p><p>传统过程（例如金属）：</p><ul><li>加热：取一金属并将其加热到高温，给它一个初始温度，原子过渡到高能态；</li><li>冷却：使其<strong>缓慢</strong>冷却，金属退火至低温。在温度下降期间，原子缓慢地移动到低能态；</li><li><strong>初始温度越高，冷却越慢，金属变得越坚硬</strong>；</li></ul><h2 id="SA（Simulated-Annealing）"><a href="#SA（Simulated-Annealing）" class="headerlink" title="SA（Simulated Annealing）"></a>SA（Simulated Annealing）</h2><p>一种模拟物理退火过程的概率技术，用于逼近给定函数的全局最优值。具体来说，就是一种元启发式方法，在大型搜索空间中寻找接近全局优化的解；    </p><p>SA 算法用于求解组合极问题和 NP 完全问题，其步骤如下：</p><ul><li>Step 1：以初始状态和温度开始（热力学类比）；</li><li>Step 2：<strong>随机</strong>改变状态，创造新的状态；</li><li>Step 3：比较新状态和当前状态的能量：<ul><li><strong>「接受」</strong>：如果新状态的能量较小，或者概率函数 $e^{-\Delta C/T}$ 小于随机值（$\Delta C$表示能量变化，$T$ 表示当前温度）；<ul><li>添加第二个条件的目的就是为了防止出现局部最小值而引入的 hill climb 方法：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/HillClimb.png" alt="HillClimb"></li></ul></li><li><strong>「拒绝」</strong>：其它新状态</li></ul></li><li>Step 4：启发式地迭代步骤 2〜3，最后达到平衡状态（为每个温度创建一个新状态）；</li></ul><p>运用到 FPGA 实际上就是一种迭代过程：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/FPGASA.png" alt="FPGASA"></p><ul><li>placer 程序提议在 SA 过程中随机移动；</li><li>每个潜在的移动（可能是两个相同类型的块之间的位置交换，或者一个块向有效空白空间的移动）都将导致 placement 成本的变化；</li><li>Annealer（退火炉）使用此更改或 “∆C” 来做出移动决策；<ul><li>与金属退火过程相似，即使代价成本增高（即：“不良举动”），在较高的温度下也有较高的机会接受更高的代价；</li><li>在 SA 期间必须执行 “爬山”，以减少陷入局部极小值的机会；</li><li>总是接受降低整体成本的 “好举动”；</li><li>随着温度下降，Annealer 将接受较少的 “不良动作”；</li></ul></li><li>满足预定义的退出条件时，SA 过程最终将停止；</li></ul><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li><strong>温度（T）</strong>：<ul><li>控制算法去接受那些使解决方案变得更糟的动作的可能性（$e^{-\Delta C/T}$）；</li></ul></li><li><strong>成本函数（C）</strong>：<ul><li>一定温度下的能量状态；</li></ul></li><li><strong>退火时间表</strong>（时间表越好，算法就越好）：<ul><li>温度降低的速率；</li><li>终止退火的退出标准；</li><li>在每个温度下尝试移动的次数；</li><li>产生潜在移动的方法；</li></ul></li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ol><li>对参数的敏感性：<ul><li>状态空间，成本函数，候选生成器，接受概率函数以及退火进度温度和初始温度等等……</li><li>他们之间的相互作用不被理解（过于复杂，只能凭借经验去尝试）；</li></ul></li><li>冻结问题：<ul><li>有时无法逃脱局部最小值；</li><li>特别是在低温下，接受不良动作的可能性非常低；</li></ul></li></ol><h1 id="Place-Algorithm-VPlace"><a href="#Place-Algorithm-VPlace" class="headerlink" title="Place Algorithm: VPlace"></a>Place Algorithm: VPlace</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>基于模拟退火；</li><li>新的自适应退火时间表；</li><li>引入了边界框；</li><li>具有 timing 驱动版本（增加了了面积驱动）；</li><li>深入研究了 VTR 中使用的学术 placement 工具；</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleVplace.png" alt="ExampleVplace"></p><h2 id="通用伪代码"><a href="#通用伪代码" class="headerlink" title="通用伪代码"></a>通用伪代码</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/VPackPseudoCode.png" alt="VPackPseudoCode"></p><h2 id="Adaptive-Annealing-Schedule"><a href="#Adaptive-Annealing-Schedule" class="headerlink" title="Adaptive Annealing Schedule"></a>Adaptive Annealing Schedule</h2><h3 id="Initial-Placement"><a href="#Initial-Placement" class="headerlink" title="Initial Placement"></a>Initial Placement</h3><ul><li>S = InitialPlacement（），S 是当前放置状态；</li><li>通过将逻辑块随机分配给 FPGA 中的可用位置来创建初始放置；</li></ul><h3 id="Initial-Temperature"><a href="#Initial-Temperature" class="headerlink" title="Initial Temperature"></a>Initial Temperature</h3><ul><li>$N_{blocks}$ 是所需的<u>逻辑块/群集</u>的数量加上<u>所需的 IO 焊盘</u>的数量；</li><li>使用预定义的概率执行 $N_{blocks}$ 的<strong>移动</strong>，并针对这些关于 $N_{blocks}$ 的不同 placement <strong>计算 cost 的标准偏差</strong>；</li><li><strong>初始温度</strong>设置为该标准偏差的 <strong>20 倍</strong>；</li><li>由于高温特性，一开始就接受所有动作；</li></ul><h3 id="Temperature-Update-Strategy"><a href="#Temperature-Update-Strategy" class="headerlink" title="Temperature Update Strategy"></a>Temperature Update Strategy</h3><ul><li>$T_{new} = \gamma \cdot T_{old}$<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TemperatureUpdate.png" alt="TemperatureUpdate"><ul><li>$R_{accept}$ 是当前温度下接受的尝试移动的一部分；</li><li>算法开始时，几乎接受了所有的移动，因此，可以将 $\gamma$ 设置比较小，使温度变化快一些，但是随着算法的进行，接受的移动策略越来越少，此时，应该将温度的变化幅度减小；</li></ul></li></ul><h3 id="Range-Limiter"><a href="#Range-Limiter" class="headerlink" title="Range Limiter"></a>Range Limiter</h3><ul><li>$R_{limit}$ 是尝试交换块的范围跨度；</li><li>$R_{limit}$ 最初设置为整个芯片的跨度，并在温度降低到一定水平以下时缩小($R_{accept} \leq 0.44$)；<script type="math/tex; mode=display">1(single\ block) \leq R_{limit} \leq  maximum\ FPGA\ dimension\ (R_{accept} \leq 0.44)</script></li><li>更新方法：<script type="math/tex; mode=display">R_{limit\_new} = R_{limit\_old} \cdot \underbrace{(1-0.44+R_{accept})}_{\leq 1}(R_{accept} \leq 0.44)</script></li></ul><h3 id="Moves-per-Temperature"><a href="#Moves-per-Temperature" class="headerlink" title="Moves per Temperature"></a>Moves per Temperature</h3><script type="math/tex; mode=display">MovesPerTemperature = InnerNum \ast {N_{blocks}}^{\frac{3}{4}}</script><ul><li>InnerNum 的默认值为 10，以允许使用不同的 CPU 时间 / placements 质量进行权衡；</li><li>将 MovesPerTemperature 降低 10 倍，可将 placer 的速度提高 10 倍，并将最终 placement 质量降低不到 10％；</li></ul><h3 id="Terminate-Criterion"><a href="#Terminate-Criterion" class="headerlink" title="Terminate Criterion"></a>Terminate Criterion</h3><p>$T &lt; \epsilon \cdot Cost / N_{nets}$</p><ul><li>$N_{nets}$ 是电路中的网络数；</li><li>$\epsilon$＝ 0.005（经验值）；<ul><li>0.05 到 0.005 之间的任何值都是合理的；</li><li>较小的值会以稍微增加的 CPU 时间为代价提供更高的 placement 质量；</li></ul></li></ul><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>Cost Function 主要取决于 Bounding Box，但是实际计算过程中，并没有那么简单，我们还需要考虑通道的宽度等因素，于是引入了 Linear Congestion，将 Bounding Box 的计算进一步精确</p><h3 id="Bounding-Box-Wirelength-Driven"><a href="#Bounding-Box-Wirelength-Driven" class="headerlink" title="Bounding Box (Wirelength-Driven)"></a>Bounding Box (Wirelength-Driven)</h3><ul><li>Net 是在电路网表中共享相同源的一组节点和连接（可能有多个 sinks）；</li><li>估算电线长度要求的模型：<script type="math/tex; mode=display">Wring_{Cost}=\sum^{N_{nets}}_{i=1}\ q(i) \cdot [\ bb_x(i)+bb_y(i)\ ]</script><ul><li>$bb_x(i)$ 是Net i的水平跨度；</li><li>$bb_y(i)$ 是Net i的垂直跨度；</li><li>$q(i)$ 将在后面讨论，实际考虑更复杂，是采用下一小节的办法计算的；</li></ul></li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleBoundingBox.png" alt="ExampleBoundingBox"></p><h3 id="Linear-Congestion-Wirelength-Driven"><a href="#Linear-Congestion-Wirelength-Driven" class="headerlink" title="Linear Congestion (Wirelength-Driven)"></a>Linear Congestion (Wirelength-Driven)</h3><script type="math/tex; mode=display">Cost=\sum^{num\_nets}_{i=1}q(i)(\frac{bb_x[i]}{[C_{av,x}(i)]^\beta}+\frac{bb_y[i]}{[C_{av,y}(i)]^\beta})</script><ul><li>$q(i)$ 是 Net i 的权重，对于具有 3 个或更少 terminals 的 Net i，$q(i)$ 设置为 1。超过 3 个 terminals 的，线性增加的速率为：<script type="math/tex; mode=display">q(i)=2.79+0.02616 \cdot (\ Num\_Terminals-50\ )</script></li><li>$C_{av,x}(i)$ 和 $C_{av,y}(i)$ 分别是 Net i 边界框上 x 和 y 方向的平均信道容量（通道宽度）；</li><li>$\beta$ 允许调整使用窄通道和宽通道的相对成本。设置为1（经验值）；<ul><li>$\beta=0$，恢复为标准 bounding box cost function，上一小节的情形；</li><li>$\beta$ 的值越大，相对于较宽通道的布线，较窄通道的布线受到的惩罚越多（布局时，尽量选用更宽的通道）；</li></ul></li></ul><p>运用举例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleLinearCongestion.png" alt="ExampleLinearCongestion"></p><ul><li>问题：有一个映射的网表，它具有 3 个 nets，每个 nets 具有 3 个 terminals，在 x 和 y 方向上的平均信道容量为 4，计算 Cost；</li><li>解决方案：<ul><li>每个 nets 都有 3 个 terminals，$q(1)=q(2)=q(3)=1$；</li><li>设置 $\beta=1$，并且 $bb_x[.]$ 和 $bb_y[.]$ 的值表都有给出；</li><li>$Cost = 1\ast(2/4+4/4) + 1\ast(4/4+4/4) + 1\ast(6/4+4/4) = 1.5+2+2.5=6$</li></ul></li></ul><h3 id="Linear-Congestion-vs-Bounding-Box"><a href="#Linear-Congestion-vs-Bounding-Box" class="headerlink" title="Linear Congestion vs. Bounding Box"></a>Linear Congestion vs. Bounding Box</h3><ul><li>$\beta = 0$: Bounding box</li><li>$\beta &gt; 0$: Linear congestion</li><li>logic-bound：仅 I/O placement</li><li>I/O-bound：仅 logic cluster placement</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/LCVsBB.png" alt="LCVsBB"></p><h3 id="Bounding-Box-re-calculation-问题"><a href="#Bounding-Box-re-calculation-问题" class="headerlink" title="Bounding Box re-calculation 问题"></a>Bounding Box re-calculation 问题</h3><ul><li>即使制定了良好的 annealing schedule，在典型的 placement 过程中也将<strong>评估数百万个潜在的块交换</strong>，计算量太大；</li><li>评估 swap 上最昂贵的计算部分是计算 swap 产生的 cost 变化 $\delta C$；尽快进行此计算至关重要；</li><li>$\delta C$ 中唯一更改的 term 是与两个交换的块所连接的网络相对应的 term；即，计算公式里面的 $bb_x[i]$ 和 $bb_y[i]$；</li><li>于是引入了一种，递增式的 Incremental Bounding Box Evaluation；</li></ul><h3 id="Incremental-Bounding-Box-Evaluation"><a href="#Incremental-Bounding-Box-Evaluation" class="headerlink" title="Incremental Bounding Box Evaluation"></a>Incremental Bounding Box Evaluation</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IncrementalBoundingBoxEvaluation.png" alt="IncrementalBoundingBoxEvaluation"></p><ul><li>$X_{min}，X_{max}，Y_{min}，Y_{max}$：对于每个网络，我们存储其边界框的四个边的每一边的坐标；</li><li>$N_{xmin}，N_{xmax}，N_{ymin}，N_{ymax}$：位于每侧的 net terminals 数；</li><li>假设此网络的 terminal 通过交换从 $(x_{old},y_{old})$ 移至 $(x_{new},y_{new})$；</li><li>可以仅通过查看移动的 terminal 而不是所有 k terminal 来确定新的边界框；</li><li>如果移动的 terminal 是边界框一侧的唯一 terminal，并且现在已向内移动到边界框的中心，仅此情况需要完全重新计算；</li><li>这样就减少了 CPU 时间；</li></ul><p>伪代码描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IBBEPsudoCode.png" alt="IBBEPsudoCode"></p><h1 id="Place-Algorithm：T-VPlace"><a href="#Place-Algorithm：T-VPlace" class="headerlink" title="Place Algorithm：T-VPlace"></a>Place Algorithm：T-VPlace</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>时序驱动的 VPlace 版本；</li><li>新的成本函数可以在<strong>导线长度</strong>和<strong>关键路径延迟</strong>之间进行权衡；</li><li>对于给定的恒定输入集，无论执行程序多少次，<strong>结果都是相同</strong>的；</li><li><strong>良好的可重复性</strong>，可用于代码调试，错误重现/</li><li>客户支持和回归测试；</li><li>速度提高 42％，同时减少线长的 5％；</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TVPackPsudoCode.png" alt="TVPackPsudoCode"></p><h2 id="延迟模型"><a href="#延迟模型" class="headerlink" title="延迟模型"></a>延迟模型</h2><p>计算延迟矩阵：</p><ul><li>两个块之间的延迟仅作为距离 $(\Delta x,\Delta y)$ 的函数；</li><li>使用 router 确定相距 $(\Delta x,\Delta y)$ 距离的两个块之间的延迟，并将其记录在位置索引 $(\Delta x,\Delta y)$ 的<strong>delay look up matrix</strong>（延迟查找矩阵）中；</li><li>重复此过程，直到在 FPGA 中计算出所有可能的位置 $(\Delta x,\Delta y)$；</li><li>由于 router 足够智能，因此只需要记录两个块之间的最小延迟，之后的按照简单的倍数相乘就能得到了；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/DelayModel.png" alt="DelayModel"></p><h2 id="Timing-Analysis"><a href="#Timing-Analysis" class="headerlink" title="Timing Analysis"></a>Timing Analysis</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TrequiredTarrival.png" alt="TrequiredTarrival"></p><p><strong>Arrival Time</strong>：</p><script type="math/tex; mode=display">T_{arrival}(i)=Max_{\forall j \in fanin(i)}\{T_{arrival}(j)+delay(j,i)\}</script><ul><li>节点 i 是当前正在计算的节点；</li><li>$delay(j,i)$ 是连接节点 j 到 i 的边缘的延迟值；</li><li>电路延迟是所有节点的最大到达时间 $D_{max}$；</li></ul><p><strong>Required Time</strong>：</p><script type="math/tex; mode=display">T_{required}(i)=Min_{\forall j \in fanout(i)}\{T_{required}(j)-delay(i,j)\}</script><ul><li>将所有接收器的 $T_{required}$ 设置为 $D_{max}$ 并向后计算；</li></ul><p><strong>Slack of a connection (i,j)</strong>：</p><script type="math/tex; mode=display">Slack(i,j)=T_{required}(j)-T_{arrival}(i)-delay(i,j)</script><h2 id="Cost-Function-1"><a href="#Cost-Function-1" class="headerlink" title="Cost Function"></a>Cost Function</h2><h3 id="Timing-Cost"><a href="#Timing-Cost" class="headerlink" title="Timing Cost"></a>Timing Cost</h3><p>基于每个连接的 Criticality，每个连接的 Delay 和用户定义的 Criticality_Exponent：    </p><script type="math/tex; mode=display">Criticality(i,j)=1-\frac{Slack(i,j)}{Dmax}</script><p>Criticality_Exponen 可以对那些重要的连接进行加权，而对其他非关键连接的加权则较小:     </p><script type="math/tex; mode=display">Timing\_Cost(i,j)=Delay(i,j)\ Criticality(i,j)^{Criticality\_Exponent}</script><p>总 timing cost 是所有连接的 timing cost 之和:     </p><script type="math/tex; mode=display">Timing\_Cost=\sum_{\forall i,j \in cricuit}\ Timing\_Cost(i,j)</script><h3 id="Auto-normalizing-Cost"><a href="#Auto-normalizing-Cost" class="headerlink" title="Auto-normalizing Cost"></a>Auto-normalizing Cost</h3><script type="math/tex; mode=display">\Delta C=\lambda \cdot \frac{\Delta Timing\_Cost}{Previous\_Timing\_Cost}+(1-\lambda)\cdot \frac{\Delta Wiring\_Cost}{Previous\_Wiring\_Cost}</script><ul><li>权衡变量 $\lambda$，以确定应赋予每个组件多少权重；<ul><li>仅使用变量 $\lambda$ 来使函数两个分量的权重，而与它们的实际值无关；</li></ul></li><li>Previous_Timing_Cost 和 Previous_Wiring_Cost，每个温度更新一次（规范化组件）；</li><li>继承 VPlace 的 annealing schedule，因为它是 “自适应的”，并且在新的成本函数中表现良好；</li></ul><h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><h3 id="调整-Timing-Analysis-间隔"><a href="#调整-Timing-Analysis-间隔" class="headerlink" title="调整 Timing Analysis 间隔"></a>调整 Timing Analysis 间隔</h3><ul><li>将 $\lambda$ 的值设置为 1（完全由时序驱动），Criticality_Exponent 设置为 1；</li><li>然后，改变对电路进行时序分析的频率，并更新连接的 Criticality 和 slack；</li><li>扫描从执行开始时一直执行一次，一直到 placement 算法内部循环内的时序分析：</li></ul><p>分析结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningTimingAnalysisInterval.png" alt="TuningTimingAnalysisInterval">  </p><ul><li>每个温度执行一次时序分析足以获得最佳的放置结果；</li><li>似乎此重新分析间隔不会影响 placement 的 bounding box (wirelength) cost；</li></ul><h3 id="调整-Criticality-Exponent"><a href="#调整-Criticality-Exponent" class="headerlink" title="调整  Criticality_Exponent"></a>调整  Criticality_Exponent</h3><p><strong>取 $\lambda = 0.5$ ：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningCriticalityExponent1.png" alt="TuningCriticalityExponent1"></p><ul><li>将 criticality exponent 提高到大约 8 或 9 会改善 placement 估算的关键路径，此时不再有明显的收益；</li><li>大指数可改善 Wiring_Cost；</li><li>分析：<ul><li>大指数使得 connections 少的具有很大的 Timing_Cost，而其他连接具有无关紧要的Timing_Cost；</li><li>高 Criticality_Exponent 导致关键电路中的连接数量减少，但对于这少数几个连接，Timing_Cost 占标准化 cost 的最大部分；</li><li>对于其他非关键连接（随着 Criticality_Exponent 的增加，其他非关键连接会更多），Wiring_Cost 占标准化 cost 的最大部分；</li></ul></li></ul><p><strong>取 $\lambda = 1$ ：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningCriticalityExponent2.png" alt="TuningCriticalityExponent2"></p><ul><li>指数值最好为 2 或 3；</li><li>$\lambda = 1$ 的延迟结果比 $\lambda = 0.5$ 差，Wiring_Cost 差很多。</li><li>分析：<ul><li>该算法很可能能够在外循环的一次迭代期间显着减少关键路径，但同时又无意中使其他路径变得非常关键；</li><li>这种振荡效应使放置算法难以收敛到最佳放置解决方案；</li><li>通过在成本方程中包含一个线长最小化项，我们可以减少放置的振荡；</li><li>这是因为 wire-length 这一项将惩罚那些大大增加 wire-length 的移动，使它们不太可能被接受，即使它们会大大减少当前的关键路径；</li><li>在我们的成本函数中，线长项作为延迟最小化项的阻尼器，并防止振荡；</li></ul></li></ul><h3 id="调整-lambda"><a href="#调整-lambda" class="headerlink" title="调整 $\lambda$"></a>调整 $\lambda$</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/Tuninglambda.png" alt="Tuninglambda"></p><p>仅由 wire-length driven 的算法可产生最佳的 Wiring_Cost；</p><ul><li>$\lambda=0.9$ 的算法产生的电路具有最佳 placement 估计的关键路径延迟；</li><li>$\lambda=1$ 时，对于关键路径，延迟和导线长度都不利；</li><li>将 $\lambda$ 设置为 0.5 可在导线长度和关键路径最小化之间取得最佳折衷；</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>先前的结果表明，使用每个温度一次的时序分析间隔，Criticality_Exponent 值为 8，$\lambda$ 为 0.5 可以提供迄今为止最好的结果</li><li>基于这些结果，我们将定时分析间隔设置为每个温度一次，Criticality_Exponent 设置为 8，设置不同的 $\lambda$；</li></ul><h1 id="Place-with-Multiple-I-O-Standards"><a href="#Place-with-Multiple-I-O-Standards" class="headerlink" title="Place with Multiple I/O Standards"></a>Place with Multiple I/O Standards</h1><p>以 Virtex 和 Virtex-E FPGAs 为例，设计的 I/O 对象和 core logic 的三个不同位置：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/MultipleIOStandards.png" alt="MultipleIOStandards">    </p><p>具有不同阴影的 I/O 对象不兼容，不能一起放置在同一存储库中，假设每个芯片边缘只有一个 I/O 库：</p><ul><li>图（a）描述了在没有与 bank 的 I/O 组织相关的约束的情况下可以实现的放置；</li><li>图（b）描绘了一个受约束的 I/O 布局，其中一组兼容的 I/O 对象分布在两个 banks 之间；</li><li>图（c），如果我们使用幼稚的方法放置 I/O 对象，即将每组兼容的 I/O 对象放置在一个 bank 中；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IOStandardVoltage.png" alt="IOStandardVoltage"></p><ul><li>当前 FPGA 支持的 I/O 标准在几种方面彼此不同；</li><li>一些 I/O 标准要求使用差分放大器输入：<ul><li>使用此类标准时，用户必须向放大器提供外部参考电压 Vref；</li><li>使用差分放大器可以减少 I/O 电压摆幅，从而加快开关速度；</li></ul></li><li>第二个特征是某些标准要求特定的电源电压 Vcco 为 I/O 模块供电；</li></ul><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/OrganizationVirtexEFPGA.png" alt="OrganizationVirtexEFPGA"></p><ul><li>Vref 和 Vccovoltages 由外部提供，并连接到为 I/O 模块组（称为存储体）提供服务的特殊引脚；</li><li>组中的所有 I/O 块均由单个 Vref 电压和单个 Vcco 电源电压供电；</li><li>Virtex-E FPGA 每个芯片边缘有两个 I / O bank，或者总共有八个 bank；</li></ul><p>总结来说：</p><ul><li>具有 Vref 和 Vcco 电压的 bank 在同一 bank 中进行组合的 I/O 标准的限制：<ul><li>两个 I/O 对象，由于其 I/O 标准而需要不同的 Vref 或不同的 Vccovoltage，它们就不能合法的放在同一 bank；</li></ul></li><li>我们看到，使用 GTL 标准的输入 I/O 对象不能与使用 HSTL_I 标准的输入 I/O 对象放在同一存储体中，因为这两个标准需要不同的 Vref 电压；</li><li>bank 组织在 I/O 灵活性和用户可用的 I/O 块数量之间提供了合理的权衡；</li></ul><p>解决方式：</p><ul><li>采用的 annealing cost function 考虑了 wirelength，timing cost 以及 非法 I/O placement 导致的违反 banking 的行为：<script type="math/tex; mode=display">PlacementCost=\alpha \cdot WirelengthCost + \beta \cdot TimingCost + \gamma \cdot BankingViolationCost</script></li><li>placement 期间，移动 core logic blocks 时，仅会影响wirelength cost 和 the timing cost，而 I/O 移动可能会影响所有三个项的值；</li><li>违反 banking rule 的 cost 是通过将每个 bank 的违规相加得出的：<script type="math/tex; mode=display">BankingViolationCost=\sum_{i \in B}BankCost_i\ ,\ B\ is\ the\ set\ of\ all\ I/O\ banks</script></li><li>Vref 冲突或 Vcco 冲突可能导致 bank 内部违规； </li><li>当 bank 包含由于其使用的标准而需要将多个 Vref 电压施加到同一 bank 的 I/O 对象时，会发生 Vref 冲突。Vcco 冲突的定义与此类似。</li><li>bank 的 cost i 是 Vref 冲突 cost 和 Vcco 冲突 cost 之和：<script type="math/tex; mode=display">bankCost_i=vrefConflictCost_i+vccoConflictCost_i</script></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍 FPGA 技术里 placement 部分；&lt;/p&gt;
    
    </summary>
    
    
      <category term="可编程逻辑系统设计与 FPGA 技术" scheme="http://www.thebetterkong.cn/categories/%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E-FPGA-%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="国科大研究生课程笔记" scheme="http://www.thebetterkong.cn/tags/%E5%9B%BD%E7%A7%91%E5%A4%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FPGA" scheme="http://www.thebetterkong.cn/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>Hexo &amp; Next 的配置，做自己的主人</title>
    <link href="http://www.thebetterkong.cn/2020/05/09/Blog-Related/Hexo-Next-FileOrganization/"/>
    <id>http://www.thebetterkong.cn/2020/05/09/Blog-Related/Hexo-Next-FileOrganization/</id>
    <published>2020-05-09T08:48:14.000Z</published>
    <updated>2020-08-14T09:25:28.114Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Hexo-Next-FileOrganization/head1.png" width="100%" alt="header.png" /> </div>    <p>最开始接触 Blog，总会遇到各种各样大大小小的问题，但是在网络上查找各种解决办法的时候，往往都是只告诉了你怎么做，却没有说为什么？我们也就机械化的进行<kbd>ctrl+c</kbd>，<kbd>ctrl+v</kbd>，这是十分不可取的。因此本着「授人以鱼不如授人以渔」的想法，决定对整个  Hexo 和 Next 的文件组织进行一波系统的整理，既便于我们维护管理，也可以更好<strong>更官方</strong>的进行 Blog 主题优化。</p><a id="more"></a> <h1 id="Hexo-篇"><a href="#Hexo-篇" class="headerlink" title="Hexo 篇"></a>Hexo 篇</h1><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>这是官方解释：</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。   </p></blockquote><p>安装（详细过程这里就不再阐述）：</p><ul><li>安装 <code>Git</code>，分散式版本控制软件</li><li>安装 <code>Node.js</code>，一个基于 Chrome V8 引擎的 JavaScript 运行时</li><li>使用 <code>npm</code> 安装 <code>Hexo</code>，npm 是 node.js 的包管理器</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>这里是从官网上摘录的一些我们日常中经常使用的命令：</p><ul><li><code>hexo init [folder]</code>：新建一个网站。<ul><li>如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</li></ul></li><li><code>hexo new [layout] &lt;title&gt;</code>：新建一篇文章；<ul><li>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替；</li><li>如果标题包含空格的话，请使用引号括起来；</li><li><code>hexo publish [layout] &lt;filename&gt;</code>：发表草稿</li></ul></li><li><code>hexo g</code>：生成静态文件；<ul><li><code>hexo g -f</code>：效果接近 <code>hexo clean &amp;&amp; hexo generate</code></li></ul></li><li><code>hexo d</code>：部署网站<ul><li>常用组合：<code>hexo g -d</code></li></ul></li><li><code>hexo server</code>:启动服务器。<ul><li>默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li></ul></li><li><code>hexo clean</code>：清除缓存文件 (db.json) 和已生成的静态文件 (public)<ul><li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</li></ul></li></ul><h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>Hexo 在指定文件夹中初始化完毕后，会出现如下文件结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><br>在后面的实际使用过程中还会创建一些其他文件或文件夹，后面都会进行说明。</p><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的配置信息，在此修改大部分的配置参数； </p><ul><li>这里直接查看内容，就能理解大部分的配置内容，如果实有不懂，更建议可查看官方文档，如下；</li></ul><p>详见：『<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置 | Hexo</a>』</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。可以查看 hexo 的版本以及安装的扩展版本。</p><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。<br>详见：『<a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模版 | Hexo</a>』</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源 文件夹是存放用户资源的地方。</p><h4 id="posts-文件夹"><a href="#posts-文件夹" class="headerlink" title="_posts 文件夹"></a>_posts 文件夹</h4><p>存放博客文章的地方，其中的 Markdown 文件、Html 文件、org 文件等会被解析并放到 public 文件夹，发布到站点。</p><ul><li>建议在这个文件夹下，<strong>按照文章分类创建子文件夹</strong>（按分类正常命名即可，不要加_(下划线)，便于文章过多时进行管理和维护；</li></ul><h4 id="其他开头命名为-下划线-的-文件-文件夹-和隐藏的文件"><a href="#其他开头命名为-下划线-的-文件-文件夹-和隐藏的文件" class="headerlink" title="其他开头命名为 _ (下划线)的 文件/文件夹 和隐藏的文件"></a>其他开头命名为 _ (下划线)的 文件/文件夹 和隐藏的文件</h4><p>会被忽略；</p><ul><li>建议在 source 目录下：</li><li>创建 _drafts 目录：存放未完成的草稿，其中内容不会发布到网站；<ul><li>可以再在这个目录下创建个子目录 img，便于 blog 草稿书写时利用 <code>./img/picturename.png</code> 引用本地图片，然后可以直接将整个文件夹上传至图床，然后再用匹配，一键替换 <code>./img</code> 为完整的图床 url；</li></ul></li><li>创建 _images 目录：图片一般会用图床，但是这样可以保存文章里的图片备份，后期可以上传到 coding 等平台进行 Blog 备份，避免数据丢失；</li></ul><h4 id="其他文件-文件夹"><a href="#其他文件-文件夹" class="headerlink" title="其他文件/文件夹"></a>其他文件/文件夹</h4><p>会被拷贝到 public 目录并上传到站点；</p><ul><li>如果要添加新的页面（例如：about），执行 <code>hexo new page PageName</code> 命令即会在 source 中自动新建子目录 <code>PageName</code> </li></ul><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题 文件夹。默认安装 landscape 主题，可以安装新主题到 themes 目录，也可以自己新建主题。   </p><p>这也是我们下面要讨论的 Next 主题文件存放的文件夹；</p><h3 id="deploy-git"><a href="#deploy-git" class="headerlink" title=".deploy_git"></a>.deploy_git</h3><p>在部署到 github 后自动创建：</p><ul><li>此目录中的内容 == github 站点中对应 repository 中的内容 == 最近一次上传到站点的public目录中的内容</li></ul><p>因此，该目录的结构和 public 目录基本一致；</p><ul><li>不一致的情况是由于重新生成，但是没有发布站点造成，此时 public 内容新于 .deploy_git 内容；</li></ul><h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>存放安装的 Hexo 扩展；</p><ul><li>Hexo 会默认安装一些扩展，在使用过程中自己安装的扩展也会在此新建目录；</li></ul><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>存放生成的静态网页内容；</p><ul><li>执行 <code>hexo g</code> 命令，Hexo 程序会解析 source 、当前使用的 theme，将生成的静态网页内容保存到 piblic；</li><li>执行 <code>hexo d</code> 则将该目录内容复制到 .deploy_git 目录，然后由 Hexo 的部署插件 hexo-deployer-git 根据 _config.yml 里的 deploy 配置，完成上传；</li></ul><h3 id="git-和-gitignore"><a href="#git-和-gitignore" class="headerlink" title=".git 和 .gitignore"></a>.git 和 .gitignore</h3><p>这个主要是用于 Blog 源资源的备份，防止电脑故障后数据丢失，也便于 Blog 的迁移；</p><ul><li>直接在 coding（这个源文件往往比较大，coding速度快） 新建仓库，然后在本地 blog 源文件夹下初始化，生成 .git；</li><li>.gitignore：整个 Blog 源文件夹下，往往有许多文件是不需要我们去备份的，于是，我们就把这些不需要备份的文件/文件夹写到这里；</li></ul><h3 id="db-json"><a href="#db-json" class="headerlink" title="db.json"></a>db.json</h3><blockquote><p>db-json 是完全在 json 中的数据库。数据库，查询和结果都是 json 数据。它在客户端和服务器端均可使用。<br>数据库结构化，表由类型化字段组成，并带有可选验证（模式，长度，范围）<br>该库在浏览器和节点上均可使用。<br>dabase 的 json 代码是人类可读的，并且可以方便地在手边进行编辑。 如果发生任何错误，则在使用该 json 代码实例化新的 Database 对象时将检测到它们。</p></blockquote><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>package-lock.json 是在 <code>npm install</code> 时候生成一份文件，用以记录当前状态下实际安装的各个 npm package 的具体来源和版本号；</p><p>以下是引用的知乎@周载南的解释：</p><blockquote><ul><li>因为 npm 是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。</li><li>这时候用户就很头疼了：在完全相同的一个 node.js 的代码库，在不同时间或者不同 npm 下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容；</li><li>因此 npm 最新的版本就开始提供自动生成 package-lock.json 功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个 package-lock.json 所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</li></ul></blockquote><p>所以也就是说，原先的 package.json 只能帮助我们锁定大版本号（即：第一位），但是由于有的库包开发者并没有严格遵守规则，从而可能出现大版本号下的小版本不兼容等问题，让我们在更新或者迁移到新机器进行环境安装时出现各式各样的问题，package-lock.json 由此赢然而生，当我们每次安装一个依赖的时候就锁定在你安装的这个版本。</p><h1 id="NexT-篇"><a href="#NexT-篇" class="headerlink" title="NexT 篇"></a>NexT 篇</h1><p>首先要说的是，很多人在网上查找的 NexT 主题安装和配置教程都比较早，他们给出的 NexT 地址是 「 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 」，但这个项目在 2017 的时候就宣布不再维护了，之后 2018-2019 年将 NexT 的地址变更为：「 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a> 」，<strong>2020 年最新的地址为：</strong>「 <a href="https://github.com/next-theme/hexo-theme-next" target="_blank" rel="noopener">https://github.com/next-theme/hexo-theme-next</a> 」     </p><p>经过不断的版本迭代，NexT 目前已经提供了非常丰富的配置来满足使用者的个性化需求，在配置主题时，如果你像我一样对前端不是特别擅长，那么我更<strong>推荐使用官方推荐的方式配置主题，多挖掘博客自带的功能，尽可能少得修改源码</strong>。    </p><p>我使用的 NexT 版本号为 7.8.0，请先到 themes -&gt; Next -&gt; package.json 里查看一下你的 NexT 版本，酌情考虑升级。新版本的官方主题配置内容会比以前会丰富，也更加简单。</p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>直接到你的 Blog 的 themes 文件夹下 git clone 整个 NexT 仓库即可；<br>官方给出的教程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd hexo</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure></p><p>下载后，打开 Hexo 站点配置文件，找到 theme 部分，然后将其值更改为 next（或另一个主题目录名称）；使用 <code>hexo clean</code> 清理缓存，然后 <code>hexo s</code> ，就可以去验证主题了。</p><h2 id="文件组织结构-1"><a href="#文件组织结构-1" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .github         # git 信息</span><br><span class="line">├── docs            # 官方的一些文档说明信息，不用管</span><br><span class="line">├── languages        # 多语言，我们常关注的是下面几个个</span><br><span class="line">|   ├── default.yml    # 默认语言</span><br><span class="line">|   └── zh-CN.yml      # 简体中文</span><br><span class="line">|   └── zh-HK.yml      # 繁体中文</span><br><span class="line">|   └── zh-TW.yml      # 繁体中文</span><br><span class="line">├── layout             # 存储相关的布局信息</span><br><span class="line">|   ├── _macro        # 可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig    # 文章模板</span><br><span class="line">|   |   ├── sidebar.swig   # 侧边栏模板</span><br><span class="line">|   |   ├── post-collapse.swig    # 没动过，理解为文章崩溃后显示的模板文件</span><br><span class="line">|   ├── _partial       # 有关文章、标题、页面等更加细节的局部布局，如果不是很懂建议不动</span><br><span class="line">|   ├── _script        # 一些脚本的局部布局</span><br><span class="line">|   ├── _third-party   # 第三方模板</span><br><span class="line">|   ├── _layout.swig   # 主页面模板</span><br><span class="line">|   ├── index.swig     # 一些索引模板</span><br><span class="line">|   ├── archive.swig   # 一些解题实现的模板</span><br><span class="line">|   └── page.swig &#x2F; tag.swig &#x2F; post.swig &#x2F; category.swig    # 相应模块的主控制模板</span><br><span class="line">├── scripts            # script 源码</span><br><span class="line">├── source             # 源码资源</span><br><span class="line">|   ├── css            # *.styl 的 css 源码</span><br><span class="line">|   ├── images         #图片</span><br><span class="line">|   ├── js             # javascript 源代码</span><br><span class="line">|   └── lib            # 其他的库文件</span><br><span class="line">└── _config.yml        # 主题配置文件</span><br></pre></td></tr></table></figure><blockquote><p>Stylus 比较年轻，是一个 CSS 的预处理框架，2010 年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，可以创建健壮的、动态的、富有表现力的CSS。默认使用 .styl 的作为文件扩展名，支持多样性的 CSS 语法。  </p><p>SWIG 是一种简化脚本语言与 C/C++ 接口的开发工具。SWIG 是一个通过包装和编译 C/C++ 语言程序来达到与脚本语言通讯目的的工具。推荐个学习地址：『<a href="https://myvin.github.io/swig.zh-CN/docs/index.html" target="_blank" rel="noopener">Swig：一个适用于 Node.js 和浏览器的模板引擎</a>』</p></blockquote><p>看了上面的文件结构后，我们大致就知道所需要修改的信息应该在哪部分。通常，<strong>只需要修改 NexT 的 _config.yml 文件即可</strong>，配置初建议把这个文件都过一遍，然后根据自己的需求更改，里面也会有许多网上可能没提到过的配置。<br>记住不要一味的参照网上各式各样的配置教程，许多时候因为版本不同，配置的方式也不同，可能导致修改许多本没必要的位置，加入杂乱的代码等等，长时间后，我们可能自己都忘了曾经修改过啥，这样十分不利于后期的维护，和 NexT 的更新。</p><h2 id="官方配置教程"><a href="#官方配置教程" class="headerlink" title="官方配置教程"></a>官方配置教程</h2><p>详见：『<a href="https://hexo-theme-next.netlify.app/docs/theme-settings/" target="_blank" rel="noopener">官方配置文档</a>』    </p><p>看完官方文档，发现我的 Blog 也还有一些配置的地方，不说了，我先行一步！别光看了，do it，加油！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></li><li><a href="https://yuchen-lea.github.io/2016-01-18-hexo-dir-struct/" target="_blank" rel="noopener">hexo目录结构小探</a></li><li><a href="https://hexo-theme-next.netlify.app/" target="_blank" rel="noopener">NexT 官方博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/Hexo-Next-FileOrganization/head1.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;    

&lt;p&gt;最开始接触 Blog，总会遇到各种各样大大小小的问题，但是在网络上查找各种解决办法的时候，往往都是只告诉了你怎么做，却没有说为什么？我们也就机械化的进行&lt;kbd&gt;ctrl+c&lt;/kbd&gt;，&lt;kbd&gt;ctrl+v&lt;/kbd&gt;，这是十分不可取的。因此本着「授人以鱼不如授人以渔」的想法，决定对整个  Hexo 和 Next 的文件组织进行一波系统的整理，既便于我们维护管理，也可以更好&lt;strong&gt;更官方&lt;/strong&gt;的进行 Blog 主题优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog 相关" scheme="http://www.thebetterkong.cn/categories/Blog-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Blog" scheme="http://www.thebetterkong.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Begin &amp; KeepGoing</title>
    <link href="http://www.thebetterkong.cn/2020/05/09/Black%20Hole/Begin-KeepGoing/"/>
    <id>http://www.thebetterkong.cn/2020/05/09/Black%20Hole/Begin-KeepGoing/</id>
    <published>2020-05-09T08:04:07.000Z</published>
    <updated>2020-08-14T09:17:32.145Z</updated>
    
    <content type="html"><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Begin-KeepGoing/head.png" width="100%" alt="header.png" /> </div>   <p>从建站到今天已经快二十天了，这些日子主要是在总结现在国科大上课期间的笔记，也算是对 Blog 相关内容的摸索，让自己能更熟悉 Blog 写作。决定在这里作为一个转折点。   </p><a id="more"></a><p>其实我建站的目的和许多人不同，因为记忆力比较差，许多学过的东西总是又忘的干干净净。所以，我会有对自己学习内容进行系统整理的习惯，但是之前多是手写，一本一本的笔记本也不方便，而且时间久了也就丢了。后来就觉得开始写电子文档，但对数据有高度强迫症的我，总是担心像 <code>oneNote</code> 这种比较依赖云的笔记本万一有天服务关了会导致数据丢失（太依赖别人总是不太放心），放在本地，又觉得查看不方便。摸索了很长时间，还是决定干脆建个 Blog，这样既有网络访问的便利性，也有本地保存的安全性（再加上把本地文件上传 coding，双层保险）。这样总算是满足了需求，而且如果有缘，我们还能一起分享讨论，共同进步。       </p><p>经过这二十天左右的写作，说实话，对比其他方式，Blog 的写作要求可能更严，但这也是它的特点，它可以让我静下心来，十分投入，会从侧面让我对技术知识点的要求更加严格，不再像以前那样十分肤浅，不够体系化。    </p><p>好吧，说了这么多，总结来就一点，既然选择了，就好好去做！</p>]]></content>
    
    <summary type="html">
    
      &lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;http://img.thebetterkong.cn/blog/Begin-KeepGoing/head.png&quot; width=&quot;100%&quot; alt=&quot;header.png&quot; /&gt; &lt;/div&gt;   

&lt;p&gt;从建站到今天已经快二十天了，这些日子主要是在总结现在国科大上课期间的笔记，也算是对 Blog 相关内容的摸索，让自己能更熟悉 Blog 写作。决定在这里作为一个转折点。   &lt;/p&gt;
    
    </summary>
    
    
      <category term="Black Hole" scheme="http://www.thebetterkong.cn/categories/Black-Hole/"/>
    
    
      <category term="Mood" scheme="http://www.thebetterkong.cn/tags/Mood/"/>
    
  </entry>
  
  <entry>
    <title>高等代数笔记</title>
    <link href="http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Advanced-Algebra/"/>
    <id>http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Advanced-Algebra/</id>
    <published>2020-04-18T05:13:14.000Z</published>
    <updated>2020-08-14T09:33:21.388Z</updated>
    
    <content type="html"><![CDATA[<p>本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p><p><strong><center><mark>多图警告！</mark></center></strong></p><a id="more"></a> <h1 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h1><p><img src="https://img-blog.csdnimg.cn/20200418204910161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">      </p><p><img src="https://img-blog.csdnimg.cn/20200418204945211.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">        </p><p><img src="https://img-blog.csdnimg.cn/20200418204958865.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">         </p><p><img src="https://img-blog.csdnimg.cn/20200418205013693.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">           </p><p><img src="https://img-blog.csdnimg.cn/20200418205025697.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">        </p><p><img src="https://img-blog.csdnimg.cn/20200418205037899.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">             </p><p><img src="https://img-blog.csdnimg.cn/20200418205049244.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">           </p><p><img src="https://img-blog.csdnimg.cn/20200418205103552.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p><h1 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h1><p><img src="https://img-blog.csdnimg.cn/2020041821124045.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p><p><img src="https://img-blog.csdnimg.cn/20200418210545462.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p><p><img src="https://img-blog.csdnimg.cn/20200418210623217.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p><p><img src="https://img-blog.csdnimg.cn/20200418210644273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p><p><img src="https://img-blog.csdnimg.cn/2020041821065966.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p><p><img src="https://img-blog.csdnimg.cn/20200418210711984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p><p><img src="https://img-blog.csdnimg.cn/20200418210726168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">    </p><p><img src="https://img-blog.csdnimg.cn/20200418210747249.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p><p><img src="https://img-blog.csdnimg.cn/20200418210759378.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211403905.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">   </p><h1 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418211507676.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p><p><img src="https://img-blog.csdnimg.cn/20200418211544584.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211556347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211605407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211614824.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p><p><img src="https://img-blog.csdnimg.cn/20200418211625194.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p><p><img src="https://img-blog.csdnimg.cn/20200418211635285.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211645591.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8"></p><h1 id="向量空间与空间解析几何"><a href="#向量空间与空间解析几何" class="headerlink" title="向量空间与空间解析几何"></a>向量空间与空间解析几何</h1><p><img src="https://img-blog.csdnimg.cn/20200418211755382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211807381.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p><p><img src="https://img-blog.csdnimg.cn/20200418211821654.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p><p><img src="https://img-blog.csdnimg.cn/20200418211836885.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p><p><img src="https://img-blog.csdnimg.cn/2020041821193096.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212011608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p><h1 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418212104459.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">      </p><p><img src="https://img-blog.csdnimg.cn/20200418212116323.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212132817.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212220565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212233608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212306524.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212323449.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p><h1 id="多元函数积分学"><a href="#多元函数积分学" class="headerlink" title="多元函数积分学"></a>多元函数积分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418212408322.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212423141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212500133.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212529908.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212607639.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212617833.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212628700.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212639496.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212650823.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212700601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">     </p><h1 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h1><p><img src="https://img-blog.csdnimg.cn/20200418212758762.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212809544.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212848933.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212904319.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212915589.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212926165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p><p><img src="https://img-blog.csdnimg.cn/20200418212936277.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p><p><img src="https://img-blog.csdnimg.cn/20200418212947311.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p><h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p><img src="https://img-blog.csdnimg.cn/20200418213034307.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p><p><img src="https://img-blog.csdnimg.cn/20200418213047568.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p><p><img src="https://img-blog.csdnimg.cn/20200418213057543.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p><p><img src="https://img-blog.csdnimg.cn/20200418213107356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p><p><img src="https://img-blog.csdnimg.cn/2020041821311791.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p><p><img src="https://img-blog.csdnimg.cn/20200418213145251.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;&lt;mark&gt;多图警告！&lt;/mark&gt;&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学基础笔记" scheme="http://www.thebetterkong.cn/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://www.thebetterkong.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合数学笔记</title>
    <link href="http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Combinatorial-Mathematics/"/>
    <id>http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Combinatorial-Mathematics/</id>
    <published>2020-04-18T05:13:14.000Z</published>
    <updated>2020-08-14T09:33:30.519Z</updated>
    
    <content type="html"><![CDATA[<p>本人本科期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p><p><strong><center><mark>多图警告！</mark></center></strong></p><a id="more"></a> <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://img-blog.csdnimg.cn/20200418214637641.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">         </p><p><img src="https://img-blog.csdnimg.cn/20200418214657106.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p><p><img src="https://img-blog.csdnimg.cn/20200418214737863.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">           </p><h1 id="鸽巢原理和Ramsey定理"><a href="#鸽巢原理和Ramsey定理" class="headerlink" title="鸽巢原理和Ramsey定理"></a>鸽巢原理和Ramsey定理</h1><p><img src="https://img-blog.csdnimg.cn/20200418214802665.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">          </p><p><img src="https://img-blog.csdnimg.cn/20200418214817446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p><h1 id="基本计数方法及应用"><a href="#基本计数方法及应用" class="headerlink" title="基本计数方法及应用"></a>基本计数方法及应用</h1><p><img src="https://img-blog.csdnimg.cn/20200418214844586.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p><p><img src="https://img-blog.csdnimg.cn/20200418214855391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p><p><img src="https://img-blog.csdnimg.cn/20200418214904651.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">             </p><p><img src="https://img-blog.csdnimg.cn/20200418214912269.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">             </p><p><img src="https://img-blog.csdnimg.cn/20200418214922510.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">        </p><p><img src="https://img-blog.csdnimg.cn/20200418214940289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">           </p><p><img src="https://img-blog.csdnimg.cn/20200418214951654.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">           </p><p><img src="https://img-blog.csdnimg.cn/20200418214958321.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">           </p><p><img src="https://img-blog.csdnimg.cn/2020041821500551.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">             </p><p><img src="https://img-blog.csdnimg.cn/20200418215011734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">           </p><p><img src="https://img-blog.csdnimg.cn/20200418215019151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="11">                 </p><p><img src="https://img-blog.csdnimg.cn/20200418215026429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="12">            </p><p><img src="https://img-blog.csdnimg.cn/20200418215039811.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="13">            </p><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p><img src="https://img-blog.csdnimg.cn/20200418215100774.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p><p><img src="https://img-blog.csdnimg.cn/20200418215106961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p><p><img src="https://img-blog.csdnimg.cn/20200418215115206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">              </p><p><img src="https://img-blog.csdnimg.cn/20200418215125786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">               </p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p><img src="https://img-blog.csdnimg.cn/20200418215149542.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">              </p><p><img src="https://img-blog.csdnimg.cn/20200418215156353.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">               </p><p><img src="https://img-blog.csdnimg.cn/20200418215204785.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">                 </p><p><img src="https://img-blog.csdnimg.cn/20200418215213149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">                </p><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p><img src="https://img-blog.csdnimg.cn/20200418215231769.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p><p><img src="https://img-blog.csdnimg.cn/20200418215242201.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">             </p><h1 id="Polya定理"><a href="#Polya定理" class="headerlink" title="Polya定理"></a>Polya定理</h1><p><img src="https://img-blog.csdnimg.cn/20200418215258585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p><p><img src="https://img-blog.csdnimg.cn/20200418215306162.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">         </p><p><img src="https://img-blog.csdnimg.cn/20200418215314153.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">               </p><p><img src="https://img-blog.csdnimg.cn/2020041821532359.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">                    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人本科期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;&lt;mark&gt;多图警告！&lt;/mark&gt;&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学基础笔记" scheme="http://www.thebetterkong.cn/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://www.thebetterkong.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>线性代数笔记</title>
    <link href="http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Linear-Algebra/"/>
    <id>http://www.thebetterkong.cn/2020/04/18/Math-Basic-Notes/Linear-Algebra/</id>
    <published>2020-04-18T05:13:14.000Z</published>
    <updated>2020-08-14T09:33:41.717Z</updated>
    
    <content type="html"><![CDATA[<p>本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p><p><strong><center><mark>多图警告！</mark></center></strong></p><a id="more"></a> <h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><img src="https://img-blog.csdnimg.cn/20200118153653460.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">            </p><p><img src="https://img-blog.csdnimg.cn/20200118153735522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">                </p><p><img src="https://img-blog.csdnimg.cn/20200118153737836.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">       </p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><img src="https://img-blog.csdnimg.cn/20200118154130390.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">              </p><p><img src="https://img-blog.csdnimg.cn/20200118154140421.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">                </p><p><img src="https://img-blog.csdnimg.cn/20200118154148137.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p><p><img src="https://img-blog.csdnimg.cn/20200118154414376.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">             </p><p><img src="https://img-blog.csdnimg.cn/2020011815444798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">      </p><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p><img src="https://img-blog.csdnimg.cn/20200118154744775.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">             </p><p><img src="https://img-blog.csdnimg.cn/20200118154815931.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">           </p><p><img src="https://img-blog.csdnimg.cn/20200118155522138.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p><p><img src="https://img-blog.csdnimg.cn/20200118155603663.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">         </p><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><img src="https://img-blog.csdnimg.cn/20200118160231836.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p><p><img src="https://img-blog.csdnimg.cn/20200118160243488.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p><p><img src="https://img-blog.csdnimg.cn/20200118160307150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p><p><img src="https://img-blog.csdnimg.cn/20200118160335631.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">          </p><p><img src="https://img-blog.csdnimg.cn/20200118160358899.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">       </p><h1 id="特征值、特征向量、相似矩阵"><a href="#特征值、特征向量、相似矩阵" class="headerlink" title="特征值、特征向量、相似矩阵"></a>特征值、特征向量、相似矩阵</h1><p><img src="https://img-blog.csdnimg.cn/20200118160824125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">         </p><p><img src="https://img-blog.csdnimg.cn/2020011816292558.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">             </p><p><img src="https://img-blog.csdnimg.cn/20200118163113577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">           </p><p><img src="https://img-blog.csdnimg.cn/2020011816314912.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">      </p><h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p><img src="https://img-blog.csdnimg.cn/20200118163350775.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p><p><img src="https://img-blog.csdnimg.cn/20200118163436524.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p><p><img src="https://img-blog.csdnimg.cn/202001181634527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p><p><img src="https://img-blog.csdnimg.cn/20200118163549294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">        </p><p><img src="https://img-blog.csdnimg.cn/20200118163607383.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">      </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;&lt;mark&gt;多图警告！&lt;/mark&gt;&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学基础笔记" scheme="http://www.thebetterkong.cn/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数学" scheme="http://www.thebetterkong.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
