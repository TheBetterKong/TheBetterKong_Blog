<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Begin &amp; KeepGoing</title>
    <url>/2020/05/09/Black%20Hole/Begin-KeepGoing/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Begin-KeepGoing/head.png" width="100%" alt="header.png" /> </div>   

<p>从建站到今天已经快二十天了，这些日子主要是在总结现在国科大上课期间的笔记，也算是对 Blog 相关内容的摸索，让自己能更熟悉 Blog 写作。决定在这里作为一个转折点。   </p>
<a id="more"></a>
<p>其实我建站的目的和许多人不同，因为记忆力比较差，许多学过的东西总是又忘的干干净净。所以，我会有对自己学习内容进行系统整理的习惯，但是之前多是手写，一本一本的笔记本也不方便，而且时间久了也就丢了。后来就觉得开始写电子文档，但对数据有高度强迫症的我，总是担心像 <code>oneNote</code> 这种比较依赖云的笔记本万一有天服务关了会导致数据丢失（太依赖别人总是不太放心），放在本地，又觉得查看不方便。摸索了很长时间，还是决定干脆建个 Blog，这样既有网络访问的便利性，也有本地保存的安全性（再加上把本地文件上传 coding，双层保险）。这样总算是满足了需求，而且如果有缘，我们还能一起分享讨论，共同进步。       </p>
<p>经过这二十天左右的写作，说实话，对比其他方式，Blog 的写作要求可能更严，但这也是它的特点，它可以让我静下心来，十分投入，会从侧面让我对技术知识点的要求更加严格，不再像以前那样十分肤浅，不够体系化。    </p>
<p>好吧，说了这么多，总结来就一点，既然选择了，就好好去做！</p>
]]></content>
      <categories>
        <category>Black Hole</category>
      </categories>
      <tags>
        <tag>Mood</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog 搭建</title>
    <url>/2020/04/04/Blog-Related/Blog-Establish/</url>
    <content><![CDATA[<p>使用阿里云服务器 + 域名 + hexo 搭建个人博客；</p>
<a id="more"></a> 
<h1 id="主体过程"><a href="#主体过程" class="headerlink" title="主体过程"></a>主体过程</h1><ul>
<li>本地环境配置：安装 <code>Node.js</code>，<code>Git</code>，<code>Hexo</code></li>
<li>阿里云服配置：域名备案，添加安全组，域名解析</li>
<li>服务器环境配置：安装 <code>Node.js</code>，<code>Git</code>，<code>Nginx</code>，<code>Pm2</code></li>
<li>Github 配置： <code>webhooks</code></li>
</ul>
<p>本地环境：<code>Win10</code>，云服务器：<code>Ubuntu 16.04</code></p>
<hr>
<h1 id="本地环境配置"><a href="#本地环境配置" class="headerlink" title="本地环境配置"></a>本地环境配置</h1><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>NVM可以帮助我们快速切换 node版本。所以，我们选择使用 <code>nvm</code> 来安装 <code>node.js</code> ：    </p>
<p>下载 <code>Windows 10版</code> 的 <code>nvm安装包</code>，『<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载地址</a>』</p>
<ul>
<li>解压,以管理员身份运行 <code>nvm-setup.exe</code>，一路 <kbd>next</kbd>；</li>
<li>命令行输入：<code>nvm</code>，检查是否安装成功；</li>
</ul>
<p>配置淘宝镜像：</p>
<ul>
<li>由于nvm默认的 <a href="http://nodejs.org/dist/" target="_blank" rel="noopener">下载地址</a> 是外国外服务器，速度非常慢，因而切换到淘宝的镜像，加快下载速度。</li>
<li>在nvm的安装路径下（默认为：C:\Users\TheBetterKong\AppData\Roaming\nvm），打开 <code>settings.txt</code>，加入（注意：将root和path的内容换成自己的）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root: C:\Users\TheBetterKong\AppData\Roaming\nvm</span><br><span class="line">path: C:\Program Files\nodejs</span><br><span class="line">node_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;</span><br><span class="line">npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</span><br></pre></td></tr></table></figure>
<p>安装 <code>Node.js</code>：</p>
<ul>
<li>安装最新的 node.js 及 配套npm ：<code>nvm install latest</code></li>
<li>查看安装过的 node 版本：<code>nvm list</code></li>
<li>使用你想使用的版本：<code>nvm use 想要使用的node版本</code>，一般就是使用刚刚安装的最新版</li>
<li>检查 node 和 npm : <code>node -v</code>、<code>npm -v</code></li>
</ul>
<h2 id="安装配置-Git"><a href="#安装配置-Git" class="headerlink" title="安装配置 Git"></a>安装配置 Git</h2><p>『<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载地址</a>』，这个安装很简单，安装完成后，确认：<code>git -version</code>    </p>
<p>配置 <code>Git ssh</code>，也即：<a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">使用 SSH 连接到 GitHub</a>，目的：之后部署代码上传时不需要每次都输入用户名密码。</p>
<ul>
<li>配置 Github 用户名和邮箱地址：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name “xxxxxx” # 替换为 Github 用户名</span><br><span class="line">git config --global user.email “xxxxxx@xx.com” # 替换为 Github 邮箱地址</span><br></pre></td></tr></table></figure></li>
<li>配置完成后，可以使用 <code>git config --list</code>查看配置信息；</li>
<li>生成ssh公钥：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 你的 GitHub邮箱地址</span><br></pre></td></tr></table></figure></li>
<li>按提示，四次 <kbd>Enter</kbd> 后生成完毕，生成过程中会提示生成路径；</li>
<li>按提示路径，打开~/.ssh文件夹，里面会包含两个文件：『id_rsa（私有秘钥）』和『id_rsa.pub（公有密钥）』，记事本打开『id_rsa.pub』，全选复制；</li>
<li>进入 Github，打开 <kbd>setting</kbd>，选择 <kbd>SSH and GPG keys</kbd>，<kbd>new SSH key</kbd>，将刚刚的公钥内容粘贴进去；</li>
<li>完成上述过程后，输入 <code>ssh -T git@github.com</code> 测试；<ul>
<li>这里我遇到了一个坑，一直提示我：<code>Permissions for &#39;C:\\Users\\TheBetterKong/.ssh/id_rsa&#39; are too open.</code>，『<a href="https://blog.csdn.net/joshua2011/article/details/90208741" target="_blank" rel="noopener">解决办法</a>』</li>
</ul>
</li>
<li>配置完成；</li>
</ul>
<h2 id="安装和使用Hexo"><a href="#安装和使用Hexo" class="headerlink" title="安装和使用Hexo"></a>安装和使用Hexo</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><ul>
<li>执行 <code>npm install -g hexo-cli</code>，全局安装hexo-cli；安装完成后，输入 <code>hexo -v</code> 验证安装；   </li>
</ul>
<h3 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h3><ul>
<li>本地新建一个文件夹（Blog：当成hexo的代码库）；    </li>
<li>打开命令行，<code>cd</code> 进入到 Blog 文件夹，输入 <code>hexo init</code> 初始化hexo库（即：在当前文件夹生成网站所需要的文件，手脚架）；</li>
<li>正常情况下，在安装手脚架时会自动安装了所有 node_modules，如果不知道是否完整安装了所有开发所需的 moudles，可以输入 <code>npm install</code>，再次手动安装代码仓库所依赖的 modules；</li>
</ul>
<p>至此，所有配置完毕，可以本地执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate #也可简写为hexo g</span><br><span class="line">hexo server #简写为hexo s</span><br></pre></td></tr></table></figure><br>在浏览器中打开：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，会看到 Hexo 模板的效果；    </p>
<p>至此，一个简单的 Hexo 网站就搭建出来了，有兴趣的话，可以先执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;first blog&quot; # 注意标题中有空格需要用双引号包起来</span><br></pre></td></tr></table></figure><br>生成一个简单的 Blog，在 source/_post 文件夹中，修改 first-blog.md 文件就能修改文章内容了，之后重新 <code>hexo s</code> 就能在本地查看到效果了。</p>
<h2 id="配置-Hexo-至-Github"><a href="#配置-Hexo-至-Github" class="headerlink" title="配置 Hexo 至 Github"></a>配置 Hexo 至 Github</h2><p>安装 hexo 的 git 部署插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>安装完毕后，登录 Github，新建一个 public 仓库，并记录该仓库的 SSH 地址；   </p>
<p>打开，Blog 文件夹里的 _config.yml 文件，修改其 deploy 配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;Ackerly&#x2F;name.git  &#x2F;&#x2F;替换为刚才新建git代码库的ssh链接</span><br><span class="line">  branch: master  &#x2F;&#x2F;注意！！！  :后面有空格，如果没有空格，这行代码失效</span><br></pre></td></tr></table></figure><br>配置完毕后，尝试将本地 blog 的代码上传到 Github：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><br>无错误出现，可登录 Github 查看更新情况；</p>
<hr>
<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><p>这里我在阿里云的云翼计划里，购买了轻量应用服务器，学生优惠话 <code>1核-2GB内存+40G的SSD 5Mbps的带宽</code> 每个月不到十块，还是很香的！</p>
<h2 id="配置安全组"><a href="#配置安全组" class="headerlink" title="配置安全组"></a>配置安全组</h2><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>备案后的域名；<br><kbd>域名控制台</kbd>-&gt;<kbd>域名列表</kbd>-&gt;<kbd>解析</kbd>-&gt;<kbd>添加记录</kbd><br>按照相关信息填取，『记录值』：你的公网ip；<br>如有不懂，详情参考域名所属的官方文档；</p>
<h2 id="安装-Node-js-1"><a href="#安装-Node-js-1" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>进入 GitHub 搜索 <code>nvm</code> 或者直接进入『<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">地址</a>』，找到 nvm 的安装脚本，如果没有找到，可以用下面的安装脚本命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.2&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装完 nvm 以后，会提示我们再开一个新的终端来连接服务器，重连后，使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm ls-remote  #显示当前可下载的版本，选一个下载就行</span><br><span class="line">nvm install v13.12.0</span><br><span class="line">nvm use v13.12.0   #把node版本指向6.10.3</span><br><span class="line">nvm alias default v13.12.0   # 将此版本设置为默认版本</span><br><span class="line">node --version   #检查是否安装成功</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install git    # 安装</span><br><span class="line">git --version    # 查看是否安装成功</span><br></pre></td></tr></table></figure>
<p>同样，配置 SSH：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxxxxx&quot;  # 自行替换你的 GitHub 用户名</span><br><span class="line">git config --global user.email &quot;xxxxxx@xx.com&quot;  # 自行替换你的 GitHub 电子邮件地址</span><br></pre></td></tr></table></figure><br>生成秘钥（在root权限下操作）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 自行替换你的 GitHub 电子邮件地址</span><br></pre></td></tr></table></figure><br>复制生成的共有秘钥：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><br>在 Github 上创建 SSH key：</p>
<ul>
<li><kbd>登录Github</kbd>-&gt;<kbd>头像</kbd>-&gt;<kbd>settings</kbd>-&gt;<kbd>SSH and GPG keys</kbd>-&gt;<kbd>New SSH key</kbd>-&gt;<kbd>将粘贴板上的秘钥粘贴上一个新的key（命名时，注意区分本地和服务器的SSH key）</kbd></li>
</ul>
<p>在服务器上，创建用来存放 Github 代码的文件夹：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;</span><br><span class="line">mkdir www # 用于存放业务代码</span><br><span class="line">cd www</span><br><span class="line">mkdir myBlog # 用于存放前端代码</span><br><span class="line">cd myBlog</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Ackerly&#x2F;name.git # 自行替换为用于存放博客代码的仓库ssh地址</span><br></pre></td></tr></table></figure><br>至此 git 的安装及代码库的部署以及完成，但是现在代码只是暂时同步了当前仓库的最新内容。但是如果有人在本地推送新的代码上去，服务端需要重新拉取代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull # git代码拉取命令</span><br></pre></td></tr></table></figure></p>
<h2 id="安装及配置-Nginx"><a href="#安装及配置-Nginx" class="headerlink" title="安装及配置 Nginx"></a>安装及配置 Nginx</h2><p>安装：</p>
<ul>
<li>安装 Nginx：<code>sudo apt-get install nginx</code>；    </li>
<li>启动 Nginx：<code>sudo systemctl start nginx</code>；    </li>
<li>设置系统自启 Nginx：<code>sudo systemctl enable nginx</code>；</li>
</ul>
<p>配置：</p>
<ul>
<li>配置 nginx 的目的：让你的域名直接访问到服务器博客代码，进而显示博客页面；</li>
<li>找到 nginx 配置文件（默认在 /etc/nginx/nginx.conf），修改其配置文件;</li>
<li>这里创建一个新的文件，然后采用 include 的方式，将这个文件包含进 nginx.conf 中，这样便于以后添加新的网站。</li>
</ul>
<p>具体做法：    </p>
<ul>
<li>在 /etc/nginx/ 目录下创建一个文件夹，叫 vhost；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;nginx&#x2F;</span><br><span class="line">mkdir vhost</span><br><span class="line">cd vhost</span><br><span class="line">vim blog.conf</span><br></pre></td></tr></table></figure></li>
<li>编辑 blog.conf 文件内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">	listen    80;</span><br><span class="line">	root &#x2F;www&#x2F;myBlog&#x2F;TheBetterKong_Blog; # 在服务端的代码路径</span><br><span class="line">	server_name www.thebetterkong.cn;  # 购买的域名</span><br><span class="line">	location &#x2F;&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>:wq</code>，保存退出；</li>
<li>打开 /etc/nginx/ 目录下的 nginx.conf 文件：<code>vi /etc/nginx/nginx.conf</code>，include 刚才新建的 conf 文件；</li>
<li><p><img src="http://img.thebetterkong.cn/blog/Blog-Establish/nginx.conf.png" alt="nginx.conf"></p>
</li>
<li><p>重启 Nginx：<code>systemctl restart nginx</code></p>
</li>
</ul>
<p>至此，在浏览器输入你的域名就可以访问博客页面；</p>
<h2 id="安装-pm2"><a href="#安装-pm2" class="headerlink" title="安装 pm2"></a>安装 pm2</h2><p>『<a href="https://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">pm2</a>』 是 node 的守护进程管理器，安装 pm2 可以对使用 webhooks 时创建的服务进行维护；    </p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pm2 </span><br><span class="line">pm2 -v # 查看pm2版本</span><br></pre></td></tr></table></figure><br>pm2 常用命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start # 执行对应路径脚本</span><br><span class="line">pm2 list # 查看看起的进程列表</span><br><span class="line">pm2 restart &lt;name|id&gt; # 重启对应进程</span><br><span class="line">pm2 delete &lt;name|id|‘all’&gt; # 删除对应的进程,all是全部</span><br><span class="line">pm2 logs # 查看进程,打印日志</span><br><span class="line">pm2 monit # 监控每个 node 进程的 cpu 和内存使用情况</span><br></pre></td></tr></table></figure></p>
<h2 id="配置-webhooks"><a href="#配置-webhooks" class="headerlink" title="配置 webhooks"></a>配置 webhooks</h2><h3 id="配置仓库-webhooks"><a href="#配置仓库-webhooks" class="headerlink" title="配置仓库 webhooks"></a>配置仓库 webhooks</h3><p>『<a href="https://developer.github.com/webhooks/" target="_blank" rel="noopener">git webhooks</a>』能够实时的将变化的代码提交到服务器；    </p>
<p>打开<kbd>GitHub仓库</kbd>-&gt;<kbd>Settings</kbd>-&gt;<kbd>Webhooks</kbd>-&gt;<kbd>add webhook</kbd>：</p>
<ul>
<li>URL: <code>http://你的公网ip:7777/</code></li>
<li>Content type: <code>application/json</code></li>
<li>Secret: <code>自己的webhook密码(后面要用到)</code></li>
<li>选择: <code>Just the push event</code></li>
</ul>
<h3 id="服务器端口设置监听"><a href="#服务器端口设置监听" class="headerlink" title="服务器端口设置监听"></a>服务器端口设置监听</h3><p>在用户目录下新建 ListenWebhooks 文件夹，新建 webhook.js文件，并写入代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir ListenWebhooks</span><br><span class="line">vi webhook.js # 写入服务</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const secret &#x3D; &quot;girhub上添加wenhook是的密码&quot;;</span><br><span class="line">const repo &#x3D; &quot;&#x2F;www&#x2F;myBlog&#x2F;TheBetterKong_Blog&quot;;</span><br><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const crypto &#x3D; require(&quot;crypto&quot;);</span><br><span class="line">const exec &#x3D; require(&#39;child_process&#39;).exec;</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    req.on(&#39;data&#39;, function(chunk)&#123;</span><br><span class="line">        let sig &#x3D; &quot;sha1&#x3D;&quot; + crypto.createHmac(&#39;sha1&#39;, secret).update(chunk.toString()).digest(&#39;hex&#39;);</span><br><span class="line">        if (req.headers[&#39;x-hub-signature&#39;] &#x3D;&#x3D; sig) &#123;</span><br><span class="line">            exec(&#39;cd &#39; + repo + &#39; &amp;&amp; git pull&#39;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&#39;err:&#39;, &#39;signature&#39;, req.headers[&#39;x-hub-signature&#39;], &#39;sig&#39;, sig, &#39;time:&#39;, new Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(7777);</span><br></pre></td></tr></table></figure></p>
<p>使用 pm2 开启服务：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pm2 start .&#x2F;webhook.js</span><br><span class="line">pm2 list # 查看开启的进程列表</span><br></pre></td></tr></table></figure><br>测试 webhook：</p>
<ul>
<li>在 Github 上，编辑 <kbd>webhook</kbd>-&gt;<kbd>Redeliver</kbd>-&gt;显示成功</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，Blog 已经搭建完毕；    </p>
<ul>
<li>可以在本地代码库 source/_post 文件夹中随意加入一个 markdown 文件；</li>
<li>接下来进入代码库文件夹，当前文件夹启动命令行（右键 <kbd>git bash here</kbd> 也可以）</li>
<li>输入命令 <code>hexo clean &amp;&amp; hexo g</code>；</li>
<li>再输入命令 <code>hexo d</code>；</li>
<li>浏览器输入域名，博客出现 md 文件的内容的文章即为设置成功；</li>
</ul>
<p>之后，就是 Blog 的主题配置等工作。</p>
<p>感谢原作者：『<a href="https://blog.csdn.net/FungLi_notLove/article/details/103450832" target="_blank" rel="noopener">参考链接</a>』</p>
]]></content>
      <categories>
        <category>Blog 相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 的配置，做自己的主人</title>
    <url>/2020/05/09/Blog-Related/Hexo-Next-FileOrganization/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Hexo-Next-FileOrganization/head1.png" width="100%" alt="header.png" /> </div>    

<p>最开始接触 Blog，总会遇到各种各样大大小小的问题，但是在网络上查找各种解决办法的时候，往往都是只告诉了你怎么做，却没有说为什么？我们也就机械化的进行<kbd>ctrl+c</kbd>，<kbd>ctrl+v</kbd>，这是十分不可取的。因此本着「授人以鱼不如授人以渔」的想法，决定对整个  Hexo 和 Next 的文件组织进行一波系统的整理，既便于我们维护管理，也可以更好<strong>更官方</strong>的进行 Blog 主题优化。</p>
<a id="more"></a> 
<h1 id="Hexo-篇"><a href="#Hexo-篇" class="headerlink" title="Hexo 篇"></a>Hexo 篇</h1><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>这是官方解释：</p>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。   </p>
</blockquote>
<p>安装（详细过程这里就不再阐述）：</p>
<ul>
<li>安装 <code>Git</code>，分散式版本控制软件</li>
<li>安装 <code>Node.js</code>，一个基于 Chrome V8 引擎的 JavaScript 运行时</li>
<li>使用 <code>npm</code> 安装 <code>Hexo</code>，npm 是 node.js 的包管理器</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>这里是从官网上摘录的一些我们日常中经常使用的命令：</p>
<ul>
<li><code>hexo init [folder]</code>：新建一个网站。<ul>
<li>如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</li>
</ul>
</li>
<li><code>hexo new [layout] &lt;title&gt;</code>：新建一篇文章；<ul>
<li>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替；</li>
<li>如果标题包含空格的话，请使用引号括起来；</li>
<li><code>hexo publish [layout] &lt;filename&gt;</code>：发表草稿</li>
</ul>
</li>
<li><code>hexo g</code>：生成静态文件；<ul>
<li><code>hexo g -f</code>：效果接近 <code>hexo clean &amp;&amp; hexo generate</code></li>
</ul>
</li>
<li><code>hexo d</code>：部署网站<ul>
<li>常用组合：<code>hexo g -d</code></li>
</ul>
</li>
<li><code>hexo server</code>:启动服务器。<ul>
<li>默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li>
</ul>
</li>
<li><code>hexo clean</code>：清除缓存文件 (db.json) 和已生成的静态文件 (public)<ul>
<li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</li>
</ul>
</li>
</ul>
<h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>Hexo 在指定文件夹中初始化完毕后，会出现如下文件结构：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><br>在后面的实际使用过程中还会创建一些其他文件或文件夹，后面都会进行说明。</p>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的配置信息，在此修改大部分的配置参数； </p>
<ul>
<li>这里直接查看内容，就能理解大部分的配置内容，如果实有不懂，更建议可查看官方文档，如下；</li>
</ul>
<p>详见：『<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置 | Hexo</a>』</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。可以查看 hexo 的版本以及安装的扩展版本。</p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。<br>详见：『<a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="noopener">模版 | Hexo</a>』</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源 文件夹是存放用户资源的地方。</p>
<h4 id="posts-文件夹"><a href="#posts-文件夹" class="headerlink" title="_posts 文件夹"></a>_posts 文件夹</h4><p>存放博客文章的地方，其中的 Markdown 文件、Html 文件、org 文件等会被解析并放到 public 文件夹，发布到站点。</p>
<ul>
<li>建议在这个文件夹下，<strong>按照文章分类创建子文件夹</strong>（按分类正常命名即可，不要加_(下划线)，便于文章过多时进行管理和维护；</li>
</ul>
<h4 id="其他开头命名为-下划线-的-文件-文件夹-和隐藏的文件"><a href="#其他开头命名为-下划线-的-文件-文件夹-和隐藏的文件" class="headerlink" title="其他开头命名为 _ (下划线)的 文件/文件夹 和隐藏的文件"></a>其他开头命名为 _ (下划线)的 文件/文件夹 和隐藏的文件</h4><p>会被忽略；</p>
<ul>
<li>建议在 source 目录下：</li>
<li>创建 _drafts 目录：存放未完成的草稿，其中内容不会发布到网站；<ul>
<li>可以再在这个目录下创建个子目录 img，便于 blog 草稿书写时利用 <code>./img/picturename.png</code> 引用本地图片，然后可以直接将整个文件夹上传至图床，然后再用匹配，一键替换 <code>./img</code> 为完整的图床 url；</li>
</ul>
</li>
<li>创建 _images 目录：图片一般会用图床，但是这样可以保存文章里的图片备份，后期可以上传到 coding 等平台进行 Blog 备份，避免数据丢失；</li>
</ul>
<h4 id="其他文件-文件夹"><a href="#其他文件-文件夹" class="headerlink" title="其他文件/文件夹"></a>其他文件/文件夹</h4><p>会被拷贝到 public 目录并上传到站点；</p>
<ul>
<li>如果要添加新的页面（例如：about），执行 <code>hexo new page PageName</code> 命令即会在 source 中自动新建子目录 <code>PageName</code> </li>
</ul>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题 文件夹。默认安装 landscape 主题，可以安装新主题到 themes 目录，也可以自己新建主题。   </p>
<p>这也是我们下面要讨论的 Next 主题文件存放的文件夹；</p>
<h3 id="deploy-git"><a href="#deploy-git" class="headerlink" title=".deploy_git"></a>.deploy_git</h3><p>在部署到 github 后自动创建：</p>
<ul>
<li>此目录中的内容 == github 站点中对应 repository 中的内容 == 最近一次上传到站点的public目录中的内容</li>
</ul>
<p>因此，该目录的结构和 public 目录基本一致；</p>
<ul>
<li>不一致的情况是由于重新生成，但是没有发布站点造成，此时 public 内容新于 .deploy_git 内容；</li>
</ul>
<h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><p>存放安装的 Hexo 扩展；</p>
<ul>
<li>Hexo 会默认安装一些扩展，在使用过程中自己安装的扩展也会在此新建目录；</li>
</ul>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>存放生成的静态网页内容；</p>
<ul>
<li>执行 <code>hexo g</code> 命令，Hexo 程序会解析 source 、当前使用的 theme，将生成的静态网页内容保存到 piblic；</li>
<li>执行 <code>hexo d</code> 则将该目录内容复制到 .deploy_git 目录，然后由 Hexo 的部署插件 hexo-deployer-git 根据 _config.yml 里的 deploy 配置，完成上传；</li>
</ul>
<h3 id="git-和-gitignore"><a href="#git-和-gitignore" class="headerlink" title=".git 和 .gitignore"></a>.git 和 .gitignore</h3><p>这个主要是用于 Blog 源资源的备份，防止电脑故障后数据丢失，也便于 Blog 的迁移；</p>
<ul>
<li>直接在 coding（这个源文件往往比较大，coding速度快） 新建仓库，然后在本地 blog 源文件夹下初始化，生成 .git；</li>
<li>.gitignore：整个 Blog 源文件夹下，往往有许多文件是不需要我们去备份的，于是，我们就把这些不需要备份的文件/文件夹写到这里；</li>
</ul>
<h3 id="db-json"><a href="#db-json" class="headerlink" title="db.json"></a>db.json</h3><blockquote>
<p>db-json 是完全在 json 中的数据库。数据库，查询和结果都是 json 数据。它在客户端和服务器端均可使用。<br>数据库结构化，表由类型化字段组成，并带有可选验证（模式，长度，范围）<br>该库在浏览器和节点上均可使用。<br>dabase 的 json 代码是人类可读的，并且可以方便地在手边进行编辑。 如果发生任何错误，则在使用该 json 代码实例化新的 Database 对象时将检测到它们。</p>
</blockquote>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p>package-lock.json 是在 <code>npm install</code> 时候生成一份文件，用以记录当前状态下实际安装的各个 npm package 的具体来源和版本号；</p>
<p>以下是引用的知乎@周载南的解释：</p>
<blockquote>
<ul>
<li>因为 npm 是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。</li>
<li>这时候用户就很头疼了：在完全相同的一个 node.js 的代码库，在不同时间或者不同 npm 下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容；</li>
<li>因此 npm 最新的版本就开始提供自动生成 package-lock.json 功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个 package-lock.json 所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。</li>
</ul>
</blockquote>
<p>所以也就是说，原先的 package.json 只能帮助我们锁定大版本号（即：第一位），但是由于有的库包开发者并没有严格遵守规则，从而可能出现大版本号下的小版本不兼容等问题，让我们在更新或者迁移到新机器进行环境安装时出现各式各样的问题，package-lock.json 由此赢然而生，当我们每次安装一个依赖的时候就锁定在你安装的这个版本。</p>
<h1 id="NexT-篇"><a href="#NexT-篇" class="headerlink" title="NexT 篇"></a>NexT 篇</h1><p>首先要说的是，很多人在网上查找的 NexT 主题安装和配置教程都比较早，他们给出的 NexT 地址是 「 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 」，但这个项目在 2017 的时候就宣布不再维护了，之后 2018-2019 年将 NexT 的地址变更为：「 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a> 」，<strong>2020 年最新的地址为：</strong>「 <a href="https://github.com/next-theme/hexo-theme-next" target="_blank" rel="noopener">https://github.com/next-theme/hexo-theme-next</a> 」     </p>
<p>经过不断的版本迭代，NexT 目前已经提供了非常丰富的配置来满足使用者的个性化需求，在配置主题时，如果你像我一样对前端不是特别擅长，那么我更<strong>推荐使用官方推荐的方式配置主题，多挖掘博客自带的功能，尽可能少得修改源码</strong>。    </p>
<p>我使用的 NexT 版本号为 7.8.0，请先到 themes -&gt; Next -&gt; package.json 里查看一下你的 NexT 版本，酌情考虑升级。新版本的官方主题配置内容会比以前会丰富，也更加简单。</p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>直接到你的 Blog 的 themes 文件夹下 git clone 整个 NexT 仓库即可；<br>官方给出的教程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure></p>
<p>下载后，打开 Hexo 站点配置文件，找到 theme 部分，然后将其值更改为 next（或另一个主题目录名称）；使用 <code>hexo clean</code> 清理缓存，然后 <code>hexo s</code> ，就可以去验证主题了。</p>
<h2 id="文件组织结构-1"><a href="#文件组织结构-1" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .github         # git 信息</span><br><span class="line">├── docs            # 官方的一些文档说明信息，不用管</span><br><span class="line">├── languages        # 多语言，我们常关注的是下面几个个</span><br><span class="line">|   ├── default.yml    # 默认语言</span><br><span class="line">|   └── zh-CN.yml      # 简体中文</span><br><span class="line">|   └── zh-HK.yml      # 繁体中文</span><br><span class="line">|   └── zh-TW.yml      # 繁体中文</span><br><span class="line">├── layout             # 存储相关的布局信息</span><br><span class="line">|   ├── _macro        # 可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig    # 文章模板</span><br><span class="line">|   |   ├── sidebar.swig   # 侧边栏模板</span><br><span class="line">|   |   ├── post-collapse.swig    # 没动过，理解为文章崩溃后显示的模板文件</span><br><span class="line">|   ├── _partial       # 有关文章、标题、页面等更加细节的局部布局，如果不是很懂建议不动</span><br><span class="line">|   ├── _script        # 一些脚本的局部布局</span><br><span class="line">|   ├── _third-party   # 第三方模板</span><br><span class="line">|   ├── _layout.swig   # 主页面模板</span><br><span class="line">|   ├── index.swig     # 一些索引模板</span><br><span class="line">|   ├── archive.swig   # 一些解题实现的模板</span><br><span class="line">|   └── page.swig &#x2F; tag.swig &#x2F; post.swig &#x2F; category.swig    # 相应模块的主控制模板</span><br><span class="line">├── scripts            # script 源码</span><br><span class="line">├── source             # 源码资源</span><br><span class="line">|   ├── css            # *.styl 的 css 源码</span><br><span class="line">|   ├── images         #图片</span><br><span class="line">|   ├── js             # javascript 源代码</span><br><span class="line">|   └── lib            # 其他的库文件</span><br><span class="line">└── _config.yml        # 主题配置文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Stylus 比较年轻，是一个 CSS 的预处理框架，2010 年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，可以创建健壮的、动态的、富有表现力的CSS。默认使用 .styl 的作为文件扩展名，支持多样性的 CSS 语法。  </p>
<p>SWIG 是一种简化脚本语言与 C/C++ 接口的开发工具。SWIG 是一个通过包装和编译 C/C++ 语言程序来达到与脚本语言通讯目的的工具。推荐个学习地址：『<a href="https://myvin.github.io/swig.zh-CN/docs/index.html" target="_blank" rel="noopener">Swig：一个适用于 Node.js 和浏览器的模板引擎</a>』</p>
</blockquote>
<p>看了上面的文件结构后，我们大致就知道所需要修改的信息应该在哪部分。通常，<strong>只需要修改 NexT 的 _config.yml 文件即可</strong>，配置初建议把这个文件都过一遍，然后根据自己的需求更改，里面也会有许多网上可能没提到过的配置。<br>记住不要一味的参照网上各式各样的配置教程，许多时候因为版本不同，配置的方式也不同，可能导致修改许多本没必要的位置，加入杂乱的代码等等，长时间后，我们可能自己都忘了曾经修改过啥，这样十分不利于后期的维护，和 NexT 的更新。</p>
<h2 id="官方配置教程"><a href="#官方配置教程" class="headerlink" title="官方配置教程"></a>官方配置教程</h2><p>详见：『<a href="https://hexo-theme-next.netlify.app/docs/theme-settings/" target="_blank" rel="noopener">官方配置文档</a>』    </p>
<p>看完官方文档，发现我的 Blog 也还有一些配置的地方，不说了，我先行一步！别光看了，do it，加油！</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></li>
<li><a href="https://yuchen-lea.github.io/2016-01-18-hexo-dir-struct/" target="_blank" rel="noopener">hexo目录结构小探</a></li>
<li><a href="https://hexo-theme-next.netlify.app/" target="_blank" rel="noopener">NexT 官方博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog 相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：二进制与逻辑电路</title>
    <url>/2020/02/21/Computer-Architecture/CA-BinaryAndLogicCircuits/</url>
    <content><![CDATA[<p>主要介绍逻辑电路中数的表示方法，CMOS 电路工艺及原理，Verilog，和一些未来计算机表示 0 和 1 的方法；</p>
<a id="more"></a> 
<h1 id="计算机中数的表示"><a href="#计算机中数的表示" class="headerlink" title="计算机中数的表示"></a>计算机中数的表示</h1><h2 id="二进制“1”和“0”的表示"><a href="#二进制“1”和“0”的表示" class="headerlink" title="二进制“1”和“0”的表示"></a>二进制“1”和“0”的表示</h2><ul>
<li>用电压的高低表示，半导体工艺，CMOS</li>
<li>用磁通量的有无表示，超导体工艺</li>
<li>用能级的高低表示，量子计算机</li>
<li>用基因序列表示，A, G, C, T, DNA计算机（本质也是二进制）</li>
</ul>
<h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>表示形式：$A = a_{n-1}a_{n-2}…a_1a_0$</p>
<ul>
<li>最高位 $a_{n-1}$ 为符号位，0 表示正，1 表示负；</li>
<li>其它位 $a_{n-2}…a_1a_0$ 表示数值；</li>
</ul>
<p>问题：</p>
<ul>
<li>加减法效率低；</li>
<li>两个 “0”；</li>
</ul>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>本质：</p>
<ul>
<li>取模运算，不包含符号位的 n 位数，$[Y]_补 =2 ^{n+1}+y$，如：$-2 \mod 8 = 6$</li>
</ul>
<p>表示形式：$A = a_{n-1}a_{n-2}…a_1a_0$</p>
<ul>
<li>表示：$-2^{n-1}a_{n-1}+a_{n-2}…a_1a_0$</li>
<li>最高位 $a_{n-1}$ 为符号位，0 表示正，1 表示负；</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>原码补码转换：</p>
<ul>
<li>最高位为 0 时，一样；</li>
<li>最高位为 1 时，最高位不变，其余位「按位取反加一」；</li>
</ul>
<p>补码运算：</p>
<ul>
<li>$A-B=A+B的负数=A+(B求补)$</li>
</ul>
<p>加法溢出判断:</p>
<ul>
<li>A 和 B 的最高位一样，且结果的最高位与 A 和 B 的最高位不一样；</li>
</ul>
<h2 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>定点数表示范围有限，太大或太小的数都不能表示，且除法不精确；</p>
<h3 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h3><p><strong>组成</strong>：符号位，阶码(exponent)，尾数(fraction)</p>
<ol>
<li><strong>符号位</strong>：最高位</li>
<li><strong>阶码(exponent)</strong>：<ul>
<li>阶码的移码表示：阶码=指数+偏移。（实际求解：$2^{阶码-偏移值}$）</li>
<li>范围：0&lt; e &lt; 255（指数范围：-127 &lt; m &lt; 128）<ol>
<li>e=255：无穷大数或非数</li>
<li>e=0：非规格化数或正负0</li>
</ol>
<ul>
<li>IEEE 754允许特别小的非规格化数：阶码能表示的最小指数为 -126，那更小的呢？<ul>
<li>此时阶码为0，尾数前的1不再加，即浮点数：0.f * 2^（e-126）。</li>
<li>例如：$2^{-128}=(0.01)_2 * 2^{-126}$。</li>
<li>这样，就填补了最小规格化数和0之间的一段空隙。</li>
<li>最小规格化数：$1.f \times 2^{-126}$</li>
<li>非规格化数：$0.f \times 2^{-126}$，最小 $2^{-23} \times 2^{-126}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>尾数(fraction)</strong><ul>
<li>规格化表示，尾数的最高位总为 1，因此可以不存;</li>
<li>例如：$0.0012=1.02*2^{-3}$，最高位 1.0 不存；</li>
</ul>
</li>
</ol>
<p><strong>单精度32和双精度64（扩展的单双精度）</strong><br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FloatFormat.png" alt="FloatFormat"><br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FloatFormat1.png" alt="FloatFormat1"></p>
<p><strong>IEEE 754 浮点格式参数</strong><br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FloatParameters.png" alt="FloatParameters"></p>
<p><strong>NaN</strong>（not a number）实现方式：</p>
<ol>
<li>「Singaling NaN」：抛出异常的方式，无需定义 NaN 宏；</li>
<li>「Quiet NaN」：计算机出现异常时不抛出异常来中断程序，而是把结果表示为一个特殊值 NaN，此时 NaN 宏会被定义；</li>
</ol>
<h1 id="CMOS-电路及工艺"><a href="#CMOS-电路及工艺" class="headerlink" title="CMOS 电路及工艺"></a>CMOS 电路及工艺</h1><h2 id="P-管与-N-管"><a href="#P-管与-N-管" class="headerlink" title="P 管与 N 管"></a>P 管与 N 管</h2><p><strong>「CMOS」</strong>：Complementary Metal Oxide Semiconductor 互补的金属氧化物半导体，有 NMOS 和 PMOS 两种；</p>
<ul>
<li><p><strong>NMOS</strong>：</p>
<ul>
<li>绘图时“无圈”</li>
<li>门电压为高时导通，门电压为低时关闭；</li>
<li>门电压现在在不断降低，现在在1v左右，甚至更低；</li>
</ul>
</li>
<li><p><strong>PMOS</strong>：</p>
<ul>
<li>绘图时“有圈”</li>
<li>门电压为高时关闭，门电压为低时导通；</li>
</ul>
</li>
</ul>
<h2 id="反相器"><a href="#反相器" class="headerlink" title="反相器"></a>反相器</h2><p>由上下两个互补的 PN 管组成电路：</p>
<p><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/Inverter.png" alt="Inverter"></p>
<p>这样设计上开下关，上关下开的好处是：</p>
<ul>
<li>没有直流电流，总有一头关死，能大幅降低功耗；</li>
</ul>
<p>取代了 TTL 和 ECL；</p>
<h2 id="N-沟道-MOS-晶体管的示意图"><a href="#N-沟道-MOS-晶体管的示意图" class="headerlink" title="N 沟道 MOS 晶体管的示意图"></a>N 沟道 MOS 晶体管的示意图</h2><p><strong>工作原理</strong>：</p>
<ul>
<li>栅极不加电时，源漏之间是一对 PN 结，不导通；</li>
<li>栅极加电后，吸引电子到栅氧化层下面，形成导电的沟道（附近会形成耗尽区）；</li>
</ul>
<p><strong>示意图</strong>：</p>
<p><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/NMOSSchematic.png" alt="NMOSSchematic"></p>
<p><strong>有关 Bulk</strong>:</p>
<ul>
<li>原理：空穴移动，加上电场，周围电子就会跑来填补空穴；<ul>
<li>N 型材料：通过掺杂而形成多余电子的材料；</li>
<li>P 型材料：通过掺杂而形成多余空穴的材料；</li>
<li>“+”：掺杂含量大，“-”：掺杂含量小</li>
</ul>
</li>
</ul>
<p>P 管和 N 管沟道长度一定，但宽度不同（常为：2:1或1.5:1）：</p>
<ul>
<li>P 管多数载流子为空穴，空穴运动能力差；N 管多数载流子为空穴，空穴运动能力强；</li>
<li>为了让 P 管和 N 管有相同的驱动能力（即：P，N 管导通时电阻相同），因此会让 P管偏宽；</li>
</ul>
<p>这样，反相器完成 0/1 跳变时，两种跳变斜率差不多：</p>
<ul>
<li>P 管导通，鬼输出结点充电，道沟决定了 0-&gt;1 上升沿多快；</li>
<li>N 管导通，鬼输出结点放电，道沟决定了 1-&gt;0 下降沿多快；</li>
</ul>
<h2 id="MOS晶体管的工作状态"><a href="#MOS晶体管的工作状态" class="headerlink" title="MOS晶体管的工作状态"></a>MOS晶体管的工作状态</h2><p><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/MOSWorkingState.png" alt="MOSWorkingState"></p>
<ul>
<li>Vgs：产生耗尽区，形成桥梁；</li>
<li>Vds：形成电压差，吸引电流从源端到漏端；</li>
</ul>
<h2 id="MOS基本工艺—-光刻"><a href="#MOS基本工艺—-光刻" class="headerlink" title="MOS基本工艺—-光刻"></a>MOS基本工艺—-光刻</h2><p><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/MOSPhotolithography.png" alt="MOSPhotolithography"></p>
<h2 id="P衬底-nWell-CMOS工艺"><a href="#P衬底-nWell-CMOS工艺" class="headerlink" title="P衬底 nWell CMOS工艺"></a>P衬底 nWell CMOS工艺</h2><p><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/P-CMOSProcessFlow.png" alt="P-CMOSProcessFlow"></p>
<h2 id="版图"><a href="#版图" class="headerlink" title="版图"></a>版图</h2><ol>
<li><p>反相器版图<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/InverterLayout.png" alt="InverterLayout"></p>
</li>
<li><p>NAND2 和 NOR2 的电路及版图<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/AndOrLayout.png" alt="AndOrLayout"></p>
</li>
</ol>
<h1 id="CMOS逻辑电路"><a href="#CMOS逻辑电路" class="headerlink" title="CMOS逻辑电路"></a>CMOS逻辑电路</h1><h2 id="基本逻辑电路"><a href="#基本逻辑电路" class="headerlink" title="基本逻辑电路"></a>基本逻辑电路</h2><ol>
<li>组合逻辑电路：<ul>
<li>电路中没有存储单元，逻辑电路的输出完全由当前的输入决定；</li>
<li>单输入单输出有四种电路：输出恒 0，输出恒 1，输出反向，直通；</li>
</ul>
</li>
<li>时序逻辑电路：<ul>
<li>电路中有存储单元，逻辑电路的输出由原来状态和当前的输入决定；</li>
<li>单输入单输出有无数种电路；</li>
</ul>
</li>
</ol>
<h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p><strong>Boolean 代数的基本操作</strong>：</p>
<ul>
<li>与(*)、或(+)、非(^)</li>
</ul>
<p><strong>基本定律</strong>：<br>|1|2|3|4|<br>|—-|—-|—-|—-|<br>|$A+0=A$|$A \cdot 1=A$|$A+1=1$|$A\cdot0=0$|<br>|$A+A=A$|$A\cdot A=A$|$A+\overline{A}=1$|$A\cdot \overline{A}=0$|<br>|$A+B=B+A$|$A \cdot B=B \cdot A$|<br>|$A+(B+C)=(A+B)+C$|$A \cdot (B \cdot C)=(A \cdot B) \cdot C$|<br>|$A \cdot (B+C)=A \cdot B+A \cdot C$|$A+(B \cdot C)=(A+B) \cdot (A+C)$|<br>|$\overline{A \cdot B}=\overline{A}+\overline{B}$|$\overline{A+B}=\overline{A} \cdot \overline{B}$|<br>|$A+A \cdot B=A$|$A+\overline{A} \cdot B=A+B$|  </p>
<p><strong>CMOS 中基本门</strong>：</p>
<ul>
<li>非、与非、或非<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/CMOSBasicGate.png" alt="CMOSBasicGate"></li>
<li>晶体管数目：<ul>
<li>非门：2</li>
<li>与非门：4</li>
<li>或非门：4</li>
</ul>
</li>
<li>因此，逻辑表达式最好写成上述操作的组合。如：$A \cdot B+C \cdot D=\overline{\overline{A \cdot B} \cdot \overline{C \cdot D}}$</li>
</ul>
<h2 id="CMOS-组合电路"><a href="#CMOS-组合电路" class="headerlink" title="CMOS 组合电路"></a>CMOS 组合电路</h2><p>用 NMOS 组成正逻辑：</p>
<ul>
<li>串联表示与；并联表示并；</li>
</ul>
<p>用 PMOS 组成反逻辑：</p>
<ul>
<li>$\overline{A \cdot B}=\overline{A}+\overline{B}$，P 管并联；</li>
<li>$\overline{A+B}=\overline{A} \cdot \overline{B}$，P 管串联；</li>
</ul>
<p>正反逻辑串联:</p>
<ul>
<li>由于 N 网络导通时接地，因此输出是反向的；</li>
<li>例：$\overline{A \cdot B + C \cdot D}=\overline{A \cdot B} \cdot \overline{C \cdot D}=(\overline{A}+\overline{B})\cdot(\overline{C}+\overline{D})$<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/ExPNLogicSeries.png" alt="ExPNLogicSeries">        </li>
<li>注意：串联级数不能太大，一般不超过四级，因为串联电阻大，延迟就大；</li>
</ul>
<h3 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h3><p>对于每一种可能的输入组合，给出输出值。</p>
<ul>
<li>对于一个 n 输入的电路，有 $2^n$ 项；</li>
</ul>
<p><strong>卡诺图</strong>：</p>
<ul>
<li>便于逻辑表达式，优化输入输出的关系表示；</li>
<li>在图中相临的 “1” 或 “X” 合并成一项；</li>
<li>例：一位全加器<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/Carnot.png" alt="Carnot"></li>
</ul>
<h3 id="逻辑图"><a href="#逻辑图" class="headerlink" title="逻辑图"></a>逻辑图</h3><p>直接用门及互连表示输入输出的逻辑关系；</p>
<p>例：一位全加器</p>
<ul>
<li>逻辑图：<br>  <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FulladdLogicDiagram.png" alt="FulladdLogicDiagram"></li>
<li>对应的 CMOS 电路：<br>  <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FulladdCMOSCircuit.png" alt="FulladdCMOSCircuit"></li>
</ul>
<p>补充问题：有关晶体管数目</p>
<ul>
<li>上述逻辑图中，标明的数字即每个门所需的晶体管数，最终一位全加器共需要 56 个晶体管；<ul>
<li>非门：两个晶体管构成，一个 P 管，一个 N 管；</li>
<li>与非门：2 输入的需要四个晶体管，3 输入需要 6 个,……</li>
</ul>
</li>
<li>相当于每一个输入都需要 2 个晶体管；</li>
</ul>
<h2 id="CMOS-时序逻辑电路"><a href="#CMOS-时序逻辑电路" class="headerlink" title="CMOS 时序逻辑电路"></a>CMOS 时序逻辑电路</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>特点：</p>
<ul>
<li>时序逻辑电路内部有存储单元，其行为由输入和内部单元的值共同决定；</li>
</ul>
<p>组成结构：</p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/SequentialComposition.png" alt="SequentialComposition"></li>
</ul>
<p>分类：</p>
<ul>
<li>同步时序逻辑电路：<ul>
<li>所有存储单元的变化由时钟统一触发；</li>
<li>功耗大，简单；（计算机常用）</li>
</ul>
</li>
<li>异步时序逻辑电路：<ul>
<li>低功耗，复杂；</li>
</ul>
</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="RS-触发器"><a href="#RS-触发器" class="headerlink" title="RS 触发器"></a>RS 触发器</h4><p>其他寄存器的基础；    </p>
<p>基本结构：<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/RSStructure.png" alt="RSStructure">    </p>
<p>加深理解：例题<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/RSExample.png" alt="RSExample">    </p>
<h4 id="D-触发器"><a href="#D-触发器" class="headerlink" title="D 触发器"></a>D 触发器</h4><h5 id="D-门闩（D-锁存器）"><a href="#D-门闩（D-锁存器）" class="headerlink" title="D 门闩（D 锁存器）"></a>D 门闩（D 锁存器）</h5><ol>
<li>结构：<br> <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/DDoorLatch.png" alt="DDoorLatch">    </li>
<li>工作原理：由时钟 C 电平进行控制，电平高时输入，低时保持<ul>
<li>C 为 0 时：R 和 S 都为 1，输出保持原有状态；</li>
<li>C 为 1 时：输出和输⼊ D 相同，相当于直通；</li>
</ul>
</li>
</ol>
<h5 id="D-触发器-1"><a href="#D-触发器-1" class="headerlink" title="D 触发器"></a>D 触发器</h5><ol>
<li><p>结构：</p>
<ul>
<li>由两个 D 锁存器串联形成；<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/DLatch.png" alt="DLatch"></li>
</ul>
</li>
<li><p>工作原理：</p>
<ul>
<li>通过时钟 C 跳沿（非电平）来锁存数据：<ul>
<li>C=1 时，锁 1 直通，锁 2 保持；</li>
<li>C=0 时，锁 1 保持，锁 2 直通；</li>
<li>C 从 1-&gt;0 时，把 D 的值锁存；</li>
</ul>
</li>
</ul>
</li>
<li><p>$触发器延迟=Setup+{CLK-to-Q}$<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/TriggerDelay.png" alt="TriggerDelay"></p>
</li>
<li><p>三个重要时间参数：</p>
<ul>
<li><strong>「Hold」</strong>：时钟下降后数据变化不影响第一级 D-Latch（可负）<ul>
<li>在本电路中为 0 </li>
</ul>
</li>
<li><strong>「Setup」</strong>：时钟沿下降之前保证数据已采到第一级 D-latch（可负）<ul>
<li>1 级反相器 + 3 级与非门（Q 端从 1 变 0） </li>
</ul>
</li>
<li><strong>「Clock-to-Q」</strong>：时钟沿下降后引起 Q 的变化<ul>
<li>1 级反相器（C 反相器与 D 方向器并行）+ 3 级与非门</li>
</ul>
</li>
<li>上述只是初略计算，具体的值需要仿真</li>
</ul>
</li>
</ol>
<h5 id="EDFF-电路"><a href="#EDFF-电路" class="headerlink" title="EDFF 电路"></a>EDFF 电路</h5><ol>
<li>结构：<ul>
<li>带输入使能的 D 触发器（只有 E 有效，才能输入）；<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/EDFFStructure.png" alt="EDFFStructure"></li>
</ul>
</li>
<li>例题：加深理解<br> <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/EDFFExample.png" alt="EDFFExample"></li>
</ol>
<h2 id="CMOS-电路延迟原理"><a href="#CMOS-电路延迟原理" class="headerlink" title="CMOS 电路延迟原理"></a>CMOS 电路延迟原理</h2><h3 id="电压变化"><a href="#电压变化" class="headerlink" title="电压变化"></a>电压变化</h3><p>输入电压变化时，输出电压的变化不是瞬时完成的；<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/CMOSCircuitDelayPrinciple.png" alt="CMOSCircuitDelayPrinciple"></p>
<h3 id="延迟模型"><a href="#延迟模型" class="headerlink" title="延迟模型"></a>延迟模型</h3><p>与延迟有关的因素：输入 transition、内部延迟、输出负载  </p>
<p>$CMOS延迟=自身延迟（ns）+负载延迟（ns/fF*负载）$</p>
<ul>
<li>负载包括：下一级负载、连线延迟等</li>
<li>ns 是电容单位，fF 是负载单位</li>
</ul>
<p>例子：</p>
<ol>
<li>二输入与非门<br> <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/TwoInNandGateDelay.png" alt="TwoInNandGateDelay">        </li>
<li>全加器<br> <img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/FullAddDelay.png" alt="FullAddDelay"></li>
</ol>
<h3 id="标准单元延迟的计算"><a href="#标准单元延迟的计算" class="headerlink" title="标准单元延迟的计算"></a>标准单元延迟的计算</h3><ol>
<li>深亚微米电路中连线延迟占总延迟的大部分；</li>
<li>连线延迟的计算是一个不断迭代求精的过程，</li>
</ol>
<ul>
<li>综合时根据负载个数估计线长，非常粗略；</li>
<li>布局后根据距离估计线长，比较准确了；</li>
<li>布线后进一步考虑具体连线、互相干扰、过孔等精确连线信息；</li>
</ul>
<h3 id="降低延迟的方法"><a href="#降低延迟的方法" class="headerlink" title="降低延迟的方法"></a>降低延迟的方法</h3><ol>
<li><p>通过结构设计降低延迟：</p>
<ul>
<li>如流水级的划分、cache 读出和命中比较是否在同一级、浮点流水级设计、Pipeline stalling signal 的设置；</li>
</ul>
</li>
<li><p>逻辑设计：</p>
<ul>
<li>减少门的级数；<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/ReduceDoors.png" alt="ReduceDoors">        </li>
<li>负载平衡：CMOS 的负载能力较低，分推<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/LoadBalance.png" alt="LoadBalance"><ul>
<li>如多选一通路的选择次序、加法器算法、流水级间的局部调整等</li>
</ul>
</li>
</ul>
</li>
<li>物理设计：<ul>
<li>动态电路、clock skew、clock jitter、transition time、布局布线</li>
</ul>
</li>
</ol>
<h1 id="从-Verilog-到版图"><a href="#从-Verilog-到版图" class="headerlink" title="从 Verilog 到版图"></a>从 Verilog 到版图</h1><h2 id="Verilog-语言"><a href="#Verilog-语言" class="headerlink" title="Verilog 语言"></a>Verilog 语言</h2><p>组合逻辑和时序逻辑：<br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/Verilog12.png" alt="Verilog12"></p>
<p>模块调用：<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四位串行加法器</span></span><br><span class="line"><span class="keyword">module</span> adder4(a,b,cin,s,cout);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b;</span><br><span class="line"><span class="keyword">input</span> cin;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] s;</span><br><span class="line"><span class="keyword">output</span> cout;</span><br><span class="line"><span class="keyword">wire</span> carry[<span class="number">2</span>:<span class="number">0</span>]</span><br><span class="line">full_adder bit0(<span class="variable">.a</span>(a[<span class="number">0</span>]),<span class="variable">.b</span>(b[<span class="number">0</span>]),<span class="variable">.c</span>(cin[<span class="number">0</span>]),<span class="variable">.s</span>(s[<span class="number">0</span>]),<span class="variable">.cout</span>(carry[<span class="number">0</span>]));</span><br><span class="line">full_adder bit1(<span class="variable">.a</span>(a[<span class="number">1</span>]),<span class="variable">.b</span>(b[<span class="number">1</span>]),<span class="variable">.c</span>(carry[<span class="number">0</span>]),<span class="variable">.s</span>(s[<span class="number">1</span>]),<span class="variable">.cout</span>(carry[<span class="number">1</span>]));</span><br><span class="line">full_adder bit2(<span class="variable">.a</span>(a[<span class="number">2</span>]),<span class="variable">.b</span>(b[<span class="number">2</span>]),<span class="variable">.c</span>(carry[<span class="number">1</span>]),<span class="variable">.s</span>(s[<span class="number">2</span>]),<span class="variable">.cout</span>(carry[<span class="number">2</span>]));</span><br><span class="line">full_adder bit3(<span class="variable">.a</span>(a[<span class="number">3</span>]),<span class="variable">.b</span>(b[<span class="number">3</span>]),<span class="variable">.c</span>(carry[<span class="number">2</span>]),<span class="variable">.s</span>(s[<span class="number">3</span>]),<span class="variable">.cout</span>(cout));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四位计数器</span></span><br><span class="line"><span class="keyword">module</span> counter4(reset,en,clock,out);</span><br><span class="line"><span class="keyword">input</span> reset,en,clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] c_in;</span><br><span class="line"><span class="keyword">assign</span> out = counter;</span><br><span class="line">adder4 counter(<span class="variable">.a</span>(counter),<span class="variable">.b</span>(<span class="number">4</span>’b0),<span class="variable">.cin</span>(<span class="number">1</span>’b1),<span class="variable">.s</span>(c_in),<span class="variable">.cout</span>());</span><br><span class="line"><span class="keyword">always</span> (@<span class="keyword">posedge</span> clock) <span class="keyword">begin</span></span><br><span class="line">counter &lt;= reset ? <span class="number">0</span> : en ? c_in : counter;</span><br><span class="line"><span class="comment">//counter&lt;=reset ? 0 : en ? counter +1 : counter;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="从-Verilog-到-GDSII"><a href="#从-Verilog-到-GDSII" class="headerlink" title="从 Verilog 到 GDSII"></a>从 Verilog 到 GDSII</h2><p>3-8译码器为例;    </p>
<p>结构功能：</p>
<ul>
<li>从左边的三位输入，二进制换算为 0-7，分别选中 8 根输出线；</li>
</ul>
<p>Verilog：<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> decode(in, out);</span><br><span class="line"><span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] out;</span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">0</span>] = (!in[<span class="number">2</span>]) &amp;&amp; (!in [<span class="number">1</span>]) &amp;&amp; (!in[<span class="number">0</span>]); <span class="comment">// (in==3'b000)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">1</span>] = (!in[<span class="number">2</span>]) &amp;&amp; (!in [<span class="number">1</span>]) &amp;&amp; ( in[<span class="number">0</span>]); <span class="comment">// (in==3'b001)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">2</span>] = (!in[<span class="number">2</span>]) &amp;&amp; ( in [<span class="number">1</span>]) &amp;&amp; (!in[<span class="number">0</span>]); <span class="comment">// (in==3'b010)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">3</span>] = (!in[<span class="number">2</span>]) &amp;&amp; ( in [<span class="number">1</span>]) &amp;&amp; ( in[<span class="number">0</span>]); <span class="comment">// (in==3'b011)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">4</span>] = ( in[<span class="number">2</span>]) &amp;&amp; (!in [<span class="number">1</span>]) &amp;&amp; (!in[<span class="number">0</span>]); <span class="comment">// (in==3'b100)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">5</span>] = ( in[<span class="number">2</span>]) &amp;&amp; (!in [<span class="number">1</span>]) &amp;&amp; ( in[<span class="number">0</span>]); <span class="comment">// (in==3'b101)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">6</span>] = ( in[<span class="number">2</span>]) &amp;&amp; ( in [<span class="number">1</span>]) &amp;&amp; (!in[<span class="number">0</span>]); <span class="comment">// (in==3'b110)?1:0;</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">7</span>] = ( in[<span class="number">2</span>]) &amp;&amp; ( in [<span class="number">1</span>]) &amp;&amp; ( in[<span class="number">0</span>]); <span class="comment">// (in==3'b111)?1:0;</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>网表：<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> decode ( in, out );</span><br><span class="line"><span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] out;</span><br><span class="line">	<span class="keyword">wire</span> n1, n2, n3;</span><br><span class="line">	AND3X1 U1 ( <span class="variable">.A</span>(in[<span class="number">1</span>]), <span class="variable">.B</span>(in[<span class="number">0</span>]), <span class="variable">.C</span>(in[<span class="number">2</span>]), <span class="variable">.Y</span>(out[<span class="number">7</span>]) );</span><br><span class="line">	AND3X1 U2 ( <span class="variable">.A</span>(in[<span class="number">1</span>]), <span class="variable">.B</span>(n1), <span class="variable">.C</span>(in[<span class="number">2</span>]), <span class="variable">.Y</span>(out[<span class="number">6</span>]) );</span><br><span class="line">	AND3X1 U3 ( <span class="variable">.A</span>(in[<span class="number">0</span>]), <span class="variable">.B</span>(n2), <span class="variable">.C</span>(in[<span class="number">2</span>]), <span class="variable">.Y</span>(out[<span class="number">5</span>]) );</span><br><span class="line">	AND3X1 U4 ( <span class="variable">.A</span>(n1), <span class="variable">.B</span>(n2), <span class="variable">.C</span>(in[<span class="number">2</span>]), <span class="variable">.Y</span>(out[<span class="number">4</span>]) );</span><br><span class="line">	AND3X1 U5 ( <span class="variable">.A</span>(in[<span class="number">0</span>]), <span class="variable">.B</span>(n3), <span class="variable">.C</span>(in[<span class="number">1</span>]), <span class="variable">.Y</span>(out[<span class="number">3</span>]) );</span><br><span class="line">	AND3X1 U6 ( <span class="variable">.A</span>(n1), <span class="variable">.B</span>(n3), <span class="variable">.C</span>(in[<span class="number">1</span>]), <span class="variable">.Y</span>(out[<span class="number">2</span>]) );</span><br><span class="line">	AND3X1 U7 ( <span class="variable">.A</span>(n2), <span class="variable">.B</span>(n3), <span class="variable">.C</span>(in[<span class="number">0</span>]), <span class="variable">.Y</span>(out[<span class="number">1</span>]) );</span><br><span class="line">	AND3X1 U8 ( <span class="variable">.A</span>(n2), <span class="variable">.B</span>(n3), <span class="variable">.C</span>(n1), <span class="variable">.Y</span>(out[<span class="number">0</span>]) );</span><br><span class="line">	INVX1 U9 ( <span class="variable">.A</span>(in[<span class="number">0</span>]), <span class="variable">.Y</span>(n1) );</span><br><span class="line">	INVX1 U10 ( <span class="variable">.A</span>(in[<span class="number">1</span>]), <span class="variable">.Y</span>(n2) );</span><br><span class="line">	INVX1 U11 ( <span class="variable">.A</span>(in[<span class="number">2</span>]), <span class="variable">.Y</span>(n3) );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br><img src="http://img.thebetterkong.cn/blog/CA-BinaryAndLogicCircuits/3-8Decoder.png" alt="3-8Decoder"></p>
<h1 id="其它-“0”-和-“1”-的表示方法"><a href="#其它-“0”-和-“1”-的表示方法" class="headerlink" title="其它 “0” 和 “1” 的表示方法"></a>其它 “0” 和 “1” 的表示方法</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>用磁通量的有无表示，超导体工艺</li>
<li>用能级的高低表示，量子计算机</li>
<li>用基因序列表示，A, G, C, T, DNA计算机</li>
</ul>
<h2 id="超导计算—-RSFQ-技术"><a href="#超导计算—-RSFQ-技术" class="headerlink" title="超导计算—-RSFQ 技术"></a>超导计算—-RSFQ 技术</h2><p>基本原理：</p>
<ul>
<li>超导(4-5K)环中的磁通量具有量子化特性；</li>
<li>设计电路使超导环中的磁通量只变化一个磁通量；</li>
<li>用磁通量的有无来表示二进制数位的 “1” 和 “0”；</li>
<li>磁通量的变化由外加电流控制。</li>
</ul>
<p>特点：</p>
<ol>
<li>工作频率高：100 GHz (实验室已达370 GHz, 1.5P 工艺)。</li>
<li>每个门的功率：0.1PW</li>
<li>工艺比较简单；</li>
</ol>
<h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><h3 id="量子力学特性"><a href="#量子力学特性" class="headerlink" title="量子力学特性"></a>量子力学特性</h3><p>量子叠加态（superposed state）：</p>
<ul>
<li>量子器件的信息位称为量子位（qubit），它可处于叠加态；</li>
<li>叠加态可以是 “0” 也可以是 “1”；</li>
<li>通过测量或与其他物体发生相互作用可呈现出 “0” 态或 “1” 态；</li>
<li>由于每个量子位都可以是 “0” 或 “1”， n 个量子位就可以表示 $2^n$ 个 n 位数；</li>
<li>常规计算机的一个 n 位存储单元只能存放一个 n 位数，而 n 个量子位可以存放 $2^n$ 个 n 位数，可以实现超大容量的存储器。</li>
</ul>
<p>量子纠缠态（entangled state)）：</p>
<ul>
<li>用作运算的多个量子位还应处于纠缠态，即所有量子位的状态紧密相关。</li>
<li>当测量某个量子位时，会影响其他量子位的测量结果。</li>
</ul>
<p>量子并行（quantum parallelism）：</p>
<ul>
<li>计算 f(x) 时，可同时计算出 x 的所有值的 f(x)。所以不需要多次循环，也不需要多个处理机并行计算；</li>
</ul>
<h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><p>大数 N 因子分解：</p>
<ul>
<li>令 $n = log_2N$ , 经典算法所需步骤为 $2^{\frac{n}{2}}$，Shor 量子并行算法所需步骤为 Poly(n)；</li>
<li>Poly(n) 为 n 的多项式，该算法将 NP 问题转换为 P 问题；</li>
</ul>
<p>搜寻算法：</p>
<ul>
<li>在 N 个元素的集合中搜寻某个元素，经典算法搜寻 N/2 次后，找到的概率为 1/2， Grover 量子搜寻算法则只需 $N^{\frac{n}{2}}$ 次，即可达到同样概率；</li>
</ul>
<p>量子系统模拟：</p>
<ul>
<li>常规计算机不可能有效地模拟量子系统，因为它们的物理机制不同。用常规计算机模拟量子系统，所需的信息量和时间都远大于模拟经典系统。量子计算可用于研究高温高密度等离子体、量子色动力学、晶体固态模型、分子行为的量子模型等。</li>
</ul>
<h3 id="物理实现"><a href="#物理实现" class="headerlink" title="物理实现"></a>物理实现</h3><p>量子位的实现：</p>
<ul>
<li>任何两态的量子系统都可作为量子位，如原子的能级、电子或原子核的自旋、光子的正交偏振态等；</li>
</ul>
<p>量子计算机的实现：</p>
<ul>
<li>有多种可能，包括：核磁共振（用磁场中的原子核自旋作为量子位）、离子阱（用被俘获在线性量子阱中的离子作为量子位）、硅基半导体量子器件（杂质核自旋与电子自旋相互作用）等。</li>
</ul>
<h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul>
<li>量子位的缠结态容易崩溃，位数越多，越难实现。</li>
<li>量子器件之间的连接。</li>
<li>为了维持量子逻辑的一致性，量子系统和环境的隔离。</li>
<li>设备缺陷所引起的逻辑错误</li>
</ul>
<h2 id="分子计算机"><a href="#分子计算机" class="headerlink" title="分子计算机"></a>分子计算机</h2><p>原理：</p>
<ul>
<li>DNA 计算机利用 DNA 分子保存信息；</li>
<li>DNA 分子是由 A, G, C, T 四种核苷酸（碱基）组成的序列，不同的序列可用来表示不同的信息；</li>
<li>通过 DNA 分子之间的一系列生化反应来进行运算，可产生表示结果的 DNA 分子；</li>
<li>已解决了 7 个城市的旅行售货员等问题；</li>
</ul>
<p>优点：</p>
<ul>
<li>高度并行：所有 DNA 分子同时运算；</li>
<li>能耗低：半导体计算机的 $\frac{1}{10^{10}}$；</li>
<li>存储密度大：磁存储器的 $10^{12}$ 倍；</li>
</ul>
<p>缺点：</p>
<ul>
<li>生化反应慢、操作有随机性、DNA 分子容易水解、DNA 分子之间难以通信；</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>改进 Hexo 中 MathJax 数学公式的渲染</title>
    <url>/2020/05/20/Blog-Related/ImproveMathJax/</url>
    <content><![CDATA[<p>之前，更新了一篇<a href="http://www.thebetterkong.cn/2020/04/04/Blog-Related/Markdown-Writing/">《Markdown 写作指南》</a>的博文，这次更新重点梳理了一下 MathJax 数学公式的书写。在之后 Blog 书写过程中，也就越来越多的开始依赖 MathJax 数学公式。但是，有时候，我发现我的公式书写完全正确，并且在本地 vscode 的预览也能渲染出正确结果。可是，当我部署到我的 blog 里时，公式总是出现大大小小的问题。不知道，你是否也有过这样的疑惑？</p>
<a id="more"></a> 
<p>首先，得先说一下，这里说的 MathJax 渲染出错，是你已经在主题配置文件下设置了 mathJax 为 true，依旧出现公式渲染出错；</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>经过网上一番了解。其实，造成这种现象主要原因是 Hexo 默认的渲染引擎 hexo-renderer-marked 对公式渲染时与 Mathjax 发生了一些冲突，导致了 bug；</p>
<blockquote>
<p>实际渲染中，Hexo 默认的 MarkDown 渲染引擎 hexo-renderer-marked 会调用 marked 模块的 node_modules\marked\lib\marked.js 脚本进行最终的解释，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签：</p>
<ul>
<li>在 markdown 语法中，下划线 <code>_</code> 代表斜体，会被渲染引擎处理为 <code>&lt;em&gt;</code> 标签；</li>
<li><code>\\</code> 也会被转义成一个 <code>\</code>；<ul>
<li>而 Latex 格式书写的数学公式下划线 <code>_</code> 表示角标，<code>\\</code> 表示公式换行，有特殊的含义，所以 MathJax 引擎在渲染数学公式的时候就会出错；</li>
<li>类似的语义冲突的符号还包括 <code>*, {, }</code> 等。</li>
</ul>
</li>
</ul>
</blockquote>
<p>解决思路：</p>
<ul>
<li>针对下划线的问题，markdown 的 marked.js 中有两种斜体的表示方式，因此取消 <code>_</code> 作为斜体转义，以后用 <code>*</code> 作为斜体表示即可；</li>
<li>针对 marked.js 与 Mathjax 对于个别字符二次转义的问题，我们只要不让 marked.js 去转义 <code>\\,\{,\}</code> 在 MathJax 中有特殊用途的字符就行了。</li>
</ul>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>首先，可以更换 Hexo 的 markdown 渲染引擎：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-renderer-marked --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-kramed --save</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>说明：<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级；</li>
<li>但是也需要注意，更换完后，可能对原先的 markdown 书写有一些影响，但是我个人觉得影响不大，如果你对此十分介意，想了解受影响的地方，可以参考该引擎官方文档；</li>
<li>其实你也可以直接跳过此步，按照下面的内容，直接修改上面提到过的 node_modules\marked\lib\marked.js 脚本；</li>
</ul>
<p>此时，hexo-renderer-kramed 只是修改了部分 bug，还不足以解决所有冲突，为了避免以后再出现其他问题，这里再手动进一步修改一下：</p>
<ul>
<li>到博客的根目录下，找到 node_modules\kramed\lib\rules\inline.js；</li>
<li>修改第 11 行的 escape 变量的值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure>
<ul>
<li>这一步是在原基础上取消了对 <code>\ , { , }</code> 的转义（escape）；</li>
</ul>
</li>
<li>现在在第 21 行的 em 变量也要做相应的修改：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line">em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure>
<ul>
<li>这一步取消了对斜体标记_的转义</li>
</ul>
</li>
</ul>
<p><strong>清除原先 hexo 缓存</strong>，重新生成部署就可以看到问题已经解决了。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>因为我们在主题配置文件中开启了 mathJax，因此，对所有的文章都会使用 mathJax 进行渲染，即使有些文章里，你根本没用上 mathJax，这样会影响你页面的访问速度。   </p>
<p>因此，可以考虑在文章的 Front-matter 里针对性的打开 mathjax 开关：<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 改进 Hexo 中 MathJax 数学公式的渲染</span><br><span class="line">data: 2020-05-20 17:05:14  </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">    - </span>Blog 相关</span><br><span class="line"></span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">    - </span>Blog</span><br><span class="line"></span><br><span class="line">mathjax: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://blog.csdn.net/weixin_30725467/article/details/96659102" target="_blank" rel="noopener">1:《在Hexo中渲染MathJax数学公式》</a></li>
<li><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">2:《在Hexo中渲染MathJax数学公式》</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog 相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：高速缓存</title>
    <url>/2020/02/21/Computer-Architecture/CA-Cache/</url>
    <content><![CDATA[<p>Cache 作为存储结构中十分重要的部分，不管是安全还是性能，它都十分关键，本节主要从性能出发，介绍 cache 的结特点和性能优化方法。</p>
<a id="more"></a> 
<h1 id="存储层次的基本概念"><a href="#存储层次的基本概念" class="headerlink" title="存储层次的基本概念"></a>存储层次的基本概念</h1><h2 id="CPU-与-RAM-的速度剪刀差"><a href="#CPU-与-RAM-的速度剪刀差" class="headerlink" title="CPU 与 RAM 的速度剪刀差"></a>CPU 与 RAM 的速度剪刀差</h2><ol>
<li><p>摩尔定律：</p>
<ul>
<li>CPU 的频率和 RAM 的容量每 18 个月翻一番</li>
<li>但 RAM 的速度增加缓慢</li>
</ul>
</li>
<li><p>通过存储层次来弥补差距：</p>
<ul>
<li>寄存器、Cache、存储器、IO</li>
</ul>
</li>
</ol>
<h2 id="处理器和内存速度剪刀差"><a href="#处理器和内存速度剪刀差" class="headerlink" title="处理器和内存速度剪刀差"></a>处理器和内存速度剪刀差</h2><ul>
<li>早期 Alpha 处理器 Cache 失效延迟：<ul>
<li>1st    Alpha (7000):  340 ns/5.0 ns = 68 clks x 2 or 136 </li>
<li>2nd  Alpha (8400):   266 ns/3.3 ns = 80 clks x 4 or 320</li>
<li>3rd   Alpha (t.b.d.):  180 ns/1.7 ns =108 clks x 6 or 648</li>
</ul>
</li>
<li>当前主流处理器主频 2GHz 以上：<ul>
<li>IBM Power 6 主频 6GHz 以上</li>
<li>内存延迟 50ns 左右</li>
</ul>
</li>
<li>访存延迟 &gt;100 拍 </li>
<li>多发射加剧了访存瓶颈</li>
</ul>
<h2 id="摩尔定律使-CPU-的内容发生了变化"><a href="#摩尔定律使-CPU-的内容发生了变化" class="headerlink" title="摩尔定律使 CPU 的内容发生了变化"></a>摩尔定律使 CPU 的内容发生了变化</h2><ol>
<li><p>冯诺依曼结构的核心思想：</p>
<ul>
<li>存储程序：指令和数据都存放在存储器中</li>
</ul>
</li>
<li><p>计算机的五个组成部分：</p>
<ul>
<li>运算器、控制器、存储器、输入、输出</li>
<li>运算器和控制器合称中央处理器（CPU）</li>
</ul>
</li>
<li><p>为了缓解存储瓶颈，把部分存储器做在片内：</p>
<ul>
<li>现在的 CPU 芯片：控制器+运算器+部分存储器</li>
<li>片内 Cache 占了整个芯片的很大一部分面积</li>
</ul>
</li>
</ol>
<h2 id="计算机硬件系统的组成"><a href="#计算机硬件系统的组成" class="headerlink" title="计算机硬件系统的组成"></a>计算机硬件系统的组成</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/CompositionComputer.png" alt="CompositionComputer"></p>
<h2 id="CPU-中-RAM-的面积和晶体管比例"><a href="#CPU-中-RAM-的面积和晶体管比例" class="headerlink" title="CPU 中 RAM 的面积和晶体管比例"></a>CPU 中 RAM 的面积和晶体管比例</h2><div class="table-container">
<table>
<thead>
<tr>
<th>CPU名称</th>
<th>片内RAM面积</th>
<th>片内RAM晶体管</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alpha 21164</td>
<td>37%</td>
<td>77%</td>
</tr>
<tr>
<td>StrongArm SA110</td>
<td>61%</td>
<td>94%</td>
</tr>
<tr>
<td>Pentium Pro</td>
<td>64%</td>
<td>88%</td>
</tr>
<tr>
<td>龙芯3A</td>
<td>31%</td>
<td>80%</td>
</tr>
</tbody>
</table>
</div>
<p>RAM 所占的面积比例小于晶体管：</p>
<ul>
<li>因为 RAM 很规则，可以做到很密，而普通逻辑不行；</li>
</ul>
<h2 id="存储层次基本原理"><a href="#存储层次基本原理" class="headerlink" title="存储层次基本原理"></a>存储层次基本原理</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/StorageHierarchy.png" alt="StorageHierarchy"></p>
<ul>
<li>程序访问的局部性：时间局部性和空间局部性<ul>
<li>新型的应用（如媒体）对传统的局部性提出了挑战</li>
</ul>
</li>
</ul>
<h1 id="Cache-结构"><a href="#Cache-结构" class="headerlink" title="Cache 结构"></a>Cache 结构</h1><h2 id="cache-特征"><a href="#cache-特征" class="headerlink" title="cache 特征"></a>cache 特征</h2><ul>
<li>Cache 的内容是主存储器内容的一个子集</li>
<li>Cache 没有程序上的意义，只是为了降低访存延迟</li>
<li>处理器访问 Cache 和访问存储器使用相同的地址</li>
</ul>
<h2 id="cache-结构特点"><a href="#cache-结构特点" class="headerlink" title="cache 结构特点"></a>cache 结构特点</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/CacheStructureCharacteristics.png" alt="CacheStructureCharacteristics"></p>
<ul>
<li>同时存储数据和地址以及在 cache 中的转态；</li>
<li>通过地址的比较判断相应数据是否在 Cache 中 ；</li>
<li>需要考虑所需要的数据不在 Cache 中的情况：替换机制，写策略等；</li>
</ul>
<h2 id="cache-分类"><a href="#cache-分类" class="headerlink" title="cache 分类"></a>cache 分类</h2><h3 id="cache-块的位置"><a href="#cache-块的位置" class="headerlink" title="cache 块的位置"></a>cache 块的位置</h3><p>同一单元在不同结构 Cache 中的位置：<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/CacheBlockLocation.png" alt="CacheBlockLocation"></p>
<ul>
<li><p><strong>全相联</strong>：</p>
<ul>
<li>命中率高；硬件复杂、延迟大；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/FullyConnected.png" alt="FullyConnected"></li>
</ul>
</li>
<li><p><strong>直接相联：</strong></p>
<ul>
<li>命中率低；硬件简单、延迟最小；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/DirectlyConnected.png" alt="DirectlyConnected"></li>
</ul>
</li>
<li><p><strong>组相联：</strong></p>
<ul>
<li>介于全相联和直接相联之间；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/GroupConnected.png" alt="GroupConnected"></li>
</ul>
</li>
<li><p>例题：<br>  <img src="http://img.thebetterkong.cn/blog/CA-Cache/ExampleCacheBlockLocation.png" alt="ExampleCacheBlockLocation"></p>
</li>
</ul>
<h3 id="Cache-替换算法"><a href="#Cache-替换算法" class="headerlink" title="Cache 替换算法"></a>Cache 替换算法</h3><ul>
<li>常见的替换算法：<ul>
<li><strong>随机替换、LRU 最近最少使用、FIFO 先进先出</strong></li>
</ul>
</li>
<li>对直接相联 Cache 不存在替换算法问题；</li>
<li>每 1000 条指令失效次数统计：<ul>
<li>SPEC CPU2000 中的 gap, gcc, gzip, mcf, perl, applu, art, equake, lucas, swim 10 个程序</li>
<li>Aplha 结构，块大小64B<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/CacheReplacementStatistics.png" alt="CacheReplacementStatistics"></li>
</ul>
</li>
</ul>
<h3 id="写命中时采取的策略"><a href="#写命中时采取的策略" class="headerlink" title="写命中时采取的策略"></a>写命中时采取的策略</h3><ul>
<li><strong>写穿透（Write Through）</strong>：<ul>
<li>写 Cache 的同时写内存</li>
<li>内存里的数据永远是最新的，Cache 替换时直接扔掉</li>
<li>Cache 块管理简单，只需有效位</li>
</ul>
</li>
<li><strong>写回（Write-back）</strong>：<ul>
<li>只写 Cache 不写内存</li>
<li>替换时要把 Cache 块写回内存</li>
<li>Cache 块状态复杂一些，需要有效位和脏位</li>
</ul>
</li>
<li><strong>写回/写穿透的使用</strong>：（CPU&lt;—&gt;L1（常在CPU内）&lt;—&gt;L2&lt;—&gt;内存）<ul>
<li>L1 到 L2 用写穿透的多，L2 较快</li>
<li>L2 到内存用写回的多，内存太慢了</li>
<li>龙芯 2 号两级都采用写回策略</li>
</ul>
</li>
</ul>
<h3 id="写失效时采取的策略"><a href="#写失效时采取的策略" class="headerlink" title="写失效时采取的策略"></a>写失效时采取的策略</h3><ul>
<li><strong>写分配（ Write Allocate ）</strong>：<ul>
<li>先把失效块读到 Cache，再在 Cache 中写</li>
<li>一般用在写命中时采用写回策略的 Cache 中 </li>
</ul>
</li>
<li><strong>写不分配（Write Non-allocate）</strong>：<ul>
<li>写 Cache 失效时直接写进内存</li>
<li>一般用在写命中时采用写穿透的 Cache 中</li>
</ul>
</li>
</ul>
<h1 id="Cache-性能优化"><a href="#Cache-性能优化" class="headerlink" title="Cache 性能优化"></a>Cache 性能优化</h1><h2 id="Cache-性能分析"><a href="#Cache-性能分析" class="headerlink" title="Cache 性能分析"></a>Cache 性能分析</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/CachePerformanceAnalysis.png" alt="CachePerformanceAnalysis"></p>
<ul>
<li>CPU 执行时间与访存延迟的关系</li>
<li>平均访存时间 AMAT = Average Memory Access Time</li>
<li>CPIALUOps 不包括访存指令</li>
</ul>
<h2 id="Cache-性能优化-1"><a href="#Cache-性能优化-1" class="headerlink" title="Cache 性能优化"></a>Cache 性能优化</h2><p>四个方向：</p>
<ol>
<li>降低失效率（MissRate）</li>
<li>降低失效延迟（MissPenalty） </li>
<li>降低命中延迟（HitTime） </li>
<li>提高Cache访问并行性</li>
</ol>
<h3 id="降低失效率"><a href="#降低失效率" class="headerlink" title="降低失效率"></a>降低失效率</h3><p><strong>引起 Cache 失效的因素（3C/4C）</strong>：</p>
<ul>
<li><strong>冷失效（Cold Miss或Compulsory Miss）</strong> ：<ul>
<li>CPU 第一次访问 Cache 块时 Cache 中还没有该 Cache 块引起的失效；</li>
<li>冷失效是不可避免的，即使 Cache 容量再大也会有；</li>
</ul>
</li>
<li><strong>容量失效（Capacity Miss） ：</strong><ul>
<li>程序执行过程中，有限的 Cache 容量导致 Cache 放不下时替换出部分 Cache 块，被替换的 Cache 块再被访问时引起失效；</li>
<li>一定容量下全相联 Cache 中的失效；</li>
</ul>
</li>
<li><strong>冲突失效（Conflict Miss）</strong> ：<ul>
<li>直接相联或组相联 Cache 中，不同 Cache 块由于 index 相同引起冲突；</li>
<li>在全相联 Cache 不存在；</li>
</ul>
</li>
<li><strong>一致性失效（Coherence Miss）</strong>：<ul>
<li>由于维护 Cache 一致性引起的失效；</li>
</ul>
</li>
</ul>
<p><strong>3C 失效率分析（SPEC92）：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-Cache/3CFailureAnalysis.png" alt="3CFailureAnalysis"></p>
<p><strong>解决方法：</strong></p>
<ol>
<li><p><strong>增加块大小降低失效率：</strong></p>
<ul>
<li>利用空间局部性：降低冷失效，增加冲突失效以及容量失效</li>
<li>SPEC92，DECstation 5000，小容量 Cache 块较小<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/BlockSizeToFailureRate.png" alt="BlockSizeToFailureRate"></li>
</ul>
</li>
<li><p><strong>增加 Cache 容量提高命中率：</strong></p>
<ul>
<li><strong>一级 Cache 访问直接决定时钟周期</strong><ul>
<li>尤其是在深亚微米的情况下，连线延迟很大</li>
<li>PIII 一级 Cache 为 16KB，PIV 一级 Cache 为 8KB；</li>
</ul>
</li>
<li><strong>增加片内 Cache 大小增加芯片面积</strong><ul>
<li>有的处理器片内 Cache 面积占整个芯片面积的 80% 以上</li>
<li>现代处理器二级或三级 Cache 大小已经达到几 MB 甚至几十 MB。</li>
</ul>
</li>
<li><strong>现代通用处理器的一级 Cache 大小</strong><ul>
<li>HP PA8700：一级 Cache 为 1MB+1.5MB，没有二级 Cache</li>
<li>其他 RISC 处理器（ Alpha, Power, MIPS, Ultra SPARC）32/64KB+32/64KB</li>
<li>PIV 12Kop Trace cache+8KB 数据 Cache（PIII: 16KB+16KB）</li>
<li>反映出设计人员的不同取舍</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>增加相联数目降低失效率：</strong></p>
<ul>
<li><strong>增加相联度：</strong><ul>
<li>2:1 规则：大小为 N 的直接相联的 Cache 命中率与大小为 N/2 的二路组相联的 Cache 命中率相当</li>
<li>八路组相联的效果已经与全相联的失效率相差很小（4 路以后再增加就不明显了)</li>
</ul>
</li>
<li><strong>增加相联度会增加时钟周期延迟以及硬件复杂性：</strong><br>   <img src="http://img.thebetterkong.cn/blog/CA-Cache/ConnectivityToDelay.png" alt="ConnectivityToDelay"><ul>
<li>例如，直接相连时钟周期为 1ns，2 路组相联为 1.36ns，4 路组相联为 1.44ns，8 路组相联为 1.52ns，失效延迟为 25 时钟周期</li>
<li>Cache 访问可能是整个处理器的关键路径</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>“路预测（Way Prediction）”和“伪相联”提高命中率：</strong></p>
<ul>
<li><mark>结合直接相联访问时间短和组相联命中率高的优点</mark></li>
<li><strong>做法：在多路相联的结构中，每次Cache访问只检查一路，如果不命中再检查其他路：</strong><ul>
<li>两种命中：hit 和 pseudohit</li>
<li>直接判断第 0 路，或进行 Way-Prediction：<ul>
<li>Alpha 21264 ICache 路猜测命中率 85%，hit 时间为 1 拍，pseudohit 时间 3 拍 ；</li>
<li>//1 位进行路预测，预测命中 1 拍，不命中再一起访问其余三路需要 3 拍。再不命中，发生 cache 失效；</li>
</ul>
</li>
<li>不用并行访问每一路，可以大幅度降低功耗</li>
<li>在片外或 L2 以下 cache 中用得较多，如 MIPS R10000、UltraSPARC 的 L2</li>
<li>//伪相联：⼆级cache在⽚外时可通过路预测，每次访问一路减少芯⽚引脚。<br> <img src="http://img.thebetterkong.cn/blog/CA-Cache/HitAndPseudohit.png" alt="HitAndPseudohit"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>软件优化降低失效率：</strong></p>
<ul>
<li><strong>常见软件优化技术：</strong><ol>
<li><strong>数组合并（Merging Arrays）：</strong><ul>
<li>通过数组合并降低数组 val 和 key 的冲突，增加空间局部性；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/MergingArrays.png" alt="MergingArrays"></li>
</ul>
</li>
<li><strong>循环交换（Loop Interchange） ：</strong><ul>
<li>通过循环交换提高空间局部性，把非连续访问变换成连续访问；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/LoopInterchange.png" alt="LoopInterchange"></li>
</ul>
</li>
<li><strong>循环合并（Loop Fusion） ：</strong><ul>
<li>通过循环合并提高空间局部性，数组 a&amp;c 的失效次数从2次降低到1次；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/LoopFusion.png" alt="LoopFusion"></li>
</ul>
</li>
<li><strong>数组分块（Array Blocking）：</strong><ul>
<li>分块前，y 和 z失效 N^3 次，x 失效 N^2 次，总失效次数从 2N^3 + N^2; </li>
<li>分块后，由于可以在 cache 中放下 BxB 的小矩阵，y 和 z 失效 1 次可以用 B 次，因此失效次数从 2N^3 + N^2 降为 2N^3/B +N^2;<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/ArrayBlocking.png" alt="ArrayBlocking"></li>
</ul>
</li>
</ol>
</li>
<li><strong>软件优化的效果:</strong><br>   <img src="http://img.thebetterkong.cn/blog/CA-Cache/EffectSoftwareOptimization.png" alt="EffectSoftwareOptimization"></li>
</ul>
</li>
</ol>
<h3 id="降低-MissPenalty"><a href="#降低-MissPenalty" class="headerlink" title="降低 MissPenalty"></a>降低 MissPenalty</h3><p><strong>通过关键字优先降低失效延迟：</strong></p>
<ul>
<li>在 Cache 访问失效时，优先访问读访问需要的字：<ul>
<li>例如，Cache 块大小为 64 字节，分为 8 个 8 字节的双字，如果取数指令访问其中的第6个双字引起 Cache 失效，就按 6、7、0、1、2、3、4、5 的次序，而不是按 0、1、2、3、4、5、6、7 的次序访问内存；</li>
<li>关键字优先的实现只需要对访问地址进行简单变换；</li>
<li>在失效的数据从内存取回之后，往 Cache 送的同时直接送回到寄存器也可以降低失效延迟；</li>
</ul>
</li>
</ul>
<p><strong>通过读优先降低失效延迟：</strong></p>
<ul>
<li>读 Cache 失效对指令流水线效率的影响比写失效大：<ul>
<li>在处理器中一般都有写缓存（Write Buffer），写指令只要把要写的数据写到写缓存就可以提交，再由写缓存写到 Cache 或内存；</li>
<li>取数在数据读回来回前取数指令不能提交，与取数指令存在数据相关的后续指令要等待取数操作读回来的数据才能执行，可见读 Cache 失效容易堵塞指令流水线；</li>
</ul>
</li>
<li>在进行 Cache 失效处理时，优先处理读失效以减小堵塞：<ul>
<li>读失效时要注意与 Write Buffer 的 RAW 相关，不能等写缓存为空，要动态检查写缓存；</li>
<li>读失效可能需要替换 dirty 块，不要把替换块写回到内存再读，可以把替换块写到写缓存，然后先读，后把写缓存的内容写回内存；</li>
</ul>
</li>
</ul>
<p><strong>通过写合并降低失效延迟：</strong></p>
<ol>
<li><strong>写缓存（Write Buffer）的作用：</strong><ul>
<li>处理器写到WB就算完成写操作，由WB写到下一级存储器</li>
<li>注意一致性问题：处理器后续的读操作、外设的DMA操作等</li>
</ul>
</li>
<li><strong>通过把写缓存中对同一 Cache 块的写操作进行合并来提高写缓存使用率，减少处理器等待</strong><ul>
<li>注意IO操作不能合并</li>
<li>Store Fill Buffer：连续的写操作拼满一个 Cache 块，写失效时不用到下一级存储器取数<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/WriteMerge.png" alt="WriteMerge"></li>
</ul>
</li>
</ol>
<p><strong>通过 Victim Cache 降低失效延迟：</strong></p>
<ul>
<li>在<strong>直接相联</strong>的 Cache 中避免冲突失效；</li>
<li>增加缓存（Victim Cache）保存从 Cache 中替换出来的数据；<ul>
<li>Jouppi [1990]：4 项 victim cache 可消除直接相联 4KB Cache 中 20%-95% 的冲突访问</li>
<li>在 Alpha, HP 等处理器中应用<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/VictimCache.png" alt="VictimCache"></li>
</ul>
</li>
</ul>
<p><strong>通过二/多级 Cache 降低失效延迟：</strong></p>
<ol>
<li><p><strong>通过L2降低失效延迟：</strong></p>
<ul>
<li>AMAT = Hit TimeL1 + Miss RateL1 x Miss PenaltyL1</li>
<li>Miss PenaltyL1 = Hit TimeL2 + Miss RateL2 x Miss PenaltyL2</li>
<li><strong>AMAT = Hit TimeL1 + Miss RateL1 x (Hit TimeL2 + Miss RateL2 x Miss PenaltyL2)</strong></li>
</ul>
</li>
<li><p><strong>L2 的失效率：</strong></p>
<ul>
<li><strong>局部失效率</strong>（Local miss rate）— L2失效次数除以L2访问次数<ul>
<li>Miss RateL2</li>
</ul>
</li>
<li><strong>全局失效率</strong>（Global miss rate） — L2失效次数除以所有访存次数<ul>
<li>$Miss Rate_{L1}∗Miss Rate_{L2} = {\frac{L2访存次数}{所有访存次数}}∗{\frac{L2失效次数}{L2访存次数}}$</li>
</ul>
</li>
<li>局部失效率较高（10%-20%），全局失效率很低（&lt;1%）；</li>
<li>一般，一级 cache 的内容是二级 cache 内容的真子集：<ol>
<li>若一级 cache 冲突，二级 cache 冲突概率也大，则二级 cache 组相联度常比一级 cache 高；</li>
<li>变换二级 cache 的索引（把二级 cache 索引和高位地址异或，降低二级 cache 冲突概率）；</li>
<li>二级 cache 容量大，且二级 cache 访问拍数不关键，因此访问二级 cache 的流水线级可能更长；</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="降低-HitTime"><a href="#降低-HitTime" class="headerlink" title="降低 HitTime"></a>降低 HitTime</h3><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/ReduceHittime.png" alt="ReduceHittime"></p>
<p><strong>简化 Cache 设计：</strong></p>
<ol>
<li>访问 Cache 常常是整个 CPU 的时钟关键路径：<ul>
<li>Cache越小，延迟越小</li>
<li>直接相联的 Cache 延迟小</li>
</ul>
</li>
<li>简化一级 Cache 设计需要统筹考虑：<ul>
<li>PIV 数据 Cache 从 PIII 的 16KB 降低为 8KB，而且只有定点可以访问，从而达到高主频</li>
<li>但 PIV 的二级 Cache 只有 6 拍的访问延迟</li>
</ul>
</li>
</ol>
<p><strong>并行访问 Cache 与 TLB：</strong></p>
<ol>
<li><strong>避免地址转换延迟：虚地址 Cache（最有效）</strong><ul>
<li>通过虚地址直接访问 Cache 减少虚实地址转换时间；</li>
<li><strong>模型：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-Cache/ParallelAccessCacheTLB.png" alt="ParallelAccessCacheTLB"></li>
<li><strong>问题：</strong><ul>
<li><strong>区分进程问题</strong>：不同进程的虚地址空间是一样的，需要在进程切换时候刷 Cache 以维护一致性，增加了冷失效</li>
<li><strong>别名（aliases）问题</strong>：操作系统有时候（如为了进程间共享）需要不同的虚地址对应同一物理地址</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚地址 Cache 中多进程对 Cache 命中率的影响：</strong><ul>
<li>进程切换问题可以通过在 TLB 中增加进程号的方式来解决：</li>
<li>单进程、多进程切换时刷 Cache、多进程用 ID 号来区分虚地址；</li>
<li>Y 轴表示 Cache 失效率；X 轴表示 Cache 大小（2 KB - 1024 KB）；<br><img src="http://img.thebetterkong.cn/blog/CA-Cache/CacheSizeFailureRate.png" alt="CacheSizeFailureRate"></li>
</ul>
</li>
<li><strong>虚 Index 实 Tag 技术：</strong><ul>
<li>在用 Index 从 cache 中读 Tag 的同时，进行虚实地址转换，可以使用物理地址做 tag；</li>
<li><strong>问题</strong>：如何保证虚实地址 Index 位的一致？<ul>
<li>增加页大小、增加相联度；（提高 Page Offset 位数 | 减少 Index 位数）</li>
<li>软件保证：<mark>页着色（Page coloring）</mark>；（现在软件支持不好）<br> <img src="http://img.thebetterkong.cn/blog/CA-Cache/PageColoring1.png" alt="PageColoring1"><ol>
<li>若：Page Offset &gt; Index+Block Offset，则：虚地址cache=物理地址cache；</li>
<li>若：Page Offset &lt; Index+Block Offset，则：虚地址 cache 中有可能存在同一块数据由于虚地址 cache 索引的不同，在 cache 中有多个备份的情况（cache 别名问题）</li>
</ol>
</li>
<li>具体详情：<br> <img src="http://img.thebetterkong.cn/blog/CA-Cache/PageColoring2.png" alt="PageColoring2"></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>增加 Cache 访问流水级：</strong></p>
<ul>
<li>Cache 访问时间是处理器主频的决定因素之一，其他因素包括加法及 bypass 时间等；</li>
<li>把 cache 访问分成多拍以提高主频：<ul>
<li>MIPS：1拍 </li>
<li>Alpha：2拍 </li>
<li>增加流水节拍增加了 load-use 延迟</li>
</ul>
</li>
</ul>
<h3 id="提高-Cache-访问并行性"><a href="#提高-Cache-访问并行性" class="headerlink" title="提高 Cache 访问并行性"></a>提高 Cache 访问并行性</h3><p><strong>多访存部件：</strong></p>
<ul>
<li>现代高性能处理器大都采用两个或更多访存部件：<ul>
<li>如 Intel 的 IvyBridge 有两个读部件、一个写部件</li>
<li>AMD 的 Bulldozer 有两个读/写部件</li>
</ul>
</li>
<li>多个访存部件提高了访存的吞吐率：<ul>
<li>降低了平均 Hittime</li>
</ul>
</li>
</ul>
<p><strong>非阻塞 Cache：</strong></p>
<ol>
<li><strong>机制：</strong><ul>
<li><strong>非阻塞（Non-blocking/Lockup-free）Cache 在访问失效时允许后续的访问继续进行：</strong><ul>
<li><mark>hit under miss、hit under multiple miss、miss under miss</mark></li>
<li>前面的失效访问不影响后续访问，需要支持多个outstanding访问，需要类似于保留栈的访存队列机制</li>
<li>在乱序执行的 CPU 中使用，显著增加 Cache 控制器复杂度</li>
</ul>
</li>
<li><strong>多个层次的非阻塞访问：</strong><ul>
<li>L1、L2、内存控制器</li>
<li>龙芯 2 号支持 24 个 L1 非阻塞访问，8 个 L2 非阻塞访问</li>
</ul>
</li>
</ul>
</li>
<li><strong>SPEC 程序的非阻塞访存效果：</strong><ul>
<li>8 KB 直接相联数据 Cache，块大小 32 字节，失效延迟 16 拍 ：<ul>
<li>浮点程序 AMAT= 0.68 -&gt; 0.52 -&gt; 0.34 -&gt; 0.26</li>
<li>定点程序 AMAT= 0.24 -&gt; 0.20 -&gt; 0.19 -&gt; 0.19</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>硬件预取：</strong></p>
<ol>
<li><strong>指令预取：</strong><ul>
<li>Alpha 21064 在 Cache 失效时取连续两块，多取的 Cache 块存放在流缓存（stream buffer）中，下一次 Cache 失效时先检查指令是否在流缓存中</li>
</ul>
</li>
<li><strong>数据预取：</strong><ul>
<li>Jouppi [1990]：对 4KB 的 Cache，1 项流缓存可以命中 25% 的 Cache 失效访问， 4 项流缓存可以命中 43% 的 Cache 失效访问</li>
<li>Palacharla &amp; Kessler [1994]：指令和数据 Cache 各为四路组相联的 64KB，对科学计算程序，8 项流缓存可以命中 50%-70% 的 Cache 失效访问</li>
</ul>
</li>
<li><strong>现代处理器都实现复杂预取技术：</strong><ul>
<li>预取对访存带宽提出了更高的要求</li>
</ul>
</li>
</ol>
<p><strong>软件预取：</strong></p>
<ol>
<li><strong>软件预取都是数据预取：</strong><ul>
<li>预取到寄存器: (HP PA-RISC loads)</li>
<li>预取到 Cache: (MIPS IV, PowerPC, SPARC v. 9)</li>
<li>预取指令不发生例外，预取到 Cache 的指令可以不等待数据返回</li>
</ul>
</li>
<li><strong>预取指令开销：占用指令槽：</strong><ul>
<li>多发射结构对预取指令占用指令槽不怎么敏感</li>
</ul>
</li>
<li><strong>龙芯 2 号对软件预取的支持：</strong><ul>
<li>目标寄存器为 0 号寄存器的取数指令不发生例外，不阻塞流水线</li>
</ul>
</li>
</ol>
<h2 id="Cache-优化小结"><a href="#Cache-优化小结" class="headerlink" title="Cache 优化小结"></a>Cache 优化小结</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Cache/CacheOptimizationSummary.png" alt="CacheOptimizationSummary"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：动态调度</title>
    <url>/2020/02/21/Computer-Architecture/CA-DynamicScheduling/</url>
    <content><![CDATA[<p>本节主要介绍一些动态调度技术，重点关注 Tomasulo 算法，以及动态流水线中的例外处理，要了解「乱序执行，顺序结束」的原则。</p>
<a id="more"></a> 
<h1 id="影响指令流水线的因素"><a href="#影响指令流水线的因素" class="headerlink" title="影响指令流水线的因素"></a>影响指令流水线的因素</h1><h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><ul>
<li><strong>运行时间 = 程序指令数 * CPI （每条指令时钟周期数）</strong></li>
<li><strong>Pipeline CPI=Ideal pipeline CPI + Structural stalls + RAW stalls + WAR stalls + WAW stalls + Control stalls</strong>   </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>技术</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>循环展开</td>
<td>Control stalls</td>
</tr>
<tr>
<td>编译相关性分析</td>
<td>Ideal CPI and data stalls</td>
</tr>
<tr>
<td>软件流水技术</td>
<td>Ideal CPI and data stalls</td>
</tr>
<tr>
<td>简单流水线</td>
<td>RAW stalls</td>
</tr>
<tr>
<td>记分板动态调度</td>
<td>RAW stalls</td>
</tr>
<tr>
<td>寄存器重命名</td>
<td>WAR and WAW</td>
</tr>
<tr>
<td>动态转移预测</td>
<td>Control stalls</td>
</tr>
<tr>
<td>多发射</td>
<td>Ideal CPI</td>
</tr>
<tr>
<td>猜测执行</td>
<td>All data and control stalls</td>
</tr>
<tr>
<td>非阻塞访存</td>
<td>RAW stall involving memory</td>
</tr>
</tbody>
</table>
</div>
<h2 id="程序的相关性"><a href="#程序的相关性" class="headerlink" title="程序的相关性"></a>程序的相关性</h2><p>程序的相关性容易引起流水线堵塞，可以通过软件和硬件的方法避免堵塞或降低堵塞的影响；</p>
<ul>
<li>编译调度：如循环展开</li>
<li>乱序执行：需要等待的指令不影响其他指令</li>
</ul>
<ol>
<li><p><strong>数据相关</strong>：（真相关）：导致 RAW</p>
<ul>
<li>定义：指令 j 数据相关于指令 i，指令 j 使用了指令i产生的结果；</li>
<li>传递性：指令 j 数据相关于指令 k，指令 k 数据相关于指令 i，则指令 j 数据相关于指令 i；</li>
<li>数据相关的指令不能并行执行；</li>
<li>寄存器的数据相关比较容易判断；存储器的数据相关不容易判断。</li>
<li>例子：  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>(<span class="built_in">R4</span>) = <span class="number">20</span>(<span class="built_in">R6</span>)?</span><br><span class="line">//对不同循环体，<span class="number">20</span>(<span class="built_in">R6</span>) = <span class="number">20</span>(<span class="built_in">R6</span>)?</span><br><span class="line"><span class="symbol">Loop:</span> LD F0, <span class="number">0</span>(<span class="built_in">R1</span>)</span><br><span class="line">ADDD F4,F0,F2</span><br><span class="line">SUBI <span class="built_in">R1</span>,<span class="built_in">R1</span>,<span class="number">8</span></span><br><span class="line">BNEZ <span class="built_in">R1</span>,<span class="keyword">Loop</span> //<span class="comment">;delayed branch</span></span><br><span class="line">SD <span class="number">8</span>(<span class="built_in">R1</span>),F4  //<span class="comment">;altered when move past SUBI</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>名字相关</strong>：会导致 WAW 和 WAR</p>
<ul>
<li>定义：两条指令使用相同名字（寄存器或存储器），但不交换数据；<ul>
<li>类型：<ul>
<li>逆相关（Antidependence）：指令 j 写指令 i 所读的存储单元且 i 先执行，逆相关会导致流水线 WAR 相关</li>
<li>输出相关（Output Dependence）：指令 j 与指令 i 写同一个单元且 i 先执行，输出相关会导致流水线 WAW 相关</li>
</ul>
</li>
<li>寄存器的名字相关可以通过寄存器重命名（Register Renaming）解决，存储单元的重命名比较困难；</li>
<li>例子：<ul>
<li><code>100(R4) = 20(R6)?</code></li>
<li>对不同循环体，<code>20(R6) = 20(R6)?</code></li>
<li>在前述例子中，编译器必须知道 <code>0(R1)!=-8(R1)!=-16(R1)!=-24(R1)</code></li>
</ul>
</li>
<li>RISC 技术极大地简化了指令之间的相关性；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>控制相关</strong>：条件转移</p>
</li>
</ol>
<h1 id="指令调度技术"><a href="#指令调度技术" class="headerlink" title="指令调度技术"></a>指令调度技术</h1><h2 id="编译器的静态调度"><a href="#编译器的静态调度" class="headerlink" title="编译器的静态调度"></a>编译器的静态调度</h2><ol>
<li>编译器分析程序中的相关性，并针对目标流水线进行代码优化，以避免程序执行时由于相关引起阻塞；</li>
<li>特点：<ul>
<li>相关不一定引起阻塞，只要隔开足够远；</li>
<li>在一个流水线上引起阻塞，在另一个流水线上不一定引起阻塞，所以编译优化与机器有关；</li>
</ul>
</li>
<li>循环展开技术：<ul>
<li>硬件流水：并行不同指令；</li>
<li>软件流水：并行循环体的不同的迭代；</li>
</ul>
</li>
<li>例子：向量的每个元素加常数<br> <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant.png" alt="VectorAddConstant"><ul>
<li><strong>初始</strong>时，每次循环需要 9 拍：<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant1.png" alt="VectorAddConstant1"></li>
<li><strong>改变指令次序</strong>每次循环需要 6 拍：（注意把 SD 放在 Delay Slot 中，偏移量的变化）<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant2.png" alt="VectorAddConstant2"></li>
<li><strong>循环展开</strong> 4 次：假设 R1 的值是 4 的倍数（注意把 SD 偏移量的变化）<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant3.png" alt="VectorAddConstant3"></li>
<li><strong>寄存器重命名</strong>：（每 4个 循环需要 $15 + 4 \times (1+2) = 27$ 拍，每个循环 6.8 拍）<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant4.png" alt="VectorAddConstant4"></li>
<li><strong>改变指令次序</strong>：<ul>
<li>注意把 SD 与 SUBI 交换次序时偏移量的变化；</li>
<li>注意 SD 与 LD 交换次序不会影响正确性；</li>
<li>每 4 个循环需要 14 拍，每个循环 3.5 拍；<br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant5.png" alt="VectorAddConstant5"></li>
</ul>
</li>
<li><strong>增加发射宽度</strong>：<ul>
<li>循环展开 5 次 ；</li>
<li>定点和浮点并行；</li>
<li>5 个循环需要 12 拍，每个循环 2.4 拍；<br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/VectorAddConstant6.png" alt="VectorAddConstant6"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="软件调度与硬件调度"><a href="#软件调度与硬件调度" class="headerlink" title="软件调度与硬件调度"></a>软件调度与硬件调度</h2><ol>
<li><p><strong>问题</strong>：既然软件可以在保持程序正确性的前提前改变指令的执行次序来提高性能，硬件能不能做到呢？</p>
<ul>
<li>可以做到，但要有特定的机制保证程序行为不被改变</li>
<li>关键是程序的数据和结构相关性得以保持</li>
</ul>
</li>
<li><p><strong>软件调度与硬件调度的比较</strong>：</p>
<ul>
<li>软件调度范围大，可在上万条指令的范围内进行调度；硬件一般只能在百条指令的范围内进行调度；</li>
<li>硬件调度可以掌握一些软件编译时还不明确的相关性信息，尤其是对访存相关以及控制相关；</li>
</ul>
</li>
</ol>
<h1 id="动态调度技术"><a href="#动态调度技术" class="headerlink" title="动态调度技术"></a>动态调度技术</h1><h2 id="静态流水线的问题"><a href="#静态流水线的问题" class="headerlink" title="静态流水线的问题"></a>静态流水线的问题</h2><ol>
<li><p>在译码阶段把指令“隔开”来解决相关:</p>
<ul>
<li>只要有一条指令停止，后面指令就不能前进，像是一种译码部件的结构相关</li>
</ul>
</li>
<li><p>对编译要求高，最好是编译把相关指令隔开：</p>
<ul>
<li>有些信息在译 1 码时难以确定，如是否发生例外、访存操作需要多少周期等；</li>
<li>例如：   <figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DIVD </span>f0,f2,f4</span><br><span class="line"><span class="keyword">ADDD </span>f10,f0,f8</span><br><span class="line"><span class="keyword">SUBD </span>f12,f8,f14</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="动态调度思想"><a href="#动态调度思想" class="headerlink" title="动态调度思想"></a>动态调度思想</h2><ol>
<li><p>基本思想：</p>
<ul>
<li>把相关的解决尽量往后拖延（<strong>Forward 技术？</strong>）</li>
<li>前面指令的等待不影响后面指令继续前进；</li>
</ul>
</li>
<li><p>把译码分成两个阶段：发射和读操作数：</p>
<ul>
<li>发射：指令译码，检查结构相关；</li>
<li>读操作数：如果操作数准备好就读数，否则等待（<strong>在哪儿等？</strong>） </li>
<li>当一条指令在读操作数阶段等待时，后面指令的发射可以继续进行；</li>
</ul>
</li>
<li><p>乱序执行的基本做法：</p>
<ul>
<li>指令进入是有序的</li>
<li>执行可以乱序，只要没有相关就可执行，多条指令同时执行</li>
<li>结束也是有序的（<strong>怎么把乱序变成有序？</strong>）</li>
</ul>
</li>
<li><p>与静态调度相比：</p>
<ul>
<li>有些相关编译无法检测、编译器更加简单、程序性能对机器依赖少  <figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DIVD </span>f0,f2,f4</span><br><span class="line"><span class="keyword">ADDD </span>f10,f0,f8</span><br><span class="line"><span class="keyword">SUBD </span>f8,f8,f14</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="解决-WAW-和-WAR-的办法"><a href="#解决-WAW-和-WAR-的办法" class="headerlink" title="解决 WAW 和 WAR 的办法"></a>解决 WAW 和 WAR 的办法</h2><p>例子：<br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/SolutionWAWWAR.png" alt="SolutionWAWWAR"></p>
<p>可能执行次序：（假设只考虑 RAW 相关）</p>
<ul>
<li>DIV发射，F1, F2都准备好</li>
<li>MUL1发射，F6没准备好，所以没有读数据</li>
<li>ADD发射， F3, F4都准备好</li>
<li>MUL2发射，F8没有准备好，所以没有读数据</li>
<li>ADD完成，F0写回</li>
<li>F6准备好，MUL1读数据</li>
<li>DIV完成，F0写回</li>
<li>F8准备好，MUL2读数据</li>
</ul>
<p>为了避免 MUL1 读回 ADD 写的 F0 值，MUL2 读回 DIV 写的 F0 值：</p>
<ul>
<li><p><strong>做法一：计分板方法</strong></p>
<ul>
<li><strong>方法</strong>：控制在 MUL 读 F0 之前 ADD 不能写回，在 DIV 写回之前 ADD 不能写回；</li>
<li><strong>问题本质</strong>：F0 成为瓶颈，它必须保证 DIV 写、MUL1 读、ADD 写、MUL2 读的串行次序；</li>
<li><strong>真正相关</strong>：MUL1 用 DIV 的结果，MUL2 用 ADD 的结果，F0 最终的结果为 ADD 的结果；</li>
<li>在写回寄存器前，forward 到下一条指令直接使用：MUL1 用 DIV 的结果、MUL2 用 ADD 结果不一定通过 F0；</li>
</ul>
</li>
<li><p><strong>做法二</strong>：</p>
<ul>
<li><strong>方法</strong>：在 MUL1 的输入端指定只接收 DIV 的输出值，在 MUL2 的输入端指定只接收 ADD 的输出值，相当于 DIV 直接把结果写到 MUL1 的输入端，ADD 直接把结果写到 MUL2 的输入端。（记得 Forward 技术吗？）</li>
<li><strong>要求</strong>：<ul>
<li>DIV 的输出连到 MUL1 的输入，ADD 的输出连接到 MUL2 的输入;</li>
<li>MUL1 和 MUL2 的输入端有寄存器，这些寄存器能够指定接收哪个部件的输出作为自己的值；</li>
</ul>
</li>
<li><strong>为了避免F0的最终值为DIV所写的值：</strong><ul>
<li>可以在 F0 记录它当前接收哪个功能部件所写的值；</li>
<li>要求 F0 有一个标志；</li>
</ul>
</li>
</ul>
</li>
<li><p>上述方法要求：</p>
<ul>
<li>每个功能部件的输入端有一些寄存器；</li>
<li>每个寄存器（包括功能部件输入端的寄存器以及通用寄存器）都记录一个功能部件号，指定它当前接收哪个功能部件的值；</li>
<li>每个功能部件的输出接到每个功能部件的输入；</li>
</ul>
</li>
<li><p><strong>有了上述功能，WAR 和 WAW 相关不用阻塞</strong>；</p>
</li>
<li><strong>寄存器重命名技术</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/RegisterRename.png" alt="RegisterRename"></li>
</ul>
<h1 id="Tomasulo-算法"><a href="#Tomasulo-算法" class="headerlink" title="Tomasulo 算法"></a>Tomasulo 算法</h1><p><mark><strong>通过寄存器重命名消除WAR和WAW相关</strong></mark></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ol>
<li><p>IBM 360/91中首次使用：</p>
<ul>
<li>1966 年，比CDC 6600 晚 3 年 </li>
<li>Robert Tomasulo 提出</li>
<li>设计目标：编译器在 360 系列中通用</li>
</ul>
</li>
<li><p>主要思想现代处理器中普遍使用：</p>
<ul>
<li>早期 Alpha 21264, HP 8000, MIPS 10000, Pentium II, PowerPC 604, …</li>
<li>现在 Intel、AMD、IBM 的几乎所有 CPU</li>
</ul>
</li>
</ol>
<h2 id="Tomasulo-算法结构"><a href="#Tomasulo-算法结构" class="headerlink" title="Tomasulo 算法结构"></a>Tomasulo 算法结构</h2><p><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/TomasuloStructure.png" alt="TomasuloStructure"></p>
<ol>
<li><p><strong>保留站内容</strong>：</p>
<ul>
<li>Busy: 忙位</li>
<li>Op：操作码</li>
<li>Vj, Vk: 源操作数的值</li>
<li>Qj, Qk: 保存没有准备好的源操作数保留站号（0 表示操作数已经准备好）</li>
</ul>
</li>
<li><p>寄存器增加一个域：</p>
<ul>
<li><strong>结果状态域</strong>：空表示寄存器值可用，否则保存产生寄存器结果的保留站号</li>
</ul>
</li>
<li><p><strong>结果总线</strong>：</p>
<ul>
<li>除了送回结果值外，还要送回产生该结果的保留站号</li>
</ul>
</li>
</ol>
<h2 id="Tomasulo-算法的流水阶段"><a href="#Tomasulo-算法的流水阶段" class="headerlink" title="Tomasulo 算法的流水阶段"></a>Tomasulo 算法的流水阶段</h2><ol>
<li><p><strong>发射</strong>：把操作队列的指令根据操作类型送到保留站（如果保留站有空），发射过程中读寄存器的值和结果状态域。</p>
</li>
<li><p><strong>执行</strong>：如果所需的操作数都准备好，则执行，否则侦听结果总线并接收结果总线的值。</p>
</li>
<li><p><strong>写回</strong>：把结果送到结果总线，释放保留站。</p>
</li>
</ol>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/TomasuloExample.png" alt="TomasuloExample"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>通过动态调度缓解流水线阻塞：</p>
<ul>
<li>例如：减少 CACHE 失效对性能的影响</li>
</ul>
</li>
<li><p>保留站：重命名寄存器 + 缓存源操作数</p>
<ul>
<li>避免寄存器成为瓶颈</li>
<li>避免 WAW 和 WAR 阻塞</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>硬件复杂性</li>
<li>结果总线成为瓶颈，多条结果总线增加硬件复杂度</li>
</ul>
</li>
<li><p>在IBM 360/91 后被广泛使用：</p>
<ul>
<li>动态调度、寄存器重命名等思想一直被使用：Pentium II; PowerPC 604; MIPS R10000; HP-PA 8000; Alpha 21264</li>
</ul>
</li>
</ol>
<h1 id="动态流水线的例外处理"><a href="#动态流水线的例外处理" class="headerlink" title="动态流水线的例外处理"></a>动态流水线的例外处理</h1><h2 id="例外（Exception）与流水线"><a href="#例外（Exception）与流水线" class="headerlink" title="例外（Exception）与流水线"></a>例外（Exception）与流水线</h2><div class="table-container">
<table>
<thead>
<tr>
<th>例外类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O 请求</td>
<td>外部中断</td>
</tr>
<tr>
<td>指令例外</td>
<td>用户请求中断：系统调用、断点、跟踪调试指令</td>
</tr>
<tr>
<td>运算部件</td>
<td>整数运算溢出、浮点异常</td>
</tr>
<tr>
<td>存储管理部件</td>
<td>访存地址不对齐、用户访问系统空间、TLB失效、缺页、存储保护错（写只读页）</td>
</tr>
<tr>
<td>保留指令错</td>
<td>未实现指令</td>
</tr>
<tr>
<td>硬件错</td>
<td></td>
</tr>
<tr>
<td>………</td>
</tr>
</tbody>
</table>
</div>
<h2 id="动态流水线的精确例外处理"><a href="#动态流水线的精确例外处理" class="headerlink" title="动态流水线的精确例外处理"></a>动态流水线的精确例外处理</h2><p><strong>精确例外的要求：</strong></p>
<ul>
<li>在处理例外时，发生例外指令前面的所有指令都执行完，例外指令后面的所有指令还未执行；</li>
</ul>
<p><strong>非精确例外的原因：</strong></p>
<ul>
<li>在乱序执行时，前面的指令发生例外时，后面的指令已经执行完并修改了寄存器或存储单元；<ul>
<li>（记分板和 Tomasulo 算法中都是非精确例外）</li>
</ul>
</li>
<li>只要保证后面指令修改机器状态时，前面的指令都已经不会发生例外即可；</li>
<li>例子：<pre><code class="lang-mips">  DIVF f0,f2,f4
  ADDF f10,f10,f8
  SUBF f12,f12,f14
</code></pre>
<ul>
<li>以上例子，没有任何相关，ADDF 和 SUBF 指令可以比 DIVF 先结束。如果在 ADDF 结束后 DIVF 发生例外，此时无法恢复例外现场；</li>
</ul>
</li>
</ul>
<h2 id="硬件支持动态流水线的精确例外处理"><a href="#硬件支持动态流水线的精确例外处理" class="headerlink" title="硬件支持动态流水线的精确例外处理"></a>硬件支持动态流水线的精确例外处理</h2><p><strong>实现精确例外处理的一个办法：</strong></p>
<ul>
<li>把后面指令对机器状态的修改延迟到前面指令都已经执行完：<ul>
<li>有些指令在 EX 阶段也修改机器状态，如运算指令修改结果状态</li>
<li>在执行阶段停止流水线会影响后面的指令执行</li>
</ul>
</li>
</ul>
<p><strong>具体做法：</strong></p>
<ul>
<li>可以用一些缓冲器来临时保存执行结果，当前面所有指令执行完后, 再把保存在缓冲器中的结果写回到寄存器或存储器：<ul>
<li>在流水线修改机器状态时（在执行或写回阶段）写到缓冲器</li>
<li>增加提交（Commit）阶段，把缓冲器的内容写回到寄存器或存储器</li>
<li>提交阶段只有前面指令都结束后才能进行</li>
<li><strong>有序提交：乱序执行，有序结束</strong></li>
<li>所用的缓冲器通常被称为 Reorder Buffer（ROB）</li>
</ul>
</li>
<li>猜测执行中也可用上述机制：都是在某些情况不确定的情况下先执行，但留有反悔的余地</li>
</ul>
<h2 id="指令重排序缓存-Reorder-Buffer-（ROB）"><a href="#指令重排序缓存-Reorder-Buffer-（ROB）" class="headerlink" title="指令重排序缓存 Reorder Buffer （ROB）"></a>指令重排序缓存 Reorder Buffer （ROB）</h2><ol>
<li><p><strong>ROB 内容</strong>：目标地址（存数地址或寄存器号）、 值、 操作类型</p>
</li>
<li><p>写回时写回到 ROB, 因此后面指令有可能从 ROB 读操作数；</p>
</li>
<li><p>使用 ROB 号作为重命名号（原来使用保留站号）， 一条指令的结果寄存器被重命名为其结果 ROB 号 ：</p>
<ul>
<li>保留站重命名源寄存器号</li>
<li>ROB 重命名结果寄存器号</li>
</ul>
</li>
<li><p>提交时把结果写回寄存器或存储器；</p>
</li>
<li><p>只要一条指令没有提交, 它就不会对寄存器或存储器的内容进行修改，在一条指令没有提交之前很容易取消该指令（由于前面指令发生了例外或由于猜测执行不正确）；</p>
</li>
<li><p>ROB 可以和 Write Buffer 合并；</p>
</li>
</ol>
<p><strong>增加Reorder Buffer的流水线：</strong></p>
<ul>
<li>「<strong>发射</strong>」：把操作队列的指令根据操作类型送到保留站（如果<u>保留站以及 ROB 有空</u>），并<u>在 ROB 中指定一项作为临时保存该指令结果</u>之用；发射过程中读寄存器的值和结果状态域，<u>如果结果状态域指出结果寄存器已被重命名到 ROB，则读 ROB</u>。</li>
<li>「<strong>执行</strong>」：如果所需的操作数都准备好，则执行，否则根据结果 ROB 号侦听结果总线并接收结果总线的值。</li>
<li>「<strong>写回</strong>」：把结果送到结果总线，释放保留站；<u>ROB 根据结果总线修改相应项</u>。</li>
<li>「<strong>提交</strong>」：<u>如果队列中第一条指令的结果已经写回且没有发生例外，把该指令的结果从 ROB 写回到寄存器或存储器，释放 ROB 的相应项。如果队列头的指令发生了例外或是猜测错误的转移指令，清除操作队列以及 ROB 等</u>。<br>  <img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/ROBStructure.png" alt="ROBStructure"></li>
</ul>
<p><strong>对比</strong>：没有 Reorder Buffer 的流水线<br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/CompareROB.png" alt="CompareROB"></p>
<p><strong>例子：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/ROBExample1.png" alt="ROBExample1"><br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/ROBExample2.png" alt="ROBExample2">    </p>
<h2 id="假设-ADD-发生了溢出例外"><a href="#假设-ADD-发生了溢出例外" class="headerlink" title="假设 ADD 发生了溢出例外"></a>假设 ADD 发生了溢出例外</h2><p><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/ADDxception1.png" alt="ADDxception1"><br><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/ADDxception2.png" alt="ADDxception2"></p>
<h2 id="龙芯-1-号把-ROB-和队列合并"><a href="#龙芯-1-号把-ROB-和队列合并" class="headerlink" title="龙芯 1 号把 ROB 和队列合并"></a>龙芯 1 号把 ROB 和队列合并</h2><p><img src="http://img.thebetterkong.cn/blog/CA-DynamicScheduling/Godson1ROB.png" alt="Godson1ROB"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>有序进入、乱序执行（允许超车）、有序结束</li>
<li>主要数据结构：<ul>
<li>保留站（发射队列）把有序变成乱序，<strong>临时存指令</strong></li>
<li>重命名寄存器用于保存未提交的临时结果，<strong>临时存数据</strong></li>
<li>ROB 把乱序重新变成有序</li>
</ul>
</li>
<li>乱序的能力和有关队列大小紧密相关</li>
<li>现代高性能 CPU 一般都有 100 条以上指令在流水线中乱序执行</li>
</ul>
<h1 id="补：Meltdown攻击的基本原理（幽灵、熔断漏洞）"><a href="#补：Meltdown攻击的基本原理（幽灵、熔断漏洞）" class="headerlink" title="补：Meltdown攻击的基本原理（幽灵、熔断漏洞）"></a>补：Meltdown攻击的基本原理（幽灵、熔断漏洞）</h1><ul>
<li>攻击者在<strong>用户态执行</strong>一条<strong>访问系统空间的load指令，发生例外</strong>，相关例外信息存在 ROB 中，访问数据 X（假设为一个字节）目标寄存器为 R1，重命名到 PR1，返回值存到 PR1，由于提交时会被取消。</li>
<li>攻击者<strong>读取 R1 并从 PR1 中读到内容 X</strong>，作为下标访问一个事先准备好的<strong>用户态数组 A，A 中被访问的的数据带到 Cache 中，其它数据仍在内存</strong>。</li>
<li>非法 load 指令成为 ROB 头指令，load 指令及其后续指令被取消，<strong>但 A[x] 内容已经在 Cache</strong>。</li>
<li>攻击者<strong>访问数组 A 的所有数据并判断其延迟，其中有一个数据在 Cache 中，延迟最短</strong>，假设数组 A 第 10号 元素访问延迟最短，则 X=10。<ul>
<li>侧信道攻击</li>
</ul>
</li>
<li>Meltdown 攻击确实由乱序执行引起，但很容易规避。<ul>
<li>Load 操作执行阶段发生例外时，在 ROB 中置例外，但不要把返回值写入寄存器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：功能部件</title>
    <url>/2020/02/21/Computer-Architecture/CA-FuUnit/</url>
    <content><![CDATA[<p>重点介绍加法器和乘法器的实现原理。</p>
<a id="more"></a> 
<h1 id="定点补码加法器设计"><a href="#定点补码加法器设计" class="headerlink" title="定点补码加法器设计"></a>定点补码加法器设计</h1><h2 id="先行进位加法器"><a href="#先行进位加法器" class="headerlink" title="先行进位加法器"></a>先行进位加法器</h2><h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><ol>
<li><p><strong>引脚</strong>：</p>
<ul>
<li>三个输入: A, B, Cin</li>
<li>两个输出: S, Cout</li>
</ul>
</li>
<li><p><strong>逻辑真值关系</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/LogicalTruthValue.png" alt="LogicalTruthValue"></p>
</li>
<li><strong>逻辑框图：</strong><br> <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/OneFullAddLogicDiagram.png" alt="OneFullAddLogicDiagram"><ul>
<li>需要 2,3 级门延迟：<ul>
<li>进位传递 2 级延迟；</li>
<li>产生结果 3 级延迟；</li>
</ul>
</li>
<li>两级与非相当于与或：$\overline{\overline{AB} \cdot \overline{CD}} = AB+CD$;</li>
</ul>
</li>
</ol>
<h3 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h3><p>以 16 位加法器为例：<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/16-bitSerialCarryAdder.png" alt="16-bitSerialCarryAdder">    </p>
<ul>
<li>进位从低位到高位传送, 形成 c16 需要 32 级门延迟；</li>
<li>延迟随位数增长线性增长；</li>
</ul>
<h3 id="并行进位逻辑"><a href="#并行进位逻辑" class="headerlink" title="并行进位逻辑"></a>并行进位逻辑</h3><h4 id="进位传递"><a href="#进位传递" class="headerlink" title="进位传递"></a>进位传递</h4><p><strong>推导</strong>：</p>
<ul>
<li>$ci+1 = ai \cdot bi+ai \cdot ci+bi \cdot ci = ai \cdot bi+(ai+bi) \cdot ci = gi+pi \cdot ci$<ul>
<li>$gi=ai \cdot bi$（进位生成因子）： 只要 gi 为 1, 就有进位；</li>
<li>$pi=ai+bi$（进位传递因子）：只要 pi 为 1, 就把低位进位向前传递；</li>
</ul>
</li>
</ul>
<p><strong>四位进位传递举例</strong>：<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ExampleFourCarry.png" alt="ExampleFourCarry"></p>
<p><strong>结论</strong>：只要低位有一个进位生成, 而且被传递, 则进位输出为1</p>
<h4 id="4-位并行进位加法器逻辑框图"><a href="#4-位并行进位加法器逻辑框图" class="headerlink" title="4 位并行进位加法器逻辑框图"></a>4 位并行进位加法器逻辑框图</h4><p><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/4-bitParallelCarryAdder.png" alt="4-bitParallelCarryAdder"></p>
<h4 id="改进：分块，块内并行（先行进位），块间串行"><a href="#改进：分块，块内并行（先行进位），块间串行" class="headerlink" title="改进：分块，块内并行（先行进位），块间串行"></a>改进：分块，块内并行（先行进位），块间串行</h4><p>以 16 位加法器为例：<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/16-bitAdvanceCarryAdder.png" alt="16-bitAdvanceCarryAdder"></p>
<ul>
<li>输入为 pi、gi，输出为 ci；</li>
<li>每次并行产生 4 位进位，从 pi、gi 产生 c16 只要 4 级传递，8 级门延迟（产生运算结果还需要一个异或）。</li>
<li>原来从 ai、bi 产生 c16 需要 16 级传递，32 级门延迟；</li>
</ul>
<h4 id="进一步改进：分块，块内并行，块间并行"><a href="#进一步改进：分块，块内并行，块间并行" class="headerlink" title="进一步改进：分块，块内并行，块间并行"></a>进一步改进：分块，块内并行，块间并行</h4><p>以 16 位加法器为例：  </p>
<ol>
<li><p><strong>进位推导</strong>：</p>
<ul>
<li>老办法：产生每块的进位传递因子和进位产生因子</li>
<li><strong>进位传递因子</strong>：每一位的传递因子都为 1 时才能传递<ul>
<li>$P = p0 \cdot p1 \cdot p2 \cdot p3$（本块可以传递低位进位）</li>
</ul>
</li>
<li><strong>进位产生因子</strong>：块内产生进位, 不考虑进位输入<ul>
<li>$G = g3+(p3 \cdot g2)+(p3 \cdot p2 \cdot g1)+(p3 \cdot p2 \cdot p1 \cdot g0)$（本块有进位生产）</li>
</ul>
</li>
<li><strong>进位</strong>：本块的进位；<ul>
<li>$c4 = g3+(p3 \cdot g2)+(p3 \cdot p2 \cdot g1)+(p3 \cdot p2 \cdot p1 \cdot g0)+(p3 \cdot p2 \cdot p1 \cdot p0 \cdot c0)= G +(P \cdot c0)$</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进位生成与传递逻辑</strong>：</p>
<ul>
<li>特别注意：大写 P,G 与小写 p，g，他们求法不同<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/16-bitParallelCarryGenerateLogic.png" alt="16-bitParallelCarryGenerateLogic">        </li>
</ul>
</li>
<li><p><strong>16 位块间并行加法器</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/16-bitInter-blockParallelAdder.png" alt="16-bitInter-blockParallelAdder"></p>
<ul>
<li><strong>逻辑步骤</strong>：（自下而上形成 pigi，自上而下形成 ci）<ul>
<li>下层的 4 个 4 位先行进位逻辑并行生成 4 个块间进位生成因子 G 和块间进位传递因子 P ；</li>
<li>上层的 4 位先行进位逻辑把下层进位逻辑生成的 P 和 G 作为本层 pi 和 gi 的输入并行生成块间的进位 c0，c4，c8，c12；</li>
<li>下层的 4 个 4 位先行进位逻辑分别把 c0，c4，c8，c12 作为本块的进位输入 c0，再结合本块的 p0-3 和 g0-3 分别计算出本块需要的每一位进位；</li>
</ul>
</li>
<li>优势在于能更快的生成第 i 位的 c，而不需要依赖于第 i-1 位的 c；</li>
<li>从 pi 和 gi 产生 c15-0 共需要 6（2 \cdot 3） 级门延迟：<ul>
<li>第一层 pg（计算每块的 p3 ,g3）</li>
<li>第二层 c（c4，c8，c12，c16）</li>
<li>第一层 c（每块的c3-0，即：c3-0，c7-4，c11-8，c15-12）//这里 c4，c8，c12，c16 为上一步计算得来，这里为了表述方便，说成是这一步产生；</li>
</ul>
</li>
<li>其中，最大与非门的扇入为 4；</li>
</ul>
</li>
</ol>
<p><strong>32/64 位加法器：</strong>（用的最多）<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/32-bitAdder.png" alt="32-bitAdder"></p>
<ul>
<li>共 10 级门延迟；</li>
</ul>
<h2 id="补码减法算法"><a href="#补码减法算法" class="headerlink" title="补码减法算法"></a>补码减法算法</h2><p><strong>原理：</strong></p>
<ul>
<li>$[A]_补 - [B]_补 = [A-B]_补 = [A]_补 + [-B]_补$ <ul>
<li>$[-B]_补$ 的计算：$[B]_补$ “取反加1”</li>
</ul>
</li>
<li>只要在 B 的输入端对 B 进行取反并置进位为 1；</li>
</ul>
<p><strong>加入减法的运算器逻辑框图：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/AddSubtractionOperator.png" alt="AddSubtractionOperator"></p>
<p><strong>溢出判断：</strong></p>
<ol>
<li><strong>加法</strong>：A和B的符号位相同, 但结果的符号位与A和B的符号位不同, 即正数相加得负或负数相加得正<ul>
<li>$ov=s31 \cdot a31 \cdot \overline{b31}+\overline{s31} \cdot a31 \cdot b31$   // s31：结果的最高位（结果符号位）</li>
</ul>
</li>
<li><strong>减法</strong>：正数减负数结果为负数或负数减正数结果为正数<ul>
<li>$ov=s31 \cdot \overline{a31} \cdot b31+\overline{s31} \cdot a31 \cdot \overline{b31}$</li>
</ul>
</li>
<li><strong>运算器溢出条件：</strong><ul>
<li>$ov=ADD \cdot (s31 \cdot \overline{a31} \cdot \overline{b31}+\overline{s31} \cdot a31 \cdot b31)+SUB \cdot (s31 \cdot \overline{a31} \cdot b31+\overline{s31} \cdot a31 \cdot \overline{b31})$</li>
</ul>
</li>
</ol>
<h1 id="定点-ALU-设计"><a href="#定点-ALU-设计" class="headerlink" title="定点 ALU 设计"></a>定点 ALU 设计</h1><h2 id="ALU-的实现"><a href="#ALU-的实现" class="headerlink" title="ALU 的实现"></a>ALU 的实现</h2><ul>
<li>ALU表示算术逻辑单元：<ul>
<li>实现加减法器</li>
<li>实现逻辑运算（a&amp;b, a|b, a xor b在加法器中产生）</li>
<li>实现比较器（相等、大小）</li>
<li>实现移位器</li>
</ul>
</li>
<li>最后，根据操作类型，从多个结果中选择；</li>
</ul>
<h2 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h2><ul>
<li>判断多 bit 的 A 信号和 B 信号是否相等：$A_{0-n} =? B_{0-n}$ ：<ul>
<li>使用异或逻辑逐 bit 的判断（A0^B0 , A1^B1 , … , An^Bn） </li>
</ul>
</li>
<li>每个 bit 结果，有任何一个为 1，则输出为 0 ：<ul>
<li>多输入或非门，位数多时需要多级逻辑<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/JudgeEqual.png" alt="JudgeEqual"></li>
</ul>
</li>
</ul>
<h2 id="判断大小"><a href="#判断大小" class="headerlink" title="判断大小"></a>判断大小</h2><ul>
<li>使用 A-B 来判断大小：A-B &gt; 0 （结果符号位为 0）则代表 A 大于 B</li>
<li>小心溢出：<ul>
<li>减法没有溢出时：结果符号位为 1，则 A &lt; B;</li>
<li>减法有溢出时：结果符号位为 0，则 A &lt; B；<ul>
<li>正-负=正，若结果为负，则溢出；</li>
<li>负-正=负，若结果为正，则溢出；</li>
</ul>
</li>
</ul>
</li>
<li>$Cond_{A&lt;B} =\overline{Ov}$ &amp; $s63$ | $Ov$ &amp; $\overline{s63}$ = $a63$ &amp; $s63$ | $\overline{b63}$ &amp; $s63$ | $a63$ &amp; $\overline{b63}$</li>
</ul>
<h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p><strong>移位操作</strong>：同时也是乘以/除以 2 的幂次的运算</p>
<ul>
<li>逻辑左移 （低位补 0） </li>
<li>逻辑右移 （高位补 0） </li>
<li>算数右移 （高位补符号位）</li>
<li>循环右移 （高位补右侧挤掉的数据）</li>
</ul>
<p><strong>硬件实现：</strong></p>
<ul>
<li>对于移 N 位数的移位操作，使用 N 选 1 来实现：<ul>
<li>根据要移动的位数，从 N 个输入中选一个</li>
<li>每个输入将输入移动特定位数，不需要延迟和逻辑</li>
</ul>
</li>
<li>每种移位结果再根据移位操作类型选择</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ShiftOperation.png" alt="ShiftOperation"></p>
<h1 id="补码乘法器设计"><a href="#补码乘法器设计" class="headerlink" title="补码乘法器设计"></a>补码乘法器设计</h1><h2 id="补码乘法原理"><a href="#补码乘法原理" class="headerlink" title="补码乘法原理"></a>补码乘法原理</h2><ol>
<li><p>$[X]_补+[Y]_补=[X+Y]_补$, 但 $[X]_补 \cdot [Y]_补 \neq [X \cdot Y]_补$；</p>
</li>
<li><p><strong>问题:</strong>已知 $[X]_补$ 和 $[Y]_补$, 求 $[X \cdot Y]_补$.<br> <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ComplementaryMultiplicationPrinciple.png" alt="ComplementaryMultiplicationPrinciple"></p>
<ul>
<li>红色位置，方括号外的加法为补码加法，需对加数进行符号位的扩充）</li>
<li>在推导中, $[X]_补$ 符号位扩充到 64 位；</li>
<li>其中：$[x∗2^k ]_补=[x]_补 ∗2^k$；<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/Prove.png" alt="Prove"></li>
</ul>
</li>
</ol>
<h2 id="补码乘法算法"><a href="#补码乘法算法" class="headerlink" title="补码乘法算法"></a>补码乘法算法</h2><h3 id="计算原则"><a href="#计算原则" class="headerlink" title="计算原则"></a>计算原则</h3><p>与普通乘法类似，只是符号位乘项要变加为减：</p>
<ul>
<li>$[X∗Y]! = [X]!∗(−y_{31}∗2^{31}+y_{30}∗2^{30}+…+y_1∗2^1+y_0∗2^0)$</li>
<li>$[X∗Y]!$ ：表示 $[X∗Y]$ 的补码；</li>
</ul>
<p>符号位的特殊性增加了电路复杂度：</p>
<ul>
<li>对 y 的最高位乘积项做减法，对其他乘积项做加法；</li>
<li>扩充符号位，对齐乘积项；<br>  <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ExampleAlignedProductTerm.png" alt="ExampleAlignedProductTerm"></li>
</ul>
<h3 id="Booth-算法"><a href="#Booth-算法" class="headerlink" title="Booth 算法"></a>Booth 算法</h3><p><strong>变换：</strong></p>
<ul>
<li>$(−y_{31}∗2^{31}+y_{30}∗2^{30}+…+y_1∗2^1+y_0∗2^0 )=(y_{30}−y_{31} )∗2^{31}+(y_{29}−y_{30})∗2^{30}+…+(y_0−y_1)∗2^1+(y_{−1}−y_0)∗2^0$</li>
</ul>
<p><strong>每一项都一样, 每次看两位：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/BoothAlgorithm.png" alt="BoothAlgorithm"></p>
<h3 id="Booth-二位一乘算法"><a href="#Booth-二位一乘算法" class="headerlink" title="Booth 二位一乘算法"></a>Booth 二位一乘算法</h3><p><strong>变换：</strong></p>
<ul>
<li>$(−y_{31}∗2^{31}+y_{30}∗2^{30}+…+y_1∗2^1+y_0∗2^0 )=(y_{29} +y_{30}−2∗y_{31} )∗2^{30}+(y_{27} +y_{28}−2∗y_{29} )∗2^{28}+…+(y_1 +y_2−2∗y_3 )∗2^2+(y_{−1}+y_0−2∗y_1 )∗2^0$</li>
<li>注意，只有偶数项：$2^0，2^2，…，2^{28}，2^{30}$</li>
</ul>
<p><strong>每一项都一样，每次看三位，只要 16 项相加：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ExampleBooth2-1MultiplicationAlgorithm.png" alt="ExampleBooth2-1MultiplicationAlgorithm"></p>
<p><strong>优势：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/AdvanceBooth2-1MultiplicationAlgorithm.png" alt="AdvanceBooth2-1MultiplicationAlgorithm"></p>
<ul>
<li>循环次数降低一倍</li>
<li>每次循环算法一样</li>
<li>$[X]_补$ 只有移 1 位和补码加减运算（两位一乘但不用乘 3）</li>
</ul>
<h3 id="Booth-算法的串行实现"><a href="#Booth-算法的串行实现" class="headerlink" title="Booth 算法的串行实现"></a>Booth 算法的串行实现</h3><p><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/BoothAlgorithmImplement.png" alt="BoothAlgorithmImplement"></p>
<ul>
<li>以二位一乘为例，32 位定点乘法需要把 16 个数相加；</li>
<li>可以用一个加法器加 15 次，需要 15 个时钟周期；</li>
</ul>
<h3 id="Booth-二位乘的输入选择逻辑"><a href="#Booth-二位乘的输入选择逻辑" class="headerlink" title="Booth 二位乘的输入选择逻辑"></a>Booth 二位乘的输入选择逻辑</h3><p><strong>其中 1 位：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/InputSelectionLogic-One.png" alt="InputSelectionLogic-One"><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/InputSelectionLogic-explain.png" alt="InputSelectionLogic-explain"></p>
<p><strong>一组所有位：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/InputSelectionLogic-All.png" alt="InputSelectionLogic-All"></p>
<h3 id="华莱士-Wallace-加法树"><a href="#华莱士-Wallace-加法树" class="headerlink" title="华莱士 Wallace 加法树"></a>华莱士 Wallace 加法树</h3><h4 id="来源问题"><a href="#来源问题" class="headerlink" title="来源问题"></a>来源问题</h4><ul>
<li>串行把 16 个数相加, 需要 15 次加法时间；</li>
<li>用 15 个加法器组织成树状, 需要 4 次加法时间, 又浪费硬件；</li>
</ul>
<h4 id="Wallace-树基本思想"><a href="#Wallace-树基本思想" class="headerlink" title="Wallace 树基本思想"></a>Wallace 树基本思想</h4><ul>
<li>n 个全加器每次把三个 n 位的数相加转换成两个数（n+1位）相加；</li>
<li>因此, n 个全加器每次可以把 m 个 n 位的数相加转换成 2m/3 个数相加, 再用一层全加器转换成 4m/9 个数相加, 直到转换成 2 个数; 再用加法器把最后两个数相加。</li>
</ul>
<h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><ol>
<li><strong>原理：</strong><ul>
<li>三个输入，两个输出；</li>
<li>进位输出在下一级相加时连到下一位；</li>
<li>两级门延迟；<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/FullAdderPrinciple.png" alt="FullAdderPrinciple"></li>
</ul>
</li>
<li><strong>全加器把三个加数变成两个加数：</strong><br> <img src="http://img.thebetterkong.cn/blog/CA-FuUnit/ExampleFullAdderPrinciple.png" alt="ExampleFullAdderPrinciple"></li>
</ol>
<h4 id="16-个数相加的-1-位加法树"><a href="#16-个数相加的-1-位加法树" class="headerlink" title="16 个数相加的 1 位加法树"></a>16 个数相加的 1 位加法树</h4><p>16个数的某一位：<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/1-bitAdditionTree.png" alt="1-bitAdditionTree"><br>全加器的进位生成部分连接到下一级时要连接到下一级的高位；</p>
<h4 id="16-个数相加的-4-位华莱士树"><a href="#16-个数相加的-4-位华莱士树" class="headerlink" title="16 个数相加的 4 位华莱士树"></a>16 个数相加的 4 位华莱士树</h4><p>左右进位相连：<br><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/4-bitAdditionTree.png" alt="4-bitAdditionTree"></p>
<h3 id="32-补码乘法器框图"><a href="#32-补码乘法器框图" class="headerlink" title="32 补码乘法器框图"></a>32 补码乘法器框图</h3><h4 id="逻辑框图"><a href="#逻辑框图" class="headerlink" title="逻辑框图"></a>逻辑框图</h4><p><img src="http://img.thebetterkong.cn/blog/CA-FuUnit/32-ComplementMultiplier.png" alt="32-ComplementMultiplier"></p>
<ul>
<li>“？” 标志是连接 16 个 “末位加1” 信号的地方；</li>
<li>“ 0 ” 部分是可能产生的 16 个 “末位加 1” 信号的地方；</li>
</ul>
<h4 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h4><p>采用 Booth 编码和 Wallace 树的乘法器经常需要累加 $[-X]_补$ 和 $[-2X]_补$。而 $[-X]_补$ 和 $[-2X]_补$ 涉及到取反加 1 的操作。这里是如何避免这些单独加 1 的？</p>
<ol>
<li>其中有 14 个连到华莱士树第 0 位加法树的进位输入；</li>
<li>剩下两个连到加法器的进位输入端以及其中一个输入端的最低位；</li>
</ol>
<ul>
<li>“其中一个输入端的最低位”：华莱士树形成的最后两个数据中有一个是通过华莱士树最后一级全加器的进位端形成的，需要左移一位与另外一个数相加，这里说的即是：左移后空出来一个最低位</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>32 位的 $[X]_补, [-X]_补,[2X]_补 ,[-2X]_补$ 如何扩展到 64 位？</p>
<ul>
<li>$[X]_补$: 左边符号位扩充, 右边补 0</li>
<li>$[-X]_补$: 对 $[X]_补$ 按位求反, 左边符号位扩充, 右边补 1, 末位加 1</li>
</ul>
<p>硬件优化：</p>
<ul>
<li>低位 “0” 不用加</li>
<li>高位符号位扩充位可以优化</li>
<li>请查阅相关资料；</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 写作指南</title>
    <url>/2020/04/04/Blog-Related/Markdown-Writing/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Markdown-Writing/Markdownl.png" width="100%" alt="header.png" /> </div>   

<p>在写作过程中，我们偶尔会忘了某个小知识点。在网上查阅相关资料，出现的文章良莠不齐，需要我们去筛选，查阅，不同的风格读起来也不那么顺心，会让我们在这些小事情上浪费时间。本文章的目标就是针对这种现象，打造一个最全的写作指南。从基础文案格式，到 Markdown 语法以及数学公式等等。并且会在以后的 Blog 的书写过程中，不断更新。</p>
<a id="more"></a> 
<h1 id="文案书写规范"><a href="#文案书写规范" class="headerlink" title="文案书写规范"></a>文案书写规范</h1><p><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">原文链接：中文文案排版</a>      </p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ol>
<li>中英文之间需要增加空格  </li>
<li>中文与数字之间需要增加空格</li>
<li>数字与单位之间需要增加空格</li>
<li>全角标点与其他字符之间不加空格</li>
</ol>
<h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>通俗的说，就是：</p>
<ul>
<li>全角：中文里的，和汉字一样占两个字节；</li>
<li>半角：英文里的，占一个字节，比全角小；</li>
<li>详见：『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全形和半形</a>』。</li>
</ul>
<ol>
<li>使用全角中文标点</li>
<li>数字使用半角字符</li>
<li>遇到完整的英文整句、特殊名词，其内容使用半角标点</li>
</ol>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ol>
<li>专有名词使用正确的大小写</li>
<li>不要使用不地道的缩写</li>
</ol>
<h2 id="Else（非官方）"><a href="#Else（非官方）" class="headerlink" title="Else（非官方）"></a>Else（非官方）</h2><p>这一块是原作者的一些日常规范，本人觉得很不错，也 copy 过来了，借用一下。</p>
<ol>
<li>链接之间增加空格</li>
<li>简体中文使用直角引号</li>
</ol>
<p><a id="test"></a></p>
<h1 id="Markdown-语法格式"><a href="#Markdown-语法格式" class="headerlink" title="Markdown 语法格式"></a>Markdown 语法格式</h1><p>对于，Markdown的一些基础语法格式等，可以参考：</p>
<ul>
<li>『<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown 教程</a>』</li>
<li>『<a href="https://juejin.im/post/5d345c5de51d454d1d6285e5#heading-10" target="_blank" rel="noopener">Markdown 写作指南</a>』    </li>
</ul>
<p>下面，是我在日常使用过程中，做的一些补充：</p>
<h2 id="GitHub-支持的表情符号"><a href="#GitHub-支持的表情符号" class="headerlink" title="GitHub 支持的表情符号"></a>GitHub 支持的表情符号</h2><ul>
<li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">GitHub 官方表情大全</a></li>
</ul>
<h2 id="实现按键效果"><a href="#实现按键效果" class="headerlink" title="实现按键效果"></a>实现按键效果</h2><ul>
<li>效果： <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</li>
<li>格式：<code>&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></li>
</ul>
<h2 id="区域高亮显示"><a href="#区域高亮显示" class="headerlink" title="区域高亮显示"></a>区域高亮显示</h2><ul>
<li>效果：<mark>I Love Markdown</mark></li>
<li>格式：<code>&lt;mark&gt;I Love Markdown&lt;/mark&gt;</code></li>
</ul>
<h2 id="表格单元格内换行"><a href="#表格单元格内换行" class="headerlink" title="表格单元格内换行"></a>表格单元格内换行</h2><ul>
<li>效果：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>姓名</th>
<th>爱好</th>
</tr>
</thead>
<tbody>
<tr>
<td>张三</td>
<td>足球<br>篮球</td>
</tr>
<tr>
<td>李四</td>
<td>羽毛球<br>乒乓球</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|姓名|爱好|</span><br><span class="line">|---|---|</span><br><span class="line">|张三|足球&lt;br&gt;篮球|</span><br><span class="line">|李四|羽毛球&lt;br&gt;乒乓球|</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="制作代办事项"><a href="#制作代办事项" class="headerlink" title="制作代办事项"></a>制作代办事项</h2><ul>
<li>效果：<ul>
<li>[ ] 未完成</li>
<li>[x] 已完成</li>
</ul>
</li>
<li>格式：<code>- [ ] 表示未完成，- [x] 表示已完成</code>，注意：键入字符与字符之间都要保留一个字符的空格。</li>
</ul>
<h2 id="文字加下划线"><a href="#文字加下划线" class="headerlink" title="文字加下划线"></a>文字加下划线</h2><ul>
<li>效果：<u>下划线</u></li>
<li>格式：<code>&lt;u&gt;下划线&lt;/u&gt;</code></li>
</ul>
<h2 id="定义锚点实现跳转"><a href="#定义锚点实现跳转" class="headerlink" title="定义锚点实现跳转"></a>定义锚点实现跳转</h2><ul>
<li>效果：<a href="#test">返回到前文</a></li>
<li>格式：<ul>
<li>需要跳转处：<code>&lt;a href=&quot;#mao&quot;&gt;返回到前文&lt;/a&gt;</code></li>
<li>跳转目标处：<code>&lt;a id=&quot;mao&quot;&gt;&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h2><ul>
<li><p>效果：</p>
<details>
  <summary><b>示例：Hello World 程序</b></summary> 

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
</li>
<li><p>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;&lt;b&gt;示例：Hello World 程序&lt;&#x2F;b&gt;&lt;&#x2F;summary&gt; </span><br><span class="line"></span><br><span class="line">  (自行替换为代码块的三点) java </span><br><span class="line">  public class Hello&#123;</span><br><span class="line">      public static void main(String[] args)&#123;</span><br><span class="line">          System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (自行替换为代码块的三点)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Markdown-Math"><a href="#Markdown-Math" class="headerlink" title="Markdown Math"></a>Markdown Math</h1><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ul>
<li><strong>行内公式</strong>：将公式插入到本行内，符号：<code>$公式内容$</code>，如：$xyz$</li>
<li><strong>独行公式</strong>：将公式插入到新的一行内并且居中，符号：<code>$$公式内容$$</code>，如：<script type="math/tex; mode=display">xyz</script></li>
</ul>
<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><ul>
<li><strong>上标符号</strong>，写法举例：<code>$x^4$</code>，显示：$x^4$</li>
<li><strong>下标符号</strong>，写法举例：<code>$x_1$</code>，显示：$x_1$</li>
<li><strong>组合符号</strong>，写法举例：<code>${abc}_{12}^{123}$</code>，显示：${abc}_{12}^{123}$</li>
</ul>
<h2 id="常用的格式控制"><a href="#常用的格式控制" class="headerlink" title="常用的格式控制"></a>常用的格式控制</h2><ul>
<li><strong>上划线符号</strong>，写法举例：<code>$\overline{x+y}$</code>，显示：$\overline{x+y}$</li>
<li><strong>下划线符号</strong>，写法举例：<code>$\underline{x+y}$</code>，显示：$\underline{x+y}$</li>
<li><strong>上大括号</strong>，写法举例：<code>$\overbrace{a+b+c+d}^{2.0}$</code>，显示：$\overbrace{a+b+c+d}^{2.0}$</li>
<li><strong>下大括号</strong>，写法举例：<code>$a+\underbrace{b+c}_{1.0}+d$</code>，显示：$a+\underbrace{b+c}_{1.0}+d$</li>
<li><strong>上位符号</strong>：<ul>
<li>符号：<code>\stacrel{上位符号}{基位符号}</code>，写法举例：<code>$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</code>，显示：<script type="math/tex">\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}</script></li>
<li>符号：{上位公式 \choose 下位公式}，写法举例：<code>${n+1 \choose k}={n \choose k}+{n \choose k-1}$</code>，显示：<script type="math/tex">{n+1 \choose k}={n \choose k}+{n \choose k-1}</script></li>
<li>符号：{上位公式 \atop 下位公式}，写法举例：<code>$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</code>，显示：<script type="math/tex">\sum_{k_0,k_1,\ldots>0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots</script></li>
</ul>
</li>
<li><strong>给公式编号</strong>：写法：<code>$$e^{i\theta}=cos\theta+\sin\theta i\tag{1}$$</code>，效果：<script type="math/tex; mode=display">e^{i\theta}=cos\theta+\sin\theta i\tag{1}</script></li>
</ul>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>主要用来微调距离，使得公式更加漂亮：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>写法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>紧贴</td>
<td><code>$a\!b$</code></td>
<td>$a!b$</td>
</tr>
<tr>
<td>没有空格</td>
<td><code>$ab$</code></td>
<td>$ab$</td>
</tr>
<tr>
<td>小空格</td>
<td><code>$a\,b$</code></td>
<td>$a\,b$</td>
</tr>
<tr>
<td>中等空格</td>
<td><code>$a\;b$</code></td>
<td>$a\;b$</td>
</tr>
<tr>
<td>大空格</td>
<td><code>$a\ b$</code></td>
<td>$a\ b$</td>
</tr>
<tr>
<td>quad 空格</td>
<td><code>$a\quad b$</code></td>
<td>$a\quad b$</td>
</tr>
<tr>
<td>两个 quad 空格</td>
<td><code>$a\qquad b$</code></td>
<td>$a\qquad b$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ul>
<li><strong>小括号</strong>，写法：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，效果：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li>
<li><strong>中括号</strong>，写法举例：<code>$[x+y]$</code>，如：$[x+y]$</li>
<li><strong>大括号</strong>，写法举例：<code>$\{x+y\}$</code>，如：$\{x+y\}$</li>
<li><strong>自适应括号</strong>，写法举例：<code>\left(x\right)</code> <code>\left(x{yz}\right)</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li>
</ul>
<h2 id="矩阵和多维数组"><a href="#矩阵和多维数组" class="headerlink" title="矩阵和多维数组"></a>矩阵和多维数组</h2><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>写法</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$\begin{matrix}1 &amp; 2\\\\3 &amp;4\end{matrix}$</code></td>
<td>$\begin{matrix}1 &amp; 2\\\\3 &amp;4\end{matrix}$</td>
</tr>
<tr>
<td><code>$\begin{pmatrix}1 &amp; 2\\\\3 &amp;4\end{pmatrix}$</code></td>
<td>$\begin{pmatrix}1 &amp; 2\\\\3 &amp;4\end{pmatrix}$</td>
</tr>
<tr>
<td><code>$\begin{bmatrix}1 &amp; 2\\\\3 &amp;4\end{bmatrix}$</code></td>
<td>$\begin{bmatrix}1 &amp; 2\\\\3 &amp;4\end{bmatrix}$</td>
</tr>
<tr>
<td><code>$\begin{Bmatrix}1 &amp; 2\\\\3 &amp;4\end{Bmatrix}$</code></td>
<td>$\begin{Bmatrix}1 &amp; 2\\\\3 &amp;4\end{Bmatrix}$</td>
</tr>
<tr>
<td><code>$\begin{vmatrix}1 &amp; 2\\\\3 &amp;4\end{vmatrix}$</code></td>
<td>$\begin{vmatrix}1 &amp; 2\\\\3 &amp;4\end{vmatrix}$</td>
</tr>
<tr>
<td><code>$\begin{Vmatrix}1 &amp; 2\\\\3 &amp;4\end{Vmatrix}$</code></td>
<td>$\begin{Vmatrix}1 &amp; 2\\\\3 &amp;4\end{Vmatrix}$</td>
</tr>
</tbody>
</table>
</div>
<p>还有一种写法：</p>
<ul>
<li><code>$\left|\begin{matrix}1 &amp; 2\\\\3 &amp;4\end{matrix}\right|$</code>，显示：$\left|\begin{matrix}1 &amp; 2\\\\3 &amp;4\end{matrix}\right|$</li>
</ul>
<p>类似于 left/right，这里是 begin/end；<br><strong>具体的矩阵语法，<code>&amp;</code> 区分行间元素，<code>\\\\</code> 代表换行；</strong>    </p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="数组排版"><a href="#数组排版" class="headerlink" title="数组排版"></a>数组排版</h4><p>效果：</p>
<script type="math/tex; mode=display">
\mathbf{X} =
\left( \begin{array}{ccc}
x\_{11} & x\_{12} & \ldots \\\\
x\_{21} & x\_{22} & \ldots \\\\
\vdots & \vdots & \ddots
\end{array} \right)</script><script type="math/tex; mode=display">
\left(\begin{array}{|c|c|}
1 & 2 \\\\
3 & 4
\end{array}\right)</script><script type="math/tex; mode=display">
\begin{array}{|c|c|}
\hline
{1111111111} & 2 \\\\
\hline
3 & 4 \\\\
\hline
\end{array}</script><p>写法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;X&#125; &#x3D;</span><br><span class="line">\left( \begin&#123;array&#125;&#123;ccc&#125;</span><br><span class="line">x\_&#123;11&#125; &amp; x\_&#123;12&#125; &amp; \ldots \\\\</span><br><span class="line">x\_&#123;21&#125; &amp; x\_&#123;22&#125; &amp; \ldots \\\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots</span><br><span class="line">\end&#123;array&#125; \right)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\left(\begin&#123;array&#125;&#123;|c|c|&#125;</span><br><span class="line">1 &amp; 2 \\\\</span><br><span class="line">3 &amp; 4</span><br><span class="line">\end&#123;array&#125;\right)</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;|c|c|&#125;</span><br><span class="line">\hline</span><br><span class="line">&#123;1111111111&#125; &amp; 2 \\\\</span><br><span class="line">\hline</span><br><span class="line">3 &amp; 4 \\\\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p>效果：</p>
<script type="math/tex; mode=display">
y=\begin{cases}
-x,\quad x\leq 0 \\\\
x,\quad x>0
\end{cases}</script><p>写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">y&#x3D;\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0 \\\\</span><br><span class="line">x,\quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h3><ul>
<li><strong>加法运算</strong>，符号：<code>+</code>，如：$x+y=z$</li>
<li><strong>减法运算</strong>，符号：<code>-</code>，如：$x-y=z$</li>
<li><strong>加减运算</strong>，符号：<code>\pm</code>，如：$x \pm y=z$</li>
<li><strong>减甲运算</strong>，符号：<code>\mp</code>，如：$x \mp y=z$</li>
<li><strong>乘法运算</strong>，符号：<code>\times</code>，如：$x \times y=z$</li>
<li><strong>点乘运算</strong>，符号：<code>\cdot</code>，如：$x \cdot y=z$</li>
<li><strong>星乘运算</strong>，符号：<code>\ast</code>，如：$x \ast y=z$</li>
<li><strong>除法运算</strong>，符号：<code>\div</code>，如：$x \div y=z$</li>
<li><strong>斜法运算</strong>，符号：<code>/</code>，如：$x/y=z$</li>
<li><strong>分式表示</strong>：<ul>
<li>符号：<code>\frac{分子}{分母}</code>，如：$\frac{x+y}{y+z}$</li>
<li>符号：<code>{分子} \voer {分母}</code>，如：${x+y} \over {y+z}$</li>
</ul>
</li>
<li><strong>绝对值表示</strong>，符号：<code>||</code>，如：$|x+y|$</li>
</ul>
<h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul>
<li><strong>平均数运算</strong>：<ul>
<li>符号：<code>\overline{算式}</code>，如：<code>$\overline{xyz}$</code>，显示：$\overline{xyz}$</li>
</ul>
</li>
<li><strong>开方运算</strong>：<ul>
<li>开二次方运算，符号：<code>\sqrt</code>，如：<code>$\sqrt x$</code>，显示：$\sqrt x$</li>
<li>高次方：<code>\sqrt[开方数]{被开方数}</code>，如：<code>$\sqrt[3]{x+y}$</code>，显示：$\sqrt[3]{x+y}$</li>
</ul>
</li>
<li><strong>取整运算</strong>：<ul>
<li>向上取整：<code>$\lceil n/2 \rceil$</code>，显示：$\lceil n/2 \rceil$</li>
<li>向下取整：<code>$\lfloor n/2 \rfloor$</code>，显示：$\lfloor n/2 \rfloor$</li>
</ul>
</li>
<li><strong>对数运算</strong>：<ul>
<li>符号：<code>\log</code>，如：<code>$\log_2(x)$</code>，显示：$\log_2(x)$</li>
<li>符号：<code>\lg</code>，如：<code>\$\lg(x)$</code>，显示：$\lg(x)$</li>
<li>符号：<code>\ln</code>，如：<code>$\ln(x)$</code>，显示：$\ln(x)$</li>
</ul>
</li>
<li><strong>极限运算</strong>：<ul>
<li>符号：<code>\lim</code>，如：<code>$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</code>，显示：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>加上风格控制：如：<code>$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</code>，显示：<script type="math/tex">\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</script></li>
</ul>
</li>
<li><strong>叠加运算</strong>：<ul>
<li>符号：<code>\sum</code>，如：<code>$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</code>，显示：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li>
<li>加上风格控制，符号：<code>\displaystyle \sum</code>，如：<code>$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</code>，显示：<script type="math/tex">\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</script></li>
</ul>
</li>
<li><strong>叠乘运算</strong>：<ul>
<li>符号：<code>\prod</code>，如：<code>$\prod_{i=0}^n \frac{1}{i^2}$</code>，显示：$\prod_{i=0}^n \frac{1}{i^2}$</li>
<li>加上风格控制，符号：<code>\displaystyle \prod</code>，如：<code>$\displaystyle \prod_{i=0}^n \frac{1}{i^2}$</code>，显示：<script type="math/tex">\displaystyle \prod_{i=0}^n \frac{1}{i^2}</script></li>
</ul>
</li>
<li><strong>积分运算</strong>：<ul>
<li>符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$，显示：$\int^{\infty}_{0}{xdx}$</li>
<li>加上风格控制，符号：<code>\displaystyle \int</code>，如：<code>$\displaystyle \int^{\infty}_{0}{xdx}$</code>，显示：<script type="math/tex">\displaystyle \int^{\infty}_{0}{xdx}</script></li>
<li>多重积分等：符号：<code>\int</code>，<code>\iint</code>，<code>\iiint</code>，<code>\oint</code>，显示：$\int$，$\iint$，$\iiint$，$\oint$</li>
</ul>
</li>
<li><strong>微分运算</strong>：<ul>
<li>符号：<code>\partial</code>，如：<code>$\frac{\partial x}{\partial y}$</code>，显示：$\frac{\partial x}{\partial y}$</li>
</ul>
</li>
</ul>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li><strong>等于运算</strong>，符号：<code>=</code>，如：$x+y=z$</li>
<li><strong>大于运算</strong>，符号：<code>&gt;</code>，如：$x+y&gt;z$</li>
<li><strong>小于运算</strong>，符号：<code>&lt;</code>，如：$x+y&lt;z$</li>
<li><strong>大于等于运算</strong>，符号：<code>\geq</code>，如：$x+y \geq z$</li>
<li><strong>小于等于运算</strong>，符号：<code>\leq</code>，如：$x+y \leq z$</li>
<li><strong>不等于运算</strong>，符号：<code>\neq</code>，如：$x+y \neq z$</li>
<li><strong>不大于等于运算</strong>，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li>
<li><strong>不大于等于运算</strong>，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li>
<li><strong>不小于等于运算</strong>，符号：<code>\nleq</code>，如：$x+y \nleq z$</li>
<li><strong>不小于等于运算</strong>，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li>
<li><strong>约等于运算</strong>，符号：<code>\approx</code>，如：$x+y \approx z$</li>
<li><strong>恒定等于运算</strong>，符号：<code>\equiv</code>，如：$x+y \equiv z$</li>
</ul>
<h3 id="逻辑条理"><a href="#逻辑条理" class="headerlink" title="逻辑条理"></a>逻辑条理</h3><ul>
<li><strong>因为</strong>，写法：<code>\because</code>，如：$\because$</li>
<li><strong>所以</strong>，写法：<code>\therefore</code>，如：$\therefore$</li>
<li><strong>任意</strong>，写法：<code>\forall</code>，如：$\forall$</li>
<li><strong>存在</strong>，写法：<code>\exists</code>，如：$\exists$</li>
</ul>
<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><ul>
<li><strong>属于运算</strong>，符号：<code>\in</code>，如：$x \in y$</li>
<li><strong>不属于运算</strong>，符号：<code>\notin</code>，如：$x \notin y$</li>
<li><strong>不属于运算</strong>，符号：<code>\not\in</code>，如：$x \not\in y$</li>
<li><strong>子集运算</strong>，符号：<code>\subset</code>，如：$x \subset y$</li>
<li><strong>子集运算</strong>，符号：<code>\supset</code>，如：$x \supset y$</li>
<li><strong>真子集运算</strong>，符号：<code>\subseteq</code>，如：$x \subseteq y$</li>
<li><strong>非真子集运算</strong>，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li>
<li><strong>真子集运算</strong>，符号：<code>\supseteq</code>，如：$x \supseteq y$</li>
<li><strong>非真子集运算</strong>，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li>
<li><strong>非子集运算</strong>，符号：<code>\not\subset</code>，如：$x \not\subset y$</li>
<li><strong>非子集运算</strong>，符号：<code>\not\supset</code>，如：$x \not\supset y$</li>
<li><strong>并集运算</strong>，符号：<code>\cup</code>，如：$x \cup y$</li>
<li><strong>交集运算</strong>，符号：<code>\cap</code>，如：$x \cap y$</li>
<li><strong>差集运算</strong>，符号：<code>\setminus</code>，如：$x \setminus y$</li>
<li><strong>同或运算</strong>，符号：<code>\bigodot</code>，如：$x \bigodot y$</li>
<li><strong>同与运算</strong>，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li>
<li><strong>实数集合</strong>，符号：<code>\mathbb{R}</code>，如：$\mathbb{R}$</li>
<li><strong>自然数集合</strong>，符号：<code>\mathbb{Z}</code>，如：$\mathbb{Z}$</li>
<li><strong>空集</strong>，符号：<code>\emptyset</code>，如：$\emptyset$</li>
</ul>
<h3 id="三角运算"><a href="#三角运算" class="headerlink" title="三角运算"></a>三角运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>写法</th>
<th>符号</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\bot$</td>
<td><code>\bot</code></td>
<td>$\angle$</td>
<td><code>\angle</code></td>
</tr>
<tr>
<td>$30^\circ$</td>
<td><code>30^\circ</code></td>
<td>$\sin$</td>
<td><code>\sin</code></td>
</tr>
<tr>
<td>$\cos$</td>
<td><code>\cos</code></td>
<td>$\tan$</td>
<td><code>\tan</code></td>
</tr>
<tr>
<td>$\cot$</td>
<td><code>\cot</code></td>
<td>$\sec$</td>
<td><code>\sec</code></td>
</tr>
<tr>
<td>$\csc$</td>
<td><code>\csc</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>写法</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>无穷</td>
<td>符号：\infty，</td>
<td>如：$\infty$</td>
</tr>
<tr>
<td>虚数</td>
<td>符号：\imath，</td>
<td>如：$\imath$</td>
</tr>
<tr>
<td>虚数</td>
<td>符号：\jmath，</td>
<td>如：$\jmath$</td>
</tr>
<tr>
<td>矢量符号</td>
<td>符号：\vec{a}，</td>
<td>如：$\vec{a}$</td>
</tr>
<tr>
<td>一阶导数符号</td>
<td>符号：\dot{a}，</td>
<td>如：$\dot{a}$</td>
</tr>
<tr>
<td>二阶导数符号</td>
<td>符号：\ddot{a}，</td>
<td>如：$\ddot{a}$</td>
</tr>
<tr>
<td>上箭头</td>
<td>符号：\uparrow，</td>
<td>如：$\uparrow$</td>
</tr>
<tr>
<td>上箭头</td>
<td>符号：\Uparrow，</td>
<td>如：$\Uparrow$</td>
</tr>
<tr>
<td>下箭头</td>
<td>符号：\downarrow，</td>
<td>如：$\downarrow$</td>
</tr>
<tr>
<td>下箭头</td>
<td>符号：\Downarrow，</td>
<td>如：$\Downarrow$</td>
</tr>
<tr>
<td>左箭头</td>
<td>符号：\leftarrow，</td>
<td>如：$\leftarrow$</td>
</tr>
<tr>
<td>左箭头</td>
<td>符号：\Leftarrow，</td>
<td>如：$\Leftarrow$</td>
</tr>
<tr>
<td>右箭头</td>
<td>符号：\rightarrow，</td>
<td>如：$\rightarrow$</td>
</tr>
<tr>
<td>右箭头</td>
<td>符号：\Rightarrow，</td>
<td>如：$\Rightarrow$</td>
</tr>
<tr>
<td>底端对齐的省略号</td>
<td>符号：\ldots，</td>
<td>如：$1,2,\ldots,n$</td>
</tr>
<tr>
<td>中线对齐的省略号</td>
<td>符号：\cdots，</td>
<td>如：$x_1^2 + x_2^2 + \cdots + x_n^2$</td>
</tr>
<tr>
<td>竖直对齐的省略号</td>
<td>符号：\vdots，</td>
<td>如：$\vdots$</td>
</tr>
<tr>
<td>斜对齐的省略号</td>
<td>符号：\ddots，</td>
<td>如：$\ddots$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\hat{a}，</td>
<td>如：$\hat{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\check{a}，</td>
<td>如：$\check{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\breve{a}，</td>
<td>如：$\breve{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\tilde{a}，</td>
<td>如：$\tilde{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\bar{a}，</td>
<td>如：$\bar{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\acute{a}，</td>
<td>如：$\acute{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\grave{a}，</td>
<td>如：$\grave{a}$</td>
</tr>
<tr>
<td>数学符号</td>
<td>符号：\mathring{a}，</td>
<td>如：$\mathring{a}$</td>
</tr>
</tbody>
</table>
</div>
<p>注意：有些符号一定要加$$才可以显示效果</p>
<h2 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\epsilon$</td>
<td><code>\epsilon</code></td>
<td>$\alpha$</td>
<td><code>\alpha</code></td>
<td>$\beta$</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>$\zeta$</td>
<td><code>\zeta</code></td>
<td>$\Gamma$</td>
<td><code>\Gamma</code></td>
<td>$\gamma$</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>$\eta$</td>
<td><code>\eta</code></td>
<td>$\Delta$</td>
<td><code>\Delta</code></td>
<td>$\delta$</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>$\iota$</td>
<td><code>\iota</code></td>
<td>$\Theta$</td>
<td><code>\Theta</code></td>
<td>$\theta$</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>$\kappa$</td>
<td><code>\kappa</code></td>
<td>$\Lambda$</td>
<td><code>\Lambda</code></td>
<td>$\lambda$</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>$\omicron$</td>
<td><code>\omicron</code></td>
<td>$\mu$</td>
<td><code>\mu</code></td>
<td>$\nu$</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>$\rho$</td>
<td><code>\rho</code></td>
<td>$\Xi$</td>
<td><code>\Xi</code></td>
<td>$\xi$</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>$\tau$</td>
<td><code>\tau</code></td>
<td>$\Pi$</td>
<td><code>\Pi</code></td>
<td>$\pi$</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>$\chi$</td>
<td><code>\chi</code></td>
<td>$\Sigma$</td>
<td><code>\Sigma</code></td>
<td>$\sigma$</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>$\omega$</td>
<td><code>\omega</code></td>
<td>$\Upsilon$</td>
<td><code>\Upsilon</code></td>
<td>$\upsilon$</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>$\Omega$</td>
<td><code>\Omega</code></td>
<td>$\Psi$</td>
<td><code>\Psi</code></td>
<td>$\psi$</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>$\nabla$</td>
<td><code>\nabla</code></td>
<td>$\Phi$</td>
<td><code>\Phi</code></td>
<td>$\Phi$</td>
<td><code>\Phi</code></td>
</tr>
</tbody>
</table>
</div>
<p>更多详情，参考：『<a href="https://github.com/mk43/BlogResource/blob/master/LaTex/LATEX%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8.pdf" target="_blank" rel="noopener">PDF</a>』</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">Markdown数学公式语法</a></li>
<li><a href="https://blog.csdn.net/qq_32126633/article/details/85268708?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1" target="_blank" rel="noopener">markdown使用数学符号/特殊符号</a></li>
<li><a href="https://juejin.im/post/5a6721bd518825733201c4a2#heading-12" target="_blank" rel="noopener">MarkDown 插入数学公式实验大集合</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog 相关</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：指令系统结构ISA</title>
    <url>/2020/02/21/Computer-Architecture/CA-ISA/</url>
    <content><![CDATA[<p>介绍指令系统与计算机体系结构的关系，它的发展历程、基本组成，以及分析对比：MIPS、SPARC、RISC、Power 。</p>
<a id="more"></a> 
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>指令系统是计算机功能的抽象模型（不仅仅是关于指令功能的编码）；</p>
<ul>
<li>是软硬件的界面，所有软件最终都以指令的形式运行；</li>
<li>体现了结构设计者对应用的深刻理解；</li>
<li>一个指令系统可以有多种实现（低功耗、高性能、软件模拟…）；</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>（承上启下）是软硬件的交互接口；</p>
<ul>
<li>软件：<ul>
<li>上层：应用软件</li>
<li>基础：操作系统、编译器、虚拟机</li>
</ul>
</li>
<li>硬件：<ul>
<li>逻辑：微体系结构</li>
<li>物理：电路与器件</li>
</ul>
</li>
</ul>
<h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p>计算机产业的枢纽，产业生态的基础；</p>
<ol>
<li>指令系统是计算机软硬件的重要标准；<ul>
<li>决定应用程序的二进制兼容（Wintel和AA都做到）；</li>
<li>是操作系统二进制兼容（Wintel做到、AA没做到）的重要因素；</li>
</ul>
</li>
<li>指令系统影响系统性能和实现复杂性等:<ul>
<li>如 RISC/CISC，32 位 /64 位，媒体指令，向量指令等；</li>
<li>微结构对系统复杂性影响更大；</li>
</ul>
</li>
</ol>
<h2 id="国际主流指令系统"><a href="#国际主流指令系统" class="headerlink" title="国际主流指令系统"></a>国际主流指令系统</h2><p>三大主流指令系统：</p>
<ul>
<li>「X86」：每年几亿片，垄断PC和服务器市场，虽受到 ARM 的一些威胁，但桌面的垄断地位难以动摇，并通过凌动阻止 ARM 向高端渗透；</li>
<li>「ARM」：每年 50-100 亿片，在手持终端市场处于垄断地位，成功侵蚀 MIPS 的数字电视、机顶盒等市场，试图在云服务器等领域与 X86 竞争；</li>
<li>「MIPS」：每年 5-10 亿片，在传统市场如打印机、网络等仍有一定势力；</li>
</ul>
<p>其他指令系统：</p>
<ul>
<li>PowerPC：在汽车电子、工控、服务器领域还有一线生机</li>
<li>Alpha、PA-RISC、Sparc、IA64主流市场机会不大</li>
<li><strong>RISC-V（开源指令集）</strong>：想成为 CPU 中的 Linux，道阻且长，巨头联手逼向低端 MCU；</li>
</ul>
<h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol>
<li><p>历史发展历程：</p>
<ul>
<li>X86位宽从 8 位、16 位、32 位、64 位不断发展；</li>
<li>功能从只支持定点、到浮点、到媒体指令、到向量指令；</li>
<li>向量指令又经历了 MMX、SSE、SSE2、SSE3、SSE4、AVX 等；</li>
</ul>
</li>
<li><p>对指令发展新的要求：</p>
<ul>
<li>多核结构要求指令增加对多核同步、通信和数据一致性的支持</li>
<li>向量部件需要指令系统增加专门的向量指令</li>
<li>媒体类应用要求指令系统增加对媒体编解码的专门支持</li>
<li>云计算要求指令系统增加对虚拟机的支持；等等</li>
</ul>
</li>
</ol>
<h2 id="自主软硬件需求自主指令系统"><a href="#自主软硬件需求自主指令系统" class="headerlink" title="自主软硬件需求自主指令系统"></a>自主软硬件需求自主指令系统</h2><p>现状：</p>
<ol>
<li>国外垄断企业设置了严密的知识产权壁垒，主要体现在包括指令系统在内的各类接口中；</li>
<li>目前 IT 产业正从单极化向多极化发展，要抓住机遇。目前自主软硬件推进效果明显，但我国软硬件力量过于薄弱，通过统一的自主指令系统可以迅速形成合力；</li>
</ol>
<p>自主指令系统发展的可行路径：</p>
<ol>
<li>先兼容后自主<ul>
<li>与国外指令兼容（MIPS、RISC等），在此基础上自主发展</li>
<li>“可控”权：自主扩展和自主再授权</li>
<li>“对等”权：协商扩展和反向授权</li>
</ul>
</li>
<li>先自主后兼容<ul>
<li>通过二进制翻译方式，运行主流指令系统的软件</li>
<li>如 Transmeta，IA64上运行IA32程序等</li>
<li>Intel 推出的基于 X86 的智能手机能运行 Android 上 ARM 的应用</li>
</ul>
</li>
<li>二者结合<ul>
<li>如基于 MIPS/RISC5，并通过扩展实现对 X86 和 ARM 的兼容</li>
</ul>
</li>
</ol>
<p>基本指令：</p>
<ul>
<li>包含：媒体指令、向量指令、…、多核同步指令、虚拟指令等</li>
</ul>
<h1 id="指令系统的设计"><a href="#指令系统的设计" class="headerlink" title="指令系统的设计"></a>指令系统的设计</h1><h2 id="指令系统在计算机中的位置"><a href="#指令系统在计算机中的位置" class="headerlink" title="指令系统在计算机中的位置"></a>指令系统在计算机中的位置</h2><ol>
<li>软硬件的界面；</li>
<li>反映了结构设计者对计算机系统的认识；</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li><strong>兼容性</strong>：对软件的包容性，长时间保持不变，如：X86</li>
<li><strong>通用性</strong>：对软件的易用性，编译器和程序员觉得好用</li>
<li><strong>高效性</strong>：对硬件的易用性，便于 CPU 设计优化和不同性能的实现</li>
<li><strong>安全性</strong>：对软硬件安全的支持，支持通用操作系统，考虑不同的安全要求</li>
</ul>
<h2 id="影响指令系统设计的因素"><a href="#影响指令系统设计的因素" class="headerlink" title="影响指令系统设计的因素"></a>影响指令系统设计的因素</h2><ol>
<li>工艺技术<ul>
<li>早期的硬件昂贵，指令系统设计主要考虑如何减少硬件；</li>
<li>集成度的提高（TLB、从 32 位到 64 位、SIMD 媒体运算）；</li>
<li>现在如何发挥存储层次的效率，如何利用芯片面积；</li>
<li>CPU 与存储器的速度差距，指令系统应能较好地利用存储层次，如通过并行或流水容忍延迟（Cache 管理指令、预取指令）</li>
<li>工艺进一步发展，主频极限和功耗问题引起的多核结构需要特殊指令支持（多线程管理和同步）</li>
</ul>
</li>
<li>系统结构<ul>
<li>指令系统本身是系统结构发展的结果；<ul>
<li>如：从 16 位、到 32 位、到 64 位；</li>
<li>SIMD 指令、从单核到多核等；</li>
</ul>
</li>
<li>指令系统的兼容性要求与系统结构发展的矛盾关系：<ul>
<li>尽量不改变指令系统的前提下提高性能，如流水、多发射等</li>
<li>尽量保持兼容，如 Intel 的做法</li>
</ul>
</li>
<li>增加指令功能还是提高主频？（RISC vs. CISC vs. VLIW）</li>
<li>并行性： SIMD、向量、多发射（兼容性好）</li>
</ul>
</li>
<li>操作系统<ul>
<li>操作系统专用的<strong>核心态指令</strong>和<strong>运行环境</strong>；</li>
<li>多进程支持、虚空间：（页表与 TLB 的关系；页保护：读写权限）</li>
<li>系统安全等级：（核心态和用户态管理）</li>
<li>异常和中断处理（异常处理入口、ERET 指令等）</li>
<li>访存和访问 I/O 的区别；</li>
<li>虚拟机：（支持多操作系统的快速切换）</li>
</ul>
</li>
<li><p>编译技术与程序设计语言</p>
<ul>
<li>指令是编译器的工作结果<ul>
<li>早期的指令系统主要考虑如何便于编程</li>
<li>后期（如RISC）兼顾便于编程和实现效率</li>
</ul>
</li>
<li>指令功能<ul>
<li>只有简单指令，甚至乘法都由加法和移位来实现</li>
<li>具有复杂指令，如除法、开方</li>
<li>更复杂的函数由库函数实现（如C库）</li>
</ul>
</li>
<li>寄存器和存储器分配<ul>
<li>堆栈存放局部变量，全局数据区存放静态数据，堆存放动态数据</li>
<li>为有效使用图着色启发式算法，至少需要 16 个通用寄存器</li>
</ul>
</li>
<li>简单规整，提高编译效率<ul>
<li>正交性，如所有访存指令都可用所有寻址方式</li>
<li>简化编译器取舍，如：允许编译时确定常量，只提供基本的通用操作等</li>
</ul>
</li>
</ul>
</li>
<li><p>应用程序</p>
<ul>
<li>应用适应性（指令归根结底为应用设计）；</li>
<li>兼容性：更新计算机时，兼容老的应用；</li>
</ul>
</li>
</ol>
<h1 id="指令系统的演变"><a href="#指令系统的演变" class="headerlink" title="指令系统的演变"></a>指令系统的演变</h1><h2 id="指令系统分类"><a href="#指令系统分类" class="headerlink" title="指令系统分类"></a>指令系统分类</h2><ul>
<li>RISC 技术有利于指令流水线的高效实现（X86 处理器内部也把 CISC 翻译成简单操作来优化流水线）；</li>
<li>VLIW 技术用于指令流水线优化不是很成功</li>
</ul>
<h3 id="复杂指令系统（CISC）"><a href="#复杂指令系统（CISC）" class="headerlink" title="复杂指令系统（CISC）"></a>复杂指令系统（CISC）</h3><ul>
<li>其指令长度可变（x86: 1~15字节）<br>  <img src="http://img.thebetterkong.cn/blog/CA-ISA/CISC.png" alt="CISC"></li>
</ul>
<ol>
<li>早期的 CPU 都采用 CISC 结构：昂贵的软硬件系统要求兼容性，计算机应用的发展要求新增指令；</li>
<li>像 Intel，曾经的辉煌也导致历史包袱（需要对过去指令可能已经淘汰不用的指令提供兼容性）太重，指令集的臃肿导致实现复杂，降低了常用指令的执行效率</li>
<li>程序中 80% 的指令只占指令集的 20%，人们开始意识到：简单指令有利于高效实现，例如：X86 指令通过内部译码后的微操作类似于 RISC</li>
</ol>
<h3 id="精简指令系统（RISC）"><a href="#精简指令系统（RISC）" class="headerlink" title="精简指令系统（RISC）"></a>精简指令系统（RISC）</h3><ul>
<li>求掉包袱，轻装上阵：其指令长度比较固定<br>  <img src="http://img.thebetterkong.cn/blog/CA-ISA/RISC.png" alt="RISC"></li>
<li>核心思想：简化<ul>
<li>简化指令功能：执行时间短</li>
<li>简化指令编码：译码简单</li>
<li>简化访存类型：访存和运算分开</li>
</ul>
</li>
<li>运用：Power、MIPS、ARM、SPARC、Alpha……</li>
<li>现代指令系统对 CISC 和 RISC 的融合：<ul>
<li>核心流水线采用 RISC</li>
<li>包含复杂功能的宏指令</li>
</ul>
</li>
</ul>
<h3 id="超长指令字（VLIW）"><a href="#超长指令字（VLIW）" class="headerlink" title="超长指令字（VLIW）"></a>超长指令字（VLIW）</h3><ul>
<li>本质上是多条同时执行的指令的组合，其“同时执行”的特征由编译器指定，无需硬件进行判断<br>  <img src="http://img.thebetterkong.cn/blog/CA-ISA/VLIW.png" alt="VLIW"></li>
<li>它是指令集并行 ILP 的极端;</li>
<li>运用：应用在早期的 GPU 中，GPGPU发 展后遭弃用（AMD 转向了 SIMT 的 GCN 架构）<ul>
<li>TRACE、Itanium（IA-64）</li>
</ul>
</li>
</ul>
<h2 id="指令系统演变-系统管理"><a href="#指令系统演变-系统管理" class="headerlink" title="指令系统演变-系统管理"></a>指令系统演变-系统管理</h2><p>满足现代操作系统的发展需求；</p>
<ol>
<li>存储管理上：<ul>
<li>连续实地址：各程序数据连续存放，显式保证不冲突</li>
<li>段式：分为多个段，通过相对段的偏移来访问</li>
<li>页式：将虚地址和实地址的对应关系组织为页表（TLB） </li>
<li>段页式：融合段式和页式</li>
</ul>
</li>
<li>运行级别的演变：<ul>
<li>唯一实模式：无管理</li>
<li>保护模式：权限管理，核心态和用户态（kernel/user） </li>
<li>调试模式：调试支持，ARM JTAG、MIPS EJTAG</li>
<li>客户模式：虚拟机支持，host/guest</li>
</ul>
</li>
</ol>
<h2 id="MIPS32-存储空间分段-页情况"><a href="#MIPS32-存储空间分段-页情况" class="headerlink" title="MIPS32 存储空间分段/页情况"></a>MIPS32 存储空间分段/页情况</h2><div class="table-container">
<table>
<thead>
<tr>
<th>地址范围</th>
<th>容量</th>
<th>映射方式</th>
<th>Cached</th>
<th>访问权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xe0000000-0xffffffff</td>
<td>0.5GB</td>
<td>查找TLB</td>
<td>Yes(TLB)</td>
<td>Kernel</td>
</tr>
<tr>
<td>0xc0000000-0xdfffffff</td>
<td>0.5GB</td>
<td>查找TLB</td>
<td>Yes(TLB)</td>
<td>Kernel,Supervisor</td>
</tr>
<tr>
<td>0xa0000000-0xbfffffff</td>
<td>0.5GB</td>
<td>地址：0xa0000000</td>
<td>No</td>
<td>Kernel</td>
</tr>
<tr>
<td>0x80000000-0x9fffffff</td>
<td>0.5GB</td>
<td>地址：0x80000000</td>
<td>Yes(Config)</td>
<td>Kernel</td>
</tr>
<tr>
<td>0x00000000-0x7fffffff</td>
<td>2GB</td>
<td>查找TLB</td>
<td>Yes(TLB)</td>
<td>Kernel,Supervisor,User</td>
</tr>
</tbody>
</table>
</div>
<h2 id="运行级别的演变：MIPS"><a href="#运行级别的演变：MIPS" class="headerlink" title="运行级别的演变：MIPS"></a>运行级别的演变：MIPS</h2><p><img src="http://img.thebetterkong.cn/blog/CA-ISA/MIPS.png" alt="MIPS">    </p>
<h1 id="指令系统的组成"><a href="#指令系统的组成" class="headerlink" title="指令系统的组成"></a>指令系统的组成</h1><h2 id="组成元素"><a href="#组成元素" class="headerlink" title="组成元素"></a>组成元素</h2><p><strong>指令主、谓、宾</strong>：CPU、操作、操作数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>具体描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作</td>
<td>算数与逻辑运算、转移、访存、系统指令</td>
</tr>
<tr>
<td>操作数</td>
<td>数据类型：定点/浮点、32位/64位；<br>访存对象：字节/半字/字/双字，大/小尾端…<br>寻址方式：寄存器、立即数、直接、间接…</td>
</tr>
<tr>
<td>指令编码</td>
<td>定长、变长</td>
</tr>
</tbody>
</table>
</div>
<h2 id="操作数的存储（地址空间）"><a href="#操作数的存储（地址空间）" class="headerlink" title="操作数的存储（地址空间）"></a>操作数的存储（地址空间）</h2><ol>
<li><p>地址空间的组成：</p>
<ul>
<li>寄存器空间: 整数通用寄存器、浮点通用寄存器、协处理器寄存器</li>
<li>系统内存空间: 内存空间、IO空间</li>
</ul>
</li>
<li><p>访问方式：</p>
<ul>
<li>寄存器：在指令中以寄存器号引用</li>
<li>系统内存：访存指令</li>
</ul>
</li>
<li><p>地址空间的演变：</p>
<ul>
<li>堆栈型（Stack）：零地址指令<ul>
<li>两操作数在栈顶，运算操作不用指定操作数，结果写回栈顶。</li>
</ul>
</li>
<li>累加器型（Accumulator）：单地址指令<ul>
<li>一个操作数由指令指定，一个操作数总在累加器中，结果也写回累加器</li>
</ul>
</li>
<li>寄存器型（Register）：多地址指令<ul>
<li>Register-Register型、Register-Memory型、Memory-Memory型</li>
</ul>
</li>
<li>不同类型指令功能举例：<ul>
<li>不同指令在指令系统完成 <code>C=A+B</code> 的指令序列（假设 ABC 在内存的不同单元中）：<br> <img src="http://img.thebetterkong.cn/blog/CA-ISA/DiffCommandFunc.png" alt="DiffCommandFunc"></li>
</ul>
</li>
</ul>
</li>
<li><p>指令系统类型的发展:</p>
<ul>
<li>早期的计算机多用<strong>堆栈</strong>和<strong>累加器型指令</strong><ul>
<li>出于降低硬件复杂度的考虑</li>
<li>现在已经不用（Intel 有点例外），JAVA 字节码使用堆栈结构</li>
</ul>
</li>
<li>1980 年代后的机器主要是<strong>寄存器型</strong><ul>
<li>访问寄存器比访问存储器快,便于编译器使用和优化</li>
<li>寄存器可以用来存放变量，减少访存次数</li>
<li><strong>寄存器间的相关容易判断，易于实现流水线、多发射、乱序执行等</strong></li>
<li>X86 通过把复杂指令翻译成类似于 RISC 的内部操作并使用 RISC 指令流水线技术提高性能，X86 的向量指令也是寄存器型</li>
</ul>
</li>
<li>RISC 的不断复杂化<ul>
<li><strong>内存离寄存器越来越远，以寄存器为中心的结构增加了不必要的数据搬运开销</strong>（如：memcpy） </li>
<li>向量指令、超越函数指令、Transacitonal memory等</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux/MIPS 虚拟地址空间安排：</p>
<ul>
<li>有关 IO 空间的划分：<ul>
<li>X86 规定了独立的 IO 空间，使用专门的 in/out 指令来访问 </li>
<li>EoMIPS/ARM 不区分 IO 空间和内存空间，使用同样的访存指令<br> <img src="http://img.thebetterkong.cn/blog/CA-ISA/LinuxMipsVAddressSpace.png" alt="LinuxMipsVAddressSpace"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="操作数的表示"><a href="#操作数的表示" class="headerlink" title="操作数的表示"></a>操作数的表示</h2><p>数据类型：</p>
<ul>
<li>整数、实数、字符、十进制数</li>
<li>字节、半字、字、双字</li>
<li>IEEE 754格式</li>
</ul>
<p>类型的表示：</p>
<ul>
<li>一般由操作码来区分不同类型</li>
<li>专门的类型标志</li>
</ul>
<p>数据类型的分布：</p>
<ul>
<li>Double word &gt; Word &gt; Byte &gt; Half word</li>
</ul>
<p>访存对象：</p>
<ol>
<li><p>存储器<strong>按字节编址</strong>：</p>
<ul>
<li>所有地址都是字节地址</li>
<li>访问长度：字节、半字、字、双字</li>
</ul>
</li>
<li><p>访存地址是否对齐（ Aligned vs. Misaligned ）：</p>
<ul>
<li>对齐原理：<br><img src="http://img.thebetterkong.cn/blog/CA-ISA/AddressAlignment.png" alt="AddressAlignment">    </li>
<li>地址对齐简化硬件设计：如字地址最低两位为 0 ；</li>
<li>跨数据通路边界的访问可能需要访问两次 RAM；</li>
<li>如何支持不对齐访问（如串操作）；</li>
</ul>
</li>
<li>大尾端（Big Endian）和小尾端（Little Endian）：<ul>
<li>Little Endian 地址指向一个字的最右字节；</li>
<li>Big Endian 反之；</li>
</ul>
</li>
</ol>
<p>寻址方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Register</td>
<td>ADD R1, R2</td>
<td>regs[R1]=reg[R1]+reg[R2]</td>
</tr>
<tr>
<td>Immediate</td>
<td>ADD R1, #2</td>
<td>regs[R1]=reg[R1]+2</td>
</tr>
<tr>
<td>Displacement(偏移)</td>
<td>ADD R1, 100(R2)</td>
<td>regs[R1]=reg[R1]+mem[100+reg[R2]]</td>
</tr>
<tr>
<td>Reg. Indirect(间接的)</td>
<td>ADD R1, (R2)</td>
<td>regs[R1]=reg[R1]+mem[reg[R2]]</td>
</tr>
<tr>
<td>Indexed</td>
<td>ADD R1, (R2+R3)</td>
<td>regs[R1]=reg[R1]+mem[reg[R2]+reg[R3]]</td>
</tr>
<tr>
<td>Absolute</td>
<td>ADD R1, (100)</td>
<td>regs[R1]=reg[R1]+mem[100]</td>
</tr>
<tr>
<td>Mem. Indirect</td>
<td>ADD R1, @(R2)</td>
<td>regs[R1]=reg[R1]+mem[mem[reg[R2]]]</td>
</tr>
<tr>
<td>Autoincrement(自增的)</td>
<td>ADD R1, (R2)+</td>
<td>regs[R1]=reg[R1]+mem[reg[R2]], <br>reg[R2]=reg[R2]+d</td>
</tr>
<tr>
<td>Autodecrement</td>
<td>ADD R1, -(R2)</td>
<td>reg[R2]=reg[R2]-d, <br>regs[R1]=reg[R1]+mem[reg[R2]]</td>
</tr>
<tr>
<td>Scaled(比例的)</td>
<td>ADD R1, 100(R2)[R3]</td>
<td>regs[R1]=reg[R1]+ mem[100+reg[R2]+reg[R3]*d]</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>访存方式（三个程序在 VAX 机上的统计）：<ul>
<li>寄存器访问占一半，存储器访问占一半，简单寻址方式占存储器访问的的 97%；</li>
</ul>
</li>
<li>偏移量分布（PEC CPU2000 在 Alpha 结构（最大偏移为 16 位）上的统计）：<ul>
<li>小偏移和大偏移较多，大偏移（14 位以上）多数为负数；</li>
<li>跟数据在内存中的分布有关；</li>
</ul>
</li>
<li>立即数比例（SPEC CPU2000 在 Alpha 结构上的统计）：<ul>
<li>ALU 操作定点 1/4、浮点 1/5 需要立即数</li>
<li>Load 操作有近 1/4 是取立即数（没有真正访存）</li>
<li>平均定点 1/5、浮点 1/6 的指令需要立即数</li>
</ul>
</li>
<li>立即数值的分布（SPEC CPU2000 在 Alpha 结构上的统计）：<ul>
<li>CINT2000 中 20%、CFP2000 中 30% 的立即数是负的</li>
<li>在支持 32 位立即数的 VAX 上统计表明，20%-30% 立即数大于 16 位</li>
</ul>
</li>
</ul>
<p>综上所述：</p>
<ol>
<li>应至少支持以下寻址方式：<ul>
<li>Register、Immediate、Displacement、Register indirect；</li>
</ul>
</li>
<li>指令中常数位数：<ul>
<li>地址偏移量位数 12-16 位 ，立即数位数 8-16 位；</li>
</ul>
</li>
</ol>
<h2 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h2><p>指令操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令类别</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术和逻辑运算指令</td>
<td>加、减、乘、除、开方..<br>移位：左移与右移、逻辑移位与算术移位..<br>与、或、非、异或..<br>格式转换..</td>
</tr>
<tr>
<td>访存指令</td>
<td>取数、存数<br>不同长度和不同类型：定点/浮点，字节/半字/字/双字<br>不同寻址方式</td>
</tr>
<tr>
<td>转移指令</td>
<td>相对/绝对、直接/间接、条件/无条件</td>
</tr>
</tbody>
</table>
</div>
<p>系统管理指令|TLB管理、Cache管理、异常管理、安全管理|</p>
<p>常见指令操作：</p>
<ul>
<li><strong>把简单指令做快点，其他慢一点没关系；</strong></li>
<li>SPECint92 的 X86 指令统计：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>指令</th>
<th>比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Load</td>
<td>22%</td>
</tr>
<tr>
<td>2</td>
<td>Conditional branch</td>
<td>20%</td>
</tr>
<tr>
<td>3</td>
<td>Compare</td>
<td>16%</td>
</tr>
<tr>
<td>4</td>
<td>Store</td>
<td>12%</td>
</tr>
<tr>
<td>5</td>
<td>Add</td>
<td>8%</td>
</tr>
<tr>
<td>6</td>
<td>And</td>
<td>6%</td>
</tr>
<tr>
<td>7</td>
<td>Sub</td>
<td>5%</td>
</tr>
<tr>
<td>8</td>
<td>Move reg-reg</td>
<td>4%</td>
</tr>
<tr>
<td>9</td>
<td>Call</td>
<td>1%</td>
</tr>
<tr>
<td>10</td>
<td>Return</td>
<td>1%</td>
</tr>
<tr>
<td>总计</td>
<td></td>
<td>96%</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>SPEC CPU2000 动态指令分布：<br>  <img src="http://img.thebetterkong.cn/blog/CA-ISA/DynamicInstrucDistribute.png" alt="DynamicInstrucDistribute"> </li>
</ul>
<p>转移指令:</p>
<ol>
<li>转移指令类型：条件转移/无条件转移、过程调用/过程返回</li>
<li>转移地址类型：<ul>
<li>相对：PC+偏移量</li>
<li>绝对：指令中给出转移地址</li>
<li>间接：根据寄存器内容转移（编译器不知道目标地址），如 Switch 语句、函数指针、动态链接、过程返回等</li>
</ul>
</li>
<li>特点：<ul>
<li>条件转移最多:<ul>
<li>根据条件位判断转移，直接比较寄存器内容转移；</li>
<li>SPEC CPU2000在Alpha结构上的统计：</li>
</ul>
</li>
<li>偏移位数多数是4-8位：<ul>
<li><strong>虚拟机生成的代码放得较远，转移指令偏移量大；</strong></li>
</ul>
</li>
<li>条件转移的分布：<ul>
<li>小于、等于、小于或等于比较最多</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h2><p>需要考虑的因素：</p>
<ul>
<li>操作码部分比较简单</li>
<li>操作数的个数、类型对指令长度影响很大</li>
<li>变长指令程序代码短、定长指令实现简单</li>
</ul>
<p>编码方法：</p>
<ul>
<li>定长：RISC</li>
<li>变长：VAX 的指令 1-53 字节，其中 ADD 指令 3-19 字节，Intel 的 X86 指令 1-17 字节</li>
<li>混合：IBM 360/370，MIPS16，Thumb，TI TMS320C54x</li>
</ul>
<p>特点（RISC 系统结构）：</p>
<ol>
<li>简单操作和简单寻址方式用得最多<ul>
<li>10 种简单操作指令占 96%</li>
<li>寄存器, 立即数, 偏移寻址, 寄存器间接寻址四种寻址方式</li>
</ul>
</li>
<li>简单指令便于高效实现和使用<ul>
<li>load-store 结构简化硬件设计，提高主频</li>
<li>定长简化译码</li>
<li>符合编译器“常用的做得快，少用的只要对”的原则</li>
</ul>
</li>
<li>硬件优化应充分考虑兼容性<ul>
<li>流水、多发射不改变指令系统</li>
<li>流水、多发射技术在 load-store 指令系统上容易实现</li>
</ul>
</li>
</ol>
<h1 id="指令集详细说明"><a href="#指令集详细说明" class="headerlink" title="指令集详细说明"></a>指令集详细说明</h1><h2 id="不同指令系统通用寄存器数量"><a href="#不同指令系统通用寄存器数量" class="headerlink" title="不同指令系统通用寄存器数量"></a>不同指令系统通用寄存器数量</h2><div class="table-container">
<table>
<thead>
<tr>
<th>指令集</th>
<th>整数通用寄存器数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Itanium</td>
<td>128</td>
</tr>
<tr>
<td>VAX</td>
<td>16</td>
</tr>
<tr>
<td>ARMv8</td>
<td>31</td>
</tr>
<tr>
<td>PowerPC</td>
<td>32</td>
</tr>
<tr>
<td>Alpha</td>
<td>32(including ”zero”)</td>
</tr>
<tr>
<td>SPARC</td>
<td>32(including ”zero”)</td>
</tr>
<tr>
<td>MIPS</td>
<td>4-32(including ”zero”)</td>
</tr>
<tr>
<td>ARMv7</td>
<td>7 in 16bit thumb mode,14 in 32bit</td>
</tr>
<tr>
<td>X86</td>
<td>8 in 16/32bit,16 in 64bit</td>
</tr>
</tbody>
</table>
</div>
<h2 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h2><p>MIPS 指令格式：<br><img src="http://img.thebetterkong.cn/blog/CA-ISA/MIPSInstrucFormat.png" alt="MIPSInstrucFormat"></p>
<p>MIPS 指令类型:</p>
<ul>
<li>访存指令（包括定点和浮点）</li>
<li>运算指令（包括定点和浮点）</li>
<li>比较和转移指令（包括定点和浮点）</li>
<li>系统管理指令:    <ul>
<li>TLB、CACHE、例外处理</li>
<li>TRAP、Breakpoint</li>
</ul>
</li>
</ul>
<p>MIPS 寄存器空间：</p>
<ul>
<li>32个整数通用寄存器<ul>
<li>$0 - $31（$0 总是返回 0）</li>
</ul>
</li>
<li>32个浮点通用寄存器<ul>
<li>$f0 - $f31</li>
</ul>
</li>
<li>控制寄存器<ul>
<li>仅 OS 使用</li>
</ul>
</li>
<li>若干协处理器寄存器<ul>
<li>DSP、MSA……<br><img src="http://img.thebetterkong.cn/blog/CA-ISA/MIPSRegister.png" alt="MIPSRegister"></li>
</ul>
</li>
</ul>
<h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p>一个“典型”的 RISC：</p>
<ul>
<li>32 位定长指令</li>
<li>32 个 32 位通用寄存器</li>
<li>三寄存器操作数运算指令</li>
<li>Load-Store 指令，基址+偏移量寻址方式</li>
<li>简单转移条件</li>
</ul>
<p>发展过程：</p>
<ul>
<li>现代 X86 处理器内部的核心也是 RISC 结构；<br>  <img src="http://img.thebetterkong.cn/blog/CA-ISA/RISCDevelopment.png" alt="RISCDevelopment"></li>
</ul>
<p>常见 RISC 指令系统比较：</p>
<ol>
<li>指令格式：<br> <img src="http://img.thebetterkong.cn/blog/CA-ISA/RISCInstrutFormat.png" alt="RISCInstrutFormat"></li>
<li>指令功能：<ul>
<li>所有 RISC 处理器都有一些公共指令：<ul>
<li>load/store 指令</li>
<li>算术运算及逻辑指令</li>
<li>控制流指令</li>
<li>系统管理指令</li>
</ul>
</li>
<li>不同处理器在发展过程中形成的特色举例：<ul>
<li>MIPS 的非对齐访问</li>
<li>SPARC 的寄存器窗口</li>
<li>PowerPC 的 Link 和 Count 寄存器</li>
<li>HP 的 Nullification</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="具体指令说明"><a href="#具体指令说明" class="headerlink" title="具体指令说明"></a>具体指令说明</h2><ol>
<li>Load/Store 指令：<ul>
<li>对任何 GPR 和 FPR 进行存取操作；</li>
<li><strong>通常 R0 总是为 0</strong>；</li>
</ul>
</li>
<li>ALU 指令：<ul>
<li><strong>所有 ALU 指令都是寄存器型的；</strong></li>
<li>ALU 的常见操作有加、减、与、或、异或、移位、比较，乘除法在专门的部件进行；</li>
</ul>
</li>
<li>控制流指令：<ul>
<li>绝对跳转 jump 和相对转移 branch；</li>
</ul>
</li>
<li>条件转移的条件判断：<ul>
<li>SPARC v8 使用 4 位条件码(CC)，该条件码在程序状态字中<ul>
<li>整数运算指令设置 CC，条件转移指令检测 CC<ul>
<li>浮点运算有另外两位 CC</li>
<li>v9 为了支持 64 位运算增加了 4 位整数 CC，3 位浮点 CC</li>
</ul>
</li>
</ul>
</li>
<li>MIPS <strong>直接比较寄存器内容判断</strong>是否转移<ul>
<li>MIPS III 浮点部件有一位条件码，记录 cmp 指令的结果</li>
<li>MIPS IV 有多位浮点条件码</li>
</ul>
</li>
<li>PowerPC 有 4 位 CC，一个条件寄存器中有 8 份 4 位 CC<ul>
<li>整数和浮点运算各 1 位，其它用于比较指令。</li>
<li>Branch 指令需指定根据哪一位进行转移</li>
<li>运算指令中有一位指定该指令是否影响 CC</li>
</ul>
</li>
<li>PA-RISC 有多种选择，最常用的是比较两个寄存器的值并根据结果决定是否转移</li>
</ul>
</li>
<li>系统管理指令：<ul>
<li>原子操作指令、存储管理指令、例外管理指令、共享存储同步指令等等</li>
<li>原子操作指令：MIPS 的 LL 和 SC 指令为例：<blockquote>
<ul>
<li>LL指令的功能是从内存中读取一个字，以实现接下来的 RMW(Read-Modify-Write）操作；</li>
<li>SC 指令的功能是向内存中写入一个字，以完成前面的 RMW 操作；</li>
<li>LL/SC 指令的独特之处在于，它们不是一个简单的内存读取/写入的函数，当使用LL 指令从内存中读取一个字之后，比如：<code>LL d, off(b)</code>，处理器会记住 LL 指令的这次操作（会在 CPU 的寄存器中设置一个不可见的 bit 位），同时 LL 指令读取的地址 off(b) 也会保存在处理器的寄存器中接下来的 SC 指令；</li>
<li>比如： <code>SC t, off(b)</code>，会检查上次 LL 指令执行后的 RMW 操作是否是原子操作（即不存在其它对这个地址的操作），</li>
<li>如果是原子操作，则 t 的值将会被更新至内存中，同时 t 的值也会变为 1，表示操作成功；</li>
<li>反之，如果 RMW 的操作不是原子操作（即存在其它对这个地址的访问冲突），则 t 的值不会被更新至内存中，且 t 的值也会变为 0，表示操作失败。<ul>
<li>LL(Load Linked)取数且置系统中 LLbit 为1；</li>
<li>LL 为 1 时，处理器检查相应单元是否被修改，如果其它处理器或设备访问了相应单元或执行了 ERET 操作，LLbit 置为 0 ；</li>
<li>执行 SC（Store Conditional）时若 LLbit 为 1，则成功，目标寄存器为 1；否则存数不成功，目标寄存器为 0；<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">L1:</span> <span class="keyword">LL </span>R1,(R3)</span><br><span class="line">    <span class="keyword">ADD </span>R2,R1,<span class="number">1</span></span><br><span class="line">    <span class="keyword">SC </span>R2,(R3)</span><br><span class="line">    <span class="keyword">BEQ </span>R2,<span class="number">0</span>,L1</span><br><span class="line">    <span class="keyword">NOP</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="特色指令"><a href="#特色指令" class="headerlink" title="特色指令"></a>特色指令</h2><ol>
<li>MIPS 特色：非对齐访存指令 LWR 和 LWL<ul>
<li>作用：边界不对齐的数据传送（小尾端）</li>
<li>说明：<ul>
<li><strong>lwr:</strong><ul>
<li>对于大端：从所指位置（地址）向低地址方向取数直至地址对齐，且按从低地址至高地址的顺序将数据排序，将排序好的数据存放在寄存器的低位。</li>
<li>对于小端：从所指位置（地址）向高低址方向取数直至地址对齐，且按从高地址至低地址的顺序将数据排序，将排序好的数据存放在寄存器的低位。</li>
</ul>
</li>
<li><strong>lwl：</strong><ul>
<li>对于大端：从所指位置（地址）向高地址方向取数直至地址对齐，且按从低地址至高地址的顺序将数据排序，将排序好的数据存放在寄存器的高位。</li>
<li>对于小端：从所指位置（地址）向低地址方向取数直至地址对齐，且按从高地址至低地址的顺序将数据排序，将排序好的数据存放在寄存器的高位。</li>
</ul>
</li>
</ul>
</li>
<li>举例：<br>   <img src="http://img.thebetterkong.cn/blog/CA-ISA/LWRLWL.png" alt="LWRLWL">    </li>
</ul>
</li>
<li>SPARC 特色：寄存器窗口<ul>
<li>2-32 个寄存器窗口，用于不同过程：<ul>
<li>8 个全局寄存器用于存放全局变量</li>
<li>24 个局部寄存器：8 个输入参数，8 个局部变量，8 个输出参数</li>
<li>过程调用和退出不用把现场保留到存储器</li>
</ul>
</li>
<li>SAVE 和 RESTORE 指令：<ul>
<li>SAVE：功能同ADD，源寄存器来自调用过程(caller)，目标寄存器来自被调用过程(callee)，该指令自动修改寄存器窗口指针CWP—</li>
<li>RESTORE：功能同ADD，源寄存器来自被调用过程(callee)，目标寄存器来自调用过程(caller)，该指令自动修改寄存器窗口指针CWP++</li>
</ul>
</li>
<li>AMD AM29000 的局部寄存器窗口大小可变，全局寄存器 64 个<br> <img src="http://img.thebetterkong.cn/blog/CA-ISA/RegisterWindow.png" alt="RegisterWindow"></li>
</ul>
</li>
<li>PowerPC 特色：Link 和 Count 寄存器<ul>
<li>寄存器说明：<ul>
<li>Link 寄存器用于保存返回地址，实现快速过程调用</li>
<li>Count 寄存器用于循环计数，每次自动递减</li>
</ul>
</li>
<li>这两个寄存器还可以放转移地址</li>
<li>PowerPC 其他特色：<ul>
<li>PowerPC 不用 Delay Slot</li>
<li>Load 和 Store 指令同时存取多个寄存器（多达 32 个）</li>
<li>Load 和 Store 字符串（变长或定长、对齐或不对齐）</li>
</ul>
</li>
</ul>
</li>
<li>PA-RISC 的 Nullification：<ul>
<li><strong>根据当前指令执行结果确定下一条指令是否执行</strong>（所有的转移指令和多数算术指令可用）<ul>
<li>如：ADDB（Add and branch）指令在完成加法后，检查加法结果是否满足条件，如果不满足就转移。同时判断下一条指令（延迟槽）是否执行。</li>
<li>可以消除一些简单的转移指令：<br><img src="http://img.thebetterkong.cn/blog/CA-ISA/Nullification.png" alt="Nullification"></li>
</ul>
</li>
<li>其它指令系统有条件移数指令如：CMOV</li>
<li>后来演化为 IA64 的谓词技术：运算指令通过 64 个谓词寄存器决定结果是否保存</li>
</ul>
</li>
</ol>
<p>Alpha 和 PowerPC 比较：<br><img src="http://img.thebetterkong.cn/blog/CA-ISA/AlphaVsPowerPC.png" alt="AlphaVsPowerPC"></p>
<ul>
<li>PowerPC 的 load-with-update 和 store-with-update 指令适合于数组运算，Alpha没有寄存器加寄存器的寻址方式，指向数组的指针每次分别递增；</li>
<li>在 Alpha 中，循环次数由指针实现，在 PowerPC 中，有 CTR 专门用于保存循环次数</li>
<li>PowerPC 只需两条浮点指令：乘及乘加</li>
<li>Alpha 需要 10 条指令，比 PowerPC 多 4 条 </li>
<li>Alpha 指令简单容易高效实现，主频也高</li>
</ul>
<p>RISC指令系统小结：</p>
<ul>
<li><strong>对于一个程序在上述四种 RISC 结构上的执行，平均 90% 以上的指令为四个指令系统共有的；</strong></li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：绪论</title>
    <url>/2020/02/21/Computer-Architecture/CA-Introduction/</url>
    <content><![CDATA[<p>从整体上对计算机体系结构的认识，介绍其相关概念、发展状况、以及一些评价指标等；</p>
<a id="more"></a> 
<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p><img src="http://img.thebetterkong.cn/blog/CA-Introduction/ResearchStatus.png" alt="现状"></p>
<h1 id="应用举例：PPT翻页过程"><a href="#应用举例：PPT翻页过程" class="headerlink" title="应用举例：PPT翻页过程"></a>应用举例：PPT翻页过程</h1><p>以龙芯处理器为例:</p>
<ul>
<li>键盘产生一个信号送到桥片（南桥、北桥）;</li>
<li>桥片通过 HT 总线向处理器发出外部中断信号;</li>
<li>外部中断信号传到控制寄存器模块与 Cause 的屏蔽位相与;</li>
<li>如果没有被屏蔽，再传到寄存器重命名模块并附在四条指令的第一条中送到 ROB 模块；由于该指令发生了例外，不会送到功能部件执行;</li>
<li>当该指令成为 ROB 的第一条指令被提交时向所有模块发出取消信号，取消该指令后面的所有指令，在 EPC 等寄存器中保存例外现场，同时在控制寄存器 Status 中把系统状态置为核心态;</li>
<li>向取指模块发出中断信号，取指模块根据中断类型到 0x80000180 取指;</li>
</ul>
<p>以龙芯处理器+Linux操作系统为例:</p>
<ul>
<li>0x80000180 为操作系统例外处理代码;</li>
<li>操作系统保留现场（把通用寄存器保存到堆栈区）;</li>
<li>操作系统通过读 Cause 寄存器分析例外原因是外部中断;</li>
<li>操作系统向桥片中的中断控制器读中断原因，读的同时清中断;</li>
<li>操作系统根据中断原因调用驱动程序，读取键盘数据;</li>
<li>操作系统唤醒正在由于等待数据而阻塞的进程（Powerpoint）;</li>
<li>Powerpoint 根据读到的键盘数据决定翻一页，调用显示驱动程序;</li>
<li>驱动程序把要显示的内容送到显存，并通知 GPU；</li>
<li>GPU通过访问显存空间刷新屏幕</li>
</ul>
<p>其中，如果觉得ppt翻页卡顿：</p>
<ul>
<li>看系统中有没有其他任务在运行，因为任务会占用CPU、内存带宽、IO 带宽等资源； </li>
<li>影响因素： <ol>
<li>「GPU」：下一页 PPT 可能图比较多，GPU 忙不过来； </li>
<li>「内存带宽」：显示内容数据量大，把数据从 PowerPoint 的应用程序空间传给 GPU 使用的显存，内存带宽不足；（独显时：数据采用类似 DMA 的方式，从内存传输到显存） </li>
</ol>
</li>
</ul>
<h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>「计算机体系结构 (Computer Architecture) 」是描述<strong>计算机各组成部分</strong>及其<strong>相互关系</strong>的一组规则和方法，是程序员所看到的计算机属性；</p>
<h2 id="主要研究内容"><a href="#主要研究内容" class="headerlink" title="主要研究内容"></a>主要研究内容</h2><p>计算机体系结构主要研究内容包括<strong>指令系统结构</strong>(ISA)和<strong>计算机组织结构</strong>；</p>
<h2 id="现代体系结构基础"><a href="#现代体系结构基础" class="headerlink" title="现代体系结构基础"></a>现代体系结构基础</h2><p><strong>二进制</strong>、<strong>冯诺依曼结构的存储程序</strong>和<strong>指令驱动执行原理</strong>；</p>
<h2 id="表现方式"><a href="#表现方式" class="headerlink" title="表现方式"></a>表现方式</h2><ol>
<li><strong>指令系统手册和结构框图</strong>：结构框图中的方块表示计算机的功能模块，线条和箭头表示指令和数据在功能模块中的流动，结构框图可以不断分解一直到门级或晶体管级； </li>
<li><strong>高级语言</strong>：（如:C语言来表示）形成结构模拟器，用于性能评估和分析； </li>
<li><strong>硬件描述语言</strong>：（如:Verilog）可通过电子设计自动化 EDA 工具，进行功能验证和性能分析，转化成门级及晶体管网表，并通过布局布线最终转换成版图，用于芯片制造。 </li>
</ol>
<h1 id="造CPU必须知道"><a href="#造CPU必须知道" class="headerlink" title="造CPU必须知道"></a>造CPU必须知道</h1><ol>
<li>指令是是应用的 “算子”；<ul>
<li>要知道哪些是硬件实现？哪些是软件实现？</li>
</ul>
</li>
<li>结构设计要结合应用行为，例如： <ul>
<li>Cache利用应用访存局部性；</li>
<li>转移猜测利用转移相关性和重复性</li>
</ul>
</li>
<li>ISA和微结构要考虑 OS 需求；<ul>
<li>页表和 TLB，多线程支持，虚拟机支持</li>
</ul>
</li>
<li>结构设计要考虑晶体管属性，例如：<ul>
<li>cache 容量影响主频；</li>
<li>多发射结构发射电路影响主频；</li>
</ul>
</li>
</ol>
<h1 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><strong><mark>存储程序和指令驱动执行:</mark></strong></p>
<p><img src="http://img.thebetterkong.cn/blog/CA-Introduction/VonNeumannStructure.png" alt="冯诺依曼结构"> </p>
<ol>
<li>计算机由<strong>存储器、运算器、控制器、输入设备、输出设备</strong>五部分组成，其中运算器和控制器合称称 CPU；</li>
<li>存储器是按地址访问的线性编址的一维结构，每个单元的位数固定。指令和数据不加区别混合存储在同一个存储器中。</li>
<li>控制器从存储器中取出指令并依指令要求发出控制信号控制计算机的操作。控制器中的程序计数器指明要执行的指令所在的存储单元地址。程序计数器一般按顺序递增，但可按指令要求而改变。</li>
<li>以运算器为中心，输入输出（IO）设备与存储器之间的数据传送都经过运算器。</li>
</ol>
<h2 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h2><ol>
<li>中心：运算器 —&gt; 存储器<ul>
<li>数据流向更加合理，使运算器、存储器和 IO 设备能并行工作。  </li>
</ul>
</li>
<li>控制：单一集中 —&gt; 分散<ul>
<li>早期计算机工作速度低，运算器、存储器、控制器和 IO 设备可在同一个时钟信号控制下同步工作。</li>
<li>现在运算器、存储器与 IO 设备的速度差异很大，需要异步分散控制。   </li>
</ul>
</li>
<li>串行算法 —&gt; 适应并行算法<ul>
<li>出现了流水线处理器、超标量处理器、向量处理器、多核处理器、对称多处理机（SMP）、大规模并行处理机（MPP）和机群系统等。   </li>
</ul>
</li>
<li>出现为适应特殊需要的专用计算机<ul>
<li>如图形处理器（GPU）、数字信号处理器（DSP）等  </li>
</ul>
</li>
</ol>
<p>目前的计算机没有能突破该特征的，都是对冯诺依曼结构的变种（哈佛结构、并行结构等） </p>
<ul>
<li><strong>「哈佛结构」</strong>:将冯诺依曼结构里的指令和数据分开存储。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优：自动快速执行</li>
<li>缺：指令驱动的顺序执行；CPU 和存储器分开且越来越远。</li>
</ul>
<h1 id="衡量计算机的指标"><a href="#衡量计算机的指标" class="headerlink" title="衡量计算机的指标"></a>衡量计算机的指标</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能的本质定义"><a href="#性能的本质定义" class="headerlink" title="性能的本质定义"></a>性能的本质定义</h3><p>以指令为基本单位，完成一个任务所需的时间；   </p>
<ul>
<li>$CPUTime = \frac{Seconds}{Program} = \frac{Instructions}{Program} \times \frac{Cycles}{Instrustion} \times \frac{Seconds}{Cycle}$</li>
<li>$程序的CPU时间=程序指令数 \times 每条指令时钟周期数 \times 时钟周期$</li>
</ul>
<h3 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h3><ul>
<li>算法（影响最大）：<ul>
<li>如冒泡排序复杂度为 $O(N*N)$，快速排序复杂度为 $O(NlogN)$</li>
</ul>
</li>
<li>编译器影响：<ul>
<li>一般有几倍的差距</li>
</ul>
</li>
<li>指令系统：<ul>
<li>复杂指令,如三角函数、FFT、AES 等是否硬件实现</li>
</ul>
</li>
<li>微结构：<ul>
<li>IPC（Instructions per cycle）：通过乱序执行、多发射、存储层次等提高 IPC</li>
</ul>
</li>
<li>主频：受工艺和微结构（流水线）的影响。<ul>
<li>主频降低，单核性能大幅提高；</li>
<li>性能的提高少量来自于自动并行化，主要是浮点；</li>
<li>主要通过结构优化提高性能：骨架做大（如：多访存部件等）、细节做精（结合应用具体优化）</li>
</ul>
</li>
</ul>
<h3 id="评价原则"><a href="#评价原则" class="headerlink" title="评价原则"></a>评价原则</h3><p><strong>拿基准测试程序来测，而不是看个别技术指标</strong>（如：主频等）；    </p>
<p>注意点：</p>
<ol>
<li>对于不同的计算机，侧重点不同需要采用不同的测试程序；<ul>
<li>例如：个人 PC 在乎单任务关注响应时间，计算中心多任务更关注吞吐量</li>
</ul>
</li>
<li>测试程序要有代表性，要足够大，而不是拿个别程序测，要能全面综合评价计算机性能；</li>
<li>多个程序测试时，最后应该采用「几何平均」，这样反映的结果更加公平；<ul>
<li>算术平均值的权重与特定程序在特定机器上的执行时间成正比，所以权重不仅与该程序的执行频度有关，也与运行该程序的机器特性和输入数据相关。可能导致测试者把自己机器上运行最快的程序的输入量增到最大，以提高计算该程序平均值时的权重，干扰了真实结果。</li>
<li>几何平均：<ul>
<li>优点：小于算术平均值、与参考机无关、强调性能平衡</li>
<li>缺点：可能导致硬件和软件设计者集中精力提高最易提高速度的软件的性能，而不是提高速度最慢的软件的性能</li>
</ul>
</li>
</ul>
</li>
<li>当负载中各程序的执行百分比不同时，常用方法：计算加权执行时间、归一化（将执行时间对一台参考机器进行归一化，然后取其归一化执行时间的平均值）</li>
<li>测试报告要足够详细，要公开，要可以检查；</li>
</ol>
<p>常见的基准测试程序套件：</p>
<ul>
<li>SPEC CPU：基准测试程序</li>
<li>TPC：事务处理测试程序</li>
<li>EEMBC：嵌入式基准测试程序</li>
<li>LMBench：比较不同的 unix 系统性能</li>
</ul>
<h3 id="CPI-和-IPC"><a href="#CPI-和-IPC" class="headerlink" title="CPI 和 IPC"></a>CPI 和 IPC</h3><p>在指令系统确定后，系统结构设计者的主要目标就是降低 CPI 或提高 IPC；   </p>
<p>CPI = (CPU时间 * CLOCK Rate频率)  / 指令数 = 时钟周期数 / 指令数</p>
<ul>
<li><p>$CPU \ time = Cycle \ Time \times (\sum_{j=1}^n CPI_j \times I_j) = Cycle \ Time \times CPI \times Instruction  \ Count$</p>
</li>
<li><p>$CPI = \sum_{j=1}^n CPI_j \times F_j ,\  \ where \ F_j = \frac{I_j}{Instruction  \ Count} $</p>
</li>
</ul>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><h3 id="成本和性能的关系"><a href="#成本和性能的关系" class="headerlink" title="成本和性能的关系"></a>成本和性能的关系</h3><ul>
<li>超级计算机：不计成本，只追求性能</li>
<li>嵌入式应用：为降低功耗和成本，可以牺牲一部分性能</li>
<li>介于两者之间：比如 PC 机，工作站，服务器等，追求性能价格比的最优设计</li>
</ul>
<h3 id="影响成本的因素"><a href="#影响成本的因素" class="headerlink" title="影响成本的因素"></a>影响成本的因素</h3><ul>
<li>生产成本降低，加速学习降低一次性成本，商品竞争量的增加。</li>
</ul>
<h3 id="芯片成本"><a href="#芯片成本" class="headerlink" title="芯片成本"></a>芯片成本</h3><p><img src="http://img.thebetterkong.cn/blog/CA-Introduction/Chip.png" alt="晶片"></p>
<ul>
<li>$芯片成本 = \frac{晶片成本+测试成本+封装成本}{最终成品率}$</li>
<li>$晶片成本 = \frac{晶圆成本}{每片晶圆的晶片数 \times 晶片成品率}$</li>
<li>$每个晶圆的晶片数 = \frac{\pi(\frac{晶圆直径}{2})^2}{晶片面积} - \frac{\pi \times 晶圆直径}{\sqrt{2 \times 晶片面积}}$</li>
<li>$晶片成品率 = 晶圆成品率 \times (1 + \frac{单位面积内缺陷数 \times 晶片面积}{\alpha})^{- \alpha}$</li>
</ul>
<blockquote>
<p>封装成本跟功耗、引脚数目、材料相关；<br>90nm 工艺下每个 12 英寸晶圆的成本在 3000-6000 美元之间；<br>$\alpha$ 是衡量工艺复杂程度的参数，在目前工艺下约为 4；<br>单位面积的缺陷数目与工艺相关，在目前的工艺下约为：$(0.4-0.8)/{cm}^2$   </p>
</blockquote>
<h3 id="成本控制"><a href="#成本控制" class="headerlink" title="成本控制"></a>成本控制</h3><p>基于以下特点：</p>
<ol>
<li>生产流程决定晶圆的成本、成品率以及单位面积的残次品数目；</li>
<li>设计者唯一能够控制的是晶片的面积，而晶片成本增长的速度和晶片面积增长速度的 4 次方成正比关系；</li>
</ol>
<p>所以做法：</p>
<ol>
<li>控制晶片大小：通过晶片所包含的功能和 I/O 管脚数目来控制晶片的大小</li>
<li>提高成品率：“冗余”设计，如片内 RAM 的冗余设计</li>
<li>控制封装、测试的成本</li>
<li>掩模成本：主要针对低产量（少于 100 万）的产品，采用可配置逻辑或选取一些门阵列来降低掩模成本</li>
</ol>
<h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p><img src="http://img.thebetterkong.cn/blog/CA-Introduction/Power.png" alt="Power"></p>
<h3 id="动态功耗"><a href="#动态功耗" class="headerlink" title="动态功耗"></a>动态功耗</h3><p><img src="http://img.thebetterkong.cn/blog/CA-Introduction/DynamicPower.png" alt="动态功耗">    </p>
<p>翻转功耗：</p>
<ul>
<li>$P_{switch}=\frac{C_{out}{V_{dd}}^2f_{clk}}{2}$</li>
</ul>
<p>短路功耗：</p>
<ul>
<li>输入信号 transition 时间不为 0：P 管和 N 管同时打开造成电源的短路；</li>
<li>输入 transition 比输出 transition 快：短路功耗小，反之则大；</li>
</ul>
<h3 id="CMOS静态功耗"><a href="#CMOS静态功耗" class="headerlink" title="CMOS静态功耗"></a>CMOS静态功耗</h3><p>在 90nm 以后漏电功耗比较突出：</p>
<ul>
<li>栅氧太薄、沟道太短、域值电压太低</li>
</ul>
<p>三种漏电：</p>
<ul>
<li>亚阈值漏电（sub-threshold leakage）：<ul>
<li>源 &lt;—&gt; 漏</li>
</ul>
</li>
<li>栅漏电（gate leakage）：<ul>
<li>栅 &lt;—&gt; 源</li>
<li>栅 &lt;—&gt; 漏</li>
</ul>
</li>
<li>反相 PN 结漏电（junction leakage）：<ul>
<li>源 &lt;—&gt; 衬底</li>
<li>漏 &lt;—&gt; 衬底</li>
</ul>
</li>
</ul>
<h3 id="降低功耗的方法"><a href="#降低功耗的方法" class="headerlink" title="降低功耗的方法"></a>降低功耗的方法</h3><p>优化对象：</p>
<ul>
<li>动态功耗优化</li>
<li>静态功耗优化</li>
</ul>
<p>优化层次：</p>
<ul>
<li>结构级：多发射 vs. 单发射；关闭不用的模块</li>
<li>逻辑级：串行进位 vs. 并行进位加法器</li>
<li>电路级：动态 vs. 静态电路</li>
<li>工艺级：使用高性能 vs. 低功耗晶体管</li>
</ul>
<h1 id="计算机体系结构发展趋势"><a href="#计算机体系结构发展趋势" class="headerlink" title="计算机体系结构发展趋势"></a>计算机体系结构发展趋势</h1><h2 id="动力"><a href="#动力" class="headerlink" title="动力"></a>动力</h2><ul>
<li>半导体工艺技术和计算机体系结构技术互为动力；</li>
<li>应用需求是计算机体系结构发展的持久动力；</li>
<li>主要动力：2010年代前工艺技术，2010年代后应用需求；</li>
</ul>
<h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><ul>
<li>非客观规律，是人们努力的结果；  </li>
<li>晶体管数目每18-24个月翻一番；   </li>
<li>同样晶体管数量的芯片价格下降一倍，现在买一颗大米的钱可以买 100-1000 只晶体管；</li>
</ul>
<ol>
<li>第一代到第四代：摩尔定律与结构进步</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>发展</th>
<th>执行速率</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>电子管计算机</td>
<td>每秒几千到几万次</td>
<td>冯诺依曼结构</td>
</tr>
<tr>
<td>晶体管计算机</td>
<td>每秒几十万次</td>
<td>高级程序语言出现（FORTRAN等），IBM7094…</td>
</tr>
<tr>
<td>中小规模IC计算机</td>
<td>每秒几百万次</td>
<td>操作系统逐步成熟，小型机出现，IBM360等</td>
</tr>
<tr>
<td>大规模IC计算机</td>
<td>每秒亿次以上</td>
<td>微处理器出现：Intel，AMD，形成wintel体系</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>摩尔定律与系统结构：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>特点</th>
<th>发展</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一阶段</td>
<td>晶体管不够用</td>
<td>计算机由很多独立芯片构成；<br>计算机结构受限于晶体管数目不够；</td>
</tr>
<tr>
<td>第二阶段</td>
<td>存储器速度太慢</td>
<td>集成度提高，微处理器蓬勃发展；<br>存储容量指数增加，但访存速度增加缓慢 ；<br>Cache 占多达 80% 的晶体管；</td>
</tr>
<tr>
<td>第三阶段</td>
<td>晶体管越来越多而“难”用</td>
<td>设计验证能力提高与晶体管增加形成剪刀差；<br>功耗问题突出、连线成为主要矛盾；<br>不得已向多核发展</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>CMOS工艺正面临物理极限：难以进一步缩小已经达成共识，所以会不会有新材料及新器件技术取代CMOS？<ul>
<li>硅的平台不可能被取代，但硅平台上生长的器件会不断改进：如碳纳米管</li>
</ul>
</li>
</ol>
<h2 id="计算机应用与体系结构"><a href="#计算机应用与体系结构" class="headerlink" title="计算机应用与体系结构"></a>计算机应用与体系结构</h2><div class="table-container">
<table>
<thead>
<tr>
<th>设备</th>
<th>性能</th>
<th>特征</th>
</tr>
</thead>
<tbody>
<tr>
<td>高性能机</td>
<td>Performance per second</td>
<td>人类对科学和工程计算的追求是永无止境的；<br>从 PFLOPS 到 EFLOPS，从通用回归专用；</td>
</tr>
<tr>
<td>个人计算机</td>
<td>Performance per dollar</td>
<td>小鱼吃大鱼（大中小型机），催生了CPU；<br>技术驱动：微结构和工艺技术相得益彰，Wintel“发明”应用</td>
</tr>
<tr>
<td>移动智能终端</td>
<td>Performance per watt</td>
<td>没有取代PC和服务器，而是互为补充；<br>应用驱动：基础软硬件技术趋于成熟，主要的创新来自应用模式；<br>服务器端，通过在片内集成更多的处理器核来提高性能；终端集成在CPU上的功能越来越多，形成片上系统（SOC）</td>
</tr>
</tbody>
</table>
</div>
<p>发展趋势：</p>
<ul>
<li>基础硬件趋于成熟：<ul>
<li>摩尔定律发展速度放缓，并将在2020年前后遭遇物理极限</li>
<li>CPU 在主频、功耗、核数等方面遇到了障碍，更新速度变慢；Intel CPU 单核性能在2010-2012年间逼近“天花板” </li>
<li>新材料不会替代晶体管，而是对晶体管的补充</li>
</ul>
</li>
<li>应用创新方兴未艾：<ul>
<li>云计算和新型移动终端的兴起改变了传统信息化平台的应用模式</li>
<li>IT 产业的商业模式在经历了从 IBM 时代的纵向整合模式到 Intel 时代的横向整合模式后，正重新经历从横向到纵向的螺旋式上升过程</li>
</ul>
</li>
<li><strong>硅平台成为应用创新的重要平台</strong>：<ul>
<li>通用 CPU 片内将集成专用处理单元（GPU/众核、智能/安全处理器<br>等），在晶体管层面与应用结合（原来主要在软件层面与应用结合）</li>
</ul>
</li>
</ul>
<h2 id="计算机体系结构发展中碰到的“墙”"><a href="#计算机体系结构发展中碰到的“墙”" class="headerlink" title="计算机体系结构发展中碰到的“墙”"></a>计算机体系结构发展中碰到的“墙”</h2><p>1980’s：存储墙</p>
<ul>
<li>CPU变快，内存只变大不变快</li>
<li><strong>80% 的晶体管用于片内高速缓存等</strong></li>
</ul>
<p>2000’s：功耗墙</p>
<ul>
<li>以 Intel 放弃 4GHz 的 Pentium IV 为标志，终止复杂的高主频设计</li>
<li><strong>多核设计成为主流</strong></li>
</ul>
<p>未来还有可能碰到的“墙” ：</p>
<ul>
<li>带宽墙：“茶壶里倒饺子”（性能和带宽 1-2FLOPS : 1BPS 的关系）</li>
<li>成本墙：太贵了做不起（目前只剩 Intel、IBM、TSMC 三家）或用不起<br>（10nm 以后单片成本反而增加）</li>
<li>应用墙：16 核以上的 CPU 卖给谁？量大面广的应用需要多少核？</li>
</ul>
<h2 id="未来可能会流行的CPU结构"><a href="#未来可能会流行的CPU结构" class="headerlink" title="未来可能会流行的CPU结构"></a>未来可能会流行的CPU结构</h2><p>「多核 + 向量处理」 ：商业主流结构</p>
<ul>
<li>典型：Sandy Bridge, Bulldozer, Power7, BG/Q……..</li>
<li>向量的位宽：64 / 128 / 256 / ……</li>
</ul>
<p>「众核」：同构的基于分片的多核（tile based）</p>
<ul>
<li>典型：GPU, Tile64</li>
<li>处理器核的个数：64 / 128 / 512 / 1024 </li>
</ul>
<p>「带有协处理器的异构多核」</p>
<ul>
<li>典型：CELL</li>
<li>通用处理器＋专用的协处理器</li>
<li>多核+向量处理+专用处理器可能是未来主流结构</li>
</ul>
<h1 id="计算机体系结构设计的基本原则"><a href="#计算机体系结构设计的基本原则" class="headerlink" title="计算机体系结构设计的基本原则"></a>计算机体系结构设计的基本原则</h1><ul>
<li>平衡性：结构设计要统筹兼顾</li>
<li>局部性：结构设计要重点突出</li>
<li>并行性：人多力量大，开发各个层次的并行性</li>
<li>虚拟化：自己麻烦点，让用户好用点</li>
</ul>
<h2 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h2><ol>
<li>木桶原理：<ul>
<li>短板决定总体性能；</li>
</ul>
</li>
<li>访存和计算机的平衡：<ul>
<li>经验定律使然，为保持通用性，峰值浮点运算速度（MFLOPS）和峰值访存带宽（MB/s）为 1:1 左右；</li>
</ul>
</li>
<li>Amdahl定律（关注短板）：<ul>
<li>通过使用某种较快的执行方式所获得的性能的提高，受可使用这种较快执行方式的时间所占的百分比例的限制；</li>
</ul>
</li>
</ol>
<h2 id="开发局部性"><a href="#开发局部性" class="headerlink" title="开发局部性"></a>开发局部性</h2><ol>
<li>计算机中的局部性事件：<ul>
<li>指令局部性：指令顺序执行，循环体中的指令</li>
<li>访存局部性：时间局部性和 空间局部性</li>
<li>转移局部性：同一条转移指令经常往同一个方向跳转（Cache、TLB、预取、转移猜测）</li>
</ul>
</li>
<li>当结构设计基于平衡后，优化性能要抓住主要矛盾，重点改进最频繁发生事件的执行效率；</li>
</ol>
<h2 id="开发并行性"><a href="#开发并行性" class="headerlink" title="开发并行性"></a>开发并行性</h2><ol>
<li>指令级并行：<ul>
<li>是过去的20年里体系结构设计者提升性能的主要途径</li>
<li>时间并行性：指令流水线</li>
<li>空间并行性：SuperScalar（Out-of-Order）和 EPIC（编译器优化） </li>
<li>进一步挖掘指令级并行的空间不大</li>
</ul>
</li>
<li>数据级并行：SIMD<ul>
<li>向量机、SSE 多媒体指令</li>
<li>作为指令级并行的有效补充，在高性能计算及流媒体等领域发挥重要作用，在专用处理器中应用较多</li>
</ul>
</li>
<li>线程级并行：<ul>
<li>线程级并行大量存在于 Internet 应用</li>
<li>多核处理器及多线程处理器</li>
</ul>
</li>
</ol>
<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><ol>
<li>虚拟化：应用和实现的“桥梁” <ul>
<li>用起来是这样的，实际上是那样的</li>
<li>逻辑上是这样的，物理上是那样的</li>
<li>宁愿自己多费点事，也要用尽量为用户提供一个好用的接口</li>
</ul>
</li>
<li>计算机中的“桥梁” <ul>
<li>操作系统对虚拟地址空间的支持（CPU 中实现 TLB）（特优） </li>
<li>多发射在维持串行编程模型的情况下提高了速度（优） </li>
<li>多线程和虚拟机技术在单一硬件上虚拟出多个 CPU（优） </li>
<li>Cache 在维持一维的地址空间的情况下提高了速度（良） </li>
<li>Cache 一致性协议在分布存储的情况下提供统一编程空间（一般）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：多发数据通路</title>
    <url>/2020/02/21/Computer-Architecture/CA-MultiDataChannel/</url>
    <content><![CDATA[<p>乱序执行时处理器提高性能的关键技术，本节主要介绍乱序执行的一些关键技术，以及各种情景下的数据通路。</p>
<a id="more"></a> 
<h1 id="乱序执行的关键技术"><a href="#乱序执行的关键技术" class="headerlink" title="乱序执行的关键技术"></a>乱序执行的关键技术</h1><h2 id="指令级并行的关键技术"><a href="#指令级并行的关键技术" class="headerlink" title="指令级并行的关键技术"></a>指令级并行的关键技术</h2><ul>
<li>「指令流水线」: 时间重叠</li>
<li>「多发射」: 空间重复</li>
<li>「乱序执行（有序结束）」: 充分利用资源<ul>
<li><strong>动态调度</strong>：前面指令因相关而等待时，后面的可继续前进。</li>
<li><strong>转移猜测</strong>：在转移条件确定前，猜测某个分支取指并执行</li>
<li><strong>非阻塞访存</strong>：提高访存指令执行效率，减少访存阻塞</li>
<li>乱序执行可以提高性能 1.5-2 倍。</li>
</ul>
</li>
</ul>
<h2 id="动态调度技术"><a href="#动态调度技术" class="headerlink" title="动态调度技术"></a>动态调度技术</h2><p>动态调度的主要作用及其思想：</p>
<ul>
<li><strong>有序进入、乱序执行、有序结束</strong></li>
<li>把读寄存器从译码中区分开来，并利用保留站等指令缓存技术避免前面的阻塞的指令影响后面指令的执行；</li>
<li>通过 ROB 对执行完的指令重新排序实现有序结束；</li>
<li>利用寄存器重命名技术保存未提交的临时结果，消除 WAW 和 WAR 相关并支持猜测性执行；</li>
</ul>
<p>影响动态调度的主要因素：</p>
<ol>
<li>指令缓存的结构：<ul>
<li>独立保留站</li>
<li>组保留站</li>
<li>全局保留站</li>
</ul>
</li>
<li>读取寄存器内容的时间：<ul>
<li>保留站前读</li>
<li>保留站后读</li>
</ul>
</li>
<li>寄存器重命名的方法：<ul>
<li>重命名寄存器和物理寄存器分开</li>
<li>重命名寄存器和物理寄存器合并</li>
</ul>
</li>
</ol>
<h1 id="动态调度流水线数据通路"><a href="#动态调度流水线数据通路" class="headerlink" title="动态调度流水线数据通路"></a>动态调度流水线数据通路</h1><h2 id="保留站的组织（指令缓存结构）"><a href="#保留站的组织（指令缓存结构）" class="headerlink" title="保留站的组织（指令缓存结构）"></a>保留站的组织（指令缓存结构）</h2><p>比较：数据通路复杂度（结果总线传送）、保留站项数、保留站效率、发射复杂度；</p>
<ol>
<li><p><strong>独立保留站</strong>：每个功能部件一个保留站<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/IndependentReservationStation.png" alt="IndependentReservationStation"></p>
<ul>
<li>每个保留站项数较少（2-4 项），只要一个写入端口一个读出端口，输出选择比较简单；</li>
<li>保留站利用率低，可能忙的忙死甚至引起堵塞，闲的闲死；</li>
<li>结果总线送到所有保留站，连线长，结果写回可能需要单独一拍；</li>
</ul>
</li>
<li><p><strong>分组保留站</strong>：同组的功能部件共享保留站<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/PacketReservationStation.png" alt="PacketReservationStation"></p>
<ul>
<li>每个保留站项数较多，每个保留站需要多个写入端口多个读出口，保留站读出可能需要单独一拍；</li>
<li>保留站效率较高；</li>
<li>结果总线不用送到每个功能部件；</li>
<li>一般划分时考虑定点、浮点、访存；</li>
</ul>
</li>
<li><p><strong>全局保留站</strong>：所有功能部件共享保留站<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/GlobalReservationStation.png" alt="GlobalReservationStation"></p>
<ul>
<li>保留站项数很多，读出写入端口都很多，保留站读出时间长，保留站控制很复杂</li>
<li>保留站效率很高</li>
<li>结果总线只送到全局保留站</li>
</ul>
</li>
</ol>
<p>不同处理器的保留站组织：<br><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/CompareReservationStation.png" alt="CompareReservationStation"></p>
<h2 id="寄存器与保留站的关系"><a href="#寄存器与保留站的关系" class="headerlink" title="寄存器与保留站的关系"></a>寄存器与保留站的关系</h2><p>主要根据读取寄存器值的时机来划分；   </p>
<ol>
<li><p><strong>保留站前读寄存器</strong>：寄存器的输出作为保留站的输入<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/PrestationReadRegister.png" alt="PrestationReadRegister"></p>
<ul>
<li>操作数没准备好就读寄存器，保留站侦听结果总线获取没写回的值；</li>
<li>有序发射：有序读寄存器</li>
<li>保留站中值的来源：寄存器、重命名寄存器、进入保留站时侦听、进入保留站后侦听；</li>
<li>保留站中有值域，较复杂；</li>
<li>寄存器读端口数为发射宽度；</li>
</ul>
</li>
<li><p><strong>保留站后读寄存器</strong>：保留站的输出作为寄存器的输入<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/AfterstationReadRegister.png" alt="AfterstationReadRegister"></p>
<ul>
<li>保留站确信所有值都已经准备好后再读寄存器，有可能有 Forward 的情况；</li>
<li>乱序发射：乱序读寄存器</li>
<li>保留站中无值域，较简单；</li>
<li>寄存器读端口数为相应功能部件数；</li>
</ul>
</li>
</ol>
<p><strong>保留站前（后）读寄存器的处理器比较</strong>：</p>
<ul>
<li>似乎保留站后读寄存器占了上风<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/CompareReadRegister.png" alt="CompareReadRegister"></li>
</ul>
<h2 id="寄存器重命名方法"><a href="#寄存器重命名方法" class="headerlink" title="寄存器重命名方法"></a>寄存器重命名方法</h2><p><strong>双重作用：</strong></p>
<ul>
<li>例外或转移猜测错误时取消后面操作；</li>
<li>解决 WAR 和 WAW 相关；</li>
</ul>
<p><strong>核心思想：</strong></p>
<ul>
<li>一个操作写寄存器时重命名到其他寄存器；</li>
<li>一个操作结束时再写到结构寄存器；</li>
</ul>
<p><strong>重命名方法多种多样，不拘一格</strong>—-总之只要找到一个地方临时放一下数据</p>
<ol>
<li><strong>软件寄存器重命名</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/SoftwareRegisterRename.png" alt="SoftwareRegisterRename"></li>
<li><strong>重命名到保留站</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/RenameToReservedStation.png" alt="RenameToReservedStation"></li>
<li><strong>重命名到 ROB</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/RenameToROB.png" alt="RenameToROB"></li>
<li><strong>重命名到发射队列</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/RenameToIssueQueue.png" alt="RenameToIssueQueue"></li>
<li><strong>建立逻辑寄存器到物理寄存器的映射</strong>：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/MapLogicalRegisterPhysicalRegister.png" alt="MapLogicalRegisterPhysicalRegister"></li>
</ol>
<h2 id="硬件重命名的分类"><a href="#硬件重命名的分类" class="headerlink" title="硬件重命名的分类"></a>硬件重命名的分类</h2><ol>
<li><p>重命名寄存器和结构寄存器分开：</p>
<ul>
<li>重命名到保留站、ROB、专门的重命名寄存器、发射队列</li>
</ul>
</li>
<li><p>重命名寄存器和结构寄存器不分开：</p>
<ul>
<li>为每个逻辑寄存器动态分配物理寄存器，需要建立逻辑寄存器和物理寄存器之间的映射表。</li>
<li>映射表可以是 RAM（多逻辑 → 单物理）的方式，即有逻辑寄存器那么多项，也可以是 CAM（单逻辑→多物理）的方式，即有物理寄存器那么多项。</li>
</ul>
</li>
</ol>
<h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p><strong>独立重命名寄存器的重命名算法</strong>：</p>
<ol>
<li>描述：假设保留站前读寄存器<ul>
<li>译码阶段<ul>
<li>为目标寄存器分配一个空闲的重命名寄存器</li>
<li>为源寄存器找到相应的重命名或结构寄存器号</li>
<li>读操作数（注意三种操作数来源）并送入保留站</li>
</ul>
</li>
<li>发射阶段<ul>
<li>在保留站中找操作数准备好的操作进行运算，不涉及重命名</li>
</ul>
</li>
<li>执行阶段<ul>
<li>执行结果写回到重命名寄存器</li>
<li>写回到侦听该重命名寄存器值的保留站</li>
<li>不写回结构寄存器</li>
</ul>
</li>
<li>提交阶段<ul>
<li>把重命名寄存器的值写回到相应的结构寄存器</li>
<li>释放相应的重命名寄存器</li>
</ul>
</li>
<li>转移猜错或例外<ul>
<li>取消后面的已经建立的重命名关系</li>
<li>把结构寄存器的状态都置为有效</li>
<li>把重命名寄存器的状态都置为空</li>
</ul>
</li>
<li>重命名寄存器的状态<ul>
<li>EMPTY：表示该寄存器没有被重命名（重命名后又已经被释放）</li>
<li>MAPPED：表示已经被重命名但结果没有写回</li>
<li>WRITEBACK：表示结果已经写回重命名寄存器但没有Commit到结构寄存器</li>
</ul>
</li>
<li>结构寄存器的状态<ul>
<li>VALID：表示相应寄存器的值可用</li>
<li>INVALID：表示相应寄存器的值不可用</li>
</ul>
</li>
<li>映射关系<ul>
<li>可在结构寄存器中增加一个指向重命名寄存器的重命名寄存器号域        </li>
</ul>
</li>
</ul>
</li>
<li>图示：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/IndependentRenameRegister.png" alt="IndependentRenameRegister"></li>
</ol>
<p><strong>使用物理寄存器堆的重命名算法</strong>：</p>
<ol>
<li>描述：假设保留站后读寄存器<ul>
<li>译码阶段<ul>
<li>把目标寄存器映射到一个空闲的物理寄存器</li>
<li>为源寄存器根据依赖关系找到相应的物理寄存器号</li>
<li>把重命名后的寄存器号写入保留站</li>
</ul>
</li>
<li>发射阶段<ul>
<li>判断所需的操作数是否已经准备好，或（Forwarding 情况下）正在写回</li>
<li>从物理寄存器或结果总线中读寄存器的值</li>
</ul>
</li>
<li>执行阶段<ul>
<li>执行结果根据目标物理寄存器号写回到物理寄存器</li>
<li>不用写回到保留站</li>
</ul>
</li>
<li>提交阶段<ul>
<li>修改重命名表确认目标寄存器的重命名关系</li>
<li>释放老的目标寄存器重命名关系</li>
</ul>
</li>
<li>转移猜错或例外<ul>
<li>修改重命名表取消后面的已经建立的重命名关系</li>
<li>把状态为 MAPPED 或 WRITEBACK 的都置为 EMPTY</li>
<li>确认状态为 COMMIT 的映射为相应逻辑寄存器的最新映射</li>
</ul>
</li>
</ul>
</li>
<li>核心是重命名表：<ul>
<li>可以用 CAM 或 RAM 的方法，以 CAM 的方法为例</li>
<li>项数与物理寄存器一样</li>
</ul>
</li>
<li>主要包括三个域：<ul>
<li>name：相应的逻辑寄存器号</li>
<li>state：状态，<ul>
<li>EMPTY：表示该寄存器没有被重命名（重命名后又已经被释放）；</li>
<li>MAPPED：表示已经被重命名但结果没有写回；</li>
<li>WRITEBACK：表示结果已经写回重命名寄存器但没有 Commit 到结构寄存器；</li>
<li>COMMIT：表示结果已经被确认</li>
</ul>
</li>
<li>valid：在一个逻辑寄存器对应多个物理寄存器的情况下表示最新映射</li>
</ul>
</li>
<li>图示：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/PhysicalRegisterRenameRegister.png" alt="PhysicalRegisterRenameRegister"></li>
</ol>
<p><strong>不同处理器的重命名方法</strong>：<br><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/CompareRenamingMethod.png" alt="CompareRenamingMethod"></p>
<ul>
<li>UltraSparc 没有使用寄存器重命名</li>
</ul>
<h1 id="常见处理器的数据通路"><a href="#常见处理器的数据通路" class="headerlink" title="常见处理器的数据通路"></a>常见处理器的数据通路</h1><h2 id="乱序执行的数据通路"><a href="#乱序执行的数据通路" class="headerlink" title="乱序执行的数据通路"></a>乱序执行的数据通路</h2><ol>
<li>三方面考虑：<ul>
<li>保留站结构（独立、分组、全局）</li>
<li>读操作数时机（译码：先读寄存器再保留站、发射： 先保留站再寄存器）</li>
<li>重命名方式（重命名寄存器与结构寄存器分开、不分开）</li>
</ul>
</li>
<li>因此一共有 12 种组合；</li>
</ol>
<h2 id="数据通路类型"><a href="#数据通路类型" class="headerlink" title="数据通路类型"></a>数据通路类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>单项保留站</th>
<th>分组保留站</th>
<th>全局保留站</th>
</tr>
</thead>
<tbody>
<tr>
<td>保留站前读操作数<br>独立重命名寄存器</td>
<td>PPC603,PPC604 ,<br>PPC620,K5,<br>Godson-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留站前读操作数<br>物理寄存器堆</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留站后读操作数<br>独立重命名寄存器</td>
<td></td>
<td>PA-8700</td>
<td>Pentium Pro</td>
</tr>
<tr>
<td>保留站后读操作数<br>物理寄存器堆</td>
<td></td>
<td>ES-9000,Power4,<br>Alpha 21264,MIPS<br>R10000,Godson-2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="常见处理器的数据通路（最近）"><a href="#常见处理器的数据通路（最近）" class="headerlink" title="常见处理器的数据通路（最近）"></a>常见处理器的数据通路（最近）</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/ProcessorDataChannel1.png" alt="ProcessorDataChannel1"></p>
<p><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/ProcessorDataChannel2.png" alt="ProcessorDataChannel2"></p>
<p><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/ProcessorDataChannel3.png" alt="ProcessorDataChannel3"></p>
<h1 id="多发射结构数据通路"><a href="#多发射结构数据通路" class="headerlink" title="多发射结构数据通路"></a>多发射结构数据通路</h1><h2 id="多发射的情况"><a href="#多发射的情况" class="headerlink" title="多发射的情况"></a>多发射的情况</h2><ol>
<li><p>数据通路变宽：</p>
<ul>
<li>Alpha21264：取指 4 条，发射 6 条，写回 6 条，Commit 11 条；</li>
<li>寄存器读端口变多；</li>
<li>访存端口要求也增加，如 Alpha 有两个访存部件，通过倍频实现；</li>
</ul>
</li>
<li><p>同一拍发射的指令之间的相关：</p>
<ul>
<li>如在重命名阶段发生同一拍之间的相关；</li>
</ul>
</li>
<li><p>流水线复杂度与发射宽度成平方关系：</p>
<ul>
<li>如发射队列（保留站）变大（读端口变多+侦听端口变多）；</li>
<li>如寄存器重命名端口变多同一拍重命名指令相关；</li>
</ul>
</li>
</ol>
<h2 id="多发射时的寄存器重命名"><a href="#多发射时的寄存器重命名" class="headerlink" title="多发射时的寄存器重命名"></a>多发射时的寄存器重命名</h2><p>假设开始时与逻辑寄存器 R1,R2,R3 对应的最近的物理寄存器分别为 PR1,PR2,PR3, 在同一拍中对如下指令进行寄存器重命名：   </p>
<p><img src="http://img.thebetterkong.cn/blog/CA-MultiDataChannel/MultiIsuueRegisterRename.png" alt="MultiIsuueRegisterRename"></p>
<h2 id="多发射的其它设计问题"><a href="#多发射的其它设计问题" class="headerlink" title="多发射的其它设计问题"></a>多发射的其它设计问题</h2><ol>
<li><p>同时提交多条指令：</p>
<ul>
<li>重命名把有序变成无序，要除了“前后看”，还要“左右看”；</li>
<li>提交把无序变成有序，也要“左右看”：同一拍可以提交多条，第二条是否提交要看第一条是否提交等；</li>
</ul>
</li>
<li><p>指令发射和读寄存器：</p>
<ul>
<li>多端口寄存器是物理设计的难点：会增加延迟、面积、功耗，四发射结构一般至少需要四写八读的寄存器堆；</li>
<li>指令发射逻辑：从保留站中同时找出多条数据准备好的指令，为了性能要适当考虑在数据准备好的情况下前面的指令先发射；</li>
</ul>
</li>
<li><p>多功能部件：</p>
<ul>
<li>增加回端口：寄存器堆、重命名寄存器表、ROB、发射队列</li>
<li>尤其是多访存部件会大大增加设计复杂度</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：转移猜测</title>
    <url>/2020/02/21/Computer-Architecture/CA-TransferPrediction/</url>
    <content><![CDATA[<p>本节从分析程序的转移行为出发，分析了软硬件解决控制相关的方法，其中重点介绍了硬件动态转移预测，介绍了一些常见的分支预测器。</p>
<a id="more"></a> 
<h1 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h1><p>提高流水线效率的技术：</p>
<ol>
<li><p>指令流水线：</p>
<ul>
<li>多发射：多车道</li>
<li>动态调度：允许超车</li>
</ul>
</li>
<li><p>喂饱“饥饿”的运算器：</p>
<ul>
<li>转移猜测：提供足够的指令</li>
<li>存储管理：提供足够的数据</li>
<li>冯诺依曼结构：存储程序和顺序执行</li>
</ul>
</li>
</ol>
<h1 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h1><h2 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h2><ul>
<li>如果转移指令计算下一条指令地址在 EX 阶段计算，下一条指令等 2 拍 ；</li>
<li><p>解决方法：</p>
<ol>
<li><p>使用专门的地址运算部件把地址<strong>计算提前到译码阶段</strong>可以少等一拍：<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/EXToDecode.png" alt="EXToDecode"></p>
</li>
<li><p>使用一个<strong>delay slot</strong>可以不用等待，但是多发射情况下延迟槽成为需要专门照顾的负担：<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/DelaySlotExample.png" alt="DelaySlotExample"></p>
</li>
</ol>
</li>
</ul>
<h2 id="转移指令对性能的影响"><a href="#转移指令对性能的影响" class="headerlink" title="转移指令对性能的影响"></a>转移指令对性能的影响</h2><ol>
<li><p>分支指令的影响是开发指令级并行性的重要障碍：</p>
<ul>
<li>一条指令流中，平均每5-7条指令中就有一条是分支指令，也即基本块大小为5-7条指令</li>
</ul>
</li>
<li><p>增大发射宽度：</p>
<ul>
<li>在发射宽度为 n 的处理器中，遇到分支指令的速度也快了 n 倍 </li>
</ul>
</li>
<li><p>增加流水线深度：</p>
<ul>
<li>流水线越深，处理分支指令所需要的时钟周期数就越多</li>
</ul>
</li>
<li><p>例子：</p>
<ul>
<li>假设平均每 8 条指令中有一条转移指令，某处理器采用 4 发射结构，第 10 级流水解决转移地址相关（即第10级流水算出转移方向和目标）：<ul>
<li>每次转移出问题，流水线停顿 9 拍，这 9 拍可发射 36 条指令，即浪费的指令带宽</li>
</ul>
</li>
</ul>
<ol>
<li>在 A 系统中不进行转移预测，遇到转移指令就等待：<ul>
<li>指令带宽浪费：$36/(36+8)=82\%$； //相当于每发射 8 条指令，浪费一次</li>
</ul>
</li>
<li>在 B 系统中进行简单的转移预测，转移猜错率为 50%，那么平均每 16 条指令预测错误一次:<ul>
<li>指令带宽浪费：$36/(36+16)=75\%$</li>
</ul>
</li>
<li>在C系统中，转移指令猜错率为 10%，那么平均每 80 条指令预测错误一次:<ul>
<li>指令带宽浪费：$36/(36+80)=31\%$</li>
</ul>
</li>
<li>在D系统中，转移指令猜错率为 4%，平均每 200 条指令预测错误一次:<ul>
<li>取指令带宽浪费：$36/(36+200)=15\%$</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="转移指令的属性"><a href="#转移指令的属性" class="headerlink" title="转移指令的属性"></a>转移指令的属性</h2><ol>
<li><p>条件转移与无条件转移：</p>
<ul>
<li>条件转移：需等待条件确定后才能取指，程序中多数转移指令是条件转移指令</li>
<li>无条件转移：不用判断条件就转移，如call/return</li>
</ul>
</li>
<li><p>直接转移与间接转移：</p>
<ul>
<li>直接转移：转移目标根据指令内容直接得出</li>
<li>间接转移：转移目标在寄存器中</li>
</ul>
</li>
<li><p>相对转移与绝对转移：</p>
<ul>
<li>相对转移：转移目标为当前PC值加上偏移量</li>
<li>绝对转移：转移目标由指令或寄存器内容直接给出</li>
</ul>
</li>
</ol>
<p>由上可知：理论上有8种组合，实际上不实现所有组合；</p>
<h2 id="MIPS-指令系统的转移指令"><a href="#MIPS-指令系统的转移指令" class="headerlink" title="MIPS 指令系统的转移指令"></a>MIPS 指令系统的转移指令</h2><p><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/MIPSTransferInstruction.png" alt="MIPSTransferInstruction"></p>
<h1 id="程序的转移行为"><a href="#程序的转移行为" class="headerlink" title="程序的转移行为"></a>程序的转移行为</h1><p>大多数的转移指令具有强烈的一个跳转方向，具有挑战性的工作是预测其余的转移指令的跳转方向；</p>
<h2 id="分支的可预测性"><a href="#分支的可预测性" class="headerlink" title="分支的可预测性"></a>分支的可预测性</h2><ol>
<li><p>利用单个转移指令的重复性（基于模式的预测方法）：</p>
<ul>
<li><strong>循环型分支：</strong><ul>
<li>for 型循环：TT…TN（成功 n 次后跟一次不成功 ） </li>
<li>while 型循环：NN…NT（不成功 n 次后跟一次成功）</li>
</ul>
</li>
<li><strong>周期重复模式型分支：</strong><ul>
<li>定长重复模式类分支：$\{pat\}^q$, |pat|=k （每隔 k 个分支模式就重复一次）</li>
<li>块模式类分支：$\{T^n N^m\}^q$， 成功 n 次，不成功 m 次，如此循环</li>
</ul>
</li>
</ul>
</li>
<li><p>利用不同转移指令之间的关系（基于相关的预测方法）：</p>
<ul>
<li><strong>利用指令间的方向相关</strong><ul>
<li>两个分支的条件（完全或部分）基于相同或相关的信息</li>
<li>第二个分支的结果基于第一个分支的结果产生<br> <img src="https://img-blog.csdnimg.cn/20200122143549719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="DirectionalCorrelation"></li>
</ul>
</li>
<li><strong>利用指令间的路径相关</strong><ul>
<li>如果一个分支是通向当前分支的前 n 条分支之一，则称该分支处在当前分支的路径之上（Y 和 Z 在通往 X 的路径上）</li>
<li>处在当前分支路径上的分支与当前分支结果之间的相关称为<strong>路径相关</strong>；<br> <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/PathRelated.png" alt="PathRelated"></li>
</ul>
</li>
</ul>
</li>
<li><p>利⽤函数调⽤的递归性：</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>分支指令是很频繁的；</li>
<li>分支指令有较好的局部性；</li>
<li>分支指令具有可预测性；</li>
</ul>
<h1 id="解决转移条件相关的方法"><a href="#解决转移条件相关的方法" class="headerlink" title="解决转移条件相关的方法"></a>解决转移条件相关的方法</h1><h2 id="方法综述"><a href="#方法综述" class="headerlink" title="方法综述"></a>方法综述</h2><ol>
<li>阻塞：<ul>
<li>等待直到转移条件确定</li>
</ul>
</li>
<li>用延迟槽容忍延迟：<ul>
<li>延迟槽指令来源</li>
</ul>
</li>
<li>编译器优化：<ul>
<li>循环：循环展开减少转移指令、软流水减少阻塞</li>
<li>分支：全局代码调度（越过分支调度指令）</li>
<li>函数调用：inline</li>
</ul>
</li>
<li>转换为数据相关：<ul>
<li>条件指令、谓词</li>
</ul>
</li>
<li>硬件转移预测：<ul>
<li>转移条件未确定时预测转移是否成功</li>
<li>静态与动态预测</li>
</ul>
</li>
</ol>
<h2 id="软件方法解决控制相关"><a href="#软件方法解决控制相关" class="headerlink" title="软件方法解决控制相关"></a>软件方法解决控制相关</h2><h3 id="利用延迟槽"><a href="#利用延迟槽" class="headerlink" title="利用延迟槽"></a>利用延迟槽</h3><ol>
<li>延迟槽指令的来源：<ul>
<li>来自转移指令前：肯定执行</li>
<li>来自转移目标地址：转移成功才执行</li>
<li>来自转移不成功地址：转移不成功才执行</li>
</ul>
</li>
<li>单延迟槽的编译效果：<ul>
<li>能为 60% 左右的转移延迟槽找到有效操作</li>
<li>大约 80% 的延迟槽指令用于有效计算</li>
<li>因此大约 50% (60% x 80%) 的延迟槽操作用于有效计算</li>
</ul>
</li>
<li>延迟槽的限制：<ul>
<li>超流水情况下一条延迟槽不够</li>
<li>多发射情况下延迟槽反而成为需要特殊照顾的兼容负担</li>
</ul>
</li>
</ol>
<h3 id="软件循环展开消除控制相关"><a href="#软件循环展开消除控制相关" class="headerlink" title="软件循环展开消除控制相关"></a>软件循环展开消除控制相关</h3><p><strong>方法</strong>：软件展开两个循环</p>
<ol>
<li>循环展开</li>
<li>寄存器重命名</li>
<li>变换次序<br> <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/SoftwareLoopUnfolding.png" alt="SoftwareLoopUnfolding"></li>
</ol>
<p><strong>软件循环展开的不足：</strong></p>
<ul>
<li>有些循环不好展开（如循环次数不定的循环）</li>
<li>增加指令 CACHE 的负担</li>
</ul>
<p><strong>循环的数据相关：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/CyclicDataCorrelation.png" alt="CyclicDataCorrelation"></p>
<ul>
<li>循环内相关：<ul>
<li>S2 使用同一次循环中 S1 计算的 A[i+1]。</li>
<li>导致一个循环体内的多条指令不能并行执行；</li>
</ul>
</li>
<li>循环间（loop-carried）相关：<ul>
<li>本次循环计算的 A[i+1]/B[i+1] 将被下一次循环使用。</li>
<li>导致多个循环体不能并行执行</li>
</ul>
</li>
<li><strong>把循环间相关转换为循环内相关</strong></li>
</ul>
<p><strong>循环展开的条件：</strong></p>
<ul>
<li><strong>数组元素相关的判断：</strong><ul>
<li>数组元素两种类型：<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/ArrayElementType.png" alt="ArrayElementType"></li>
</ul>
</li>
<li><strong>名字相关的消除</strong>：重命名技术</li>
<li><strong>指针相关的判断</strong>：只有一些经验的方法</li>
</ul>
<p><strong>循环间相关的解决—-软流水：</strong></p>
<ul>
<li>新循环体的每个操作来自不同的循环体，以分开数据相关的指令，相当于软件的 Tomasulo 算法；</li>
<li>符号级循环展开，比真正循环展开代码开销小；<br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/SoftRunningWater1.png" alt="SoftRunningWater1"><br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/SoftRunningWater2.png" alt="SoftRunningWater2"></li>
</ul>
<h3 id="把控制相关转换成数据相关"><a href="#把控制相关转换成数据相关" class="headerlink" title="把控制相关转换成数据相关"></a>把控制相关转换成数据相关</h3><p><strong>把条件转移指令转换为条件执行：</strong></p>
<ul>
<li>条件指令的条件作为指令执⾏阶段的⼀个输⼊,实际上把控制相关转化为数据相关</li>
<li><code>if (x) then A = B op C else NOP</code> （在执行阶段判断x是否为0） //CMOV A ,B , X<br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/MOVEInstruction.png" alt="MOVEInstruction"></li>
<li>只有条件为真时才写结果，为假时不写结果也不发生例外</li>
<li>RISC 系统如 Alpha, MIPS, PowerPC, SPARC 都增加了条件 MOVE 指令; PA-RISC 的nullification</li>
<li>EPIC: 使用 64 个 1位 的谓词寄存器来选择是否写执行结果</li>
</ul>
<p><strong>条件指令的缺点：</strong></p>
<ul>
<li>条件为假时仍需要1拍，占用发射槽和功能部件</li>
<li>条件未确定仍需要在执行前等待，转移猜测反而在执行后</li>
<li>条件复杂时会降低效率，因为条件在执行时才确定</li>
</ul>
<p><strong>条件指令举例：</strong></p>
<ul>
<li>假设转移指令没有延迟槽</li>
<li>条件指令可消除简单的条件转移，对取绝对值等操作有用</li>
<li>条件指令仍要在执行前等待条件，注意例外的处理<br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/ExampleConditionalInstructions.png" alt="ExampleConditionalInstructions"></li>
</ul>
<h2 id="硬件动态转移预测"><a href="#硬件动态转移预测" class="headerlink" title="硬件动态转移预测"></a>硬件动态转移预测</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ol>
<li><strong>在取指或译码阶段预测==转移是否成功==以及==转移目标==进行后续指令的取指</strong><ul>
<li>以减少指令流水线由于控制相关而堵塞</li>
</ul>
</li>
<li><strong>在执行阶段判断转移预测是否正确</strong><ul>
<li>如果猜测正确，则正常提交</li>
<li>如果猜测错误，则取消该转移指令及其后续指令</li>
</ul>
</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>猜测依据：</p>
<ul>
<li>当前指令的地址（PC）和性质（是否转移指令）</li>
<li>过去转移指令历史记录</li>
</ul>
<p>猜测内容：</p>
<ul>
<li>转移方向、转移目标地址</li>
</ul>
<p>原理图示：<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/PrinciplesDynamicTransferPrediction.png" alt="PrinciplesDynamicTransferPrediction"></p>
<h3 id="分支处理机制的性能取决于"><a href="#分支处理机制的性能取决于" class="headerlink" title="分支处理机制的性能取决于"></a>分支处理机制的性能取决于</h3><ul>
<li>预测精度（BPA）=&gt; 设计好的预测器<ul>
<li>预测精度越高，能抽取的并行性就越多</li>
</ul>
</li>
<li>预测正确所付的代价：转到目标地址处执行所需的延迟<ul>
<li>译码时根据 IR 内容预测：有一拍的延迟槽，在 4 发射情况下有 4 条指令的延迟槽</li>
<li>取指时根据 PC 预测：没有延迟槽，需要 BTB/Trace Cache 等机制</li>
<li>MIPS R10000 无 BTAC，MIPS R12000 有 32 项 BTAC</li>
</ul>
</li>
<li>预测错所付的代价：<ul>
<li>尽量提前执行转移操作</li>
<li>Pentium II/III 和 Alpha 21264 重新刷新流水线需要 11 周期以上</li>
</ul>
</li>
</ul>
<h3 id="转移预测关键技术"><a href="#转移预测关键技术" class="headerlink" title="转移预测关键技术"></a>转移预测关键技术</h3><ol>
<li>如何保证准确的预测：根据记录的历史进行预测<ul>
<li>如何记录转移历史，记录哪些转移历史</li>
<li>记录多少转移历史</li>
<li>何时更新：更新太早，转移指令也可能被取消；更新太晚，导致转移历史不准确</li>
</ul>
</li>
<li>如何在取消猜测执行的操作时保证现场精确性<ul>
<li>增加提交流水级，在提交时修改寄存器（寄存器重命名）和内存（write buffer 机制）</li>
<li>I/O 指令的猜测执行难以取消</li>
</ul>
</li>
<li>如何识别流水线中的指令哪些需要取消，哪些不要取消<ul>
<li>例外取消一般在提交时，取消所有后续指令</li>
<li>转移取消一般在执行后，只取消部分指令</li>
<li>要求有⼀种机制来判断指令流⽔线中的每⼀条指令和错误预测的转移指令的先后关系。</li>
</ul>
</li>
<li>延迟槽指令的处理</li>
<li>每个周期多个分支预测<ul>
<li>每周期 1 个预测，基本可满足 4-6 发射需要的取指带宽</li>
</ul>
</li>
</ol>
<h3 id="高性能性能转移预测机制特征"><a href="#高性能性能转移预测机制特征" class="headerlink" title="高性能性能转移预测机制特征"></a>高性能性能转移预测机制特征</h3><ol>
<li>减少预测延迟槽 (如⽤根据 PC 预测的 BTB/BTAC 等机制）；</li>
<li>在执⾏阶段尽早确定转移结果,降低错误预测的开销；</li>
<li>在转移预测错误时要有⾼效的流⽔线刷新机制；</li>
<li>具有⾼预测精度的转移预测机制；</li>
</ol>
<h3 id="静态-动态转移预测"><a href="#静态-动态转移预测" class="headerlink" title="静态/动态转移预测"></a>静态/动态转移预测</h3><ul>
<li><strong>静态预测</strong>：总是预测转移成功或总是预测转移不成功<ul>
<li>预测转移成功：较精确，计算转移地址需要 delay slot</li>
<li>预测转移不成功：直接用 PC+4</li>
</ul>
</li>
<li><strong>动态预测</strong>：根据转移指令执行历史进行预测<ul>
<li>复杂预测技术：精确、控制复杂</li>
</ul>
</li>
<li><strong>混合预测</strong>：利用编译器的提示，结合动态和静态预测</li>
</ul>
<h3 id="局部转移预测"><a href="#局部转移预测" class="headerlink" title="局部转移预测"></a>局部转移预测</h3><ul>
<li>独立考虑单个循环的历史记录，寻找其中的重复性规律，并根据该规律预测未来的转移行为；</li>
<li>对于重复性特征明显的转移指令（如循环）效果好；</li>
<li>例子：<ul>
<li>for (I=0, I&lt;10; I++){ } </li>
<li>转移模式为 (1111111110)^n</li>
</ul>
</li>
</ul>
<h3 id="利用单个分支的重复性：BHT"><a href="#利用单个分支的重复性：BHT" class="headerlink" title="利用单个分支的重复性：BHT"></a>利用单个分支的重复性：BHT</h3><p><strong>转移历史表 BHT（Branch History Table）：</strong></p>
<ul>
<li>用 PC 的低位索引，每项 1 位 （可能两条转移指令的 PC 低位相同 ,从⽽引起冲突）</li>
<li>记录同一项上次转移是否成功，表示是否转移成功<ul>
<li>具有上述两项特征的 BHT 表，1 位，称为<strong>PHT表</strong></li>
</ul>
</li>
<li>不进行地址比较检查（cache，tag 用于地址比较检查）(因为即使预测错误也还有纠正措施)</li>
</ul>
<p><strong>问题：</strong><br><code>for(i=0;i&lt;10;i++) for(j=0;j&lt;10;j++){......}</code></p>
<ul>
<li>对循环进行猜测时，1 位 BHT（PHT）引起两次猜错：<ul>
<li>1 位 PHT 表预测时仅看该转移指令上次跳转是否成功</li>
</ul>
<ol>
<li>循环退出时，转移方向不一致</li>
<li>进入循环时，和上次退出时的转移方向不一致</li>
</ol>
</li>
</ul>
<p><strong>改进：两位BHT表—-==转移历史表==</strong></p>
<ul>
<li><strong>特点</strong>：<ul>
<li>只有连续两次猜错，才会改变猜测方向</li>
</ul>
</li>
<li><strong>要求</strong>：<ul>
<li>12 位 PC 索引：4096 项已经足够，和无穷项效果差不多；</li>
<li>BHT 表 2 位已经足够, n 位 (n&gt;2)与 2 位效果差不多；</li>
</ul>
</li>
<li><strong>预测机制</strong>：<ul>
<li><strong>执行动作</strong>：转移指令每次转移成功（这里的转移成功是指：分支真是的跳转情况）加 1，加到 3 为止；转移不成功减 1，减到 0 为止；</li>
<li><strong>预测方向</strong>：转移预测时，若相应 PHT 表项的高位为 1（计数器的值为 2 或 3）就预测跳转；高位为 0（计数器的值为 1 或 0）就预测不跳转；</li>
</ul>
</li>
<li><strong>功能结构</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/BHTStructure.png" alt="BHTStructure">    </li>
<li><strong>缺点：</strong><ol>
<li>仅能预测转移指令⽅向,⽆法预测跳转⽬标；</li>
<li>仅在译码阶段使⽤，仅只使⽤ PC 低位索引，可能把普通指令也当作转移指令进⾏预测；</li>
</ol>
</li>
<li><strong>例子说明：</strong><ul>
<li>在前述两重循环的例子中，循环预测准确率从：<ul>
<li>（8+80）/（10+100）= 80%  // “8” 外层循环错两次；“80” 内层循环错 20 次</li>
<li>提高到：（7+88）/（10+100）= 87.2%<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/BHTExample.png" alt="BHTExample"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="减少猜测延迟：转移目标缓冲器-BTB"><a href="#减少猜测延迟：转移目标缓冲器-BTB" class="headerlink" title="减少猜测延迟：转移目标缓冲器 BTB"></a>减少猜测延迟：转移目标缓冲器 BTB</h3><ul>
<li>使用 CAM 结构，在取指阶段根据当前 PC 值预测转移方向和转移地址：<ul>
<li>需要进行地址全相等比较；</li>
<li>直接预测 PC 值而不是根据指令内容计算；</li>
<li>失效时进行替换；</li>
</ul>
</li>
<li><strong>硬件结构：</strong><br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/BTBStructure.png" alt="BTBStructure"></li>
<li><strong>缺点：</strong><ol>
<li>表项复杂 ,需全相联查找，不能做⼤；</li>
<li>BTB 需配合 PHT；</li>
</ol>
</li>
</ul>
<h3 id="RAS：返回地址栈"><a href="#RAS：返回地址栈" class="headerlink" title="RAS：返回地址栈"></a>RAS：返回地址栈</h3><ul>
<li>返回地址栈（Return Addresses Stack）预测返回地址</li>
<li>函数调用时压栈，返回时从栈顶弹出作为返回地址</li>
<li>针对函数调用有很高的预测准确率</li>
</ul>
<h3 id="BHR-转移历史寄存器—-转移指令的相关性"><a href="#BHR-转移历史寄存器—-转移指令的相关性" class="headerlink" title="BHR 转移历史寄存器—-转移指令的相关性"></a>BHR 转移历史寄存器—-转移指令的相关性</h3><ul>
<li><strong>作用</strong>：记录所有转移指令的历史</li>
<li><strong>实现方式：</strong><ul>
<li><strong>移位寄存器</strong>：处理器执行转移指令，就把 BHR 左移 1 位，左移时最高位扔掉，最低位如果转移成功就填 1，否则填 0；</li>
</ul>
</li>
<li>m 位的 BHR 记录了处理器 M 次的转移历史;</li>
<li><strong>BHR 表</strong>：为每条转移指令单独记录 BHR ,再把多个 BHR 组织在⼀起的表</li>
<li>2 位分支预测之后，预测正确率难以提高，主要原因是分支指令的相关性  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(d &gt;= <span class="number">10</span>)  <span class="comment">//分支1</span></span><br><span class="line">	d = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">12</span>)  <span class="comment">//分支2依赖分支1</span></span><br><span class="line">	d = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Yeh-和-Patt-分类"><a href="#Yeh-和-Patt-分类" class="headerlink" title="Yeh 和 Patt 分类"></a>Yeh 和 Patt 分类</h3><p><strong>当前的转移依赖于两种情况：</strong></p>
<ul>
<li>该指令的过去m次转移记录：PHT（Pattern History Table） </li>
<li>程序中所有转移指令过去m次的转移记录：BHR（Branch History Register）</li>
</ul>
<p><strong>BHR 的组织：</strong></p>
<ul>
<li>“PA” 表示 per address BHR，每条转移指令都有自己的 BHR，用 PC 索引 BHR；</li>
<li>“GA” 表示 global address BHR，所有转移指令共用一个 BHR；</li>
<li>“SA” 表示 set address BHR，用 PC 的低位索引 BHR</li>
</ul>
<p><strong>PHT 的组织：</strong></p>
<ul>
<li>只用历史记录索引 PHT 表，用“g”表示</li>
<li>用全地址和历史记录一起索引 PHT 表，用“p”表示</li>
<li>使用部分地址和历史记录一起索引 PHT 表，用“s”表示</li>
</ul>
<p><strong>两层自适应预测器组合情况：</strong></p>
<ul>
<li>BHR: Branch History Register</li>
<li>PHT: Pattern History Table</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Global PHT</th>
<th>per-address PHTs</th>
<th>per-set PHTs</th>
</tr>
</thead>
<tbody>
<tr>
<td>Global BHR</td>
<td>GAg</td>
<td>GAp</td>
<td>GAs</td>
</tr>
<tr>
<td>per-address BHR</td>
<td>PAg</td>
<td>PAp</td>
<td>PAs</td>
</tr>
<tr>
<td>per-set BHR</td>
<td>SAg</td>
<td>SAp</td>
<td>SAs</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p><strong>GAg 结构：</strong></p>
<ul>
<li>BHR 和 PHT 都是全局的，全局的 BHR 又称为 GHR（Global History Rigster）。</li>
<li>其中 GHR 存储过去 k 次转移历史，并用 GHR 的 k 位值去索引 $2^k$ 个入口的 PHT，</li>
<li>PHT 每项利用 2 位饱和计数器进行预测。<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/GAg.png" alt="GAg"></li>
</ul>
</li>
<li><p><strong>GAs 结构：</strong></p>
<ul>
<li>其中 BHR 表还是全局的，只有 k 位；</li>
<li>PHT 表用 k 位的 GHR 和 PC 的低 n 位进行索引，因此一共有 $2^{k+n}$项。<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/GAs.png" alt="GAs"></li>
</ul>
</li>
<li><p><strong>SAg(k) 的结构：</strong></p>
<ul>
<li>PHT 是全局的，BHR 寄存器一共有 $2^n$ 个，每个 BHR 为 k 位。</li>
<li>先用 PC 的低 n 位索引 GHR，然后再用 GHR 的值索引 PHT 表。<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/SAg(k" alt="SAg(k)">.png)</li>
</ul>
</li>
<li><p><strong>PAp(4) 结构：</strong></p>
<ul>
<li>每个 PC 值一个 BHR 寄存器，每个 BHR 为 k 位。</li>
<li>先用 PC 索引 BHR，然后再用 BHR 的值和 PC 一起索引 PHT 表。<br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/PAp(4" alt="PAp(4)">.png)</li>
</ul>
</li>
</ol>
<h3 id="分支别名干扰问题"><a href="#分支别名干扰问题" class="headerlink" title="分支别名干扰问题"></a>分支别名干扰问题</h3><p><strong>模式：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/BranchAliasModel.png" alt="BranchAliasModel"></p>
<ul>
<li>无论 BHR 和 PHT 表如何增大，效果也不是很明显</li>
<li>主要原因是不同分支地址访问同一个 PHT，造成分支干扰</li>
<li>⾃从⼆级转移预测器出现来，预测精度⼀般在 92% 左右 </li>
</ul>
<p><strong>分支别名干扰的消除：</strong></p>
<ol>
<li><strong>Gselect</strong>:全局历史 m 位和地址 n 位组合寻址<br> <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/Gselect.png" alt="Gselect"></li>
<li><strong>Gshare</strong>: 部分地址和全局历史异或寻址<br> <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/Gshare.png" alt="Gshare">    </li>
</ol>
<ul>
<li>性能分析结果表明：gshare 稍微好于 gselect</li>
</ul>
<h3 id="Agree-分支预测"><a href="#Agree-分支预测" class="headerlink" title="Agree 分支预测"></a>Agree 分支预测</h3><p><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/Agree.png" alt="Agree"></p>
<ul>
<li>分支预测缓冲区 BTB：<ul>
<li>在指令 Cache 或转移目的地址缓存（BTB）中为每一个转移都加上一个偏向位，偏向位中保存的是这条指令最常见的转移方向。</li>
<li>偏向位依据：前面分析的多数转移指令具有强烈跳转或者不跳转倾向性</li>
</ul>
</li>
<li>Gshare预测器：<ul>
<li>2 位计数器不是用来预测转移方向的，而是用来决定是否按照偏向位来转移的。</li>
</ul>
</li>
<li>当转移的实际结果与偏向位一致时，计数器加一，否则减一</li>
</ul>
<ol>
<li><p><strong>举例计算说明：</strong></p>
<ul>
<li>2条分支预测正确率分别为 85%和15%，使用同一项PHT</li>
<li>传统方法 - 两条分支结果相反（分支冲突）的概率:<br>   (br1taken, br2nottaken) + (br1nottaken, br2taken) = (85% <em> 85%) + (15% </em> 15%) = 74.5%</li>
<li>Agree 方法–两条分支结果相反（分支冲突）的概率:<br>   (br1agree, br2disagree) + (br1disagree, br2agree)= (85% <em> 15%) + (15% </em> 85%) = 25.5%</li>
</ul>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>2 条不同方向的分支可以映射到同一表项</li>
<li>偏向位不变，只改变 PHT</li>
<li>gcc 误预测在 64k 的 PHT 下减少 8.6%, 1K 的 PHT 误预测减少 33.3%</li>
</ul>
</li>
<li><p><strong>应用</strong>：HP 的 PA-8700 处理器</p>
</li>
</ol>
<h3 id="Bi-Mode-预测器"><a href="#Bi-Mode-预测器" class="headerlink" title="Bi-Mode 预测器"></a>Bi-Mode 预测器</h3><p><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/Bi-Mode.png" alt="Bi-Mode"></p>
<ul>
<li>Bi-mode 和Agree 分支预测的思想一致，不过它是把容易发生跳转和不跳转的分支放入不同的 PHT。</li>
<li>它由3 部分组成，一部分用来选择 PHT，另外两部分表示 PHT 的方向，分别为跳转和不跳转，PHT 的方向被全局历史索引。</li>
<li>由于对预测器的选择，达到了针对每条转移的程度，因此命中率又有所提高。</li>
</ul>
<h3 id="组合分支预测器"><a href="#组合分支预测器" class="headerlink" title="组合分支预测器"></a>组合分支预测器</h3><ul>
<li>不同的分支预测只能对某类的分支行为有效</li>
<li>不同分支预测组合起来，根据分支行为选不同分支预测器<br>  <img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/CombinedBranchPredictor.png" alt="CombinedBranchPredictor"></li>
</ul>
<h2 id="动态转移猜测小结"><a href="#动态转移猜测小结" class="headerlink" title="动态转移猜测小结"></a>动态转移猜测小结</h2><ul>
<li><strong>转移的重复性和偏向性</strong>：BHT</li>
<li><strong>转移指令的相关性问题</strong>：两层转移预测</li>
<li><strong>分支别名干扰问题</strong>：Gshare等</li>
<li><strong>混合预测器</strong>：不同的分支预测只能对某类的分支行为有效<br><strong>不要执着于具体办法，关键是抓住应用程序的特点</strong></li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/Example.png" alt="Example"></p>
<h2 id="常见处理器的分支预测"><a href="#常见处理器的分支预测" class="headerlink" title="常见处理器的分支预测"></a>常见处理器的分支预测</h2><p><img src="http://img.thebetterkong.cn/blog/CA-TransferPrediction/All.png" alt="All"></p>
<h2 id="分支预测未来"><a href="#分支预测未来" class="headerlink" title="分支预测未来"></a>分支预测未来</h2><ul>
<li><strong>进一步提高很难：</strong><ul>
<li>95%－98％ 左右</li>
<li>工业界分支预测越做越大，Alpha21464 有 48KB</li>
</ul>
</li>
<li><strong>进一步提高很有意义：</strong><ul>
<li>预测精度提高 0.5%，10000 条分支指令就能减少 50 次流水线刷新</li>
</ul>
</li>
<li><strong>新应用及新结构需要新的预测机制：</strong><ul>
<li>Power-aware 分支预测</li>
<li>SMT 结构分支预测</li>
<li>神经网络分支预测器</li>
</ul>
</li>
<li><strong>分支预测大赛：</strong><ul>
<li>工业界支持，2 年一次</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：存储管理</title>
    <url>/2020/02/21/Computer-Architecture/CA-MemManage/</url>
    <content><![CDATA[<p>一个程序片段：</p>
<ul>
<li><code>array = (int*)malloc(0x1000);</code></li>
<li><code>for (i=0;i&lt;1024;i++) array[i] = 0;</code></li>
</ul>
<p>软件功能：</p>
<ul>
<li>分配一个 1024 项的一维整数数组 array，并初始化为 0； </li>
</ul>
<p>硬件过程？</p>
<ul>
<li>数组地址分配在什么地址？</li>
<li>数组存在什么地方（内存/硬盘）？</li>
<li>什么时候分配？什么时候存？</li>
<li>虚地址和物理地址如何转换？</li>
</ul>
<a id="more"></a> 
<h1 id="虚拟存储的基本原理"><a href="#虚拟存储的基本原理" class="headerlink" title="虚拟存储的基本原理"></a>虚拟存储的基本原理</h1><h2 id="虚拟存储的作用"><a href="#虚拟存储的作用" class="headerlink" title="虚拟存储的作用"></a>虚拟存储的作用</h2><ol>
<li>隔离进程编程地址空间；</li>
<li>虚拟地址空间可大于实际物理地址空间；（swap 交换区：内存和硬件交换）</li>
<li>支持多进程环境下的内存的共享和保护；</li>
</ol>
<h2 id="虚拟存储原理"><a href="#虚拟存储原理" class="headerlink" title="虚拟存储原理"></a>虚拟存储原理</h2><ul>
<li>由操作系统和 CPU 紧密配合才能完成</li>
<li>虚拟存储是计算机系统发展过程中有里程碑作用的事件：<ul>
<li>多进程环境下统一的编程空间</li>
<li>多进程环境下的共享与保护</li>
<li>支持大于实际物理内存的编程空间</li>
</ul>
</li>
<li>虚实地址分开，建立一种从虚地址空间映射到物理内存的机制：<ul>
<li>把两个层次的存储转换为一个层次的存储</li>
<li>物理内存实际上是磁盘的一个 Cache</li>
</ul>
</li>
</ul>
<h2 id="虚实地址转换与页表"><a href="#虚实地址转换与页表" class="headerlink" title="虚实地址转换与页表"></a>虚实地址转换与页表</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/VirtualRealAddressPagetable.png" alt="VirtualRealAddressPagetable"></p>
<ul>
<li>在页的范围内，虚实地址相等；</li>
<li>TLB 是页表的 cache；</li>
</ul>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/MultilevelPagetable.png" alt="MultilevelPagetable"></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p><strong>TLB 实际上是操作系统中页表的 Cache：</strong></p>
<ul>
<li>TLB 主要负责完成用户空间到物理空间的转化</li>
<li>一般与 Cache 访问同时进行</li>
<li>TLB 内容：虚地址（Cache的Tag）,物理地址（Cache的Data）,保护位（Cache的状态）//判断访问是否合法</li>
</ul>
<p><strong>TLB 失效处理：</strong></p>
<ul>
<li>TLB 失效时需要把相应页表内容从内存取到 TLB</li>
<li>TLB 失效时硬件（如X86的page walker）和软件（如MIPS的特殊例外）来填充 TLB</li>
</ul>
<h2 id="Cache-和虚拟存储"><a href="#Cache-和虚拟存储" class="headerlink" title="Cache 和虚拟存储"></a>Cache 和虚拟存储</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/CacheVirtualStorage.png" alt="CacheVirtualStorage"></p>
<h2 id="分清两种映射关系"><a href="#分清两种映射关系" class="headerlink" title="分清两种映射关系"></a>分清两种映射关系</h2><ul>
<li>TLB 是页表的 Cache：<ul>
<li>负责地址转换，一页管 4KB 以上数据</li>
<li>页表由操作系统管理，存在系统空间</li>
</ul>
</li>
<li>内存是硬盘的 Cache：<ul>
<li>负责数据缓存，一字节就是一字节</li>
<li>用户程序的数据在用户空间</li>
</ul>
</li>
</ul>
<h1 id="MIPS-处理器对虚存系统的支持"><a href="#MIPS-处理器对虚存系统的支持" class="headerlink" title="MIPS 处理器对虚存系统的支持"></a>MIPS 处理器对虚存系统的支持</h1><h2 id="总技术支持"><a href="#总技术支持" class="headerlink" title="总技术支持"></a>总技术支持</h2><ul>
<li>分段（控制访问权限），段内分页</li>
<li>TLB</li>
<li>特殊的控制寄存器</li>
<li>特殊指令</li>
<li>专用的例外入口</li>
</ul>
<h2 id="MIPS-的访问权限"><a href="#MIPS-的访问权限" class="headerlink" title="MIPS 的访问权限"></a>MIPS 的访问权限</h2><ul>
<li><strong>User mode 用户态：</strong><ul>
<li>EXL=0 and ERL=0 and KSU=10</li>
</ul>
</li>
<li><strong>Supervisor mode 管理态：</strong><ul>
<li>EXL=0 and ERL=0 and KSU=01</li>
</ul>
</li>
<li><strong>Kernel mode 核心态：</strong><ul>
<li>EXL=1 or ERL=1 or KSU=00</li>
</ul>
</li>
</ul>
<h2 id="MIPS-存储空间分段情况"><a href="#MIPS-存储空间分段情况" class="headerlink" title="MIPS 存储空间分段情况"></a>MIPS 存储空间分段情况</h2><p>32位模式：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/MIPSStorageSegmentation.png" alt="MIPSStorageSegmentation"></p>
<ul>
<li><strong>问题一</strong>：为什么在内核地址空间中要有一段空间不能用 TLB 转换以及不能进 cache，而且两个虚地址不同的段（kseg0 和 kseg1）要映射到相同的物理地址呢？<ol>
<li>是系统初始化的需要；</li>
<li>因为在 MIPS 中各自 I/O 设备都被映射到 0~512MB 的空间中。在启动计算机的时候，CPU 刚开始上电运行，硬件复位信号只对非常必要的一些寄存器进行了初始化，而 CPU 中的 cache、TLB 以及各自寄存器都需要由软件进行初始化。（即：CPU 刚启动时用于初始化的指令不能存在 cache 中，其地址也不能用 TLB 进行转换，否则就会出现先有鸡还是先有蛋的问题：</li>
</ol>
</li>
<li><strong>CPU 加电、初始化和启动操作系统的整个过程，其中最关键的约定是CPU 第一条指令必须有一个固定的入口，并且这个入口的地址不能使用 TLB 转换，也不能用 cache：</strong><ul>
<li>在 MIPS 系统中，CPU 初始化时，复位信号 reset 把程序计数器PC 置为 0xbfc00000，这个地址属于 kseg1 段，地址映射方式是直接减去 0xa0000000，所以物理地址就是 0x1fc00000；</li>
<li>上述地址是一个非缓存地址，一旦 CPU 发生 reset，访存总线第一次送出来一个地址肯定是 0x1fc00000，这个地址对应主板的 BIOS，CPU 从 BIOS 取指令对 cache 和控制寄存器等进行初始化后，由于没有使用 cache，每条指令的取址和执行都需要上百拍。对 cache 等初始化后，BIOS 程序跳转到另一段地址空间 kseg0。</li>
<li>这一段是可以使用 cache 的，指令和数据都可以进入 cache，比非缓存的 kseg1 快很多。在对内存以及 I/O 接口进行必要的初始化后，把操作系统代码从硬盘复制到内存中，开始引导操作系统（跳转到操作系统在内存的地址），操作系统就把所有的资源都管理起来了。</li>
</ul>
</li>
</ul>
<h2 id="MIPS-的-TLB-及相关控制寄存器"><a href="#MIPS-的-TLB-及相关控制寄存器" class="headerlink" title="MIPS 的 TLB 及相关控制寄存器"></a>MIPS 的 TLB 及相关控制寄存器</h2><p>32 位模式、全相联、32-64 项</p>
<ul>
<li><p><strong>MIPS 的 TLB 格式：</strong><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/MIPSTLBFormate.png" alt="MIPSTLBFormate"></p>
<ul>
<li><strong>MASK</strong>：12位，用于TLB查找时，控制VPN2的低12位是否参与地址比较（其某位为1：在查找TLB时该为不参与比较），则MIPS的页在4KB-16MB之间可变；</li>
<li><strong>VPN2</strong>：虚拟页号：每项把两个连续的虚拟页映射为两个物理页；</li>
<li><strong>G</strong>：全局域：当G等于1时，关闭ASID匹配使得该TLB项适用于所有的地址空间；</li>
<li><strong>ASID</strong>：地址空间标识符，标记该项地址属于哪个地址空间（只有CPU当前ASID号和该域匹配时，地址查找才命中），ASID域可以理解为：用于区分不同进程表项的编号；</li>
<li><strong>PFN</strong>：物理页帧号，有效宽度依赖于该CPU支持的物理内存空间的大小；</li>
<li><strong>C</strong>：表示相应物理页的cache算法；</li>
<li><strong>D</strong>：dirty脏位，D=1：该页允许写入；OS可利用该位了解该页上是否有写操作发生过；</li>
<li><strong>V</strong>：有效位，表示相应物理页是否在内存中；</li>
</ul>
</li>
<li><p><strong>MIPS，TLB 相关控制寄存器：</strong><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/MIPSTLBRegister.png" alt="MIPSTLBRegister">    </p>
<ul>
<li><strong>PageMask</strong>：Mask ⾥⾯值为 1 的位，书上说的在执⾏ TLB 表项匹配时被忽略（也就相当于 PageMask 寄存器值为 1 的位被看作了⻚内偏移位），⻚内偏移多⼀位，就相当于⻚⼤⼩ *2。初始⻚内偏移（12 位 = 4K）⼤⼩，当 MASK 12 位全位 1 的时候，⻚内偏移成了 24 位也就是 16MB（这也就是 FPN 为啥要是 24位 的原因）（页大小四倍递增）</li>
<li><strong>PageMask、EntryHi、EntryLo0、EntryLo1</strong>，这四个寄存器内容与 TLB 一样，主要用于读写 TLB：<ul>
<li>写 TLB 时，把寄存器的内容写到其中某一项去（其中 G 位处理方法：把 EntyrLo0 和 EntyrLo1 的 G 位相与后写到 TLB）；</li>
<li>读 TLB 时，把 TLB 某一项的内容读到这些寄存器中（其中 G 位处理方法：把 TLB 的 G 位同时写入到 EntyrLo0 和 EntyrLo1 的 G 位）；</li>
</ul>
</li>
<li><strong>Index、Random（值随机更新）、Wired</strong>，这三个寄存器决定读写 TLB 的哪个表项；<ul>
<li>wired：锁定某些 TLB 项的作用，即指定 Random 寄存器的值只能在 Wired 和（TLB 最大表项值-1）之间变换；</li>
<li>当软件用 Rondom 作索引写 TLB 进行随机替换的时候，0 到 wired 之间的 TLB 项就不可能被替换（则 OS 常把一些常用的页表项放到 0 到 wired 之间）；</li>
</ul>
</li>
<li><strong>EPC</strong>：例外时的当前 PC，便于例外处理完后返回该位置重新执行；（MIPS 中存在分支延迟槽，如果发生例外的指令在分支延迟槽中，EPC 保存的是发生例外的前一条指令，这样可以返回到分支指令）；</li>
<li><strong>BadVAddr</strong>：引起例外的虚地址；</li>
<li><strong>Context</strong>：环境上下文，其内容与 BadVAddr 的内容有些重复，主要是为了加速快 TLB 异常回填过程中的页表查找速度，其中页表的基地址存储在 PTEBase 域中，而 BadVPN2 指向页表内的表项；</li>
</ul>
</li>
<li><p><strong>虚拟地址转换为物理地址过程为：</strong>   </p>
<ul>
<li>虚拟地址的⾼位 (VPN) 和当前程序的 ASID 送给 TLB，与 TLB 中的所有 entry 表项同时进⾏匹配，匹配过程中如果有如下都满⾜的 TLB 表项，从中读取 PFN,V,D 域：<ol>
<li>当前程序(进程)的 ASID 等于 TLB 表项中的 ASID(EntryHi 的 Gbit 置位的话，不⽐较 ASID)；</li>
<li>虚拟地址的 bit63~62 与 TLB 表项的 R 字段相同；</li>
<li>虚拟地址的相应位域和 TLB 的 VPN2 相同，相应位域取决于 PageMask 寄存器设置的⻚表⼤⼩；   </li>
</ol>
</li>
<li>注意：最终转换是否成功取决于 V,D 域。如果 V ⽆效，该 entry ⽆效，产⽣ TLB ⽆效异常；如果 D 指示不可写，⽽有写操作会产⽣ TLB 修改异常。如果没有上述异常，即是 TLB 命中，命中 entry 的 PFN 和虚拟地址低位(1KBpage 的话是低 10bit，4KBpage 的话低 12bit)构成最终的物理地址。</li>
</ul>
</li>
</ul>
<h2 id="与-TLB-管理有关的指令（核心态下才能执行）"><a href="#与-TLB-管理有关的指令（核心态下才能执行）" class="headerlink" title="与 TLB 管理有关的指令（核心态下才能执行）"></a>与 TLB 管理有关的指令（核心态下才能执行）</h2><ul>
<li><strong>MFC0, MTC0</strong>：在通用寄存器和控制寄存器之间搬运数据</li>
<li><strong>TLBR</strong>：以 Index 寄存器为索引把 TLB 内容读到 PageMask、EntryHi 和 EntryLo0/1 等寄存器</li>
<li><strong>TLBP</strong>：检查 EntryHi 中指定的虚页是否在 TLB 中 </li>
<li><strong>TLBWR, TLBWI</strong>：分别以 Random 和 Index 寄存器为索引把 Pagemask、EntryHi 和 EntryLo0/1 寄存器的内容写入 TLB</li>
</ul>
<h2 id="处理器访问-TLB"><a href="#处理器访问-TLB" class="headerlink" title="处理器访问 TLB"></a>处理器访问 TLB</h2><p>处理器访问 TLB 时，将访存地址和 EntryHi 中的 ASID 与 TLB 的每一项进行匹配：</p>
<ul>
<li>如果命中，则读出相应的 PFN、C、D、V等内容；</li>
<li>如果不命中则发 TLB 重填（TLB Refill）例外；</li>
<li>如果TLB命中但读出的 V 位为 0，则发出 TLB 无效（TLB Invalid）例外；</li>
<li>如果是存数操作且 TLB 命中、有效但读出的 D 位为 0，则发出 TLB 修改（TLB Modify）例外；</li>
</ul>
<p>发生 TLB 例外时，硬件除了把当前 PC 保存在 EPC 中用于例外返回，把 PC 置为例外入口地址，在 Cause 控制寄存器中记录例外原因，把系统转态置为核心态（置 status 控制寄存器的 EXL 位为 1）以外，还需要在 BadVAddr 和 Context 控制寄存器中保存于 TLB 例外相关的信息；</p>
<h2 id="TLB-例外"><a href="#TLB-例外" class="headerlink" title="TLB 例外"></a>TLB 例外</h2><h3 id="发生-TLB-例外时硬件处理过程"><a href="#发生-TLB-例外时硬件处理过程" class="headerlink" title="发生 TLB 例外时硬件处理过程"></a>发生 TLB 例外时硬件处理过程</h3><ul>
<li>置 BadVaddr, Context, EntryHi：<ul>
<li>把发生例外的虚地址放到 BadVaddr，和 Context 的 PTEBase 和 BadVPN2 域，以及 EntryHi 的 VPN2 域中</li>
</ul>
</li>
<li>PC=例外入口地址，当前 PC 保存在 EPC 中用于例外返回<ul>
<li>TLB Refill 入口=0x80000000</li>
<li>其它入口=0x80000180 </li>
</ul>
</li>
<li>置 Status（置 EXL 位进入核心态）, Cause（向其 ExCode 域中记录例外原因）；<br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBException1.png" alt="TLBException1"><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBException2.png" alt="TLBException2"><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBException3.png" alt="TLBException3"><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBException4.png" alt="TLBException4">    </li>
</ul>
<h3 id="TLB-例外类型"><a href="#TLB-例外类型" class="headerlink" title="TLB 例外类型"></a>TLB 例外类型</h3><ol>
<li><p>Refill：TLB 中没有对应的项   </p>
<ul>
<li>如果查找 TLB 没有找到一个虚地址匹配（VPN2+ASID/G） </li>
<li>例外入口：80000000 （除非 exl=1）<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBRefill.png" alt="TLBRefill"></li>
</ul>
</li>
<li><p>TLB invalid：相应物理页不再内存</p>
<ul>
<li>如果找到一个虚地址匹配项，但其 v=0</li>
<li>例外入口：80000180</li>
<li>细分为两种：TLBL for loads, TLBS for stores</li>
</ul>
</li>
<li><p>TLB modify：非法写只读页</p>
<ul>
<li>如果找到一个虚地址匹配项，其 v=1，但 D=0 且访问为 store</li>
<li>例外入口 80000180</li>
</ul>
</li>
</ol>
<h3 id="例外返回"><a href="#例外返回" class="headerlink" title="例外返回"></a>例外返回</h3><ol>
<li><p>例外处理器在核心态下进行：（用户只能通过（系统调用）进入核心态）</p>
<ul>
<li>不允许在核心态下执行一条用户指令</li>
<li>不允许在用户态下执行指令核心指令</li>
</ul>
</li>
<li><p>例外返回的两种方式：</p>
<ul>
<li>jr+mtc0: mtc0 必须在 jr 的延迟槽中：<ul>
<li>用 MTC0 指令清除 status 中的 EXL 位（权限切换：内核-&gt;用户）</li>
<li>用跳转指令（如：jr）转移到EPC指定的地方</li>
</ul>
</li>
<li>eret: eret 没有延迟槽：<ul>
<li>自动将 status 寄存器中的转态位改为用户态；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="一种虚拟存储实现方式"><a href="#一种虚拟存储实现方式" class="headerlink" title="一种虚拟存储实现方式"></a>一种虚拟存储实现方式</h2><ol>
<li><p>使得发生例外时，context 寄存器指向页表中相应项：</p>
<ul>
<li>一维线性页表</li>
<li>内存页表每项 8 个字节，每对页面占用 16 字节页表（VPN2）</li>
<li>进程切换时操作系统更改 context 寄存器中 pte_base 域，使其指向该进程的页表基地址</li>
<li>（pte_base 是进程上下文的一部分）</li>
</ul>
</li>
<li><p>一维线性页表需要很大的空间，不能全部分配物理内存：</p>
<ul>
<li>放在 kernel mapped的kseg2/kseg3 段 </li>
<li>需要解决 TLB refill 重入问题</li>
</ul>
</li>
<li><p>TLB refill 过程：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBRefillProcess.png" alt="TLBRefillProcess"></p>
<ul>
<li>Pagemask 在操作系统初始化时由 OS 设置（固定页操作系统）</li>
<li>Pte_base 在进程切换时由 OS 设置</li>
<li>Vpn2 和 EntryHi 在缺页时由 CPU 设置</li>
</ul>
</li>
<li><p>TLB refill 代码：<br> <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBRefillCode1.png" alt="TLBRefillCode1"><br> <img src="http://img.thebetterkong.cn/blog/CA-MemManage/TLBRefillCode2.png" alt="TLBRefillCode2"></p>
</li>
</ol>
<h1 id="LINUX-操作系统的存储管理"><a href="#LINUX-操作系统的存储管理" class="headerlink" title="LINUX 操作系统的存储管理"></a>LINUX 操作系统的存储管理</h1><h2 id="Linux-MIPS-虚拟地址空间安排"><a href="#Linux-MIPS-虚拟地址空间安排" class="headerlink" title="Linux/MIPS 虚拟地址空间安排"></a>Linux/MIPS 虚拟地址空间安排</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/LinuxMIPSVirtualAddressSpace.png" alt="LinuxMIPSVirtualAddressSpace"></p>
<h2 id="内存中的页表组织（32-位情况）"><a href="#内存中的页表组织（32-位情况）" class="headerlink" title="内存中的页表组织（32 位情况）"></a>内存中的页表组织（32 位情况）</h2><ol>
<li><p>两级页表，每项 4 个字节：</p>
<ul>
<li>PFN：物理帧号</li>
<li>Flags：V、C、D </li>
<li>Exts：软件扩展位，用于维护一些硬件没有实现的功能，例如 ref 位，modified 位 </li>
</ul>
</li>
<li><p>页表存放在 kseg0：</p>
<ul>
<li>页表访问不引起 TLB 例外（该段不用通过TLB映射的地址空间查询）</li>
<li>页表存储空间在使用到的时候分配</li>
</ul>
</li>
<li><p>每个进程的页表基地址（PGD 表基地址）存放在进程上下文中：</p>
<ul>
<li>进程切换时，把 PGD 表的基地址写到 context 的 PTEBase中</li>
</ul>
</li>
</ol>
<h2 id="Linux-MIPS-的两层页表"><a href="#Linux-MIPS-的两层页表" class="headerlink" title="Linux/MIPS 的两层页表"></a>Linux/MIPS 的两层页表</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/LinuxMIPSTwoLevelPagetable.png" alt="LinuxMIPSTwoLevelPagetable"></p>
<h2 id="Linux-的-tlb-重填代码（共-18-条指令）"><a href="#Linux-的-tlb-重填代码（共-18-条指令）" class="headerlink" title="Linux 的 tlb 重填代码（共 18 条指令）"></a>Linux 的 tlb 重填代码（共 18 条指令）</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/LinuxTLBRefill.png" alt="LinuxTLBRefill"></p>
<ul>
<li>例子：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/ExampleLinuxTLBRefill1.png" alt="ExampleLinuxTLBRefill1"><br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/ExampleLinuxTLBRefill2.png" alt="ExampleLinuxTLBRefill2"></li>
</ul>
<ul>
<li>问题：为什么要分两次例外？<br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/Why2Exception.png" alt="Why2Exception"></li>
</ul>
<h2 id="Linux-MIPS-中-TLB-例外的处理"><a href="#Linux-MIPS-中-TLB-例外的处理" class="headerlink" title="Linux/MIPS 中 TLB 例外的处理"></a>Linux/MIPS 中 TLB 例外的处理</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/LinuxMIPSTLBException.png" alt="LinuxMIPSTLBException"></p>
<ul>
<li>例题：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MemManage/ExampleLinuxMIPSTLBException.png" alt="ExampleLinuxMIPSTLBException"></li>
</ul>
<h2 id="展望-不忘初心"><a href="#展望-不忘初心" class="headerlink" title="展望-不忘初心"></a>展望-不忘初心</h2><ol>
<li><p>为什么访存指令的执行这么复杂？</p>
<ul>
<li>虚拟化：结构设计复杂一些，用户用起来简单一些；</li>
<li>结构设计：虚实地址转换，支持比实际内存容量更大的访问空间；</li>
<li>用户程序：每个进程都感到整个 CPU 和内存都是“我的”；</li>
</ul>
</li>
<li><p>进一步虚拟化：</p>
<ul>
<li>运行多个 OS，让每个 OS 都感到整个 CPU 和内存都是”我的“；</li>
<li>两次地址转换：guest VA=&gt;guest PA（host VA）=&gt;host PA，两个不同的 TLB 以及一个“影子TLB”（guest VA =&gt;host PA）；</li>
<li>地址例外时 guest OS 和 host OS 切换；</li>
</ul>
</li>
<li><p>OS 的摩尔定律终结：2020 年 OS 的复杂度也到头了</p>
<ul>
<li>把 CPU 最后一点“家当”（核心态功能）也虚拟化掉了</li>
</ul>
</li>
</ol>
<h1 id="TLB-的优化"><a href="#TLB-的优化" class="headerlink" title="TLB 的优化"></a>TLB 的优化</h1><ul>
<li>防缓冲区溢出攻击优化</li>
<li>硬件性能优化</li>
<li>软件性能优化</li>
</ul>
<h2 id="利用-TLB-的保护机制防范攻击"><a href="#利用-TLB-的保护机制防范攻击" class="headerlink" title="利用 TLB 的保护机制防范攻击"></a>利用 TLB 的保护机制防范攻击</h2><ul>
<li>利用缓冲区溢出进行攻击的例子</li>
<li>龙芯处理器通过可执行保护防止缓冲区溢出攻击：TLB 增加可执行位<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/PreventBufferOverflowAttacks.png" alt="PreventBufferOverflowAttacks"></li>
</ul>
<h2 id="TLB-相关性能数据"><a href="#TLB-相关性能数据" class="headerlink" title="TLB 相关性能数据"></a>TLB 相关性能数据</h2><ul>
<li>TLB miss 处理的时间可以占到高达 40% 的运行时间，占 40~90% 的内核运行时间；</li>
<li>SPEC CPU2000 大约 1/4 的程序有比较显著的 TLB miss；<ul>
<li>早期多数 CPU 的 TLB 是全相连的 32-128 项，如果每项 4KB，能映射的空间只有几百 KB，越来越难满足现代程序的需求</li>
</ul>
</li>
<li>性能优化方法：<ul>
<li>增加 TLB 覆盖空间大小，降低 TLB 失效概率</li>
<li>降低 TLB 失效开销</li>
</ul>
</li>
</ul>
<h2 id="增加页大小后性能显著提高"><a href="#增加页大小后性能显著提高" class="headerlink" title="增加页大小后性能显著提高"></a>增加页大小后性能显著提高</h2><ul>
<li>增加页大小后，TLB 失效明显减少</li>
<li>16KB 页时 128 页有 2MB</li>
<li>通过软件配置 pagemask 可以增加/减少页大小</li>
</ul>
<h2 id="MIPS-Linux-多级页表"><a href="#MIPS-Linux-多级页表" class="headerlink" title="MIPS-Linux 多级页表"></a>MIPS-Linux 多级页表</h2><h3 id="查找过程示意图"><a href="#查找过程示意图" class="headerlink" title="查找过程示意图"></a>查找过程示意图</h3><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/MIPSLinuxMultilevelPagetableFind.png" alt="MIPSLinuxMultilevelPagetableFind"></p>
<p>MIPS 原 Context 寄存器设计不再适合多级页表的快速查找（原设计针对一级页表）；</p>
<h3 id="加速-MIPS-Linux-多级页表查找"><a href="#加速-MIPS-Linux-多级页表查找" class="headerlink" title="加速 MIPS-Linux 多级页表查找"></a>加速 MIPS-Linux 多级页表查找</h3><ol>
<li><p>首先通过软件可配置寄存器来描述具体的页表结构：</p>
<ul>
<li>PGBase：页表基址寄存器（进程上下文一部分，其余寄存器操作系统启动时配置）</li>
<li>PGSize：描述各级页表的大小</li>
<li>PGIndex：描述各级页表索引值在待查询地址中的起始位置</li>
<li>PGEntry：描述奇偶页表项之间位置关系，以及页表中软件用的位的宽度<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/DescribePagetableStructure.png" alt="DescribePagetableStructure"></li>
</ul>
</li>
<li><p>定义专门的页表访存指令：</p>
<ul>
<li><code>LDDIR dest, src, #N</code>：将 src 寄存器中的值作为第 N 级目录页表的基址，同时根据 CP0.BadVaddr 中存放的待查询地址以及新增的 PGSize、PGINdex 配置寄存器信息，访存得到第 N+1 级页表的基址，写入到 dest 寄存器中。</li>
<li><code>LDPTE src, #0/#1</code>：将 src 寄存器中的值作为页表项页表的基址，同时根据 CP0.BadVaddr 中存放的待查询地址以及新增的 PGSize、PGINdex、PGEntry 配置寄存器信息，访存得到偶数号/奇数号页表项的内容，将页表中纯粹软件用的位移除后，写入到 CP0.EntryLo0/CP0.EntryLo1中。</li>
</ul>
</li>
</ol>
<h3 id="MIPS-Linux-TLB-重填代码优化"><a href="#MIPS-Linux-TLB-重填代码优化" class="headerlink" title="MIPS-Linux TLB 重填代码优化"></a>MIPS-Linux TLB 重填代码优化</h3><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/MIPSLinuxTLBOptimization.png" alt="MIPSLinuxTLBOptimization"></p>
<h2 id="软-TLB-方案"><a href="#软-TLB-方案" class="headerlink" title="软 TLB 方案"></a>软 TLB 方案</h2><ol>
<li><p>目的：主要减少 TLB 重载入异常处理的时间，提高 TLB 重载入异常处理的效率。</p>
</li>
<li><p>原理：</p>
<ul>
<li>通过减少 TLB 重载入异常处理过程 Cache Miss 的次数来减少 TLB 重载入异常处理的时间。</li>
</ul>
</li>
<li><p>具体流程图：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/SoftTLBFlowChart.png" alt="SoftTLBFlowChart"></p>
</li>
<li><p>软 TLB 的命中率：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/SoftTLBHitRate.png" alt="SoftTLBHitRate"></p>
</li>
<li><p>缓冲区大小对软 TLB 命中率的影响：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/BufferSoftTLBHitRate.png" alt="BufferSoftTLBHitRate"></p>
</li>
<li><p>软 TLB 对 SPEC 性能的提高：<br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/SoftTLBSPEC.png" alt="SoftTLBSPEC"></p>
</li>
</ol>
<h1 id="常见处理器的结构参数"><a href="#常见处理器的结构参数" class="headerlink" title="常见处理器的结构参数"></a>常见处理器的结构参数</h1><p><img src="http://img.thebetterkong.cn/blog/CA-MemManage/ProcessorStructuralParameters1.png" alt="ProcessorStructuralParameters1"><br><img src="http://img.thebetterkong.cn/blog/CA-MemManage/ProcessorStructuralParameters2.png" alt="ProcessorStructuralParameters2"></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>利用爬虫实现课程网站资源的批量下载</title>
    <url>/2020/05/22/Crawler/CrawlSEPBatchDownload/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/head.png" width="100%" alt="head.png" /> </div>   

<p>现在大学上课，老师一般都是通过学校的课程网站来分享课程的课件等资源。但是，在果壳大课程网站上下载资源，总是需要一项一项的点入，再单击下载，显得十分麻烦，特别有时囤积了大量资源需要去下载，还得比对一下哪些没有下载，这对于我这种数据强迫症的人来说，十分不友好！<br>恰巧那会对爬虫挺感兴趣的，就寻思着拿这个练练手（重在学习），说做就做吧！Let’s go！</p>
<a id="more"></a>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先，得先定我的需求：</p>
<ol>
<li>可以选择课程，对该课程的所有课件实现一键下载；</li>
<li>鉴于我的数据强迫症，课件下载完毕后，应该能向我反馈下载的信息，主要就是新下载了哪些课件；</li>
<li>由于疫情的特殊原因，学校采取了网上授课的方式，但是家里网络不稳定，总是故障，考虑下载视频到本地观看，也便于课后复习；（想想以前，为了能课后复习，都是拿着电脑在上课的时候现场录的）；</li>
</ol>
<p>现在，需求以及清楚，接下来就是开始捣鼓课程网站的情况；    </p>
<ul>
<li>正常情况下，我们首先需求登录，进入教务系统主页；</li>
<li>然后，进入课程网站主页；</li>
<li>然后，在自己的选课情况中，选择课程，进入到课程主页；</li>
<li>然后，找到进入该课程主页的资源页面；</li>
<li>进入相关资源，并点击下载；</li>
</ul>
<p>Emmm，用的时候都还好，这么一捋愈发觉得麻烦了……</p>
<h1 id="弯路：webdriver"><a href="#弯路：webdriver" class="headerlink" title="弯路：webdriver"></a>弯路：webdriver</h1><p>果壳大的教育业务平台网址是：<a href="http://sep.ucas.ac.cn/" target="_blank" rel="noopener">http://sep.ucas.ac.cn/</a> ，要想进行后面的操作，首先，就得实现教育业务平台的自动登录；   </p>
<p>起初嘛，刚接触爬虫，对网络也不是特别了解。脑海里冒出来最简单的思路就是：利用 selenium 的 webdriver 模拟登录过程，然后获取 cookies，之后再利用 cookies 登录；</p>
<ol>
<li><code>pip install selenium</code> 安装 selenium；<ul>
<li>selenium 是 ThoughtWorks 提供的一个强大的基于浏览器的开源自动化测试工具。支持的浏览器包括 IE、Chrome 和 Firefox 等；</li>
</ul>
</li>
<li>到相应的官网下载浏览器驱动，我这里下载的是火狐的浏览器驱动；</li>
</ol>
<p>接下来，写段程序测试：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">headers = &#123;</span></span><br><span class="line"><span class="string">    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span><span class="params">( )</span>:</span></span><br><span class="line">    user = input(<span class="string">"请输入用户名："</span>)</span><br><span class="line">    password = input(<span class="string">"请输入密码："</span>)</span><br><span class="line">    driver = webdriver.Firefox()</span><br><span class="line">    driver.get(<span class="string">'http://sep.ucas.ac.cn/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#time.sleep(3)</span></span><br><span class="line">    <span class="comment"># 清空登录框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录用户名</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhuusername']"</span>).send_keys(user)</span><br><span class="line">    <span class="comment"># 清空密码框</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).clear()</span><br><span class="line">    <span class="comment"># 自动填入登录密码</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhupassword']"</span>).send_keys(password)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 点击登录按钮进行登录</span></span><br><span class="line">    driver.find_element_by_class_name(<span class="string">'loginbtn'</span>).click()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取cookies</span></span><br><span class="line">    cookie_items = driver.get_cookies()</span><br><span class="line">    cookie = [item[<span class="string">"name"</span>] + <span class="string">"="</span> + item[<span class="string">"value"</span>] <span class="keyword">for</span> item <span class="keyword">in</span> cookie_items]</span><br><span class="line">    cookie_str = <span class="string">';'</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> cookie)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'cookie.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(cookie_str)</span><br><span class="line">    f.close()</span><br><span class="line">    print(<span class="string">"已获取到cookies！"</span>)</span><br><span class="line"></span><br><span class="line">    headers_cookie = &#123;</span><br><span class="line">        <span class="string">"Cookie"</span>: cookie_str  <span class="comment"># 通过接口请求时需要cookies等信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    session = requests.session()</span><br><span class="line">    session.post(<span class="string">'http://sep.ucas.ac.cn/'</span>, headers=headers_cookie)</span><br><span class="line">    print(<span class="string">'登录系统成功……'</span>)</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    session = log_in()</span><br></pre></td></tr></table></figure></p>
<p>本以为，万事大吉，结果运行测试，emmmmm……才意识到，还得输入验证码！   </p>
<p>那就继续造：</p>
<ul>
<li>要用到图形处理，所以 <code>pip install pillow</code>；<ul>
<li>坑：安装 pillow，但是导入的时候是 PIL；</li>
</ul>
</li>
<li>抓取下来验证码，还不够，肯定还得识别验证码内容，选择百度文字识别的 OCR，<code>pip install baidu_api</code>；</li>
</ul>
<blockquote>
<p>pillow 的原身是 PIL（Python Imaging Library），PIL 是 Python 图像处理标准库，功能非常强大，API 却非常简单易用；<br>但是 PIL 仅支持到 Python 2.7，后来由志愿者在此基础上创建了兼容的版本，即：Pillow，支持最新Python 3.x，又加入了许多新特性<br>百度文字识别的OCR，即：Optical Character Recognition，光学字符识别</p>
</blockquote>
<p>然后，在上面代码的基础上，新增如下内容：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 导入下载的第三方库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 查找验证码</span></span><br><span class="line">png = driver.find_element_by_id(<span class="string">'captcha_img'</span>)  <span class="comment"># 查找验证码元素</span></span><br><span class="line">png.screenshot(<span class="string">'captcha.png'</span>)  <span class="comment"># 对验证码截图并保存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码处理</span></span><br><span class="line"><span class="comment"># 用 pillow 库对验证码进行图像处理，提高验证码的识别率；</span></span><br><span class="line"><span class="comment"># 处理方法：</span></span><br><span class="line"><span class="comment">#   1.先将图像转换成灰度模式</span></span><br><span class="line"><span class="comment">#   2.通过对阈值的调整使得多余的噪点消失</span></span><br><span class="line">img = Image.open(<span class="string">'captcha.png'</span>)</span><br><span class="line">img = img.convert(<span class="string">'L'</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">count = <span class="number">165</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; count:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line">img = img.point(table, <span class="string">'1'</span>)</span><br><span class="line">img.save(<span class="string">'captcha1.png'</span>)  <span class="comment"># 保存处理后的验证码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 验证码识别</span></span><br><span class="line"><span class="comment"># 调用 baidu_api 的通用文字识别接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别码</span></span><br><span class="line">APP_ID = <span class="string">'***'</span></span><br><span class="line">API_KEY = <span class="string">'***'</span></span><br><span class="line">SECRET_KEY = <span class="string">'***'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化对象</span></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line">image = get_file_content(<span class="string">'captcha.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数变量</span></span><br><span class="line">options = &#123;<span class="string">'language_type'</span>: <span class="string">'ENG'</span>, &#125;  <span class="comment"># 识别语言类型，默认为'CHN_ENG'中英文混合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用通用文字识别</span></span><br><span class="line">result = client.basicGeneral(image, options)  <span class="comment"># 高精度接口 basicAccurate</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> result[<span class="string">'words_result'</span>]:</span><br><span class="line">    captcha = (word[<span class="string">'words'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出，检查结果</span></span><br><span class="line">print(<span class="string">'识别结果：'</span> + captcha)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空验证码框</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).clear()</span><br><span class="line"><span class="comment"># 自动填入验证码</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"./*//input[@id='menhucaptcha']"</span>).send_keys(captcha)</span><br></pre></td></tr></table></figure></p>
<p>至此，总算是完成了登录过程，麻不麻烦？<br>肯定麻烦啊！而且有个很大的问题，就是每次运行会启动 webdriver，把程序拖得很慢，十分影响使用体验，所以我后来才改用了其他方法；</p>
<p>但是也不得不说，这段弯路也让我学到了挺多东西，还是很有意义的！</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>其实说正解不太准确，只是说这个办法更加简单易行罢了；</p>
<p>之所以会突然又提出新的办法，是因为有一次，我发现果壳大的综合信息网（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ）也可以登录到教育业务平台，而且在这里登录<strong>不需要验证码！</strong><br>这下子，终于可以去掉上面那繁琐的验证码处理过程了。   </p>
<p>但是，这只解决了一个问题，还是无法让我摆脱 webdriver。于是，我寻思这么难顶的资源下载方式，难道就没有前人 “种个树”？再仔细搜了搜，还真有！</p>
<p>原作者的程序是一键下载课程网站<strong>所有课程所有课件</strong>，呃……，对我来说有点夸张了，毕竟几十门课程，怎么得也有个几百项资源吧？也许对于一个爬虫来说爬取这些资源不算什么，但是，还有好多资源我可能不那么需要，事后还得整理。不过无妨，程序框架在这了，修改起来也简单。     </p>
<p>确定修改目标：</p>
<ol>
<li>能够输出选课的课程目录，供按课程批量下载课件；</li>
<li>加入视频下载功能；</li>
</ol>
<p><strong>开干！！！</strong></p>
<h2 id="网站登录"><a href="#网站登录" class="headerlink" title="网站登录"></a>网站登录</h2><p>首先，是登录信息，这里采用了直接将登录信息保存在 txt 文本文件里，避免了我原先那样每次运行脚本都需要手动输入的尴尬。简单的文本处理：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#读取登录信息，第一行存账号，第二行存密码</span></span><br><span class="line">        config = open(<span class="string">"user.txt"</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        line = config.readline().split()</span><br><span class="line">        username = line[<span class="number">0</span>]</span><br><span class="line">        password = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure></p>
<p>重点来了，这次登录改用了 requests 库的 session 会话对象，构造 post 表单的方式实现登录，并且由于 session 对象的特性，也便于我们后续其他页面的操作；</p>
<blockquote>
<p>session 的特性体现在它的作用时间：从用户到达某个特定的 Web 页开始，到该用户离开 Web 站点，或在程序中利用代码终止某个 Session 结束。<br>引用 Session 则可以让一个用户访问多个页面，之间的切换也会保留该用户的信息；<br>说白了，就是一旦我们使用 session 成功的登录了某个网站后，则在再次使用该 session对象求求该网站的其他网页都会默认使用该 session 之前使用的 cookie 等参数；<br>详细用法参见文章：<a href="https://www.cnblogs.com/linxiyue/p/3980003.html" target="_blank" rel="noopener">Python Requests库：HTTP for Humans</a></p>
</blockquote>
<ol>
<li>构造请求头：<ul>
<li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/findheader.png" alt="findheader"></li>
<li><code>Accept</code>：用户代理期望的 MIME 类型列表，不用管；</li>
<li><code>Accept-Encoding</code>：用户代理支持的压缩方法，不用管；</li>
<li><code>Accept-language</code>：用户代理期望的页面语言，不用管；</li>
<li><code>Connection</code>：决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。因此，需要设置；</li>
<li><code>Cookie</code>：就不用说了，我们目标就是自动获取<strong>登录后</strong>的 cookie；</li>
<li><code>host</code>：指明服务器域名，需要设置；</li>
<li><code>upgrade-insecure-requests</code>：用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应，并且它可以成功处理 upgrade-insecure-requests CSP 指令。</li>
<li><code>User-Agent</code>；指明用户代理软件的应用类型、操作系统、软件开发商以及版本号；</li>
<li>更多详情可见：『<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank" rel="noopener">MDN web docs</a>』</li>
</ul>
</li>
<li>构造 post 表单：<ul>
<li>打开网页（ <a href="http://onestop.ucas.ac.cn/" target="_blank" rel="noopener">http://onestop.ucas.ac.cn/</a> ），然后进入开发者模式（未登录状态）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost1.jpg" alt="buildpost1"><ul>
<li><code>Preserve log</code>：保留 log 信息；</li>
<li><code>XHR</code>：（XMLHttpRequest）筛选出与服务器的交互信息；</li>
</ul>
</li>
<li>然后，开发者模式设置完成后，在浏览器输入信息登录（不要关闭开发窗口）；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost2.jpg" alt="buildpost2"></li>
<li>很明显，我所需要的信息应该在 Name = 0，的那条记录里，打开这条记录；<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/buildpost3.png" alt="buildpost3"></li>
<li>在 Form Data 里就有我们构造 post 表单所需要去构造的信息，为：用户名、密码、是否记住密码，这三个字段；</li>
</ul>
</li>
</ol>
<p>这一部分代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = requests.session()  <span class="comment"># 创建 session 对象</span></span><br><span class="line">login_url = <span class="string">'http://onestop.ucas.ac.cn/'</span>  <span class="comment"># 更换为不需要验证码登录的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 构造请求头</span></span><br><span class="line">headers=  &#123;</span><br><span class="line">            <span class="string">'Host'</span>: <span class="string">'onestop.ucas.ac.cn'</span>,</span><br><span class="line">            <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">'Referer'</span>: <span class="string">'http://onestop.ucas.ac.cn/home/index'</span>,</span><br><span class="line">            <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>,  <span class="comment"># 指明 Ajax 请求(异步)，注意，这样返回的数据是 json 类型</span></span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36"</span>,</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">### 构造表单数据</span></span><br><span class="line">post_data = &#123; </span><br><span class="line">            <span class="string">"username"</span>: username,</span><br><span class="line">            <span class="string">"password"</span>: password,</span><br><span class="line">            <span class="string">"remember"</span>: <span class="string">'checked'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">html = session.post(login_url, data=post_data, headers=headers).text <span class="comment"># 请求，并建立 session</span></span><br><span class="line"><span class="comment"># 将返回的 json 数据转换为 html 文本保存</span></span><br><span class="line">res = json.loads(html)</span><br><span class="line">html = session.get(res[<span class="string">'msg'</span>]).text</span><br><span class="line">print(<span class="string">'登录系统成功！'</span>)</span><br><span class="line"><span class="comment"># save_html(html)  # 用来保存 html 文本做检测</span></span><br></pre></td></tr></table></figure>
<p>这样，我们就有了一个建立了连接的 session，以后就可以利用该 session 完成其他页面的操作；</p>
<h2 id="进入课程网站"><a href="#进入课程网站" class="headerlink" title="进入课程网站"></a>进入课程网站</h2><p>首先，查找进入课程网站的 url：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/tocoursesite1.jpg" alt="tocoursesite1">    </p>
<p>利用之前的 session 访问：<code>h_k = session.get(url)</code></p>
<p>这里有个注意点，在我们直接点击课程网站图标时，会进入一个跳转页面，而我们刚刚 session 访问到的就是这个跳转页面，所以实际上我们还并没有进入到课程网站页面中去；   </p>
<p>为了便于分析，将 session.get() 到的对象转换成文本文件存储：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    f = open(<span class="string">'test.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    f.write(html)</span><br><span class="line">    f.close</span><br><span class="line"></span><br><span class="line"><span class="comment">### 调用</span></span><br><span class="line">url = <span class="string">"http://sep.ucas.ac.cn/portal/site/16/801"</span>   <span class="comment"># 跳转页面地址</span></span><br><span class="line">h_k = session.get(url)   <span class="comment"># 访问跳转，并获取返回的对象</span></span><br><span class="line">save_html(h_k.text) <span class="comment"># 转换为文本文件保存下来</span></span><br></pre></td></tr></table></figure></p>
<p>打开 h_k.text，我们知道跳转页面里，提示信息会有 “点击这里跳转” 这种选项，在这个文本里 <kbd>ctrl F</kbd>，输入：“跳转”，就可以看到，确实存在一个标签，如下：<br>（当然了，也可以在跳转的时候，强制停止刷新网页，然后在跳转页面用开发者模式查找 “这里” 这个字段的 href）<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row-fluid"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"span12"</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">					<span class="tag">&lt;<span class="name">h4</span>&gt;</span>2秒钟没有响应请点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://course.ucas.ac.cn/portal/plogin?Identity=fbd361f2-73cc-48b7-a5ec-37528b27a058&amp;roleId=801"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这里<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>直接跳转<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           	<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--//container-fluid:end--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，利用正则表达式，获取这个 url 里，Identity 的值（身份认证信息），重新构造 url，直接进入到课程网站页面：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用正则表达式找Request URL，Identity后的身份认证信息</span></span><br><span class="line">key = re.findall(<span class="string">r'"https://course.ucas.ac.cn/portal/plogin\?Identity=(.*)"'</span>, h_k.text)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 利用得到的身份认证信息，打开课程网站系统</span></span><br><span class="line">url = <span class="string">"http://course.ucas.ac.cn/portal/plogin/main/index?Identity="</span> + key</span><br><span class="line">page = session.get(url)</span><br><span class="line">print(<span class="string">'课程网站系统进入成功！'</span>)</span><br><span class="line"><span class="keyword">return</span> page</span><br></pre></td></tr></table></figure>
<h2 id="获取课程信息"><a href="#获取课程信息" class="headerlink" title="获取课程信息"></a>获取课程信息</h2><p>先进入主页：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，找到课程网站的主页地址，并进入主页</span></span><br><span class="line">mycourseBS = BeautifulSoup(courseSite.text,<span class="string">"lxml"</span>) <span class="comment"># 利用 lxml 解析 text 文本</span></span><br><span class="line">url_mycourse = mycourseBS.find_all(<span class="string">'a'</span>,&#123;<span class="string">"class"</span>:<span class="string">'Mrphs-toolsNav__menuitem--link'</span>&#125;)[<span class="number">0</span>] <span class="comment"># 找 class 名为 xxx 的 a 标签</span></span><br><span class="line">url_mycourse = url_mycourse[<span class="string">"href"</span>] <span class="comment"># 获取 href ，即获取 url </span></span><br><span class="line">coursePage = session.get(url_mycourse)  <span class="comment"># 访问进入主页</span></span><br></pre></td></tr></table></figure>
<p>在我的课程里，获取课程信息：<br><img src="http://img.thebetterkong.cn/blog/CrawlSEPBatchDownload/courseinfo.jpg" alt="courseinfo"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用 BeautifulSoup 的 find_all 方法，在课程网站主页，寻找课程信息，并利用元组的形式记录在course_list中</span></span><br><span class="line">coursePageBS = BeautifulSoup(coursePage.text,<span class="string">"lxml"</span>) </span><br><span class="line">Course_info = coursePageBS.find_all(<span class="string">'li'</span>,&#123;<span class="string">"class"</span>:<span class="string">"fav-sites-entry"</span>&#125;)</span><br><span class="line">length = len(Course_info)   <span class="comment"># 标签数，即：课程总数</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line">print(<span class="string">"所选课程总数为："</span>,length)</span><br><span class="line">print((<span class="string">"已选课程列表："</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length<span class="number">-1</span>):</span><br><span class="line">    info = Course_info[i]</span><br><span class="line">    tag = info.div.a</span><br><span class="line">    courseName = tag[<span class="string">"title"</span>]  <span class="comment">#课程名字</span></span><br><span class="line">    print(<span class="string">"   "</span>,i,courseName)</span><br><span class="line">    courseUrl = tag[<span class="string">"href"</span>]   <span class="comment">#课程链接</span></span><br><span class="line">    course_list.append((courseName,courseUrl)) <span class="comment">#利用元组的形式保存</span></span><br><span class="line">print(<span class="string">"*****************************************************************"</span>)</span><br><span class="line"><span class="keyword">return</span> course_list</span><br></pre></td></tr></table></figure></p>
<h2 id="课件下载"><a href="#课件下载" class="headerlink" title="课件下载"></a>课件下载</h2><p>后面的页面跳转等处理，其实都类似，这里只介绍一些关键点，毕竟主要的目的在于学习：    </p>
<p>进入课程资源页面，这里直接将关键的 BeautifulSoup 查找语句列出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 访问进入某课程后，在课程页面里，利用 “资源” 模块的 title 查找，拿到其 href，即 url</span></span><br><span class="line">url = h_bs.find_all(title=<span class="string">"资源 - 上传、下载课件，发布文档，网址等信息"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure><br>查找所有资源链接：</p>
<ul>
<li>这里文件夹的处理，涉及到 onclick()，展开文件夹，更新 html 页面，但是这里我没态弄太明白，后面再琢磨。可以的话，可以在评论区给我留言一些相关知识讲解文章；</li>
</ul>
<p>下载文件：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### className：文件夹名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_kj</span><span class="params">(url, fileName, className, session)</span>:</span></span><br><span class="line">    <span class="comment">### 文件名称处理</span></span><br><span class="line">    <span class="comment"># \xa0（不间断空白符&amp;nbsp）转gbk（汉字内码扩展规范）会有错，去掉；</span></span><br><span class="line">    fileName = fileName.replace(<span class="string">u"\xa0"</span>, <span class="string">" "</span>).replace(<span class="string">u"\xc2"</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="comment"># 去掉不合法的文件名字符</span></span><br><span class="line">    fileName = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, fileName)</span><br><span class="line">    className = re.sub(<span class="string">r"[/\\:*\"&lt;&gt;|?]"</span>, <span class="string">""</span>, className)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路径构造，os.getcwd()获取当前路径</span></span><br><span class="line">    dir = os.getcwd() + <span class="string">"/"</span> + className</span><br><span class="line">    file = os.getcwd() + <span class="string">"/"</span> + className + <span class="string">"/"</span> + fileName</span><br><span class="line">    <span class="comment"># 没有课程文件夹则创建</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="comment"># 存在该文件，返回</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file):</span><br><span class="line">        print(<span class="string">"%s已存在，就不下载了"</span> % fileName)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    print(<span class="string">"开始下载%s..."</span> % fileName)</span><br><span class="line">    s = session.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">"wb"</span>) <span class="keyword">as</span> data:</span><br><span class="line">        data.write(s.content)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="视频下载"><a href="#视频下载" class="headerlink" title="视频下载"></a>视频下载</h2><p>进入课程资源页面：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h_bs = BeautifulSoup(h.text, <span class="string">"lxml"</span>)</span><br><span class="line">url = h_bs.find_all(title=<span class="string">"课程视频 - 课程视频"</span>)[<span class="number">0</span>].get(<span class="string">"href"</span>)</span><br></pre></td></tr></table></figure></p>
<p>又分为：课程视频（录播），直播视频（回放），这两部分处理方法一样，以第一项为例：</p>
<p>由于视频页可能包含多页，先抓取各个页的链接：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当时写的比较傻，采用循环加载下一页做的，其实可以直接抓取网页下面显示的页数，然后在原来 url 的基础上构造为： url+"&amp;pageNum="+i 即可；</span></span><br><span class="line">allpageURL.append(url)</span><br><span class="line">        flag =<span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> flag:</span><br><span class="line">            s = session.get(allpageURL[i])</span><br><span class="line">            page = re.search(<span class="string">'&lt;span&gt;&lt;a href="([^上]*?)"&gt;下一页&lt;/a&gt;&lt;/span&gt;'</span>,s.text, re.S)  <span class="comment"># 其实就是获取："&amp;pageNum="+i</span></span><br><span class="line">            <span class="keyword">if</span> page :</span><br><span class="line">                page = page.groups()[<span class="number">0</span>]</span><br><span class="line">                pageURL = <span class="string">'http://course.ucas.ac.cn'</span> + page</span><br><span class="line">                allpageURL.append(pageURL)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            i = i+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>接下来，就是循环在每页，不断的获取所有视频播放的 url，然后进入到播放页面，再找到视频源的 url 即可；    </p>
<p>视频下载：由于果壳大视频采用的 .m3u8 流媒体格式，我使用到了 ffmpeg（需要提前在电脑上安装）；用 subprocess 模块来产生子进程，调用 ffmpeg 完成下载；<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 按照获取到的视频链接调用ffmpeg进行下载，也可以尝试多进程下载，提高下载速度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_sp</span><span class="params">(spName, spUrl)</span>:</span></span><br><span class="line">    ins = <span class="string">'ffmpeg -i '</span> + spUrl + <span class="string">' -c copy '</span> + spName +<span class="string">'.mp4'</span></span><br><span class="line">    p = subprocess.Popen(ins)</span><br><span class="line">    p.wait()</span><br><span class="line">    print(<span class="string">'下载完毕'</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实这个脚本是挺久之前弄的了，但是总觉得之前边写边学，零零碎碎，慢慢的又觉得忘的差不多了。这当然不行，于是，重新梳理总结了一下当时的编写历程。     </p>
<p>通过这次，主要学习到的知识点：</p>
<ol>
<li>利用 webdriver 模拟登陆，以及遇到验证码时，将验证码抓取下来处理，并完成识别；</li>
<li>利用 session 构造 post 表单的方式，实现网站登录；</li>
<li>正则表达式的使用；</li>
<li>BeautifulSoup 的查找方法；</li>
<li>subprocess 的简单使用；</li>
<li>等等</li>
</ol>
<p>不足：</p>
<ul>
<li>还需要学习 js 的处理方法；</li>
</ul>
<p>最后还是需要强调一下，重在学习，利用脚本下载的资源，仅供自己学习使用，请不要传播！</p>
<ul>
<li>『<a href="https://github.com/TheBetterKong/UCAS_Sep" target="_blank" rel="noopener">脚本源码</a>』</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li>『<a href="https://zhuanlan.zhihu.com/p/94402506" target="_blank" rel="noopener">python实现网站的自动登录</a>』</li>
<li>『<a href="https://blog.csdn.net/lusongno1/article/details/79995009" target="_blank" rel="noopener">国科大（UCAS）课件自动批量下载 python3 脚本</a>』</li>
</ul>
]]></content>
      <categories>
        <category>Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
        <tag>Webdriver</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：多处理器</title>
    <url>/2020/02/21/Computer-Architecture/CA-MultiProcessor/</url>
    <content><![CDATA[<p>多处理器中共享存储，和存储一致性问题。</p>
<a id="more"></a> 
<p><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/Overview.png" alt="Overview"></p>
<h1 id="消息传递与共享存储"><a href="#消息传递与共享存储" class="headerlink" title="消息传递与共享存储"></a>消息传递与共享存储</h1><h2 id="消息传递与共享存储对比"><a href="#消息传递与共享存储对比" class="headerlink" title="消息传递与共享存储对比"></a>消息传递与共享存储对比</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ComparisonMessagingSharedstorage.png" alt="ComparisonMessagingSharedstorage"></p>
<ol>
<li><p><strong>共享存储：</strong></p>
<ul>
<li>复杂度高，影响了可升缩性（几百或几十个：SMP 服务器系统几个到几十个）<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/SharedstorageDescription.png" alt="SharedstorageDescription"></li>
</ul>
</li>
<li><p><strong>消息传递：</strong></p>
<ul>
<li>目前常用的几万个处理器；</li>
</ul>
</li>
</ol>
<h2 id="共享存储与消息传递的编程复杂度"><a href="#共享存储与消息传递的编程复杂度" class="headerlink" title="共享存储与消息传递的编程复杂度"></a>共享存储与消息传递的编程复杂度</h2><ol>
<li><p>任务划分与数据划分</p>
<ul>
<li>共享存储编程只需划分任务</li>
<li>消息传递编程除了划分任务外，还需划分数据和考虑通信</li>
<li>共享存储：BBS 与消息传递：Email</li>
</ul>
</li>
<li><p>传递复杂的数据结构较困难：</p>
<ul>
<li>多个指针组成的结构</li>
<li><code>struct {int *pa; int pb*; int *pc}</code></li>
</ul>
</li>
<li><p>动态通信：</p>
<ul>
<li><code>{for (i,j){ x=…; y=…; a [i][j] = b [x][y];}}</code></li>
<li>进程迁移及进程数目的变化</li>
</ul>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="积分求-π"><a href="#积分求-π" class="headerlink" title="积分求 π"></a>积分求 π</h3><p><strong>问题：</strong><br>$\pi = 4\int ^1_0 \frac{1}{1+x^2} {\rm d}x = \sum^N_{i=1} \frac{4}{1+(\frac{i-0.5}{N})^2} \times \frac{1}{N}$</p>
<p><strong>串行程序：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h = <span class="number">1.0</span>/N; pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">	temp = (i<span class="number">-0.5</span>)*h;</span><br><span class="line">	pi = pi +<span class="number">4</span>/(<span class="number">1</span>+temp*temp);</span><br><span class="line">&#125;</span><br><span class="line">pi = pi * h;</span><br><span class="line"><span class="built_in">printf</span> pi;</span><br></pre></td></tr></table></figure></p>
<p><strong>并行程序：</strong><br>该并行程序都采用 SPMD（single program multiple data）模式；<br>每个进程虽然都运行同一个程序，但是处理不同的数据；<br>其中：</p>
<ul>
<li><strong>numprocs</strong>：参与运算的进程个数，所有参与运算的进程都有相同的numprocs值；</li>
<li><strong>myid</strong>：参与运算的进程的编号，每个进程都有自己的编号（一般并行编程系统都会提供接口函数让进程知道自己的编号）</li>
</ul>
<ol>
<li><p><strong>共享存储程序</strong>：（JIAJIA 虚拟共享存储系统）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">double</span> *pi;</span><br><span class="line"> pi = jia_alloc(<span class="number">8</span>);</span><br><span class="line"> h = <span class="number">1.0</span>/N;</span><br><span class="line"> mypi = <span class="number">0.0</span>;</span><br><span class="line"> <span class="keyword">if</span>(myid == <span class="number">0</span>) &#123;pi = <span class="number">0.0</span>;&#125;</span><br><span class="line"> <span class="keyword">for</span>(i=muid+<span class="number">1</span>; i&lt;N; i+=numprocs) &#123;mypi = ...&#125;</span><br><span class="line"> jia_lock(<span class="number">1</span>);</span><br><span class="line">pi+=mypi;</span><br><span class="line"> jia_unlock(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(myid==<span class="number">0</span>) <span class="built_in">printf</span> pi;</span><br></pre></td></tr></table></figure>
<ul>
<li>由 jie_alloc() 分配空间的变量 pi 是所有参与运算的进程共享的，所有进程只有一份，其他变量都是每个进程局部的，每个进程都有一份；</li>
<li>每个进程通过 numprocs 和 myid 号分别计算部分的圆周率值，最后通过一个临界区的机制吧所有进程的计算结果加到一起；</li>
<li>Jia_lock() 和 jia_unlock() 是临界区的锁机制；</li>
</ul>
</li>
<li><p><strong>消息传递程序：</strong></p>
</li>
</ol>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> *pi;</span><br><span class="line">pi = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">h = <span class="number">1.0</span>/N;</span><br><span class="line">mypi = <span class="number">0.0</span>;</span><br><span class="line">pi = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=muid+<span class="number">1</span>; i&lt;N; i+=numprocs) &#123;mypi = ...&#125;</span><br><span class="line">reduce(mypi,pi,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(myid==<span class="number">0</span>) <span class="built_in">printf</span> pi;</span><br></pre></td></tr></table></figure>
<ul>
<li>由 malloc() 分配空间的变量每个进程都有独立的一份，互相看不见；</li>
<li>每个进程算完部分结果后，通过规约操作 reduce（）把所有进程的 mypi 加到 0 号进程的 pi 中；</li>
</ul>
<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p><strong>问题描述：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/MatrixMultiplication.png" alt="MatrixMultiplication"></p>
<ul>
<li>A x B = C 的过程可分为四个独立的部分：Ai x B = Ci，i = 1, 2, 3, 4</li>
<li>每部分包含的运算可由一台处理机单独完成</li>
<li>矩阵较大时，需分开存放，即 Ai,Bi,Ci 放在结点i上 </li>
<li>每个结点的工作分为 AiB1, AiB2, AiB3, AiB4 四个部分</li>
</ul>
<p><strong>并行程序：</strong></p>
<ol>
<li><p><strong>共享存储：</strong><br> <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/MatrixSharedStorage.png" alt="MatrixSharedStorage"></p>
<ul>
<li>先由 0 号进程对 A、B、C 三个矩阵进程初始化，而其他进程通过jia_barrier（）语句等待；</li>
<li><mark>barrier</mark> 是并行程序常见的同步方式，它要求所有进程都到齐后在前进；</li>
<li>然后每个进程分别完成部分运算，在通过 jia_barrier（）到齐后由进程 0 统一打印结果；</li>
</ul>
</li>
<li><p><strong>消息传递：</strong><br> <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/MatrixMessaging.png" alt="MatrixMessaging">    </p>
<ul>
<li>需要通过显示的发送语句 send 和接受语句 recv 进程多个进程之间的通信；</li>
<li>先由进程 0 进行初始化后发生给其他进程，每个进程分别算完后在发生给进程 0 进行打印；</li>
<li>在该机制中，要详细列出每次发送的数据大小和起始地址等信息， 0 号进程接收的时候还要把从其他进程收到的数据拼接在一个矩阵中；</li>
</ul>
</li>
</ol>
<h3 id="图像纠正"><a href="#图像纠正" class="headerlink" title="图像纠正"></a>图像纠正</h3><p><strong>问题描述：</strong></p>
<ul>
<li>把原始图像in通过多项式函数P（）映射到目标图像</li>
</ul>
<p><strong>串行程序：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;lin2; i++)&#123;</span><br><span class="line">	fpor(j=<span class="number">0</span>; j&lt;co12; j++)&#123;</span><br><span class="line">		x=P(i,j,...);</span><br><span class="line">		y=P(i,j,...);</span><br><span class="line">		out[i,j]=in[x][y]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>共享存储并行程序：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start=line2/jiahosts*jiapid;</span><br><span class="line"><span class="built_in">end</span>=star+lin2/jiahosts;</span><br><span class="line"><span class="keyword">if</span>(jiaid==jiahosts) <span class="built_in">end</span>=lin2;</span><br><span class="line"><span class="keyword">for</span>(i=start;i&lt;co12;j++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;<span class="built_in">end</span>;i++)&#123;</span><br><span class="line">		x=P(i,j,...);</span><br><span class="line">		y=P(i,j,...);</span><br><span class="line">		out[i,j]=in[x][y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">jia_barrier();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通信行为是在程序运行过程中动态确定的，这些应用消息传递的方法写并行程序难度大；</li>
<li>数组 in 和 out 分布在不同进程的内存上，在消息传递环境下进程并行化时，由于访问 in 的下标（x，y）是通过多项式 P（）动态算出来的，编写程序是不知道谁需要跟谁通信；</li>
<li>在共享存储环境下由于不用考虑数据分布，只考虑任务分配，所以并行化比较简单；</li>
</ul>
<h2 id="常见的共享存储系统体系结构"><a href="#常见的共享存储系统体系结构" class="headerlink" title="常见的共享存储系统体系结构"></a>常见的共享存储系统体系结构</h2><p><strong>分类依据：</strong></p>
<ul>
<li>存储器的分布、一致性的维护、实现方式等</li>
</ul>
<p><strong>依据存储器的分布：</strong></p>
<ul>
<li><strong>集中式</strong>：多处理器由总线或交叉开关等与共享存储器相连（访问延迟相同），当个数增加时，集中式的存储器成为瓶颈；</li>
<li><strong>分布式（DSM）</strong>：每个结点包含共享存储器的一部分，结点间由伸缩性好的互联网（如：mesh）相连，这样增加了访存带宽，但导致不一致的访存结构NUMA；</li>
</ul>
<p><strong>常见结构：</strong></p>
<ol>
<li><p><strong>无 CACHE 结构：</strong></p>
<ul>
<li>集中式共享存储；</li>
<li>无 cache，多个处理器通过交叉开关或多级互联网络等直接访问共享存储器；</li>
<li>无 CACHE 一致性问题，可伸缩性受限于交叉开关或多级互联网络的带宽；</li>
<li>如：CRAY-XMP，YMP-C90</li>
</ul>
</li>
<li><p><strong>SMP 结构（共享总线结构）：</strong></p>
<ul>
<li>集中式共享存储；</li>
<li>每个处理器都有 cache，多个处理器通过总线与存储器相连；</li>
<li>侦听总线或环等维护一致性，但由于总线是独占性资源，可伸缩性有限；</li>
<li>如：DEC，SUN，SEQUENT，SGI 等公司的 SMP 产品、目前流行的片内多核也多采用该结构；</li>
</ul>
</li>
<li><p><strong>CC-NUMA 结构：</strong></p>
<ul>
<li>cache 一致的分布式共享存储；</li>
<li>共享存储器分布于各结点之间，结点间通过可伸缩性好的互联网相连，每个处理器都能缓存共享单元；</li>
<li>cache 一致性维护是该系统关键，决定了系统的可伸缩性；</li>
<li>通过目录协议等维护一致性；</li>
<li>如：DASH, Alewife, Origin 2000等 </li>
</ul>
</li>
<li><p><strong>NCC-NUMA 结构：</strong></p>
<ul>
<li>cache 不一致的分布式共享存储系统；</li>
<li>虽然每个处理器都有 cache，但硬件不负责维护 cache 一致性，cache 一致性由编译器或程序员维护；</li>
<li>可伸缩性好，可达上千个处理机；</li>
<li>如：以 Cray-T3D 及 T3E 为代表；他们提供了一些用于同步的库函数，便于用户通过设置临界区等手段来维护数据一致性</li>
</ul>
</li>
<li><p><strong>COMA 结构：</strong></p>
<ul>
<li>唯有 cache 结构；共享存储器的地址是活动的；</li>
<li>存储单元与物理地址分离，数据可以根据访存模式动态地在各结点间的存储器移动和复制；</li>
<li>每个结点的存储器相当于一个大容量 CACHE，数据一致性也在这一级维护；</li>
<li>如：KSR，DDM 等； </li>
<li>优点：当处理器访问不在 cache 命中时，在本地共享存储器命中的概率较高；</li>
<li>缺点：当处理器的访问不在本结点命中时，由于存储器的地址是活动的，需要有一种机制来查找被访问单元的当前位置，因此延迟大。</li>
</ul>
</li>
<li><p><strong>虚拟共享存储系统：</strong></p>
<ul>
<li>又称软件 DSM 系统；</li>
<li>在基于消息传递的 MPP 多计算机或机群中，用软件的方法把分布于各节点的多个独立编址的存储器转化为一个统一编址的共享虚拟存储空间；</li>
<li>如：IVY, Midway, Munin, TreadMarks, JIAJIA等；</li>
</ul>
</li>
</ol>
<h2 id="共享存储与消息传递发展趋势"><a href="#共享存储与消息传递发展趋势" class="headerlink" title="共享存储与消息传递发展趋势"></a>共享存储与消息传递发展趋势</h2><ul>
<li>1970 年代到 1980 年代中期，并行系统主要是 <strong>SMP与向量机</strong>，结点个数不多（4-8 路），是科学计算、事务处理、服务器领域的主要产品；</li>
<li>由于 SMP 与向量机可伸缩性差，1990年代<strong>消息传递的 MP</strong>P兴起，主要用于科学计算，同时NUMA系统的研究全面展开，如DASH，Alewife，KSR-1等 ；</li>
<li>1990年代后期，由于解决了伸缩性问题，以 Origin 2000 为标志，<strong>中规模和大规模的共享存储兴起</strong>，SUN 的Starfile，Compaq的Wildfire, 及IBM的NUMA-Q ；<ul>
<li>目前主流的服务器均采用共享存储，低端服务器由处理器ᨀ供直接互连形成2-4路系统；高端服务器通过桥片连接形成几十路的系统；</li>
</ul>
</li>
<li>以科学计算为目的大规模 MPP 系统仍以消息传递为主，几千到上万个处理机，随着带宽的增加与用户级通信的发展，<strong>机群系统与MPP系统</strong>的界限越来越模糊；</li>
<li>主流商业片内多核都采用共享存储结构，甚至==分布式共享存储系统==；片内众核（几百到上千核）如GPU 结构采用独立存储结构；</li>
</ul>
<h2 id="共享存储多核处理器的关键问题"><a href="#共享存储多核处理器的关键问题" class="headerlink" title="共享存储多核处理器的关键问题"></a>共享存储多核处理器的关键问题</h2><p>通用多核处理器一般采用共享存储结构：</p>
<ol>
<li>多个处理器核发出的访存指令次序如何约定？<ul>
<li>存储一致性模型：如顺序一致性、处理器一致性等</li>
</ul>
</li>
<li>多个处理器核间共享片上 Cache 如何组织及维护一致性？<ul>
<li>Cache 一致性协议：片上 Cache 结构及 Cache 一致性协议</li>
</ul>
</li>
<li>多个核处理器核间如何实现通信？ <ul>
<li>片上互连结构</li>
</ul>
</li>
<li>多个处理器核间如何实现同步？<ul>
<li>多核同步机制：互斥锁操作（lock）、路障操作（barrier）</li>
</ul>
</li>
</ol>
<h1 id="共享存储系统中的访存相关性"><a href="#共享存储系统中的访存相关性" class="headerlink" title="共享存储系统中的访存相关性"></a>共享存储系统中的访存相关性</h1><h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><ul>
<li>在单机系统中，只要保持程序中的数据相关性，就可以保证执行正确。在多处理机系统中，不仅要考虑单机内的数据相关，而且要考虑多机之间的数据相关；</li>
<li>为了执行的正确性，每个处理机都必须根据程序序来执行指令</li>
<li>共享存储程序片段 PRG1：是保证只有一个进程进入临界区的一种同步机制</li>
</ul>
<p>例子：<br><img src="https://img-blog.csdnimg.cn/20200123172437996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="ExampleConsistencyProblem"></p>
<ul>
<li>变量定义：<ul>
<li>变量 a，b：指示进程 P1，P2 是否进入临界区的标志（0 未进入，1 进入）；P1，P2 的共享变量；</li>
<li>寄存器 R1，R2 是 P1,P2 的内部寄存器；</li>
</ul>
</li>
<li>工作机制：<ul>
<li>当一个进程试图进入临界区时，它首先把本进程的标志置 1，然后检查另一进程的标志；</li>
<li>若另一进程的标志为 0，说明另一进程为进入临界区，则本进程进入临界区；</li>
<li>否则本进程等待，直到另一进程退出临界区；</li>
</ul>
</li>
<li>可能情况：<ul>
<li>当P1和P2分别执行完相应的进程时，R1 和 R2 的值的正确组合是（0,1）、（1,0）、（1,1）。</li>
<li>这里最后一种情况将导致死锁（假设没有其他方法来防止死锁）；</li>
<li>只有 R1=R2=0 的结果是错误的，它将导致 P1 和 P2 同时进入临界区；            </li>
</ul>
</li>
<li>即使每个处理机都根据程序序执行指令，仍可能导致错误结果：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleConsistencyProblem1.png" alt="ExampleConsistencyProblem1"><ul>
<li>起因：从 Write Atomic 原子的到 Write Non-atomic；</li>
<li>什么是写可分割系统中正确的执行？<ul>
<li><strong>存储一致性模型</strong>和 <strong>Cache 一致性协议</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是正确的执行？"><a href="#什么是正确的执行？" class="headerlink" title="什么是正确的执行？"></a>什么是正确的执行？</h2><ul>
<li><strong>正确性标准</strong>：符合程序员的直觉</li>
<li><strong>正确性规范</strong>：顺序一致性<ul>
<li>如果在多处理机环境下的一个并行执行的结果等于同一程序在单处理机多进程环境下的一个执行的结果，则此并行程序执行正确；</li>
</ul>
</li>
</ul>
<h2 id="并行程序模型"><a href="#并行程序模型" class="headerlink" title="并行程序模型"></a>并行程序模型</h2><p><strong>程序模型 = 指令集 + 指令集上的序关系：</strong></p>
<ul>
<li>一个进程 P 是一个二元组 $<V(P),PO(P)>$，其中 $V(P)$ 是 LOAD 和 STORE 指令的集合，$PO(P)$ 是 $V(P)$ 上的一个全序关系；</li>
<li>由 N 个进程 P1,P2,…,Pn 组成的程序 PRG(P1,P2,…,Pn) 是一个二元组 $<V(PRG),PO(PRG)>$，其中 $V(PRG)=V(P1)\cup V(P2)\cup…\cup V(Pn)$ 是程序 PRG 的指令集，$PO(PRG)=PO(P1)\cup PO(P2)\cup…\cup PO(Pn)$ 是程序 PRG 的程序序；</li>
<li>例：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleParallelProgramModel.png" alt="ExampleParallelProgramModel"></li>
</ul>
<p><strong>冲突访问的概念：</strong></p>
<ul>
<li>意义：程序中冲突访问的执行次序决定了程序执行的结果；</li>
<li>如果两个访存操作访问的是同一单元（单处理器中同一变量）且其中至少有一个是存数操作, 则称这两个访存操作是冲突的；</li>
<li>C(PRG)={(u,v)|((u,v)∈V(PRG))∩(u,v是冲突访问)} 称为程序 PRG 中冲突访问对集；</li>
<li>例：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleConflictAccess.png" alt="ExampleConflictAccess"></li>
</ul>
<h2 id="程序执行的正确性"><a href="#程序执行的正确性" class="headerlink" title="程序执行的正确性"></a>程序执行的正确性</h2><h3 id="执行的概念"><a href="#执行的概念" class="headerlink" title="执行的概念"></a>执行的概念</h3><ul>
<li>在在一个并行执行中，一旦互相冲突的访问的执行次序确定了。那么执行结果也就确定了；</li>
<li>在程序 PRG 中, 对冲突访问对集 C(PRG) 的任一无圈定序称为程序PRG 的一个执行，记为 E(PRG)。</li>
<li>E（PRG ）是C（PRG ）的 ⼀个 定序 : 对任意的 (u,v)∈C(PRG)，(u,v)∈E(PRG) 和 (v,u)∈E(PRG) 有且仅有⼀个成⽴</li>
<li>例子：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleConceptOfExecution.png" alt="ExampleConceptOfExecution"></li>
</ul>
<h3 id="执行的正确性"><a href="#执行的正确性" class="headerlink" title="执行的正确性"></a>执行的正确性</h3><ul>
<li>如果存在 PRG 的⼀个正确串⾏执⾏ SE（PRG），使得 SE（PRG）U P0（PRG）⽆圈 ，且 E（PRG）和 SE（PRG）结果相等 ,则称 E（PRG）是程序 PRG 的⼀个正确执⾏；</li>
<li>串⾏程序串指令的相关性是并⾏程序中冲突访问的⼀种特殊情况；</li>
<li>串⾏程序的执⾏中满⾜程序的相关性是并⾏程序中 E（PRG）U P0（PRG）⽆圈的⼀种特殊情况；</li>
<li>例子：<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleExecuteCorrectly.png" alt="ExampleExecuteCorrectly"></li>
</ul>
<h1 id="共享存储系统的访存事件次序"><a href="#共享存储系统的访存事件次序" class="headerlink" title="共享存储系统的访存事件次序"></a>共享存储系统的访存事件次序</h1><h2 id="满足顺序一致的访存事件次序"><a href="#满足顺序一致的访存事件次序" class="headerlink" title="满足顺序一致的访存事件次序"></a>满足顺序一致的访存事件次序</h2><p><strong>顺序一致的一个充分条件（GPPO条件）：</strong><br>在共享存储多处理机中，若任一处理机都严格按照访存指令在进程中出现的次序执行，且在当前访存指令彻底执行完之前不能开始执行下一条访存指令，则此共享存储系统是顺序一致的。</p>
<ul>
<li>一个存数操作“彻底完成”指的是它所引起的值的变化已被所有处理机所接受；</li>
<li>一个取数操作彻底完成是指它取回的值已确定，且写此值的存数操作已“彻底完成；</li>
</ul>
<h2 id="分布式系统的访存模型"><a href="#分布式系统的访存模型" class="headerlink" title="分布式系统的访存模型"></a>分布式系统的访存模型</h2><ol>
<li><p><strong>写可分割系统的访存事件模型：</strong></p>
<ul>
<li>系统中有 N 个处理机, 每个处理机执行一个进程。</li>
<li>任一访存操作 u 被分割成 N 个子操作 u1,u2,… , un, 其中 ui 表示 u 相对于 Pi 已执行完。 </li>
</ul>
</li>
<li><p><strong>GPPO 条件的描述：</strong></p>
<ul>
<li>任一处理机都按访存指令在进程中出现的次序执行，且在当前访存指令彻底执行完之前不能开始执行下一条访存指令；<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/GPPOConditions.png" alt="GPPOConditions"></li>
</ul>
</li>
<li><p>在写可分割系统中，若执行 E(PRG) 满足 GPPO 条件，则 E(PRG) 正确；</p>
</li>
</ol>
<h2 id="顺序一致系统中的乱序执行"><a href="#顺序一致系统中的乱序执行" class="headerlink" title="顺序一致系统中的乱序执行"></a>顺序一致系统中的乱序执行</h2><ul>
<li>如果访存操作 u 和 v 是同一进程 Pi 的两个访存操作且 u 在 v 之前，则在如下条件下 v 可先于 u 执行而不影响程序正确性：<ul>
<li>在v发出之后u“彻底完成”之前的这段时间内，没有其他对v所访问单元的访问相对于Pi完成（如v所访问单元在Pi中的备份不被更新）<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleOutOfOrder.png" alt="ExampleOutOfOrder"></li>
</ul>
</li>
<li>乱序执行的实现方法：猜测执行<ul>
<li>先往下执行，收到相应的invalidate信号再反悔（区分处理器是不是顺序一致的主要标志）</li>
</ul>
</li>
</ul>
<h1 id="存储一致性模型"><a href="#存储一致性模型" class="headerlink" title="存储一致性模型"></a>存储一致性模型</h1><h2 id="常见的存储一致性模型"><a href="#常见的存储一致性模型" class="headerlink" title="常见的存储一致性模型"></a>常见的存储一致性模型</h2><p><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/StorageConsistencyModel.png" alt="StorageConsistencyModel"></p>
<p>从某种意义上说，存储一致性模型对共享存储系统中多处理机的访存次序作了限制，从而影响了性能；</p>
<h2 id="对存储一致性模型（Memory-Consistency）的观点"><a href="#对存储一致性模型（Memory-Consistency）的观点" class="headerlink" title="对存储一致性模型（Memory Consistency）的观点"></a>对存储一致性模型（Memory Consistency）的观点</h2><ol>
<li><p><strong>历史的观点: Hardware-Centric：</strong></p>
<ul>
<li>对多个处理机访问共享存储器的次序的一些限制</li>
<li>弱一致性模型：放松限制来ᨀ高性能</li>
<li>程序员必须考虑访存次序</li>
<li>系统设计者没有优化余地</li>
</ul>
</li>
<li><p><strong>正确的观点: Programmer-Centric：</strong></p>
<ul>
<li>结构设计者与应用程序员之间的一种约定</li>
<li>给出正确程序的标准</li>
<li>程序员不用考虑访存次序</li>
<li>系统设计者有更多的ᨀ高性能的空间</li>
</ul>
</li>
</ol>
<h2 id="各存储模型"><a href="#各存储模型" class="headerlink" title="各存储模型"></a>各存储模型</h2><h3 id="顺序一致性模型-SC"><a href="#顺序一致性模型-SC" class="headerlink" title="顺序一致性模型 SC"></a>顺序一致性模型 SC</h3><p>正确性标准：符合程序员的直觉<br>正确性规范：顺序一致性</p>
<ul>
<li>如果在多处理机环境下的一个并行执行的结果等于同一程序在单处理机多进程环境下的一个执行的结果，则此并行程序执行正确</li>
</ul>
<h3 id="处理机一致性模型-PC"><a href="#处理机一致性模型-PC" class="headerlink" title="处理机一致性模型 PC"></a>处理机一致性模型 PC</h3><ul>
<li>由 Goodman 提出的处理机一致性（Processor Consistency）比顺序一致性弱；</li>
<li>处理机一致性对访存事件发生次序施加的限制是：<ul>
<li>在任一取数操作 LOAD 允许被执行之前，所有在同一处理机中先于这一 LOAD 的取数操作都已完成</li>
<li>在任一存数操作 STORE 允许被执行之前，所有在同一处理机中先于这一STORE 的访存操作（包括 LOAD 和 STORE）都已完成</li>
<li>上述条件允许 STORE 之后的 LOAD 越过 STORE 而执行，放松了顺序一致性模型对访存次序的限制</li>
</ul>
</li>
<li>实际上是把 Write Buffer 变得让用户可见：<ul>
<li>如：Store 提交后在 Write Buffer，还没有写 Cache /内存，后面的 Load 已经从 Cache 取回数据，此时收到对 Load 访问 Cache 行的一个无效请求（load 指令不可取消）；</li>
</ul>
</li>
</ul>
<h3 id="弱存储一致性模型-WC"><a href="#弱存储一致性模型-WC" class="headerlink" title="弱存储一致性模型 WC"></a>弱存储一致性模型 WC</h3><ul>
<li>把同步操作和普通访存操作区分开来，只在同步点维护一致性：<ul>
<li>同步操作实现顺序一致性；</li>
<li>冲突访问必须用同步操作保护；</li>
</ul>
</li>
<li>访存次序：<ul>
<li>同步操作的执行满足顺序一致性条件；</li>
<li>在任一普通访存操作允许被执行之前，所有在同一处理机中先于这一访存操作的同步操作都已完成；</li>
<li>在任一同步操作允许被执行之前，所有在同一处理机中先于这一同步操作的普通访存操作都已完成；</li>
</ul>
</li>
</ul>
<h3 id="释放一致性模型-RC"><a href="#释放一致性模型-RC" class="headerlink" title="释放一致性模型 RC"></a>释放一致性模型 RC</h3><ul>
<li>把同步操作进一步分成获取操作 ACQUIRE 和释放操作 RELEASE；</li>
<li>冲突访问必须用 REL-&gt;ACQ 对隔开；</li>
<li>访存次序：<ul>
<li>同步操作的执行满足顺序一致性条件；</li>
<li>任一普通访存操作允许被执行之前，所有在同一处理机中先于这一访存操作的 ACQUIRE 操作都已完成；</li>
<li>任一 RELEASE 操作允许被执行之前，所有在同一处理机中先于这一 RELEASE 的普通访存操作都已完成；</li>
</ul>
</li>
</ul>
<h4 id="急切更新释放一致性-ERC"><a href="#急切更新释放一致性-ERC" class="headerlink" title="急切更新释放一致性 ERC"></a>急切更新释放一致性 ERC</h4><ul>
<li>临界区内的多个存数操作对共享内存的更新不是及时进行，而是在执行 release 操作前（退出临界区）集中进行；</li>
<li>把多个存数操作合在一起，从进行统一执行，进而减少了数据通信次数；</li>
</ul>
<h4 id="懒惰更新释放一致性-LRC"><a href="#懒惰更新释放一致性-LRC" class="headerlink" title="懒惰更新释放一致性 LRC"></a>懒惰更新释放一致性 LRC</h4><ul>
<li>由一个处理器对某单元的存数操作并不是由此处理器主动的传播到所有共享该单元的处理器，而是在其他处理器要用到此处理器所写的数据时（其他处理器acquire时）再向此处理器索取该单元的最新备份；</li>
</ul>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleRC.png" alt="ExampleRC"></p>
<ul>
<li>处理器 p1 所写的 y 值到达处理器 p2 的时刻不同：<ul>
<li>RC：P1 执行操作 “y=1” 时就开始把 y 的新值传播到 P2；</li>
<li>ERC：P1 执行 “rell（11）” 时才开始传播 y 的新值；</li>
<li>LRC：它不要求 P1 主动传播 y 的新值，只有在 P2 执行 “acq（11）” 时才向 P1 索取 y 的新值；</li>
</ul>
</li>
<li>RC、ERC、LRC 对同一程序体现出相同的行为，即它们在程序行为一级有相同的语义，对程序员有相同的正确程序设计要求。它们不是不同的存储一致性模型，而是同一存储一致性模型的不同实现；</li>
</ul>
<h3 id="域一致性模型-ScC"><a href="#域一致性模型-ScC" class="headerlink" title="域一致性模型 ScC"></a>域一致性模型 ScC</h3><ul>
<li>冲突访问必须用同一把锁保护；</li>
<li>举例：<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExampleSsC.png" alt="ExampleSsC"></li>
</ul>
<h3 id="单项一致性模型-EC"><a href="#单项一致性模型-EC" class="headerlink" title="单项一致性模型 EC"></a>单项一致性模型 EC</h3><ul>
<li>必须为每一个共享变量指定相应的锁；</li>
<li>加重了程序员的负担；</li>
<li>有利于性能；</li>
</ul>
<h1 id="CACHE-一致性协议"><a href="#CACHE-一致性协议" class="headerlink" title="CACHE 一致性协议"></a>CACHE 一致性协议</h1><h2 id="共享存储多处理机中的-Cache-一致性问题"><a href="#共享存储多处理机中的-Cache-一致性问题" class="headerlink" title="共享存储多处理机中的 Cache 一致性问题"></a>共享存储多处理机中的 Cache 一致性问题</h2><ol>
<li>Cache 在共享存储系统中的作用：<ul>
<li>弥补 CPU 与主存间的速度差距</li>
<li>减少访存冲突以及对互连网络带宽的需求</li>
</ul>
</li>
<li>Cache 一致性问题：<ul>
<li>如何保持数据在 Cache 及主存中的多个备份的一致性</li>
</ul>
</li>
</ol>
<h2 id="Cache-一致性协议（Cache-Coherence-Protocol）"><a href="#Cache-一致性协议（Cache-Coherence-Protocol）" class="headerlink" title="Cache 一致性协议（Cache Coherence Protocol）"></a>Cache 一致性协议（Cache Coherence Protocol）</h2><p><strong>定义：</strong></p>
<ul>
<li>一种把新写的值传播到其他处理机的机制；</li>
</ul>
<p><strong>类别：</strong></p>
<ul>
<li>如何传播新值：Write Invalidate vs. Write Update // 写无效 vs 写更新</li>
<li>谁可以产生新值：Single Writer vs. Multiple Writer // 单写协议 vs 多写协议</li>
<li>何时开始传播新值：Early vs. Delayed Propagation // 及时传播 vs 延时传播</li>
<li>向何处传播新值：Snoopy vs. Directory Protocol  // 侦听协议 vs 目录协议</li>
</ul>
<p><strong>意义：</strong></p>
<ul>
<li>Cache 一致性协议决定系统为维护一致性所做的具体动作，因而直接影响系统性能；</li>
</ul>
<p><strong>Write-Invalidate 和 Write Update：</strong></p>
<ol>
<li><p>Write-Invalidate：</p>
<ul>
<li>当一个处理机更新某共享单位（如存储行或存储页）时（之前或之后），通过某种机制使该共享单位的其它备份无效，当其它处理机访问该共享单位时，访问失效，再取得有效备份；</li>
<li>适用于顺序共享（sequential sharing）的程序：在较长时间内只有一个处理器访问一个变量；</li>
</ul>
</li>
<li><p>Write-Update：</p>
<ul>
<li>当一个当一个处理机更新某共享单位时，把更新的内容传播给所有拥有该共享单位备份的处理机；</li>
<li>适用于紧密共享（tight sharing）的程序：多个处理器在一段时间内频繁的访问同一变量；</li>
</ul>
</li>
<li><p>比较：</p>
<ul>
<li>Write Update: 重复更新已不再使用的行；</li>
<li>Write Invalidate: 假共享导致乒乓问题（处理器之间频繁的互相剥夺对一个共享块的访问权导致性能严重地下降）；</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>在共享粒度较⼤的共享存储系统中（尤其指共享虚拟存储系统中，共享粒度很⼤，通常为⼀⻚），容易导致假共享。</li>
<li><strong>假共享</strong>：⼏个处理器虽然共享某个存储块，但没有真正共享数据。在⼏个处理器同时访问同⼀共享块的不同部分时就会发⽣假共享</li>
</ul>
</li>
</ol>
<p><strong>单写和多写：</strong></p>
<ol>
<li><p>单写：任一时刻只有一个处理机能写某共享单位</p>
</li>
<li><p>多写：多个处理机同时写某共享单位的不同部分</p>
<ul>
<li>多写协议会引起额外的存储和计算开销；</li>
<li>问题：<ul>
<li>为了把不同处理器对同一共享块中不同部分的修改内容“合并”在一起，需要识别每个处理器修改了该共享块中的哪部分内容？</li>
</ul>
</li>
<li>做法：<ul>
<li>在处理器第一次写一个共享块之前，为该共享块做一个备份（该共享块的块备份 twin）；</li>
<li>当一致性协议要求对不同处理器的修改内容进行合并时，每个修改过该共享块的处理器吧该快当前的内容与它的 twin 进行比较，得出本处理器的修改内容（块差 diff）；</li>
<li>这样，可以把不同处理器关于同一共享块的 diff 合并在一起，得到该共享块的新内容；</li>
</ul>
</li>
</ul>
</li>
<li><p>图示：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/SingleMultipleWrite.png" alt="SingleMultipleWrite"></p>
</li>
</ol>
<p><strong>急切更新与懒惰更新：</strong></p>
<ul>
<li>普通 RC：边写边传输写操作</li>
<li>Eager RC：把写操作延迟到 Release 时一起发出</li>
<li>Lazy RC：进一步延迟到下一个 Acquire 时再传输</li>
<li>ERC 和 LRC 是 RC 的不同实现，不是不同的一致性模型<br>  <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/UrgentLazyUpdatesCompare.png" alt="UrgentLazyUpdatesCompare"></li>
</ul>
<p><strong>侦听协议：</strong></p>
<ol>
<li>通过广播维护一致性：<ul>
<li>写数的处理机把新写的值或所需的存储行地址广播出去；</li>
<li>其他处理机侦听广播，当广播中的内容与自己有关时，接受新值或提供数据：<ol>
<li>写使无效侦听：让自己的备份无效；</li>
<li>写更新侦听：更新自己的备份值；</li>
</ol>
</li>
<li>存储器和每个处理机的 Cache 只维护状态信息；</li>
</ul>
</li>
<li>适合于总线结构的 SMP 系统中：<ul>
<li>只适用于可伸缩性差的共享总线结构；</li>
<li>总线是一种廉价而有效的广播工具</li>
</ul>
</li>
<li>可伸缩性有限<ul>
<li>总线是一种独占性资源</li>
<li>总线延迟随处理机数的增加而增加：仲裁、总线长度、总线阻抗</li>
</ul>
</li>
</ol>
<p><strong>基于目录的协议：</strong></p>
<ul>
<li>每个存储行对应一个目录项：<ul>
<li>记录拥有该行的一个副本的那些处理机以及此行是否已被改写等信息；</li>
<li>当某个处理机写该行时,根据目录项的内容传播数据（写使无效/写更新信号）；</li>
<li>在 COMA 结构中，记录该行的 Owner</li>
</ul>
</li>
<li>由于避免了广播，目录协议有一定的伸缩性；</li>
<li>适⽤于采⽤通⽤互联⽹络的分布式系统；</li>
<li>目录需要大量存储空间, 需要动态维护：<ol>
<li>位向量目录: O(MN)，存储开销大；<ul>
<li>其中：M：共享存储容量；N：处理器数；</li>
<li>目录表每一目录项，包括：<ul>
<li>n位的向量：第i位为1表示此存储行在第i个存储器有备份；</li>
<li>改写位：为1表示某处理器独占并改写此行，此行为dirty，否则为CLEAN状态；</li>
</ul>
</li>
</ul>
</li>
<li>有限指针目录：O(M logN)，指针溢出；<ul>
<li>用有限个指针（log2n）指向当前持有此向量的几个处理器；</li>
<li>共享的处理器太多时，可能出现指针溢出，此时用指针替换、广播等方法处理；</li>
</ul>
</li>
<li>链目录: O(M logN)，串行更新；<ul>
<li>把所有持有同一存储行的cache行用链表链接起来，链表头存在存储行处；</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="ESI-协议"><a href="#ESI-协议" class="headerlink" title="ESI 协议"></a>ESI 协议</h2><p><strong>状态</strong>：<br>ESI 是指 Cache 行的三种一致性状态：</p>
<ul>
<li>EXC（Exclusive，独占）：表明对应Cache 行被当前处理器核独占，当前处理器核可以随意读写，其他处理器核如果想读写这个cache 行需要请求占有这个cache 块的处理器核释放该Cache 行 ；</li>
<li>SHD（Shared，共享）：表明当前Cache 行可能被多个处理器核共享，只能读取，不能写入；</li>
<li>INV （Invalid，无效）：表明当前Cache 块是无效的；</li>
</ul>
<p><strong>状态转换图：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/StateTransitionDiagram.png" alt="StateTransitionDiagram"></p>
<p><strong>应用情景：</strong><br>根据 x 在 cache 和存储器中的不同状态采取不同的操作:<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ESI1.png" alt="ESI1"><br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ESI2.png" alt="ESI2"><br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ESI3.png" alt="ESI3"></p>
<p><strong>协议举例</strong><br>基于目录，单写，写使无效；</p>
<ol>
<li><p>单元 x 初始时在存储器中处于 CLEAN 状态（改写位为 0），并被处理器 Pj 和 Pk 所共享（在 Pj 和 Pk 的 cache 中处于 SHD 状态，如图 a；<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements1.png" alt="ExamplesAgreements1"></p>
</li>
<li><p>接着 x 被多个处理器按如下次序访问：</p>
<ul>
<li>处理器 Pi 发出存数操作 STORE x；<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements2.png" alt="ExamplesAgreements2"></li>
<li>处理器 Pk 发出存数操作 STORE x；<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements3.png" alt="ExamplesAgreements3"></li>
<li>处理器 Pi 发出取数操作 LOAD x；<ul>
<li>若支持 SC，Pi 需等到 Pk 的 “STORE x” 执行完；</li>
<li>若支持 RC，无限制；<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements4.png" alt="ExamplesAgreements4"></li>
</ul>
</li>
<li>处理器 Pj 发出取数操作 LOAD x；<br><img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements5.png" alt="ExamplesAgreements5"></li>
</ul>
</li>
<li><p>最终状态：<br> <img src="http://img.thebetterkong.cn/blog/CA-MultiProcessor/ExamplesAgreements6.png" alt="ExamplesAgreements6"></p>
</li>
</ol>
<h2 id="存储一致性模型与-Cache-一致性协议"><a href="#存储一致性模型与-Cache-一致性协议" class="headerlink" title="存储一致性模型与 Cache 一致性协议"></a>存储一致性模型与 Cache 一致性协议</h2><p>存储一致性模型对 Cache 一致性协议的制约作用：</p>
<ol>
<li>Cache 一致性协议都是针对某种存储一致性模型而设计的；</li>
<li>存储一致性模型为 Cache 一致性协议规定了“一致性”的目标，即，什么是“一致性”；<ul>
<li>如，顺序一致性模型要求对某处理机所写的值立即进行传播，在确保该值已经被所有处理机接受后才能继续其它指令的执行；</li>
<li>如，释放一致性模型允许将某处理机所写的值延迟到释放锁时进行传播；</li>
</ul>
</li>
</ol>
<h2 id="访存事件次序在微结构中的实现"><a href="#访存事件次序在微结构中的实现" class="headerlink" title="访存事件次序在微结构中的实现"></a>访存事件次序在微结构中的实现</h2><ol>
<li><p>指令在保留站中等待发射时检查并等待：</p>
<ul>
<li>等到前面所有指令都提交</li>
<li>Store 操作写到 Cache、访存失效队列空</li>
<li>同步操作如 sync、LL、SC 一般在发射时控制</li>
</ul>
</li>
<li><p>Load 操作能不能越过未完成（地址未确定或尚在 Store Buffer 中）的 Store 操作执行：</p>
<ul>
<li>如果 Load 数据返回到寄存器并被使用了，取消起来很麻烦</li>
<li>外部来的 invalidate 操作要查看 Store Buffer 也很麻烦</li>
</ul>
</li>
<li><p>为了性能和实现的简洁常使用弱一致性模型</p>
</li>
</ol>
<h2 id="分析多核-CPU-的要素"><a href="#分析多核-CPU-的要素" class="headerlink" title="分析多核 CPU 的要素"></a>分析多核 CPU 的要素</h2><ol>
<li><p>处理器核：</p>
<ul>
<li>异构、同构；通用、专用；重核、轻核；多核、众核</li>
</ul>
</li>
<li><p>互连结构：</p>
<ul>
<li>可伸缩程度，是否支持片间互连</li>
</ul>
</li>
<li><p>访存结构：</p>
<ul>
<li>所有核同一地址空间、不同核不同地址空间</li>
<li>Cache 一致性协议：是否可伸缩</li>
</ul>
</li>
<li><p>峰值性能和访存带宽及 IO 带宽：</p>
<ul>
<li>避免茶壶里面倒饺子</li>
<li>通用多核处理器访存带宽和峰值性能差距不能太大</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Architecture：静态流水线</title>
    <url>/2020/02/21/Computer-Architecture/CA-StaticPipeline/</url>
    <content><![CDATA[<p>本章会介绍一个基本的流水线，并在此流水线的基础上，不断改进，引入一些相关、冲突、例外处理技术等；</p>
<a id="more"></a> 
<h1 id="一个简单的-MIPS-CPU"><a href="#一个简单的-MIPS-CPU" class="headerlink" title="一个简单的 MIPS CPU"></a>一个简单的 MIPS CPU</h1><p>从 MIPS 指令集拣选部分代表性的指令，基本特征包括：</p>
<ul>
<li>RISC 结构；</li>
<li>32 位指令及数据；</li>
<li>32 个通用寄存器，0 号 GPR 恒为 0；</li>
<li>指令格式：<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/MIPSInstructFormat.png" alt="MIPSInstructFormat"></li>
</ul>
<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/BasicInstructions.png" alt="BasicInstructions"></p>
<h2 id="主要数据通路"><a href="#主要数据通路" class="headerlink" title="主要数据通路"></a>主要数据通路</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannel.png" alt="DataChannel"></p>
<ul>
<li>其中，<strong>“两读一写”寄存器堆电路结构</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/RegisterFileCircuit.png" alt="RegisterFileCircuit"></li>
</ul>
<h2 id="主要控制逻辑"><a href="#主要控制逻辑" class="headerlink" title="主要控制逻辑"></a>主要控制逻辑</h2><ol>
<li><p>控制信号：</p>
<ul>
<li>C1 ：PC 计算源操作数 2 的二选一</li>
<li>C2 ：ALU 源操作数 2 的二选一</li>
<li>C3 ：寄存器写回结果的二选一</li>
<li>C4 ：目的寄存器号的二选一</li>
<li>C5 ：寄存器堆的写使能</li>
<li>C6 ：数据存储器的写使能</li>
<li>ALUOp：ALU 控制</li>
</ul>
</li>
<li><p>真值表：<br> <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/TruthTable.png" alt="TruthTable"></p>
</li>
<li><p>控制信号的 Verilog 描述：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] op = inst[<span class="number">31</span>:<span class="number">26</span>];</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] func = inst[<span class="number">5</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">wire</span> inst_addu = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100001);</span><br><span class="line"><span class="keyword">wire</span> inst_subu = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100010);</span><br><span class="line"><span class="keyword">wire</span> inst_slt = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b101010);</span><br><span class="line"><span class="keyword">wire</span> inst_sltu = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b101011);</span><br><span class="line"><span class="keyword">wire</span> inst_and = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100100);</span><br><span class="line"><span class="keyword">wire</span> inst_or = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100101);</span><br><span class="line"><span class="keyword">wire</span> inst_xor = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100110);</span><br><span class="line"><span class="keyword">wire</span> inst_nor = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b100111);</span><br><span class="line"><span class="keyword">wire</span> inst_sllv = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6'b000100</span>);</span><br><span class="line"><span class="keyword">wire</span> inst_srlv = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6'b000110</span>);</span><br><span class="line"><span class="keyword">wire</span> inst_srav = (op==<span class="number">6'b0</span>) &amp;&amp; (func==<span class="number">6</span>’b000111);</span><br><span class="line"><span class="keyword">wire</span> inst_addiu = op==<span class="number">6</span>’b001001;</span><br><span class="line"><span class="keyword">wire</span> inst_lw = op==<span class="number">6</span>’b100011;</span><br><span class="line"><span class="keyword">wire</span> inst_sw = op==<span class="number">6</span>’b101011;</span><br><span class="line"><span class="keyword">wire</span> inst_beq = op==<span class="number">6</span>’b000100;</span><br><span class="line"><span class="keyword">wire</span> inst_bne = op==<span class="number">6</span>’b000101;</span><br><span class="line"><span class="keyword">wire</span> inst_blez = op==<span class="number">6</span>’b000110;</span><br><span class="line"><span class="keyword">wire</span> inst_bgtz = op==<span class="number">6</span>’b000111;</span><br><span class="line"><span class="keyword">wire</span> c1 = inst_beq | inst_bne</span><br><span class="line">		| inst_blez | inst_bgtz;</span><br><span class="line"><span class="keyword">wire</span> c2 = inst_addiu | inst_lw | inst_sw;</span><br><span class="line"><span class="keyword">wire</span> c3 = inst_addiu | inst_lw;</span><br><span class="line"><span class="keyword">wire</span> c4 = inst_lw;</span><br><span class="line"><span class="keyword">wire</span> c5 = ~(inst_sw | c1);</span><br><span class="line"><span class="keyword">wire</span> c6 = inst_sw;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] aluop;</span><br><span class="line"><span class="keyword">assign</span> aluop[<span class="number">0</span>] = inst_subu | inst_sltu | inst_or</span><br><span class="line">		| inst_nor | inst_srav;</span><br><span class="line"><span class="keyword">assign</span> aluop[<span class="number">1</span>] = inst_slt | inst_sltu | inst_xor</span><br><span class="line">		| inst_nor | inst_srlv | inst_srav;</span><br><span class="line"><span class="keyword">assign</span> aluop[<span class="number">2</span>] = inst_and | inst_or | inst_xor | inst_nor;</span><br><span class="line"><span class="keyword">assign</span> aluop[<span class="number">3</span>] = inst_sllv | inst_srlv | inst_srav;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="加入控制逻辑的数据通路"><a href="#加入控制逻辑的数据通路" class="headerlink" title="加入控制逻辑的数据通路"></a>加入控制逻辑的数据通路</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelControlLogic.png" alt="DataChannelControlLogic"></p>
<h2 id="加入时序：指令内、指令间"><a href="#加入时序：指令内、指令间" class="headerlink" title="加入时序：指令内、指令间"></a>加入时序：指令内、指令间</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelSequence.png" alt="DataChannelSequence"></p>
<h1 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h1><h2 id="时序改进"><a href="#时序改进" class="headerlink" title="时序改进"></a>时序改进</h2><ol>
<li><p>原来时序的三个步骤：</p>
<ul>
<li>指令地址送到 PC、取指到 IR、计算结果到 GPR<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/Sequence1.png" alt="Sequence1"></li>
</ul>
</li>
<li><p>合并后的时序：</p>
<ul>
<li>计算下一条指令的 PC 和指令执行重叠；<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/Sequence2.png" alt="Sequence2"></li>
<li>可以把计算下一拍 PC 值作为指令执行的一部分（转移指令的运算结果是 PC 的值）<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/Sequence3.png" alt="Sequence3"></li>
</ul>
</li>
<li><p>改进后的时序：<br> <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelSequenceImprove.png" alt="DataChannelSequenceImprove"></p>
</li>
</ol>
<h2 id="进一步并行：取指与运算"><a href="#进一步并行：取指与运算" class="headerlink" title="进一步并行：取指与运算"></a>进一步并行：取指与运算</h2><ol>
<li><p>通常情况下：</p>
<ul>
<li>第 n+1 条指令执行时，第 n 条指令已经执行完，因此第 n+1 条指令可以用到第 n 条指令的结果。</li>
</ul>
</li>
<li><p>例外：</p>
<ul>
<li>如果第 n+1 条指令的取指也要用到第 n 条指令的结果，则第 n+1 条指令的取指必须等到第 n 条指令结束后才能执行。（转移指令常出现）</li>
</ul>
</li>
<li><p>“延迟槽”解决：</p>
<ul>
<li>紧挨着转移指令后面的一条指令不依赖转移条件执行，则可以：<ul>
<li>从转移指令前面放一条指令到后面去</li>
<li>也可以放一条 nop</li>
</ul>
</li>
<li>例：把内存中 100 个整数的值分别加 1（左边的程序段 R1 初始值为 400，右边的程序段 R1 初始值为 396）<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/InstructDelaySlot.png" alt="InstructDelaySlot"></li>
</ul>
</li>
<li><p>进一步改进后的时序—-转移指令需要延迟槽<br> <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelDelaySlot.png" alt="DataChannelDelaySlot"></p>
</li>
</ol>
<h2 id="进一步改进：划分执行阶段"><a href="#进一步改进：划分执行阶段" class="headerlink" title="进一步改进：划分执行阶段"></a>进一步改进：划分执行阶段</h2><p>上述两级流水线：</p>
<ul>
<li>取指和执行</li>
<li>执行阶段做的事情较多：<ul>
<li>译码（包括读取寄存器的值）</li>
<li>运算（ALU操作）</li>
<li>访存（取数或存数）</li>
<li>写回到寄存器</li>
</ul>
</li>
<li>时钟周期较长，一拍内必须做完上述四件事情</li>
<li>于是，将执行阶段再细分：分成译码、运算、访存、写回</li>
</ul>
<p><strong><mark>标准指令流水线</mark></strong>：</p>
<ul>
<li><strong>五级流水线：IF, ID, EX, MEM, WB</strong>（计算 PC 在 ID 阶段）</li>
<li>标准指令流水：<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/StandardInstruction.png" alt="StandardInstruction"></li>
<li>指令流水线控制及时序：<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/StandardInstructionPipeline.png" alt="StandardInstructionPipeline"></li>
</ul>
<h1 id="指令相关和流水线冲突"><a href="#指令相关和流水线冲突" class="headerlink" title="指令相关和流水线冲突"></a>指令相关和流水线冲突</h1><h2 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h2><ul>
<li>流水线变深了，相关问题更为突出；</li>
<li>在流水线中，如果某指令的某个阶段必须等到它前面另一条指令的某个阶段后才能开始，则这两条指令存在相关；</li>
<li>相关的指令要隔开足够远，否则后面的指令就必须等待；</li>
</ul>
<h2 id="之前流水线可能存在的相关"><a href="#之前流水线可能存在的相关" class="headerlink" title="之前流水线可能存在的相关"></a>之前流水线可能存在的相关</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/PossibleInstructRelated.png" alt="PossibleInstructRelated"></p>
<h2 id="指令流水线的相关"><a href="#指令流水线的相关" class="headerlink" title="指令流水线的相关"></a>指令流水线的相关</h2><p>相关引起流水线阻塞;     </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>相关种类</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据相关</td>
<td>使用同一个寄存器引起的相关</td>
<td>如后面的指令用到前面指令的结果</td>
</tr>
<tr>
<td>控制相关</td>
<td>与 PC 有关的相关</td>
<td>每条指令取指用到 PC，转移指令修改 PC</td>
</tr>
<tr>
<td>结构相关</td>
<td>资源冲突</td>
<td>多条指令同时使用一个功能部件</td>
</tr>
</tbody>
</table>
</div>
<h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>访存引起：</p>
<ul>
<li>访存和取指都需要存储器端口；</li>
</ul>
<p>例如：Havard 结构<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/HavardStructure.png" alt="HavardStructure"></p>
<h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>数据相关的类型：</p>
<ul>
<li>在动态流水线中会有 WAR 和 WAW 相关</li>
</ul>
<ol>
<li>RAW(Read After Write)：<ul>
<li>后面指令用到前面指令所写的数据</li>
</ul>
</li>
<li>WAW(Write After Write)：<ul>
<li>两条指令写同一个单元</li>
<li>在简单流水线中没有此类相关，因为不会乱序执行</li>
</ul>
</li>
<li>WAR(Write After Read)：<ul>
<li>后面指令覆盖前面指令所读的单元</li>
<li>在简单流水线中没有此类相关</li>
</ul>
</li>
</ol>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataRelated.png" alt="DataRelated"></p>
<p>相关控制：<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelDataRelated.png" alt="DataChannelDataRelated"></p>
<h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>PC 相关：</p>
<ul>
<li>转移指令计算的下一条指令地址在 EX 阶段计算，下一条指令等 2 拍 ；</li>
<li>使用专门的地址运算部件把地址计算提前到译码阶段可以少等一拍；</li>
<li>使用一个转移指令延迟槽（delay slot）可以不用等待；<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/PCRelated.png" alt="PCRelated"></li>
</ul>
<p>转移条件相关：</p>
<ul>
<li>如果在ID阶段执行转移指令时转移指令的源操作数没有准备好还是要等待<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/TransferConditionsRelated.png" alt="TransferConditionsRelated"></li>
</ul>
<p>转移控制相关的流水线：<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelControlRalated.png" alt="DataChannelControlRalated"></p>
<h1 id="流水线的前递技术"><a href="#流水线的前递技术" class="headerlink" title="流水线的前递技术"></a>流水线的前递技术</h1><h2 id="前递-Forwarding-技术"><a href="#前递-Forwarding-技术" class="headerlink" title="前递 Forwarding 技术"></a>前递 Forwarding 技术</h2><p>解决 RAW 相关；</p>
<ul>
<li>在执行（EX）阶段的运算结果出来后直接送到后续指令的 EX 阶段</li>
<li>例子：<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/ForwardingExample.png" alt="ForwardingExample"></li>
</ul>
<h2 id="前递情况下的数据相关"><a href="#前递情况下的数据相关" class="headerlink" title="前递情况下的数据相关"></a>前递情况下的数据相关</h2><ul>
<li>取数指令的结果在 MEM 阶段才有效，后续相关指令需要阻塞一拍</li>
<li>例子：<br>  <img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/ForwardingDataRalated.png" alt="ForwardingDataRalated"></li>
</ul>
<h2 id="ALU-Forward-控制"><a href="#ALU-Forward-控制" class="headerlink" title="ALU Forward 控制"></a>ALU Forward 控制</h2><p>（只考虑ALU前递，不包括访存和转移前递）   </p>
<p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelForward.png" alt="DataChannelForward">   </p>
<p><strong>Forwarding的相关处理逻辑（前递技术的三选一选择器的控制）：</strong></p>
<ul>
<li>把指令的两个源寄存器号：src1D 和 src2D 传递到 EX 流水级</li>
<li>以 ALU 左端的输入即 src1D 为例（优先级由高到低）：<ul>
<li>当 src1D=destE 且执行级操作是 LW 时，后面流水线暂停，往前面流水线送空操作；</li>
<li>当 src1D=destE 且执行级操作不是 LW 时，选择左边通路；</li>
<li>当 src1D=destM 时，选择右边通路；</li>
<li>当 src1D 和前面两级的目标寄存器域 destE 和 destM 都不相等时，选择中间通路；</li>
</ul>
</li>
</ul>
<h2 id="通过静态调度解决相关"><a href="#通过静态调度解决相关" class="headerlink" title="通过静态调度解决相关"></a>通过静态调度解决相关</h2><p>例子：如下程序段的优化和非优化代码：a = b + c; d = e -f;   </p>
<p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/StaticSchedulRelatedSolution.png" alt="StaticSchedulRelatedSolution"></p>
<h1 id="流水线和例外"><a href="#流水线和例外" class="headerlink" title="流水线和例外"></a>流水线和例外</h1><h2 id="例外-Exception"><a href="#例外-Exception" class="headerlink" title="例外(Exception)"></a>例外(Exception)</h2><p>例外原因：</p>
<ul>
<li>I/O请求：外部中断</li>
<li>指令例外：用户请求例外（系统调用、断点、跟踪调试指令）</li>
<li>运算部件：（整数运算溢出、浮点异常）</li>
<li>存储管理部件：（访存地址不对齐、用户访问系统空间、TLB 失效、缺页、存储保护错（写只读页））</li>
<li>保留指令错：未实现指令</li>
<li>硬件错</li>
<li>……………</li>
</ul>
<p>例外发生的流水阶段：</p>
<ul>
<li>取指：访存例外</li>
<li>译码：保留指令、中断指令如 Trap、Syscall</li>
<li>执行：整数溢出、浮点异常（如除零）等</li>
<li>访存：访存例外</li>
<li>其它：外部中断，可能在任何时候发生</li>
</ul>
<p>例外特征：</p>
<ul>
<li>同步与异步</li>
<li>用户请求与系统强制</li>
<li>可屏蔽与不可屏蔽</li>
<li>指令内与指令间</li>
<li>可恢复与结束</li>
</ul>
<p>综述：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>同步/异步</th>
<th>用户/强制</th>
<th>可/不可屏蔽</th>
<th>指令内/间</th>
<th>可恢复/结束</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O 请求</td>
<td>异步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令间</td>
<td>可恢复</td>
</tr>
<tr>
<td>系统调用</td>
<td>同步</td>
<td>用户</td>
<td>不可屏蔽</td>
<td>指令间</td>
<td>可恢复</td>
</tr>
<tr>
<td>跟踪调试</td>
<td>同步</td>
<td>用户</td>
<td>可屏蔽</td>
<td>指令间</td>
<td>可恢复</td>
</tr>
<tr>
<td>断点</td>
<td>同步</td>
<td>用户</td>
<td>可屏蔽</td>
<td>指令间</td>
<td>可恢复</td>
</tr>
<tr>
<td>整数溢出</td>
<td>同步</td>
<td>强制</td>
<td>可屏蔽</td>
<td>指令内</td>
<td>可恢复</td>
</tr>
<tr>
<td>浮点异常</td>
<td>同步</td>
<td>强制</td>
<td>可屏蔽</td>
<td>指令内</td>
<td>可恢复</td>
</tr>
<tr>
<td>缺页</td>
<td>同步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令内</td>
<td>可恢复</td>
</tr>
<tr>
<td>访存地址不齐</td>
<td>同步</td>
<td>强制</td>
<td>可屏蔽</td>
<td>指令内</td>
<td>可恢复</td>
</tr>
<tr>
<td>存储保护错</td>
<td>同步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令内</td>
<td>可恢复</td>
</tr>
<tr>
<td>非法指令</td>
<td>同步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令内</td>
<td>结束</td>
</tr>
<tr>
<td>硬件错</td>
<td>异步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令内</td>
<td>结束</td>
</tr>
<tr>
<td>电源错</td>
<td>异步</td>
<td>强制</td>
<td>不可屏蔽</td>
<td>指令内</td>
<td>结束</td>
</tr>
</tbody>
</table>
</div>
<p><strong>指令内可恢复</strong>例外的处理比较困难，条件转移指令的 delay slot 又增加了例外处理的难度；   </p>
<p><strong>精确例外</strong></p>
<ul>
<li>存储管理和IEEE运算规范的要求；</li>
</ul>
<ol>
<li>定义：<ul>
<li>在处理例外时，发生例外指令前面的所有指令都执行完，例外指令后面的所有指令还未执行。</li>
</ul>
</li>
<li>做法：<ul>
<li>发生例外指令前面的指令继续执行完</li>
<li>后面的指令不能修改机器状态，对运算状态字的修改可能在 EX 阶段进行</li>
<li>多条指令发生例外</li>
<li>可以把每条指令的例外延迟到 WB 时再处理<ul>
<li>对机器状态的修改也在 WB 阶段进行</li>
<li>对状态寄存器的修改从 EX 阶段延迟到 WB 阶段</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="流水线例外处理"><a href="#流水线例外处理" class="headerlink" title="流水线例外处理"></a>流水线例外处理</h2><p>简单流水线的例外处理：</p>
<ul>
<li>任何一级流水发生例外时，在流水线中记录下发生例外的事件，直到 WB 阶段再处理</li>
<li>如果在 EX 阶段要修改机器状态（如状态寄存器），保存下来直到 WB 阶段再修改。</li>
<li>指令的 PC 值随指令流水前进到 WB 阶段例外处理专用</li>
<li>外部中断作为 IF 的例外处理</li>
<li>指定一个通用寄存器中（如最后一个）为例外处理时保存 PC 值专用。</li>
<li>当发生例外的指令在 WB 阶段时：<ul>
<li>保存该指令的 PC（也在 WB 阶段），有些机器还保存其它状态</li>
<li>置PC值为例外处理程序入口地址</li>
</ul>
</li>
</ul>
<p><strong>例外处理通路：</strong><br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/DataChannelException.png" alt="DataChannelException"></p>
<h1 id="多功能部件与多拍操作"><a href="#多功能部件与多拍操作" class="headerlink" title="多功能部件与多拍操作"></a>多功能部件与多拍操作</h1><h2 id="多功能部件"><a href="#多功能部件" class="headerlink" title="多功能部件"></a>多功能部件</h2><p>定点 ALU、定点乘法、浮点 ALU、浮点乘法、访存</p>
<h2 id="不同功能部件有不同延迟"><a href="#不同功能部件有不同延迟" class="headerlink" title="不同功能部件有不同延迟"></a>不同功能部件有不同延迟</h2><ul>
<li>定点 ALU 1 拍，定点乘法 2 拍，浮点 ALU 4 拍，浮点乘法 7 拍</li>
<li>访存部件延迟不确定（CACHE 不命中、访存总线竞争、动态存储器刷新等原因），每次只能一个操作（内部不流水）</li>
</ul>
<h2 id="多功能部件主要数据通路"><a href="#多功能部件主要数据通路" class="headerlink" title="多功能部件主要数据通路"></a>多功能部件主要数据通路</h2><p><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/Multifunctional.png" alt="Multifunctional"></p>
<h2 id="多功能部件及多拍操作引起的问题"><a href="#多功能部件及多拍操作引起的问题" class="headerlink" title="多功能部件及多拍操作引起的问题"></a>多功能部件及多拍操作引起的问题</h2><ol>
<li><p>结构相关：</p>
<ul>
<li>访存部件不流水引起多个访存操作的等待</li>
<li>结果总线相关：不同功能部件延迟不一致<ul>
<li>定点 ALU 操作的 MEM 周期就是为了避免结果总线冲突的 stall 操作<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/MultifunctionalStructRelated.png" alt="MultifunctionalStructRelated"></li>
</ul>
</li>
</ul>
</li>
<li><p>WAW 相关：</p>
<ul>
<li>即使有多个写端口也会阻塞<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/MultifunctionalWAWRelated.png" alt="MultifunctionalWAWRelated"></li>
</ul>
</li>
<li><p>WAR 相关：</p>
<ul>
<li>没有，因为读数总是在较早的 ID 阶段</li>
</ul>
</li>
<li><p>RAW 相关：（最多）</p>
<ul>
<li>有些操作需要多拍产生结果</li>
<li>Forwarding 技术的作用也很有限<br><img src="http://img.thebetterkong.cn/blog/CA-StaticPipeline/MultifunctionalRAWRelated.png" alt="MultifunctionalRAWRelated"></li>
</ul>
</li>
<li><p>指令乱序结束：</p>
<ul>
<li>例外处理更加困难，例外的发生难以预料</li>
<li>在下面的例子中，没有任何相关，因此，ADD.D 和SUB.D 指令可以比 DIV.D 先结束。如果在 ADD.D 结束后 DIV.D 发生例外，此时无法恢复例外现场。<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DIV.D </span>f0, f2, f4</span><br><span class="line"><span class="keyword">ADD.D </span>f10,f10,f8</span><br><span class="line"><span class="keyword">SUB.D </span>f12,f12,f14</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="通过流水线堵塞来保证避免数据冲突"><a href="#通过流水线堵塞来保证避免数据冲突" class="headerlink" title="通过流水线堵塞来保证避免数据冲突"></a>通过流水线堵塞来保证避免数据冲突</h2><ul>
<li>把<strong>所有流水线执行阶段指令的目标寄存器号</strong>和<strong>译码阶段的源寄存器号</strong>以及<strong>目标寄存器号</strong>进行比较：<ul>
<li>如果发现有寄存器号相等的情况就阻塞译码阶段的指令，这样就可以避免由于数据相关引起冲突</li>
</ul>
</li>
<li>要把<strong>译码阶段指令的目标寄存器号</strong>也跟<strong>前面指令的目标寄存器号</strong>进行比较以避免 WAW 相关导致冲突</li>
</ul>
<h2 id="结构相关-1"><a href="#结构相关-1" class="headerlink" title="结构相关"></a>结构相关</h2><p>通过请求和仲裁允许流水线前进。</p>
<h2 id="例外处理"><a href="#例外处理" class="headerlink" title="例外处理"></a>例外处理</h2><ul>
<li>不管指令要执行多少拍，都可以要求所有指令顺序写回，而且所有例外在写回阶段进行统一处理。</li>
<li>有的早期机器不保证精确例外。</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>国科大研究生课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java 数据结构之线性表</title>
    <url>/2020/06/27/DataStructure-Algorithm/DataStructure-LinearList/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>线性表</strong>（Linear List）是最简单也是最常用的一种数据结构。简言之，线性表是 n 个数据元素的有限序列。每个数据元素可以使一个数或一个符号，也可以是一页书，甚至其他更加复杂的信息。</p>
<a id="more"></a> 
<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>依据数据元素之间的关系，线性表主要有两种实现方式：<strong>顺序存储</strong>、<strong>链式存储</strong></p>
<ul>
<li>顺序存储结构：是依靠<strong>元素在存储器中的相对位置</strong>来表示数据元素之间的逻辑关系；</li>
<li>链式存储结构：是<strong>依靠指针</strong>（Java 为引用）来表现数据元素之间的逻辑关系；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/TwoStructure.png" alt="TwoStructure"></p>
<p>接着，我们来看一下线性表在 java 集合里的对应部分：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinearListInJavaSet.png" alt="LinearListInJavaSet">   </p>
<p>图中阴影部分就是和线性表相关的接口和类，其中红色标明的是重点。</p>
<h1 id="顺序表（ArrayList）"><a href="#顺序表（ArrayList）" class="headerlink" title="顺序表（ArrayList）"></a>顺序表（ArrayList）</h1><p>顺序表中的<strong>数据元素存储是连续的</strong>，<strong>内存划分的区域也是连续的</strong>。其存储结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/SequenceTableExample.png" alt="SequenceTableExample">      </p>
<p>而顺序表对应到 java 中的实现就是：<strong>ArrayList 类</strong></p>
<ul>
<li>它是利用<strong>大小可变的数组</strong>来实现的 <strong>List 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li>
<li>此类<strong>与 Vector 大致等效</strong>，但它是<strong>不同步</strong>的；</li>
<li><code>size</code>、<code>isEmpty</code>、<code>get</code>、<code>set</code>、<code>iterator</code> 和 <code>listIterator</code> 操作在恒定时间内运行。加法运算以固定的固定时间运行，即添加 n 个元素需要 $O(n)$ 时间。所有其他操作均以线性时间运行（大致而言）。与 LinkedList 实现相比，常数因子较低；</li>
<li>每个 ArrayList 实例都有一个<strong>容量</strong>；<ul>
<li>容量:是用于在列表中存储元素的数组的大小,它总是至少与列表大小一样大；</li>
<li>将元素添加到 ArrayList 时，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定增长策略的详细信息；</li>
<li>应用程序可以使用 <code>ensureCapacity</code> 操作在添加大量元素之前增加 ArrayList 实例的容量。这可以减少增量重新分配的数量；</li>
</ul>
</li>
<li>此类是 Java Collections Framework 的成员；</li>
<li><strong>擅长随机访问</strong>，查找速度快，添加删除操作慢；</li>
</ul>
<p>ArrayList 常用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ArrayList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;...&#125;     <span class="comment">// 构造具有指定初始容量的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;...&#125;                        <span class="comment">// 构造一个初始容量为 10 的空列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;   <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span>;              <span class="comment">// 将此 ArrayList 实例的容量调整为列表的当前大小。应用程序可以使用此操作来最小化 ArrayList 实例的存储。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>;   <span class="comment">// 手动增加此 ArrayList 实例的容量，以确保它至少可以容纳最小容量参数指定的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回动态数组里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;              <span class="comment">// 动态数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 动态数组是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 设定指定位置的元素值，执行完毕会返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向动态数组的末尾添加元素（实现时，先用 ensureCapacityInternal 函数扩容，再添加）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向动态数组的指定位置添加元素，index 位置元素和其后面所有元素后移一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 将指定集合中的所有元素按指定集合的Iterator返回的顺序追加到此列表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此列表</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 删除指定位置的元素，并且该位置后面的元素全部左移一个位置，返回被删除的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 删除首次出现的对象 o，如果不存在，则不进行任何操作</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除指定集合中包含的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;     <span class="comment">// 从此列表中删除所有未包含在指定集合中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 清空动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回动态数组里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回动态数组里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span></span>;                 <span class="comment">// 返回动态数组实例的拷贝，数组里的元素没有被复制</span></span><br><span class="line"></span><br><span class="line">Object[] toArray();             <span class="comment">// 分配一个新数组来（按原顺序）存储该动态数组里的所有元素，调用者可以随意修改返回的数组</span></span><br><span class="line">T[] toArray(T[] a);             <span class="comment">// 转化到指定数组，但是该数组必须足够大，否则会分配一个新的数组</span></span><br></pre></td></tr></table></figure></p>
<h1 id="链表（LinkedList）"><a href="#链表（LinkedList）" class="headerlink" title="链表（LinkedList）"></a>链表（LinkedList）</h1><p>链表的特点是用一组<strong>任意的存储单元存储线性表的数据元素</strong>（这组存储单元可以是连续的，也可以不连续）。链表的结点通常包含：<strong>数据域、指针域</strong>，数据域用来存储数据信息，指针域则负责将这些结点串接成一个链式结构。   </p>
<p>链表又通常有三种表示结构，如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/LinkedListExample.png" alt="LinkedListExample">    </p>
<p>链表对应到 java 里的实现就是：<strong>LinkedList 类</strong></p>
<ul>
<li>它是利用<strong>双链表</strong>实现的 <strong>List 和 Deque 接口</strong>，实现了所有可选的列表操作，并允许所有元素，包括 null；</li>
<li>所有操作都执行双链表所期望的操作：索引到列表中的操作将从开头或结尾遍历列表，以更接近指定索引的位置为准；</li>
<li>此实现<strong>未同步</strong>；</li>
</ul>
<p>LinkedList 常用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* LinkedList</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;       <span class="comment">// 构造一个空链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;...&#125;  <span class="comment">// 构造一个列表，该列表包含指定集合的元素，其顺序由集合的迭代器返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                     <span class="comment">// 返回链表里元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;     <span class="comment">// 链表是否包含指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;               <span class="comment">// 返回链表里指定位置的元素</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span></span>;                   <span class="comment">// 返回链表里第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span></span>;                    <span class="comment">// 返回链表里最后一个元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;    <span class="comment">// 用指定元素取代链表里指定位置的元素，并返回旧值</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;                <span class="comment">// 移除并返回链表第一个元素</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;                 <span class="comment">// 移除并返回链表最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;       <span class="comment">// 移除链表里指定元素首次出现的结点，如果没有，链表不变</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;            <span class="comment">// 移除并返回指定位置的元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;             <span class="comment">// 向链表开头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;              <span class="comment">// 向链表末尾插入指定元素，等效于 add 方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 向链表指定位置插入指定元素，该位置和后续元素会被后移</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;  <span class="comment">// 按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此链表的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;   <span class="comment">// 从指定位置开始，将指定集合中的所有元素插入此链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                   <span class="comment">// 移除链表里所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;          <span class="comment">// 返回链表里首次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;      <span class="comment">// 返回链表里最后一次出现的指定元素的索引，不存在时返回 -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 下面的函数是用来实现栈和队列时所用；</span></span><br><span class="line"><span class="comment">* 这里可以先不关注，在后面讲解栈和队列时再回来查看</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue operations.</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 移除并返回队列第一个元素，队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 移除并返回队列第一个元素，队列为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列末尾添加指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Deque operations</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span></span>;        <span class="comment">// 向双端队列头插入指定元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span>;         <span class="comment">// 向双端队列尾插入指定元素</span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span></span>;                  <span class="comment">// 返回但不删除双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span></span>;                   <span class="comment">// 返回但不删除双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>;                  <span class="comment">// 移除并返回双端队列第一个元素，双端队列为空时返回 null</span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;                   <span class="comment">// 移除并返回双端队列最后一个元素，双端队列为空时返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stack operations</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;                 <span class="comment">// 用链表实现，元素入栈</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>;                        <span class="comment">// 用链表实现，元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h1><p>栈是一种特殊（操作受限）的线性表。它仅允许在线性表的尾部进行添加和删除操作，这一端被称为<strong>栈顶</strong>，另一端称为<strong>栈底</strong>。向一个栈添加新元素叫<strong>压栈</strong>，删除元素又称为<strong>出栈</strong>。<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/StackExample.png" alt="StackExample">    </p>
<p>栈对应到 java 里的实现就是：<strong>Stack 类</strong></p>
<ul>
<li>Stack 类表示对象的后进先出（<strong>LIFO</strong>）堆栈；</li>
<li>它通过五个操作<strong>扩展了 Vector 类</strong>，这些操作允许将 Vector 视为 Stack：<ul>
<li>提供了通常的 push 和 pop 操作；</li>
<li>peek 堆栈顶部元素的方法；</li>
<li>用于测试堆栈是否为空的方法；</li>
<li>用于在堆栈中搜索元素并发现其距顶部距离的方法；</li>
</ul>
</li>
<li>首次创建堆栈时，它不包含任何项目；</li>
<li><code>{@link Deque}</code> 接口及其实现提供了一组更完整和一致的 LIFO 堆栈操作，应优先使用此类。 例如：<code>{@code Deque stack = new ArrayDeque（）;}</code></li>
</ul>
<p>Stack 常用方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Stack</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 有关迭代器的部分，以后单独总结；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************构造方法*********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;&#125;     <span class="comment">// 构造一个空栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span></span>;          <span class="comment">// 向栈顶压入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span>;    <span class="comment">// 将栈顶元素弹出并返回该对象，栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span></span>;   <span class="comment">// 返回栈顶元素（不删除），栈为空时会抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>;         <span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span>;   <span class="comment">// 返回该元素距离栈顶的位置（栈顶元素返回 1）；如果栈里不存在该元素返回 -1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h1><p>队列也是一种操作受限制的线性表。只能从<strong>队头</strong>取出（删除）元素，从<strong>队尾</strong>添加元素，其结构如下图：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueExample.png" alt="QueueExample"></p>
<p>它在 java 中比较特殊，只是一个接口：<strong>Queue</strong></p>
<ul>
<li>它只是一个<strong>接口</strong>，代表了我们通常理解的 <strong>FIFO 队列</strong>（通常利用 LinkedList 实现），但这不是绝对的，例外情况包括：<strong>优先级队列</strong>（根据提供的比较器对元素进行排序或元素的自然排序）和 <strong>LIFO 队列</strong>（或堆栈）；<ul>
<li>无论使用哪种顺序，队列的开头都是该元素，可以通过调用 <code>remove()</code> 或 <code>poll()</code> 来删除该元素。在 FIFO 队列中，所有新元素都插入队列的尾部。其他种类的队列可能使用不同的放置规则；</li>
<li>每个 Queue 实现都必须指定其排序属性；</li>
</ul>
</li>
<li>Queue 实现<strong>通常不允许插入 <code>null</code> 元素</strong>，尽管某些实现（例如：<code>LinkedList</code>）不禁止插入 <code>null</code>；<ul>
<li>即使在允许的实现中，也不应将 <code>null</code> 插入 Queue 中，因为 <code>poll</code> 方法将 <code>null</code> 用作特殊的返回值，以指示队列不包含任何元素；</li>
</ul>
</li>
<li>Queue 实现通常不定义方法 <code>equals</code> 和 <code>hashCode</code> 的基于元素的版本，而是从类 <code>Object</code> 继承基于身份的版本，因为基于元素的相等性并不总是对于元素相同但排序属性不同的队列，定义明确。</li>
<li>该接口是 Java Collections Framework 的成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Queue</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对常用方法的总结罗列，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们通常用的 FIFO 队列是基于 LinkedList 实现的</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> LinkedList(); <span class="comment">// 相关方法的实现可见 LinkedList 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************接口声明的方法**********************/</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;               <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，可能抛异常</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;             <span class="comment">// 向队列添加元素，如果队列的实现是容量受限的，此方法更可取</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;                     <span class="comment">// 返回并删除此队列的头，如果此队列为空，它将引发异常</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;                       <span class="comment">// 返回并删除此队列的头，队列为空时，返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;                    <span class="comment">// 返回但不删除队头，如果队列为空，抛异常</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;                       <span class="comment">// 返回但不删除队头，如果队列为空，返回 null</span></span><br></pre></td></tr></table></figure>
<p>java 里 Queue 的家族还是很大的，但是很多我们也不常用，我做了个简单的整理如下（图片较乱）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-LinearList/QueueStructure.png" alt="QueueStructure"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li>
<li>『 jdk1.8.0_231 源码 』</li>
</ul>
]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Architecture</title>
    <url>/2020/03/21/FPGA-technology/FPGA-Architecture/</url>
    <content><![CDATA[<p>② 综述 FPGA 里面的常见模块；</p>
<a id="more"></a> 
<h1 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h1><h2 id="FPGA微芯片"><a href="#FPGA微芯片" class="headerlink" title="FPGA微芯片"></a>FPGA微芯片</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/FPGAMicrochip.png" alt="FPGAMicrochip">  </p>
<ul>
<li>主要包含五部分：<ul>
<li>CLB：configurable logic block，或称logic cluster，用作逻辑控制</li>
<li>BRAM：block RAM ，用于信息存储</li>
<li>DSP（MAC) Block：专用的乘、加运算器</li>
<li>Interconnect Network：</li>
<li>I/O Bank：</li>
</ul>
</li>
</ul>
<h2 id="FPGA体系结构"><a href="#FPGA体系结构" class="headerlink" title="FPGA体系结构"></a>FPGA体系结构</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/FPGAArchitecture.png" alt="FPGAArchitecture">  </p>
<ul>
<li>基于LUT（查找表）的逻辑电路（组合逻辑和时序逻辑）；</li>
<li>异构集成的处理内核（DSP，BRAM，DLL，PLL，I/O等）；</li>
<li>精细的可重构计算—-位级别；</li>
<li>存储在CRAM（配置随机存取存储器）中的配置bit流，用于定义逻辑电路和片上互连；</li>
</ul>
<h1 id="CLB-Logic-Cluster-or-Configurable-Logic-Block"><a href="#CLB-Logic-Cluster-or-Configurable-Logic-Block" class="headerlink" title="CLB (Logic Cluster or Configurable Logic Block)"></a>CLB (Logic Cluster or Configurable Logic Block)</h1><p>逻辑集群（或可配置逻辑块）是一个主电路单元，可以在给定一定数量的输入变量的情况下进行编程，以执行任何组合/时序逻辑功能；   </p>
<p>每个逻辑集群都包含多个相同的<mark>逻辑元素logic elements（LEs）</mark>;</p>
<h2 id="LE（logic-element）"><a href="#LE（logic-element）" class="headerlink" title="LE（logic element）"></a>LE（logic element）</h2><p>通用电路结构：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/LECircuit.png" alt="LECircuit"></p>
<ul>
<li>通常，逻辑集群由几个LE组成（也称：Intel FPGA的ALM，Xilinx FPGA的Slice等等）；</li>
<li>典型的LE由一个k输入LUT，一个全加法器（FA）和一个D型触发器（D-type flip-flop）组成；</li>
</ul>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/ExampleLE.png" alt="ExampleLE"></p>
<ul>
<li>LUT分为两个3输入LUT；</li>
<li>在正常模式下，它们通过左边的MUX组合成4输入LUT；</li>
<li>在算术模式下，它们的输出被送到加法器FA；</li>
<li>模式的选择是通过编程中间的MUX；</li>
<li>输出可以是同步的，也可以是异步的，具体取决于右侧MUX的编程。</li>
<li>实际上，为了节省空间，加法器的全部或部分作为函数存储在LUT中。</li>
</ul>
<h1 id="Interconnection"><a href="#Interconnection" class="headerlink" title="Interconnection"></a>Interconnection</h1><p> Interconnection是可以通过编程，路由任何点对点的电气连接的电线通道网络；   </p>
<p>Interconnection包括以下部分：</p>
<ul>
<li>Horizontal/Vertical interconnection channels，即：水平/垂直互连通道；</li>
<li>Switch Matrixes，即：开关矩阵（例如接线盒，开关盒）；</li>
</ul>
<h2 id="Interconnection-channel"><a href="#Interconnection-channel" class="headerlink" title="Interconnection channel"></a>Interconnection channel</h2><p>主要有三种形式：Channel-based Network、Hierarchical Network、Island-style Network；</p>
<h3 id="Channel-based-Network"><a href="#Channel-based-Network" class="headerlink" title="Channel-based Network"></a>Channel-based Network</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/ChannelBasedNetwork.png" alt="ChannelBasedNetwork"></p>
<blockquote>
<p>空白圆圈:表示预制保险丝<br>实心圆圈:表示通过熔断的保险丝完成了互连</p>
<ul>
<li>水平通道贯穿整个设备，水平线布线到：逻辑集群的输入和输出、其他水平通道;</li>
<li>水平和垂直通道的交点由反熔丝构成，使用反熔丝打开/关闭任意两个通道之间的连接；</li>
<li>anti-fuses （反熔丝）：正常不导通，对其施加大电流熔断后导通；</li>
</ul>
</blockquote>
<h3 id="Hierarchical-Network"><a href="#Hierarchical-Network" class="headerlink" title="Hierarchical Network"></a>Hierarchical Network</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/HierarchicalNetwork.png" alt="HierarchicalNetwork"></p>
<ul>
<li>互连资源根据其层次结构进行划分:<ul>
<li>仅底层的电线连接到逻辑块</li>
<li>中线必须通过上线连接</li>
<li>顶层的电线构成主要的互连路径</li>
</ul>
</li>
<li>广泛用于早期CPLD（复杂可编程逻辑器件）;</li>
<li>Level 3 &lt;-&gt; Level 2 &lt;-&gt; Level 1</li>
<li>优势：可预测的路由延迟</li>
<li>缺点：无法通过重新路由来改善关键路径</li>
<li>现代FPGA不再基于此架构</li>
</ul>
<h3 id="Island-Style-Network"><a href="#Island-Style-Network" class="headerlink" title="Island-Style Network"></a>Island-Style Network</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/IslandStyleNetwork.png" alt="IslandStyleNetwork"></p>
<ul>
<li>在现代FPGA中很流行</li>
<li>每个逻辑块均通过其四个方向的输入/输出端口直接访问常规路由资源；</li>
<li>通用路由资源包括各种长度的电线；</li>
<li>路由线通过Switch Matrixes连接，多条连接线形成路由网；</li>
</ul>
<p>设计理念：</p>
<ul>
<li>通常，所有的布线通道都具有相同的宽度（线数）</li>
<li>必须将应用电路映射到具有足够资源的FPGA中。虽然可以很容易地从设计中确定所需的CLB和I/O的数量，但即使在具有相同逻辑量的设计之间，所需的布线路径的数量也可能有很大不同。</li>
<li>由于未使用的布线轨迹会增加零件的成本（并降低性能），却没有带来任何好处，因此FPGA制造商试图提供足够的轨迹，以便大多数适合查找表（LUT）和I/O的设计都可以被路由</li>
<li>这是根据估算得出的，例如根据 Rent’s rule得出的估算值或通过对现有设计进行的实验得出的估算值：<ul>
<li>Rent’s Rule：是一个经验公式，来大致估计<ul>
<li>引脚pins（端子，T）数量和内部元件（g）的数量（如：逻辑门或标准单元）之间有一个显著的趋势，线性关系：$T = t \cdot g^p$，其中t和p是常数（p&lt;1.0)，通常：0.5 &lt; p &lt; 0.8</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Switch-Matrix"><a href="#Switch-Matrix" class="headerlink" title="Switch Matrix"></a>Switch Matrix</h2><p>电路结构：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/SwitchMatrixCircuit.png" alt="SwitchMatrixCircuit"></p>
<ul>
<li>使用晶体管开启和关闭；</li>
<li>使用配置位控制晶体管状态；</li>
</ul>
<p>也有三种形式： Disjoint-style、Universal-style、Wilton-style</p>
<h3 id="Disjoint-style"><a href="#Disjoint-style" class="headerlink" title="Disjoint-style"></a>Disjoint-style</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/DisjointStyle.png" alt="DisjointStyle"></p>
<ul>
<li>input只能通过switch matrix连接到具有相同编号的output，不同编号的wires无法相连。（0-0,1-1,2-2,3-3,4-4）；</li>
<li>灵活性较差；</li>
</ul>
<h3 id="Universal-style"><a href="#Universal-style" class="headerlink" title="Universal-style"></a>Universal-style</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/UniversalStyle.png" alt="UniversalStyle"></p>
<ul>
<li>能将不同编号的wires相连，例如：input1能通过switch matrix 连到三个不同的ouput端，output的编号为1,1,3（1的补）；</li>
<li>灵活性有所提高；</li>
</ul>
<h3 id="Wilton-style"><a href="#Wilton-style" class="headerlink" title="Wilton-style"></a>Wilton-style</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/WiltonStyle.png" alt="WiltonStyle"></p>
<ul>
<li>也能将不同编号的wires相连，例如：input1能通过switch matrix 连到三个不同的ouput端，output的编号为0（1-1=0）,1,4（0的互补）；</li>
<li>灵活性有所提高；</li>
</ul>
<h1 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/InputOutput.png" alt="InputOutput"></p>
<ul>
<li>可编程的I/O pads（焊盘）用于将逻辑块和路由架构连接到外部组件；</li>
<li>I/O焊盘和周围的逻辑电路形成为I/O块（IOB），pin和IOB一一对应；这些模块占用了FPGA的很大一部分面积；</li>
<li>I/O可编程块的设计很复杂，因为电源电压和参考电压之间存在很大差异；</li>
<li>I/O标准的选择在I/O架构设计中很重要，支持大量的I/O标准可以增加I/O单元所需的硅芯片面积；</li>
</ul>
<p>IOB 的基础结构：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/IOBStructure.png" alt="IOBStructure"></p>
<p>可编程的 I/Os 应该支持：</p>
<ul>
<li>多种电压等级标准（例如1V，1.2V，1.8V，3.3V等）</li>
<li>多种I / O标准（例如LVDS，CMOS，TTL等）</li>
<li>变化的驱动强度（ID [n]，n = 1、2，…）</li>
<li>Open-drain输出（数据总线）</li>
<li>抖动控制（定时控制）</li>
<li>Bus holder电路</li>
<li>延迟控制</li>
<li>各种 pull-up电阻</li>
</ul>
<p><mark>低压差分信号LVDS (Low Voltage Differential Signaling)</mark>：</p>
<ul>
<li>一种技术标准，规定了差分串行通信协议的电气特性；</li>
<li>使用低廉的双绞铜线，可在低功率下运行，并能以极高的速度运行（gigabits at milliwatts)；</li>
<li>仅是物理层规范，许多数据通信标准和应用程序都使用它并添加数据链路层;</li>
</ul>
<p><mark>高速SerDes数据收发器</mark>： </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/transceiver.png" alt="transceiver"></p>
<ul>
<li>串行器/解串器是一对功能块，通常用于高速通信中，以补偿有限的输入/输出;</li>
<li>这些块在每个方向上在串行数据和并行接口之间转换数据;</li>
<li>“ SerDes”通常是指在各种技术和应用中使用的接口;</li>
</ul>
<h1 id="Block-RAM（mem）"><a href="#Block-RAM（mem）" class="headerlink" title="Block RAM（mem）"></a>Block RAM（mem）</h1><p>Block RAM 是一个专用的两端口内存，其中包含几千个 RAM，FPGA 包含几个（或多个）这些模块；   </p>
<p>可以将 BRAM 配置为不同的存储模式：</p>
<ul>
<li>单端口模式：一个端口读或写</li>
<li>简单双端口模式：一个读取端口和一个写入端口</li>
<li>真正的双端口模式：两个端口同时读取； 两个端口同时写入； 读一个端口，写一个端口</li>
<li>各种字节宽度</li>
</ul>
<h2 id="Pass-Transistor-Logic"><a href="#Pass-Transistor-Logic" class="headerlink" title="Pass Transistor Logic"></a>Pass Transistor Logic</h2><p>信号相关传导状态：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/Strong0Weak1.png" alt="Strong0Weak1"></p>
<ul>
<li>弱传输：相当于 $V_{dd}-V_{th}$，导致电压变低，受影响；</li>
</ul>
<p>电压损失与恢复:</p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/solutions.png" alt="solutions"></li>
</ul>
<h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/DesignSchematic.png" alt="DesignSchematic"></p>
<p>详细分析：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/DesignSchematic1.png" alt="DesignSchematic1"> </p>
<p>读写过程：</p>
<ol>
<li>首先，通过pre-charge进行预充电：<ul>
<li>让pre-charge=0，则与之直接相连的三个PMOS管导通。此时，BL、BLB与Vdd导通，BL=BLB=Vdd，进而完成预充电。之后，置pre-charge=1。</li>
</ul>
</li>
<li>Write 0（BL=0，BLB=1）的过程：<ul>
<li>情景一：SRAM内部存储值为0（data=0，SRAM内部右半部分的P管导通，右部的内部状态点连接Vdd，呈现1状态；左半部分的N管导通，左部的内部状态点连接Vdd，呈现0状态）<ul>
<li>这时，初始内部状态：与BL相连的NMOS管另一端值为0，与BLB相连的NMOS管另一端值为1。打开选择信号，即Word=1，使其控制的两个NMOS管导通。对于左边的NMOS管来说，其左端BL=0，右端内部状态也为0，所以内部保持0；同样，对于右边的NMOS管，其两端的值均为1，内部也保持为1。也即：write0后，SRAM内部保持存储值为0，data=0。</li>
</ul>
</li>
<li>情景二：SRAM内部存储值为1（data=1）<ul>
<li>这时，初始内部状态：与BL相连的NMOS管另一端值为1，与BLB相连的NMOS管另一端值为0。打开选择信号，即Word=1，使其控制的两个NMOS管导通。对于左边的NMOS管来说，其左端BL为强0信号，右端的内部状态为1，因此，右端的1信号值会向左端的强0信号放电，使得右端内部状态变成0。同理，对于右边的NMOS管来说，其左端内部状态为0，右端BLB为强1信号，右端对左端进行充电，使得左端的内部状态变成1。经过上述过程后，内部状态变成：与BL相连的NMOS管另一端值为0，与BLB相连的NMOS管另一端值为1。也即：write0后，SRAM内部存储值成为0，data=0。</li>
</ul>
</li>
</ul>
</li>
<li>再次通过pre-charge进行预充电，使得BL=BLB=1；</li>
<li>现在进行Read：<ul>
<li>经过write 0操作后，此时的内部状态：与BL相连的NMOS管另一端值为0，相应的与BLB相连的NMOS管另一端值为1。（data=0）然后，打开选择信号，即Word=1，使其控制的两个NMOS管导通。预充电时，BL及BLB均为1。这时，对于右边的NMOS管来说，两端的值均为1，不会进行信号传输，BLB仍=1。但对于左边的NMOS管来说，左端的BL预充电为1，而右端内部状态初始为0，所以NMOS管左端会对右端进行放电，使得BL=0。经过上述过程，BL=0，BLB=1，于是就将内部的0信号读取出来了，也即完成了读0操作。</li>
</ul>
</li>
</ol>
<p>SRAM保持其状态:</p>
<ul>
<li>SRAM保持内部状态主要是针对，其数据读取过程中可能导致的数据丢失问题而引出的。</li>
<li>在上述过程分析中，我们可以看到，在读取SRAM的0数据过程中，对左半部分的NMOS管，会出现其左端对右端放电的情况，这样，SRAM左半部分的内部状态点在接收到电荷后就可能出现弱1的状态，随着连续读取次数增多，其接收到的电荷越来越多，就可能影响到之后读取时左端向右端的放电，导致数据丢失。<br>-但是，注意到，图中的data控制信号，就可以通过其解决上述问题。当SRAM内存储值为0时，data=0，因此，SRAM左半部分N管导通，左边的内部状态点连接至gnd。因此，随着连续读操作的进行，不管左边的内部状态点接收到多少电荷，其始终会呈现出强0状态，也即，SRAM内部始终保持为0。其他情况，与该过程类似。</li>
</ul>
<h1 id="DSP（multiplier）"><a href="#DSP（multiplier）" class="headerlink" title="DSP（multiplier）"></a>DSP（multiplier）</h1><p>DSP模块架构经过优化，可实现各种通用DSP功能，并具有最佳性能和最小逻辑资源利用率；<br>除乘法器外，每个DSP模块还具有典型DSP算法中经常需要的功能，这些功能包括预加器，加法器，减法器，累加器，系数寄存器存储和求和单元；   </p>
<p>DSP在DSP类型的应用中非常常见的一种操作称为<mark>乘加（MAC）单元</mark>；<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/BasicMACBlockStructure.png" alt="BasicMACBlockStructure"> </p>
<p>商用FPGA产品包含DSP模块，可对它们进行编程以对各种字节宽度的数据输入执行加，减，乘，累加，乘法运算;   </p>
<p>FPGA包含几个（或多个）DSP模块，它为高性能、高精度DSP应用提供了理想的解决方案:</p>
<ul>
<li>DSP资源可以选择为与逻辑资源结合使用，可实现诸如FIR（有限脉冲响应）滤波器，IIR（无限脉冲响应）滤波器，FFT（快速傅立叶变换），调制解调，加密，神经网络等IP核</li>
</ul>
<p>blocks DSP模块是非常高效的，并且在软实施中的工作频率远高于等效电路；   </p>
<p><strong>FPGA DSP vs. Standard DSP</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Architecture/FPGADSPvsStandardDSP.png" alt="FPGADSPvsStandardDSP"></p>
<ul>
<li>传统解决方案（使用数字信号处理器（DSP））与FPGA实现之间的区别在于：<ul>
<li>DSP必须用汇编器或C编程，而FPGA算法则用HDL描述</li>
</ul>
</li>
<li>FPGA适合并行计算；</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>java 数据结构之字符串</title>
    <url>/2020/07/02/DataStructure-Algorithm/DataStructure-String/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-String/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>字符串</strong>（String）是由零个或多个字符（char）组成的有序序列。学过 C/C++ 的人会有一种固定的思维模式，凡是字符串都是以 <code>\0</code> 结束。但是 java 却不同，要知道 java 里始终秉承的一句话 『<strong>everything is object</strong>』，字符串也不例外，它也被作为 String 类型的对象处理。</p>
<a id="more"></a> 
<h1 id="认识-java-字符串"><a href="#认识-java-字符串" class="headerlink" title="认识 java 字符串"></a>认识 java 字符串</h1><p><code>String</code> 类表示字符串，Java 程序中的所有字符串文字（例如 <code>abc</code>）都实现为此类的实例。让我们来看一下 java 中 <code>String</code> 类的声明源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这里我们可以看出两点结论：</p>
<ul>
<li><strong><code>String</code> 类是通过 <code>char</code> 数组来保存字符串的</strong>，因此有如下关系：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">char</span> [] data = &#123;<span class="string">'a'</span>，<span class="string">'b'</span>，<span class="string">'c'</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String (data);</span><br></pre></td></tr></table></figure></li>
<li><strong>字符串是常量，它们的值在内存创建后则无法更改（字符串的不变性）</strong>，平常我们用到的更改实际上都只是重新创建了一个新的字符串（后面会进行详细描述），这样效率很低。因此如果需要一个可以改变的字符串，更推荐使用 <code>StringBuffer</code> 或者 <code>StringBuilder</code>；</li>
</ul>
<h1 id="创建-java-String-对象的方法"><a href="#创建-java-String-对象的方法" class="headerlink" title="创建 java String 对象的方法"></a>创建 java String 对象的方法</h1><p>在具体讲解之前，我们有必要先弄清楚 java String 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 构造方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里只是对 jdk 源码里常用方法的总结罗列，如果有疑惑，具体的实现过程还需查看源码；</span></span><br><span class="line"><span class="comment">* 如果可以的话，强烈建议将实现的源码阅读一遍；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 注意：除非另有说明，否则将 null 参数传递给此类中的构造函数或方法将引发  NullPointerException；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空字符串，由于字符串不可变，所以它通常不会被使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;<span class="keyword">this</span>.value = <span class="string">""</span>.value;&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建参数字符串的副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;...&#125;;       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新的 String，它包含参数字符数组的字符序列；</span></span><br><span class="line"><span class="comment">// 字符数组的内容被复制，字符数组的后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;...&#125;;          </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这次创建的是参数数组的子数组</span></span><br><span class="line"><span class="comment">// @param offset 是子数组第一个字符的索引</span></span><br><span class="line"><span class="comment">// @param count 指定子数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 Uncode 编码数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 主要内容同上，这一次是基于 ascii 编码字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="comment">// 通过使用指定的字符集解码指定的字节子数组，构造一个新的 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string buffer 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string buffer 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个新 string，它包含当前在参数 string builder 中包含的字符序列；</span></span><br><span class="line"><span class="comment">// string builder 的内容被复制，它后续修改不会影响新创建的字符串；</span></span><br><span class="line"><span class="comment">// 提供此构造函数可简化向 StringBuilder 的迁移；</span></span><br><span class="line"><span class="comment">// 通过 toString 方法从 StringBuilder 获取字符串可能运行得更快，通常是首选。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了共享数组的包私有构造器，但是总是期望 share == true</span></span><br><span class="line"><span class="comment">// 因为已经有一个公共 String（char []）构造函数，它可以复制给定char []，因此需要一个单独的构造函数</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>源码嘛，比较复杂一点，但其实我们实际使用中经常用到的也就<strong>两种形式，特别关注他们的差异</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、使用 "" 引号创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：单独使用 "" 引号创建的字符串都是常量，编译期就已经确定，存储</span></span><br><span class="line"><span class="comment">*       到 String Pool 中</span></span><br><span class="line"><span class="comment">* 具体过程：在执行到双引号包含字符串的语句时，如 String a = "123"，</span></span><br><span class="line"><span class="comment">*           JVM 会先到常量池里查找，如果有的话返回常量池里的这个实</span></span><br><span class="line"><span class="comment">*           例的引用，否则的话创建一个新实例并置入常量池里</span></span><br><span class="line"><span class="comment">* 注意：使用此方法，对象可能并没有被创建！而只是将引用指向了一个先前</span></span><br><span class="line"><span class="comment">*       已经创建的对象  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 创建一个字符串对象 imooc，引用名为 s1</span></span><br><span class="line">String s1 = <span class="string">"imooc"</span>;</span><br><span class="line"><span class="comment">// 新声明一个字符串引用，名为 s2，也指向了常量池里与上面字符串相同的字符串</span></span><br><span class="line">String s2 = <span class="string">"imooc"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二、使用 new 关键字创建字符串：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 说明：使用 new String("") 创建的对象会存储到 heap 中，是运行期新创建的；</span></span><br><span class="line"><span class="comment">* 具体过程：new 首先在堆中创建一个对象，引用 s3 指向这个对象。然后在常量池中找值</span></span><br><span class="line"><span class="comment">*          为 "immoc" 的对象：</span></span><br><span class="line"><span class="comment">*          如果没有，则进行创建，然后将这个 String 对象成员变量 char 数组</span></span><br><span class="line"><span class="comment">*          （value[]），指向值为 "immoc" 的这个对象（这时就创建了两个对象）；</span></span><br><span class="line"><span class="comment">*          如果有，则直接将 String 对象成员变量 char 数组指向这个 "immoc" 对象</span></span><br><span class="line"><span class="comment">*          即可（这时只创建了一个对象）；</span></span><br><span class="line"><span class="comment">*    </span></span><br><span class="line"><span class="comment">* 注意：此方法一定有一个新的对象被创建，至于最终有几个对象创建得分情况考虑，这也</span></span><br><span class="line"><span class="comment">*      是面试中的高频考点！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 分配内存，创建一个新的字符串对象 imooc，引用名为 s2</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"imooc"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 补充说明：</span></span><br><span class="line"><span class="comment">*   （1）使用只包含常量的字符串连接符如 "aa" + "aa" 创建的也是常</span></span><br><span class="line"><span class="comment">*        量，编译期就能确定，已经确定存储到 String Pool 中；</span></span><br><span class="line"><span class="comment">*   （2）使用包含变量的字符串连接符如 "aa" + s1 创建的对象是运行期</span></span><br><span class="line"><span class="comment">*        才创建的，存储在 heap 中；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>上面对这两种形式的差异解释可能有点晕，给出一段代码帮助理解：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"爱慕课"</span>;  </span><br><span class="line">String s2 = <span class="string">"爱慕课"</span>; </span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">"爱慕课"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);       <span class="comment">// 多次出现的字符常量，Java 编译程序只创建一个，所以返回 true</span></span><br><span class="line">System.out.println(s1 == s3);       <span class="comment">// s1 和 s3 是不同的对象，所以返回 false</span></span><br><span class="line">System.out.println(s3 == s4);       <span class="comment">// s3和 s4 是不同的对象，所以返回 false</span></span><br><span class="line">s1 = <span class="string">"欢迎来到："</span> + s1;</span><br><span class="line">System.out.println(s1);             <span class="comment">// 字符串 s1 被修改，指向新的内存空间，输出“欢迎来到：爱慕课”</span></span><br></pre></td></tr></table></figure></p>
<h1 id="java-字符串的不可变性"><a href="#java-字符串的不可变性" class="headerlink" title="java 字符串的不可变性"></a>java 字符串的不可变性</h1><p>首先，我们来认识一下，什么叫做<strong>类的不可变性</strong>：<br><div class="note warning">
            <ul><li><strong>定义</strong>：简单地说，就是其实例一旦创建完成，在其整个生命周期内状态都不会发生变化。状态这个词有一些抽象，在 Java 中对象的状态是由其成员变量来表现的，那么状态不变即是成员变量不变（具体来说，基本类型变量的值不变、引用类型变量的引用地址不变）；</li><li><strong>不可变的类的好处</strong>：<ul><li>更加易于设计、实现和使用。</li><li>并发时，不容易出错，并且更加安全。</li></ul></li><li><strong>为了使类成为不可变，要遵循下面五条规则</strong>（来自《Effective Java》）：<ul><li>不提供任何会修改对象状态的方法；</li><li>保证类不能被扩展；</li><li>所有的成员变量都被 final 修饰的；</li><li>所有的成员变量都是 private 的；</li><li>确保对于任何可变组件的互斥访问。如果一个类的成员变量引用了可变对象，则必须确保外部调用类无法获取指向这些对象的引用；</li></ul></li><li>当然，所有的这些条件都是针对正常调用而言的，如果使用反射，则仅仅满足上述的条件也无法保证对象不可变；</li><li>看到这里，你就一定明白上面为什么说 java 的字符串是一个不可变的常量；</li></ul>
          </div></p>
<p>关于 java 字符串，就需要牢记一句话：<strong><mark>String 对象一旦被创建就是固定不变的了，对 String 对象的任何改变都不影响到原对象，相关的任何 change 操作都会生成新的对象</mark></strong>；    </p>
<p>关于这一点结合前文所学，就有必要认识一下<strong>三个比较重要的方法</strong>：   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String.intern()</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：在常量池中查找值等于（equals）当前字符串的对象，如果找到，则直接返回</span></span><br><span class="line"><span class="comment">*          这个对象的地址；如果没有找到，则将当前字符串拷贝到常量池中，然后返回</span></span><br><span class="line"><span class="comment">*          拷贝后的对象地址；    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String a = <span class="string">"123"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);                     <span class="comment">// false</span></span><br><span class="line">System.out.println(a == b.intern());            <span class="comment">// true</span></span><br><span class="line">System.out.println(c == b.intern());            <span class="comment">// false</span></span><br><span class="line">System.out.println(c.intern() == b.intern());   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equals 和 ==</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*（1）对于 ==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,</span></span><br><span class="line"><span class="comment">*     double,boolean ），则直接比较其存储的"值"是否相等；如果作用于引用类型的变</span></span><br><span class="line"><span class="comment">*     量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）；</span></span><br><span class="line"><span class="comment">*（2）equals 方法是基类 Object 中的方法，因此对于所有的继承于 Object 的类都会有</span></span><br><span class="line"><span class="comment">*    该方法。在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是</span></span><br><span class="line"><span class="comment">*    否指向同一个对象；</span></span><br><span class="line"><span class="comment">*（3）对于 equals 方法，注意：equals 方法不能作用于基本数据类型的变量。如果没有</span></span><br><span class="line"><span class="comment">*    对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而 </span></span><br><span class="line"><span class="comment">*    String 类对 equals 方法进行了重写，用来比较指向的字符串对象所存储的字符串</span></span><br><span class="line"><span class="comment">*    是否相等。其他的一些类诸如 Double，Date，Integer 等，都对 equals 方法进行</span></span><br><span class="line"><span class="comment">*    了重写用来比较指向的对象所存储的内容是否相等；   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);          <span class="comment">// true，表示 s1 和 s2 指向同一对象，它们都指向常量池中的 "hello" 对象</span></span><br><span class="line">System.out.println(s1 == s3);          <span class="comment">// flase，表示 s1 和 s3 的地址不同，即它们分别指向的是不同的对象，s1 指向常量池中的地址，s3 指向堆中的地址</span></span><br><span class="line">System.out.println(s1.equals(s3));     <span class="comment">// true，表示 s1 和 s3 所指向对象的内容相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符串的连接："+"</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*    作用：连接两个字符串</span></span><br><span class="line"><span class="comment">*    工作细节：连接操作最开始时如果都是字符串常量，编译后将尽可能多的直接将字符</span></span><br><span class="line"><span class="comment">*             串常量连接起来，形成新的字符串常量参与后续连接。接下来的字符串连接</span></span><br><span class="line"><span class="comment">*             是从左向右依次进行，对于不同的字符串，首先以最左边的字符串为参数创</span></span><br><span class="line"><span class="comment">*             建 StringBuilder 对象，然后依次对右边进行 append 操作，最后将</span></span><br><span class="line"><span class="comment">*             StringBuilder 对象通过 toString() 方法转换成 String 对象（注</span></span><br><span class="line"><span class="comment">*             意：中间的多个字符串常量不会自动拼接）。      </span></span><br><span class="line"><span class="comment">*   例如：String c = "xx" + "yy " + a + "zz" + "mm" + b; 实质上的实现过程</span></span><br><span class="line"><span class="comment">*         是： String c = new StringBuilder("xxyy ").append(a).append("zz").</span></span><br><span class="line"><span class="comment">*         append("mm").append(b).toString();</span></span><br><span class="line"><span class="comment">*   结论：当使用 + 进行多个字符串连接时，实际上是产生了一个 StringBuilder 对象</span></span><br><span class="line"><span class="comment">*         和一个 String 对象。也正因如此，导致了 string 中 + 连接符效率十分低</span></span><br><span class="line"><span class="comment">*         下。因此，当经常涉及字符串的改变（拼接）时，更推荐用 StringBuffer 或 </span></span><br><span class="line"><span class="comment">*         StringBulider 对象来进行 append 操作，特别是在循环中；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;         <span class="comment">// 创建时，编译器可以进行优化，这里只创建了一个对象。变量 s 的创建等价于 String s = "abc"; </span></span><br><span class="line">String s1  =  <span class="string">"a"</span>; </span><br><span class="line">String s2  =  <span class="string">"b"</span>; </span><br><span class="line">String s3  =  <span class="string">"c"</span>; </span><br><span class="line">String s4  =  s1  +  s2  +  s3;</span><br><span class="line"><span class="comment">// s4 不能在编译期进行优化，其对象创建相当于：</span></span><br><span class="line"><span class="comment">// StringBuilder temp = new StringBuilder();   </span></span><br><span class="line"><span class="comment">// temp.append(a).append(b).append(c);   </span></span><br><span class="line"><span class="comment">// String s = temp.toString();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   最后再来一段代码加深理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="string">"12"</span>;</span><br><span class="line">String s1 = <span class="string">"34"</span>;</span><br><span class="line">String s2 = s + s1;</span><br><span class="line">String s3 = <span class="string">"1234"</span>;</span><br><span class="line">String s4 = <span class="string">"12"</span> + <span class="string">"34"</span>;</span><br><span class="line">String s5 = s + <span class="string">"34"</span>;</span><br><span class="line">String s6 = <span class="string">"12"</span> + <span class="keyword">new</span> String(<span class="string">"34"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s4);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s4);   <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s5);   <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h1 id="String-的方法"><a href="#String-的方法" class="headerlink" title="String 的方法"></a>String 的方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* String 方法</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  TheBetterKong</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> jdk1.8.0_231</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//*********************** 基础方法 **************************************</span></span><br><span class="line"><span class="function">String <span class="title">intern</span><span class="params">()</span></span>;        <span class="comment">// 在常量池中查找值等于（equals）当前字符串的对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;	                            <span class="comment">// 返回当前字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                          <span class="comment">// 判断字符串是否为空（length == 0）</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 获取字符串中指定位置的字符</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;           <span class="comment">// 是否包含</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;	            <span class="comment">// 返回去除了前后空格的字符串</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span>;                  <span class="comment">// 将指定字符串连接到此字符串的结尾</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;     <span class="comment">// 返回字符串的 hashcode，计算方式：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 转换 ************************************</span></span><br><span class="line"><span class="comment">// 大小写转换</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span></span>;  <span class="comment">// 指定转换规则</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">(Locale locale)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;               <span class="comment">// 将字符串转换为大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #### 其他类型转换为 string</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span>;      <span class="comment">// 它本身就是一个 srtring，所以返回他自身</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>; <span class="comment">// 返回 Object 参数的字符串表示形式，null 或者 obj.toString()</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[])</span></span>;    <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>; <span class="comment">//和上一方法相同</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>; <span class="comment">// 返回 b 代表的 "true" 或者 "false"</span></span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #### string 转换为其他类型</span></span><br><span class="line"><span class="keyword">char</span>[] toCharArray();   <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;    </span><br><span class="line">    <span class="comment">// 将字符串中的字符复制到 dst 中从 dstBegin 开的位置（无范围检查）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;  </span><br><span class="line">    <span class="comment">// 将字符串 srcBegin 到 srcEnd-1 的字符复制到 dst 中从 dstBegin 开的位置（有范围检查）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] getBytes();      <span class="comment">// 将该字符串本身转化为 byte 数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">byte</span> dst[], <span class="keyword">int</span> dstBegin)</span></span>;</span><br><span class="line"><span class="comment">// 将该字符串指定位置的内容转换至 byte 数组指定位置</span></span><br><span class="line"><span class="comment">// 每个字节接收相应字符的8个低位，每个字符的八个高位不被复制，也不以任何方式参与传输（汉子占两个字节，英文字符一个字节）</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes(String charsetName)；   <span class="comment">// 指定字符串转化为 bytes 数组，返回这个数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 比较方法 **************************************</span></span><br><span class="line"><span class="comment">//（1）比较是否完全相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>;            <span class="comment">// 将该字符串与指定对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span></span>;     <span class="comment">// 将该字符串与指定 StringBuffer 对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>；    <span class="comment">// 两个 String 比较，不考虑大小写</span></span></span><br><span class="line"><span class="function"><span class="comment">//（2）按字典序从头至尾对比（不一定完全相等）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>;    <span class="comment">// 从左至右挨个字符对比（只比较公共长度的部分）</span></span><br><span class="line">    <span class="comment">// 如果参数字符串等于此字符串，则值为 0；</span></span><br><span class="line">    <span class="comment">// 如果此字符串在字典上小于字符串参数，则小于 0的值；</span></span><br><span class="line">    <span class="comment">// 如果该字符串在字典上大于字符串参数，则该值大于 0；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;    <span class="comment">// 忽略大小写</span></span><br><span class="line"><span class="comment">//（3）匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span>;  <span class="comment">// 告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="comment">// 将该字符串从 toffset 开始的 len 个字符与 other 字符串从 ooffset 开始的 len 个字符进行匹配</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 拼接 **************************************</span></span><br><span class="line"><span class="comment">// 用 delimiter 作为分割符，将后面的序列拼接起来</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  String message = String.join("-", "Java", "is", "cool"); </span></span><br><span class="line"><span class="comment">//  message returned is:"Java-is-cool"</span></span><br><span class="line"><span class="function">String <span class="title">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span></span>;</span><br><span class="line"><span class="comment">// 运用实例：</span></span><br><span class="line"><span class="comment">//  List&lt;String&gt; strings = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//  strings.add("Java");strings.add("is");</span></span><br><span class="line"><span class="comment">//  strings.add("cool");</span></span><br><span class="line"><span class="comment">//  String message = String.join(" ", strings);</span></span><br><span class="line"><span class="comment">//  message returned is: "Java is cool"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 分割 aplit ************************************</span></span><br><span class="line"><span class="comment">// 将字符串按正则规则分割为子字符串，返回字符串数组</span></span><br><span class="line">String[] aplit(String regex,<span class="keyword">int</span> limit); </span><br><span class="line"><span class="comment">// limit 参数控制应用模式的次数，因此会影响结果数组的长度：</span></span><br><span class="line"><span class="comment">// - 如果限制 n 大于零，则将最多应用 n-1 次该模式，该数组的长度将不大于 n，并且该数组的最后一个条目将包含除最后一个匹配的定界符之外的所有输入;</span></span><br><span class="line"><span class="comment">// - 如果 n 为非正数，则该模式将被尽可能多地应用，并且数组可以具有任何长度；</span></span><br><span class="line"><span class="comment">// - 如果 n 为零，则该模式将被尽可能多地应用，该数组可以具有任何长度，并且尾随的空字符串将被丢弃</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// Regex    Limit   Result</span></span><br><span class="line"><span class="comment">// :	    2       &#123;@code &#123; "boo", "and:foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :	    5	    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// :	    -2	    &#123;@code &#123; "boo", "and", "foo" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o	    5	    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o	    -2	    &#123;@code &#123; "b", "", ":and:f", "", "" &#125;&#125;</span></span><br><span class="line"><span class="comment">// o	    0	    &#123;@code &#123; "b", "", ":and:f" &#125;&#125;</span></span><br><span class="line">String[] split(String regex);   <span class="comment">// 相当于 limit=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 替换 replace ************************************</span></span><br><span class="line"><span class="comment">// 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的第一个子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span>; </span><br><span class="line"><span class="comment">// 替换在与正则表达式匹配的所有子字符串中进行</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>;   </span><br><span class="line"><span class="comment">// 用指定的文字替换序列替换该字符串中与文字目标序列匹配的每个子字符串。 替换从字符串的开头到结尾进行，例如，在字符串“ aaa”中将“ aa”替换为“ b”将得到“ ba”而不是“ ab”</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//********************* 索引 index ************************************</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;	            <span class="comment">// 查找 ch 字符在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>; <span class="comment">// 指定从字符串的 fromIndex 处开始查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;            <span class="comment">// 查找 str 字符串在该字符串中第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>;            <span class="comment">// 查找 ch 字符在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;	    <span class="comment">// 查找 str 字符串在该字符串中最后一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="comment">// 处理（罕见）带有补充字符的 indexOf 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 AbstractStringBuilder 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            String target, <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="comment">// String 和 StringBuffer 共享的代码以进行搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> fromIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 子字符串 **************************************</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span></span>; <span class="comment">// 测试此字符串的子字符串是否从指定的索引开始，并以指定的前缀开头</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>;               <span class="comment">// 获取从 beginIndex 位置开始到结束的子字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span>;  <span class="comment">// 获取从 beginIndex 位置开始到 endIndex-1 位置的子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ###下面是一些不太常用的方法</span></span><br><span class="line"><span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//********************* 格式化字符串 ************************************</span></span><br><span class="line"><span class="comment">// 字符串的格式化内容较多，还需另外具体学习</span></span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(String format, Object... args)</span></span>;   </span><br><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************** 不常用方法 **************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                         <span class="comment">// 返回指定位置的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span></span>;                     <span class="comment">// 返回指定位置的前一个字符的字符值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>;   <span class="comment">// 返回从 beginIndex 到 endIndex-1 范围内的 Unicode code 数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span></span>; <span class="comment">// 返回从 index 开始，偏移 codePointOffset 的索引</span></span><br></pre></td></tr></table></figure>
<h1 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h1><p><code>StringBuffer</code> 和 <code>StringBuilder</code> 不同于 <code>String</code> 的地方在于：它们在修改时会改变对象自身，每次结果都会对他们对象的本身进行操作；而不是像 string 那样生成新的对象，再改变对象引用。</p>
<p>这三者的区别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>可变性</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串常量, 内容不可变</td>
<td>线程安全, 可多线程使用</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>字符串变量</td>
<td>线程安全, 可多线程使用</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>字符串变量</td>
<td>非线程安全, 单线程使用，单线程效率优于 StringBuffer</td>
</tr>
</tbody>
</table>
</div>
<p>大多数方法和 String 都相同，需要重点关注的如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// append：将任何数据类型的字符串表示，拼接到调用的对象的末尾</span></span><br><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</span><br><span class="line">s.append(<span class="string">" World"</span>);</span><br><span class="line">s.append(<span class="string">" !"</span>);</span><br><span class="line">System.out.println(s); <span class="comment">// 输出字符串 “Hello World !”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(int index，String str); 将一个字符串插入到另一个字符串中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse(); 颠倒 StringBuffer 对象中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// delete(int startIndex,int endIndex); 调用对象中删除一串字符</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>体会：写之前我是怎么也没想到这个点的内容量如此之多，很多细节知识都需要好好体会。所以说，在平时的学习过程中真的不能小瞧任何一个知识点，要保持敢钻的态度！</p>
<ul>
<li>『 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk 官方文档</a> 』</li>
<li>『 jdk1.8.0_231 源码 』</li>
<li>『 <a href="https://blog.csdn.net/xialei199023/article/details/63251366" target="_blank" rel="noopener">重新认识Java——字符串（String）</a> 』</li>
<li>『 <a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">深入理解Java中的String</a> 』</li>
</ul>
]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 数据结构之树</title>
    <url>/2020/07/09/DataStructure-Algorithm/DataStructure-Tree/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>树</strong>（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n （$n \geq 0$）个有限节点组成一个具有层次关系的集合。在任意一棵非空树中，它都满足如下特点：</p>
<div class="note warning">
            <ul><li>有且仅有一个特定的称为根（Root）的结点；</li><li>当 $n &gt;1$ 时，其余结点可分为 m（$m &gt;0$）个互不相交的有限集 $T_1,T_2,…,T_m$，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）；</li></ul>
          </div>
<a id="more"></a> 
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="Why-tree？"><a href="#Why-tree？" class="headerlink" title="Why tree？"></a>Why tree？</h2><p>我们知道两种十分常用的线性表：有序数组、链表。在实际使用中，它们都有着自己的优势与不足：</p>
<ul>
<li>在有序数组中插入数据项太慢：<ul>
<li>数组的特点是查找迅速，根据 <code>index</code> 可以快速定位到一个元素。但是，如果要插入一个元素，就需要将这个元素位置之后的所有元素后移。平均来讲，一个长度为 $N$ 的有序数组，插入元素要移动的元素个数为 $N/2$。有序数组的插入和删除的时间复杂度为 $O(N)$，效率很低；</li>
</ul>
</li>
<li>在链表中查找太慢：<ul>
<li>链表的插入和删除效率就很高，只要改变一些值的引用就行了，时间复杂度为 $O(1)$。但是链表的查询效率却很低，每次都要从头开始找，依次访问链表的每个数据项。平均来说，要从一个有 $N$ 个元素的链表查询一个元素，要遍历 $N/2$ 个元素，时间复杂度为 $O(N)$；</li>
</ul>
</li>
</ul>
<p>而树的存在，就很好的权衡了这两种结构，它结合了数组和链表的优点，在实际中有十分广泛的应用领域。可以说生活中几乎无处不存在树，例如：家族族谱、企业用人结构、体育竞赛组织结构、HTML 的文档对象模型（DOM），特别是操作系统的文件目录组织结构你一定不可能不知道吧！</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeTerms.png" alt="TreeTerms">  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>根结点</td>
<td>树最顶层结点</td>
<td>结点 A</td>
</tr>
<tr>
<td>边</td>
<td>两个结点之间的连接</td>
<td>略</td>
</tr>
<tr>
<td>父节点</td>
<td>若一个节点含有子节点，则这个节点称为其子节点的父节点；</td>
<td>H 的父结点为 F；</td>
</tr>
<tr>
<td>子节点</td>
<td>一个节点含有的子树的根节点称为该节点的子节点；</td>
<td>C 的子节点为 F、G；</td>
</tr>
<tr>
<td>兄弟节点</td>
<td>具有相同父节点的节点互称为兄弟节点；</td>
<td>I 的兄弟结点为 H、J；</td>
</tr>
<tr>
<td>堂兄弟节点</td>
<td>父节点在同一层的节点互为堂兄弟；</td>
<td>结点 E 和 F 为堂兄弟结点；</td>
</tr>
<tr>
<td>节点的祖先</td>
<td>从根到该节点所经分支上的所有节点；</td>
<td>F 的祖先为 C、A；</td>
</tr>
<tr>
<td>子孙</td>
<td>以某节点为根的子树中任一节点都称为该节点的子孙；</td>
<td>F 的子孙为 H、I、J；</td>
</tr>
<tr>
<td>节点的度</td>
<td>一个节点含有的子树的个数称为该节点的度；</td>
<td>结点 C 的度为 2；</td>
</tr>
<tr>
<td>树的度</td>
<td>一棵树中，最大的节点度称为树的度；</td>
<td>上述树的度为 3；</td>
</tr>
<tr>
<td>叶节点（终端节点）</td>
<td>度为零的节点；</td>
<td>D、E、G、H、I、J；</td>
</tr>
<tr>
<td>分支节点（非终端节点）</td>
<td>度不为零的节点；</td>
<td>A、B、C、F；</td>
</tr>
<tr>
<td>节点的层次</td>
<td>从根开始定义起，根为第 0 层，根的子节点为第 1 层，以此类推；</td>
<td>见图中标注；</td>
</tr>
<tr>
<td>路径</td>
<td>从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径；</td>
<td>结点 A 到结点 I 的路径为：A、C、F、I；</td>
</tr>
<tr>
<td>深度</td>
<td>对于任意节点 n，n 的深度为从根到 n 的唯一路径长（经过的结点个数），根的深度为 1；</td>
<td>结点 F 的深度为 3；</td>
</tr>
<tr>
<td>高度</td>
<td>对于任意节点 n，n 的高度为从 n 到一片树叶的最长路径长（路径上结点个数的最大值），所有树叶的高度为 1；</td>
<td>结点 F 的深度为 2；</td>
</tr>
<tr>
<td>森林</td>
<td>由 m（$m \geq 0$）棵互不相交的树的集合称为森林；</td>
<td>见后面的讲解；</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注意：有关高度、深度这两个概念，在不同的地方初始值的设定可能有所不同。有些地方习惯将根结点的深度定为 0，将叶结点的高度定为 0，我们没必要特别纠结于到底谁对谁错。关键还是得弄清高度和深度的含义。</li>
</ul>
<h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2><p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeCategory.png" alt="TreeCategory"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序树（自由树）</td>
<td>树中任意节点的子节点之间没有顺序关系；</td>
<td></td>
</tr>
<tr>
<td>有序树</td>
<td>树中任意节点的子节点之间有顺序关系；</td>
<td></td>
</tr>
<tr>
<td>二叉树</td>
<td>每个节点最多含有两个子树的树；</td>
<td></td>
</tr>
<tr>
<td>完全二叉树</td>
<td>对于一颗二叉树，假设其深度为 d（d&gt;1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</td>
<td>见本文二叉树部分；</td>
</tr>
<tr>
<td>满二叉树</td>
<td>所有叶节点都在最底层的完全二叉树；</td>
<td>见本文二叉树部分；</td>
</tr>
<tr>
<td>平衡二叉树（AVL 树）</td>
<td>当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；</td>
<td>参见：<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>；</td>
</tr>
<tr>
<td>排序二叉树（Binary Search Tree）</td>
<td>也称二叉搜索树、有序二叉树、二叉查找树；</td>
<td>也可参见上述文章；</td>
</tr>
<tr>
<td>B 树</td>
<td>一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树；</td>
<td>也可参见上述文章；</td>
</tr>
<tr>
<td>霍夫曼树（最优二叉树）</td>
<td>带权路径最短的二叉树；</td>
<td>本文后面会详细介绍；</td>
</tr>
</tbody>
</table>
</div>
<h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a>树的表示方法</h2><p>树的结构定义是一个基于递归的定义（即在树的定义中又用到树的概念），这道出了树的固有特性；   </p>
<p>除去前面展示过的树形图外，树还有其他三种常用表示形式：</p>
<ul>
<li>以<strong>嵌套集合</strong>（即一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）的形式表示；</li>
<li><strong>广义表</strong>的形式，根作为由子树森林组成的表的名字写在表的左边；</li>
<li><strong>凹入法</strong>（类似书的目录）；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeExpression.png" alt="TreeExpression"></p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历有两种方法：</p>
<ul>
<li>先根（次序）遍历树：先访问树的根结点，然后依次先根遍历根的每棵子树；<ul>
<li>上图的遍历结果为：<code>A B E K L F C G D H M I J</code></li>
</ul>
</li>
<li>后根（次序）遍历树：先依次后根遍历每棵子树，然后访问根结点；<ul>
<li>上图遍历结果为：<code>K L E F B G C M H I J D A</code></li>
</ul>
</li>
</ul>
<h2 id="树的抽象（ADT）及实现"><a href="#树的抽象（ADT）及实现" class="headerlink" title="树的抽象（ADT）及实现"></a>树的抽象（ADT）及实现</h2><p>树作为一个抽象的数据类型，它主要有基于数组、基于链表这两种实现方式；</p>
<h3 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h3><p>使用数组实现，节点在数组中的位置对应于它在树中的位置:</p>
<ul>
<li>下标为 0 的节点是根，下标为 1 的节点是根的左子节点，依次类推，按从左到右的顺序存储树的每一层；</li>
<li>树中的每个位置，无论是否存在节点，都对应数组中的一个位置。把节点插入树的一个位置， 意味着要在数组的相应位置插入一个数据项。树中没有节点的位置在数组中的对应位置用 0 或 null 来表示；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeImpleBaseArray.png" alt="TreeImpleBaseArray"></p>
<p>在这种表示方式中，如果树是一棵二叉树（每个结点最多只有两个子节点），那么找节点的子节点和父节点就可以利用简单的算术计算它们在数组中的索引值：</p>
<ul>
<li>设节点索引值为 $index$，则节点的左子节点是：$2 \times index + 1$，它的右子节点是$2 \times index + 2$，它的父节点是 $\frac{index-1}{2}$；</li>
</ul>
<p>通过上述的定义，我们就能看出这种实现方式的优缺点如下：</p>
<ul>
<li>因为树中的每个位置都需要在数组中表示出来（不管该位置有无结点），这样树中空缺的结点或者被删除的结点都会在数组里留下 “空洞”，造成了内存浪费；</li>
<li>如果树中某个结点被删除后，需要调整树的结构（移动子树），那么子树对应到数组的每个元素都需要移动位置，在大型的树结构中，这一操作将十分耗时；</li>
<li>上述问题反映的也可以说是数组的劣势。当然了，如果某种树结构中不允许有删除操作，特别是在为结点动态分配空间比较耗时的情况下，这种实现方式也将很好的展现出它的优势；</li>
</ul>
<h3 id="基于链表实现"><a href="#基于链表实现" class="headerlink" title="基于链表实现"></a>基于链表实现</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>假设以一组<strong>连续空间</strong>存储树的结点，同时<strong>在每个结点中附设一个指示器指示其双亲结点在链表中的位置</strong>；</p>
<p>该结构利用的是每个结点（除根节点外）只有唯一双亲的性质。示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ParentsTree.png" alt="ParentsTree"></p>
<h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有以下两种结点格式：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildsTree.png" alt="ChildsTree"></p>
<ul>
<li>第一种结构，多重链表中的结点时同构的，其中 d 为树的度。由于树中很多结点的度小于 d，因此链表中会有很多空链表，造成空间浪费；</li>
<li>第二种结构，多重链表中的结点时不同构的，其中 $\overline{d}$ 是结点的度，degree 域的值同 $\overline{d}$。此时虽然节约存储空间，但操作不方便；</li>
</ul>
<p>还有一种办法：把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构（上面的树存储为如下形式）：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ChildLinkedTree.png" alt="ChildLinkedTree"></p>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>基于链表实现时采用的是 <code>父亲-长子-弟弟</code> 模型来定义，结构示意图如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeLinkedList.png" alt="TreeLinkedList"></p>
<p>首先，定义树的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 树的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:25 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点中存放的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span></span>; <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;  <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span></span>; <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> treelinkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 实现树接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:36 2020/7/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkedList</span> <span class="keyword">implements</span> <span class="title">Tree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object element; <span class="comment">// 树根节点</span></span><br><span class="line">    <span class="keyword">private</span> TreeLinkedList parent, firstChild, nextSibling; <span class="comment">// 父节点、长子及最大的弟弟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeLinkedList</span><span class="params">(Object object, TreeLinkedList parent, TreeLinkedList firstChild, TreeLinkedList nextSibling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = object;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.firstChild = firstChild;</span><br><span class="line">        <span class="keyword">this</span>.nextSibling = nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前结点存放的对象元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前结点的对象元素替换为 obj，并返回被替换的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">setElem</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Object bak = element;</span><br><span class="line">        element = obj;</span><br><span class="line">        <span class="keyword">return</span> bak;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的长子（左孩子）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getFirstChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的最大弟弟</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkedList <span class="title">getNextSibling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点后代元素的数目，即以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>; <span class="comment">// 当前节点也是自己的后代</span></span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            size += subtree.getSize(); <span class="comment">// 累加</span></span><br><span class="line">            subtree = subtree.getNextSibling(); <span class="comment">// 所有孩子的后代数目</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size; <span class="comment">// 得到当前节点的后代总数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回当前节点的高度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TreeLinkedList subtree = firstChild; <span class="comment">// 从长子开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != subtree) &#123;</span><br><span class="line">            height = Math.max(height, subtree.getHeight()); <span class="comment">// 在所有孩子中取最大高度</span></span><br><span class="line">            subtree = subtree.getNextSibling();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> height + <span class="number">1</span>; <span class="comment">// 每往下一行高度加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前节点的深度</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        TreeLinkedList p = parent; <span class="comment">// 从父亲开始</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            p = p.getParent(); <span class="comment">// 访问各个真祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth; <span class="comment">// 真祖先的数目，即为当前节点的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二叉树（Binary Tree）是另一种树型结构，它的特点是每个结点至多只有两颗子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。 </p>
<p>根据定义就能看出二叉树的 5 种基本形态如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeFiveStructure.png" alt="BinaryTreeFiveStructure">   </p>
<p>具有特殊形态的二叉树如下所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/SpecialFormBinaryTree.png" alt="SpecialFormBinaryTree"></p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质 1</strong>：二叉树的第 i 层上至多有 $2^{i-1}$ 个结点（$i \geq 1$）；</p>
<ul>
<li>证明：利用归纳法<ul>
<li>当 $i = 1$ 时，只有一个根节点，显然成立；</li>
<li>假设对所有的 $j$，$1 \leq j &lt; i$，命题成立，即第 $j$ 层上至多有 $2^{j-1}$ 个结点；</li>
<li>由于二叉树每个结点的度至多为 2，则对于 $j+1$ 层来说：至多有 $2 \times 2^{j-1}=2^j$ 个结点，上述命题也成立；</li>
<li>因此，命题为真；</li>
</ul>
</li>
</ul>
<p><strong>性质 2</strong>：深度为 k 的二叉树至多有 $2^k-1$ 个结点（$k \geq1$）；</p>
<ul>
<li>证明：由性质 1，深度为 k 的二叉树的最大节点数为：<script type="math/tex">\sum^k_{i=1}\ (第\ i\ 层上的最大结点数)=\sum^k_{i=1}\ 2^{i-1}=2^k-1</script></li>
</ul>
<p><strong>性质 3</strong>：对任何一棵二叉树 T，如果其终端节点数为 $n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$；</p>
<ul>
<li>证明：设 $n_1$ 为二叉树 T 中度为 1 的节点数，$n$ 为二叉树的总结点数，则：$n=n_0+n_1+n_2$；</li>
<li>考察二叉树的分支数。除了根节点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$；</li>
<li>由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_1+2\cdot n_2$；</li>
<li>将上述表达式联合起来也就不难推出：$n_0=n_2+1$；</li>
</ul>
<p>由于完全二叉树在实际中的运用比较多，接下来的两条性质就是围绕完全二叉树展开：   </p>
<p><strong>性质 4</strong>：具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n \rfloor+1$；</p>
<ul>
<li>证明：假设深度为 k，则根据性质 2 和完全二叉树的定义有：<script type="math/tex">2^{k-1}-1 < n \leq 2^k-1\ 或\ 2^{k-1} \leq n < 2^k</script>，于是 $k-1 \leq log_2n &lt; k$，因为 k 是整数，所以 $k=\lfloor log_2n \rfloor+1$；</li>
</ul>
<p><strong>性质 5</strong>：如果对一棵有 n 个结点的完全二叉树（其深度为 $\lfloor log_2n \rfloor+1$）的结点按层序编号（从第 1 层到第 $\lfloor log_2n \rfloor+1$ 层，每层从左到右），则对任一结点 i（$1\leq i \leq n$），有：</p>
<ol>
<li>如果 $i=1$，则结点 i 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲 $PARENT(i)$ 是结点 $\lfloor i/2 \rfloor$；</li>
<li>如果 $2i&gt;n$，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子 $LCHILD(I)$ 是结点 $2i$；</li>
<li>如果 $2i+1&gt;n$，则结点 i 无右孩子；否则其右孩子 $RCHILD(i)$ 是结点 $2i+1$；</li>
</ol>
<ul>
<li>证明：结论 1 可由结论 2 和 3 推导而出；<ul>
<li>对于 $i=1$ 的情况，很好推出；</li>
<li>对 $i&gt;1$ 分两种情况讨论：<ul>
<li>设第 $j（1 \leq j \leq \lfloor log_2n \rfloor）$层的第一个结点的编号为 i（由前面性质易推出 $i=2^{j-1}$）：<ul>
<li>则其左孩子必为第 $j+1$ 层的第一个结点，其编号为 $2^j=2(2^{j-1})=2i$，若 $2i&gt;n$，则无左孩子；</li>
<li>其右孩子必为第 $j+1$ 层的第二个结点，其编号为 $2i+1$，若 $2i+1&gt;n$，则无右孩子；</li>
</ul>
</li>
<li>假设第 $j(1 \leq j \leq \lfloor log_2n \rfloor)$ 层上某个结点的编号为 $i(2^{j-1} \leq i &lt; 2^j-1)$，且 $2i+1&lt;n$：则其左孩子为 $2i$，右孩子为 $2i+1$；<ul>
<li>又编号为 $i+1$ 的结点是编号为 $i$ 的结点的右兄弟或者堂兄弟，若它有左孩子，则编号必为 $2i+2=2(i+1)$，若它有右孩子，则其编号必为 $2i+3=2(i+1)+1$;</li>
</ul>
</li>
</ul>
</li>
<li>文字描述比较抽象，可以参照具体的完全二叉树的图示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/LRChild.png" alt="LRChild"></li>
</ul>
</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>假设用下面的图示来表示表达式：<code>a+b*(c-d)-e/f</code><br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TraverseBinaryTree.png" alt="TraverseBinaryTree"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>先序遍历</th>
<th>中序遍历</th>
<th>后序遍历</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>先访问根结点，再访问左子树，再访问右子树；</td>
<td>先访问左子树，再访问根结点，再访问右子树；</td>
<td>先访问左子树，在访问右子树，再访问根结点；</td>
</tr>
<tr>
<td>遍历结果</td>
<td><code>-+a*b-cd/ef</code></td>
<td><code>a+b*c-d-e/f</code></td>
<td><code>abcd-*+ef/-</code></td>
</tr>
<tr>
<td>表达式类型</td>
<td>前缀表达式（波兰式）</td>
<td>中缀表达式</td>
<td>后缀表达式（逆波兰式）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="树与二叉树的转换"><a href="#树与二叉树的转换" class="headerlink" title="树与二叉树的转换"></a>树与二叉树的转换</h2><p><strong>树转换为二叉树</strong>：</p>
<ul>
<li>加线：在所有的兄弟结点之间加线</li>
<li>去线：对树中的每一个结点，只保留它与第一个结点的连线，删除与其他孩子结点之间的连线</li>
<li>层次调整：调整成一颗二叉树（第一个孩子是二叉树的左孩子，兄弟转换过来是它的右孩子）</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/TreeToBinaryTree.png" alt="TreeToBinaryTree"></p>
<p><strong>二叉树转换为树</strong>：就是树转换成二叉树的逆过程</p>
<ul>
<li>加线：若某结点的左孩子结点存在，则将左孩子的n个右孩子结点与此结点连接在一起</li>
<li>去线：删除二叉树中所有结点与其右孩子之间的连线</li>
<li>层次调整</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToTree.png" alt="BinaryTreeToTree"></p>
<h2 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h2><p>这里只是给出一种实现示例，该数据结构使用十分广泛，实际运用时可根据需求进行调整，例如：《<a href="http://www.thebetterkong.cn/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/#more">查找算法（详解 + java 实现）</a>》 文章里的 『二叉搜索树』、『平衡二叉树』、 『B 树』等；</p>
<details>
  <summary><b>二叉树的 java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> binarytree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> WWX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 二叉树的链式存储结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 0:07 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树的节点数据结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span>  <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key=<span class="number">0</span>; <span class="comment">// 序号</span></span><br><span class="line">        <span class="keyword">private</span> String data=<span class="keyword">null</span>; <span class="comment">// 值（数据域）</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isVisted=<span class="keyword">false</span>; <span class="comment">// 用来判断结点是否被访问到</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode leftChild=<span class="keyword">null</span>; <span class="comment">// 左儿子节点</span></span><br><span class="line">        <span class="keyword">private</span> TreeNode rightChild=<span class="keyword">null</span>; <span class="comment">// 右儿子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="comment">// 默认构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="comment">// 带参数构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> key,String data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.leftChild=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightChild=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode root=<span class="keyword">null</span>;  <span class="comment">// 二叉树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法</span></span><br><span class="line"><span class="comment">     * 指定根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> TreeNode(<span class="number">1</span>,<span class="string">"rootNode(A)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手动创建一棵二叉树</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *           A</span></span><br><span class="line"><span class="comment">     *     B          C</span></span><br><span class="line"><span class="comment">     *  D     E            F</span></span><br><span class="line"><span class="comment">     *  &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode newNodeB = <span class="keyword">new</span> TreeNode(<span class="number">2</span>,<span class="string">"B"</span>);</span><br><span class="line">        TreeNode newNodeC = <span class="keyword">new</span> TreeNode(<span class="number">3</span>,<span class="string">"C"</span>);</span><br><span class="line">        TreeNode newNodeD = <span class="keyword">new</span> TreeNode(<span class="number">4</span>,<span class="string">"D"</span>);</span><br><span class="line">        TreeNode newNodeE = <span class="keyword">new</span> TreeNode(<span class="number">5</span>,<span class="string">"E"</span>);</span><br><span class="line">        TreeNode newNodeF = <span class="keyword">new</span> TreeNode(<span class="number">6</span>,<span class="string">"F"</span>);</span><br><span class="line"></span><br><span class="line">        newNodeC.rightChild = newNodeF;<span class="comment">//root.rightChild.rightChild=newNodeF;</span></span><br><span class="line">        newNodeB.leftChild = newNodeD;<span class="comment">//root.leftChild.leftChild=newNodeD;</span></span><br><span class="line">        newNodeB.rightChild = newNodeE;<span class="comment">//root.leftChild.rightChild=newNodeE;</span></span><br><span class="line"></span><br><span class="line">        root.leftChild = newNodeB;</span><br><span class="line">        root.rightChild = newNodeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断根节点是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树的规模（树中结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二叉树某个节点的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归结束：空树高度为0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = height(subTree.leftChild);</span><br><span class="line">            <span class="keyword">int</span> j = height(subTree.rightChild);</span><br><span class="line">            <span class="keyword">return</span> (i &lt; j) ? (j + <span class="number">1</span>) : (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以当前节点为根的子树的规模（结点个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + size(subTree.leftChild) + size(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找某结点的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root == <span class="keyword">null</span> || root == element) ? <span class="keyword">null</span> : parent(root, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以 subTree 为根的树中，element 的父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">parent</span><span class="params">(TreeNode subTree,TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(subTree.leftChild == element || subTree.rightChild == element)</span><br><span class="line">            <span class="comment">//返回父结点地址</span></span><br><span class="line">            <span class="keyword">return</span> subTree;</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="comment">//现在左子树中找，如果左子树中没有找到，才到右子树去找</span></span><br><span class="line">        <span class="keyword">if</span>((p = parent(subTree.leftChild, element)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//递归在左子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//递归在右子树中搜索</span></span><br><span class="line">            <span class="keyword">return</span> parent(subTree.rightChild, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回左孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeftChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.leftChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回右孩子结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRightChildNode</span><span class="params">(TreeNode element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element != <span class="keyword">null</span>) ? element.rightChild : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除根为 subTree 的子树</span></span><br><span class="line">    <span class="comment">//   在释放某个结点时，该结点的左右子树都已经释放，</span></span><br><span class="line">    <span class="comment">//   所以应该采用后续遍历，当访问某个结点时将该结点的存储空间释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//删除左子树</span></span><br><span class="line">            destroy(subTree.leftChild);</span><br><span class="line">            <span class="comment">//删除右子树</span></span><br><span class="line">            destroy(subTree.rightChild);</span><br><span class="line">            <span class="comment">//删除根结点</span></span><br><span class="line">            subTree=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span> + subTree.key + <span class="string">"--name:"</span> + subTree.data);;</span><br><span class="line">        traverse(subTree.leftChild);</span><br><span class="line">        traverse(subTree.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            visted(subTree); <span class="comment">// 输出根节点</span></span><br><span class="line">            preOrder(subTree.leftChild); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            preOrder(subTree.rightChild); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(subTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrder(subTree.leftChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">            inOrder(subTree.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode subTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subTree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            postOrder(subTree.leftChild);</span><br><span class="line">            postOrder(subTree.rightChild);</span><br><span class="line">            visted(subTree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecPreOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node=p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                visted(node);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonRecInOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack =<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>||stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//存在左子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node=node.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈非空</span></span><br><span class="line">            <span class="keyword">if</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                node=stack.pop();</span><br><span class="line">                visted(node);</span><br><span class="line">                node=node.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历的非递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noRecPostOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;BinaryTree.TreeNode&gt;();</span><br><span class="line">        TreeNode node =p;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//左子树入栈</span></span><br><span class="line">            <span class="keyword">for</span>(;p.leftChild!=<span class="keyword">null</span>;p=p.leftChild)&#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前结点无右子树或右子树已经输出</span></span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;(p.rightChild==<span class="keyword">null</span>||p.rightChild==node))&#123;</span><br><span class="line">                visted(p);</span><br><span class="line">                <span class="comment">//纪录上一个已输出结点</span></span><br><span class="line">                node =p;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                p=stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理右子树</span></span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被访问到就输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visted</span><span class="params">(TreeNode subTree)</span></span>&#123;</span><br><span class="line">        subTree.isVisted=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"key:"</span>+subTree.key+<span class="string">"--name:"</span>+subTree.data);;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree bt = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        bt.createBinTree(bt.root);</span><br><span class="line">        System.out.println(<span class="string">"the size of the tree is "</span> + bt.size());</span><br><span class="line">        System.out.println(<span class="string">"the height of the tree is "</span> + bt.height());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.preOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.inOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*******(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.postOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(前序遍历)[ABDECF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecPreOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(中序遍历)[DBEACF]遍历*****************"</span>);</span><br><span class="line">        bt.nonRecInOrder(bt.root);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"***非递归实现****(后序遍历)[DEBFCA]遍历*****************"</span>);</span><br><span class="line">        bt.noRecPostOrder(bt.root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>线索二叉树是在二叉树的基础上新增了下列规则：</p>
<ul>
<li>若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；</li>
<li>若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 域指示其后继；</li>
</ul>
<p>为了避免混淆，尚需改变结点结构，增加两个标志域：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ClueBinaryTreeStruct.png" alt="ClueBinaryTreeStruct">   </p>
<p>由定义的结构，我们知道线索二叉树也应该分为：前序线索树、中序线索树、后序线索树。这其中在后序线索树中找结点后继较复杂，以其为例，分为 3 种情况考虑：</p>
<ul>
<li>若结点 x 是二叉树的根，则其后继为空；</li>
<li>若结点 x 是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；</li>
<li>若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲的右子树上按后序遍历列出的第一个结点；</li>
</ul>
<p>若在某程序中所用二叉树需经常遍历或查找结点在遍历所得线性序列中的前驱和后继，则应采用线索链表作为存储结构；</p>
<h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><p>前面已经说过，森林是 $m（m \geq 0）$棵互不相交的树的集合；   </p>
<p><strong>将森林转换为二叉树</strong>：</p>
<ul>
<li>转换：把每一棵树转换成二叉树</li>
<li>连线：第一棵二叉树不变，从第二棵二叉树开始，依次将后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子，用线连起来</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/ForestToBinaryTree.png" alt="ForestToBinaryTree"></p>
<p><strong>二叉树转换为森林</strong>：</p>
<ul>
<li>判断二叉树转换成森林还是树：二叉树的根节点是否有右孩子，若有是森林，否则是树</li>
<li>从根节点开始，若有右孩子，则把与右孩子结点的连线删除，再看分离后的二叉树，若还有右孩子连线继续删除，则到没有为止</li>
<li>将分离的二叉树转换成树</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/BinaryTreeToForest.png" alt="BinaryTreeToForest"></p>
<p><strong>森林的遍历</strong>：</p>
<ul>
<li>先序遍历：<ul>
<li>若森林非空，则按如下规则遍历：<ul>
<li>访问森林中第一棵树的根结点；</li>
<li>先序遍历第一棵树中根结点的子树森林；</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林；</li>
</ul>
</li>
<li>上述森林的遍历结果：<code>A B C D E F G H J I</code></li>
</ul>
</li>
<li>中序遍历：<ul>
<li>若森林非空，则按如下规则遍历：<ul>
<li>中序遍历森林中第一棵树的根结点的子树森林；</li>
<li>访问第一棵树的根结点；</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林；</li>
</ul>
</li>
<li>上述森林的遍历结果：<code>B C D A F E J H I G</code></li>
</ul>
</li>
</ul>
<h1 id="哈夫曼（Huffman）树"><a href="#哈夫曼（Huffman）树" class="headerlink" title="哈夫曼（Huffman）树"></a>哈夫曼（Huffman）树</h1><p>哈（赫）夫曼树又称最优树，它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度最小的二叉树；</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>路径与路径长</strong>：</p>
<ul>
<li><strong>路径</strong>：从树中的一个结点到另一个结点之间的分支构成的部分，而分支（边）的数目就是<strong>路径长度</strong>；</li>
<li><strong>树的路径长度</strong>：就是从树根到每一结点的路径长度之和；</li>
</ul>
<p><strong>考虑带权的结点</strong>：</p>
<ul>
<li><strong>结点的带权路径长度</strong>：从该结点到树根之间的路径长度与结点上权的乘积；</li>
<li><strong>树的带权路径长度 WPL</strong>（weighted path length）：树中所有叶子结点的带权路径长度之和；<ul>
<li>假设一个有 $n$ 个带权叶子结点的二叉树，其权值为 $\{w_1,w_2,….w_n\}$，每个叶子结点带权 $w_k$，每个叶子的路径长度为 $l_k$，则从根结点到各个叶子结点的路径长度与相应的权值的乘积之和叫做<strong>二叉树的带权路径长度</strong>，通常记作：<script type="math/tex">WPL = \sum^n_{k=1}\ w_kl_k</script></li>
<li>示例：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanWPL.png" alt="HuffmanWPL"></li>
</ul>
</li>
</ul>
<p>观察上述示例，（b）所示的二叉树的 WPL 最小，为哈夫曼树（最优树）；</p>
<ul>
<li>注意：由相同权值的一组叶子结点所构成的二叉树有不同的形态和不同的带权路径。在由 n 个带权叶子结点所构成的二叉树中，满二叉树或完全二叉树不一定是最优二叉树。<strong>权值越大的结点离根结点越近的二叉树才是最优二叉树</strong>；</li>
</ul>
<h2 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h2><p>哈夫曼算法是用来构造二叉树的，其描述如下：</p>
<ul>
<li>根据给定的 $n$ 个叶子结点的权值 $\{w_1,w_2,….w_n\}$ 构成 $n$ 棵二叉树的集合 $F=\{T_1,T_2,…T_n\}$，其中每棵二叉树 $T_i$ 中只有一个带权为 $w_i$的根结点，其左右子树均为空;</li>
<li>在 $F$ 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为左右子树上根结点的权值之和；</li>
<li>在 $F$ 中删除这两棵树，同时将新得到的二叉树加入 $F$ 中；</li>
<li>重复步骤 2、3，直到 $F$ 只含一棵树为止。这棵树便是哈夫曼树；</li>
</ul>
<p>示例如下：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanTreeBuild.png" alt="HuffmanTreeBuild"></p>
<h2 id="应用：哈夫曼编码"><a href="#应用：哈夫曼编码" class="headerlink" title="应用：哈夫曼编码"></a>应用：哈夫曼编码</h2><p>在数字通信中，经常需要将传送的文字转换成由二进制字符 <code>0、1</code> 组成的二进制串，这一过程被称为<strong>编码</strong>。在传送电文时，总是希望电文代码尽可能短，采用哈夫曼编码构造的电文的总长最短。</p>
<ul>
<li>从根节点出发，每个父节点都会有分支，现在给左右分支各赋予一个数值，左分支表示 <code>0</code>，右分支表示 <code>1</code>；</li>
<li>当从根节点一直数到叶子结点过程中所经历的左右分支以 <code>0</code>、<code>1</code> 表示时，每个叶子结点会形成一个特定的编码，这个就是哈夫曼编码。如图所示：<br><img src="http://img.thebetterkong.cn/blog/DataStructure-Tree/HuffmanCode.png" alt="HuffmanCode"></li>
</ul>
<div class="note warning">
            <p>来自：<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">本段来源</a><br>在电文传输中，需要将电文中出现的每个字符进行二进制编码。在设计编码时需要遵守两个原则：</p><ul><li>发送方传输的二进制编码，到接收方解码后必须具有唯一性，即解码结果与发送方发送的电文完全一样；</li><li>发送的二进制编码尽可能地短;</li></ul><p>下面我们介绍两种编码的方式。</p><ol><li><p>等长编码：</p><ul><li>这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）；</li><li>假设字符集只含有 4 个字符 A，B，C，D，用二进制两位表示的编码分别为 00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为 14 位。当接收方接收到这段电文后，将按两位一段进行译码。</li><li>这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</li></ul></li><li><p>不等长编码：</p><ul><li>在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编；</li><li>例如，可以为 A，B，C，D 四个字符分别分配 0，00，1，01，并可将上述电文用二进制序列：000011010 发送，其长度只有 9 个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面 4 个 0 是 4 个 A，1 个 B、2 个 A，还是 2 个 B，即译码不唯一，因此这种编码方法不可使用。</li><li>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即（<strong>前缀编码</strong>）在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀。<strong>这个问题可以采用哈夫曼编码解决</strong>。</li></ul></li></ol>
          </div>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>将一个字符串中出现的字符生成其对应的哈夫曼编码，分为以下几步：</p>
<ol>
<li>统计出现的字符及频率；</li>
<li>将各个字符创建为叶子结点，频率为结点的权值，用链表保存这些叶子结点；</li>
<li>将结点队列中的结点按权值升序排列；</li>
<li>取出权值最小的两个结点构建父节点（要从链表中删除取出的结点），将新生成的父节点添加到结点链表，并从新排序；</li>
<li>重复（4）步骤，直到只剩下一个结点；</li>
<li>返回最后的结点，即为哈夫曼树的根节点；</li>
</ol>
<details>
  <summary><b>哈夫曼树的 java 实现</b></summary> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modify</span> TheBetterKong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 哈夫曼树的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 23:47 2020/7/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树的结点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String code = <span class="string">""</span>; <span class="comment">// 节点的哈夫曼编码</span></span><br><span class="line">        <span class="keyword">public</span> String data = <span class="string">""</span>; <span class="comment">// 节点的数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> count;        <span class="comment">// 节点的权值</span></span><br><span class="line">        <span class="keyword">public</span> HNode lChild;     <span class="comment">// 左孩子</span></span><br><span class="line">        <span class="keyword">public</span> HNode rChild;     <span class="comment">// 右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(<span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(String data, <span class="keyword">int</span> count, HNode lChild, HNode rChild)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">            <span class="keyword">this</span>.lChild = lChild;</span><br><span class="line">            <span class="keyword">this</span>.rChild = rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼树部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String str;                     <span class="comment">// 最初用于压缩的字符串</span></span><br><span class="line">    <span class="keyword">private</span> HNode root;                     <span class="comment">// 哈夫曼二叉树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;                   <span class="comment">// 最新的字符是否已经存在的标签</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;CharData&gt; charList;  <span class="comment">// 存储不同字符的队列 相同字符存在同一位置</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;HNode&gt; NodeList;     <span class="comment">// 存储节点的队列</span></span><br><span class="line">    <span class="comment">// 字符类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CharData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>; <span class="comment">// 字符个数</span></span><br><span class="line">        <span class="keyword">char</span> c; <span class="comment">// 字符</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharData</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">            c = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatHfmTree</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line"></span><br><span class="line">        NodeList = <span class="keyword">new</span> LinkedList&lt;HNode&gt;();</span><br><span class="line">        charList = <span class="keyword">new</span> LinkedList&lt;CharData&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.统计字符串中字符以及字符的出现次数</span></span><br><span class="line">        <span class="comment">// 以CharData类来统计出现的字符和个数</span></span><br><span class="line">        getCharNum(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.根据第一步的结构，创建节点</span></span><br><span class="line">        creatNodes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.对节点权值升序排序</span></span><br><span class="line">        Sort(NodeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">        <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">        creatTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.重复第四五步，就是那个while循环</span></span><br><span class="line">        <span class="comment">// 7.将最后的一个节点赋给根节点</span></span><br><span class="line">        root = NodeList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是构造哈夫曼树的子方法实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计出现的字符及其频率</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 最初用于压缩的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCharNum</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i); <span class="comment">// 从给定的字符串中取出字符</span></span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charList.size(); j++) &#123; <span class="comment">// charList中存放的是已经识别出来的字符</span></span><br><span class="line">                CharData data = charList.get(j);</span><br><span class="line">                <span class="keyword">if</span>(ch == data.c)&#123; <span class="comment">// 字符对象链表中有相同字符则将个数加1</span></span><br><span class="line">                    data.num++;</span><br><span class="line">                    flag = <span class="keyword">false</span>;  <span class="comment">// 标志该字符已被识别出来不再加入 charList</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                charList.add(<span class="keyword">new</span> CharData(ch)); <span class="comment">// 字符对象链表中没有相同字符,则创建新对象加如链表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将出现的字符创建成哈夫曼树单个的结点对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charList.size(); i++) &#123;</span><br><span class="line">            String data = charList.get(i).c + <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">int</span> count = charList.get(i).num;</span><br><span class="line">            HNode node = <span class="keyword">new</span> HNode(data, count); <span class="comment">// 创建节点对象</span></span><br><span class="line">            NodeList.add(node); <span class="comment">// 加入到节点链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">creatTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (NodeList.size() &gt; <span class="number">1</span>) &#123;    <span class="comment">// 当节点数目大于一时</span></span><br><span class="line">            <span class="comment">// 4.取出权值最小的两个节点，生成一个新的父节点</span></span><br><span class="line">            <span class="comment">// 5.删除权值最小的两个节点，将父节点存放到列表中</span></span><br><span class="line">            HNode left = NodeList.poll();</span><br><span class="line">            HNode right = NodeList.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在构建哈夫曼树时设置各个结点的哈夫曼编码</span></span><br><span class="line">            left.code = <span class="string">"0"</span>;  <span class="comment">// 左节点为 1</span></span><br><span class="line">            right.code = <span class="string">"1"</span>; <span class="comment">// 右节点为 0</span></span><br><span class="line">            setCode(left);</span><br><span class="line">            setCode(right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parentWeight = left.count + right.count; <span class="comment">// 父节点权值等于子节点权值之和</span></span><br><span class="line">            HNode parent = <span class="keyword">new</span> HNode(parentWeight, left, right);</span><br><span class="line">            NodeList.addFirst(parent); <span class="comment">// 将父节点置于首位</span></span><br><span class="line">            Sort(NodeList); <span class="comment">// 重新排序，避免新节点权值大于链表首个结点的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 升序排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodelist</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Sort</span><span class="params">(LinkedList&lt;HNode&gt; nodelist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodelist.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nodelist.size(); j++) &#123;</span><br><span class="line">                HNode temp;</span><br><span class="line">                <span class="keyword">if</span> (nodelist.get(i).count &gt; nodelist.get(j).count) &#123;</span><br><span class="line">                    temp = nodelist.get(i);</span><br><span class="line">                    nodelist.set(i, nodelist.get(j));</span><br><span class="line">                    nodelist.set(j, temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置结点的哈夫曼编码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(HNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.lChild.code = root.code + <span class="string">"0"</span>;</span><br><span class="line">            setCode(root.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.rChild.code = root.code + <span class="string">"1"</span>;</span><br><span class="line">            setCode(root.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(HNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.lChild == <span class="keyword">null</span> &amp;&amp; node.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(node.data + <span class="string">": "</span> + node.code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            output(node.rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果字符的哈夫曼编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        output(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***********************以下是编解码的实现*************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String hfmCodeStr = <span class="string">""</span>;<span class="comment">// 哈夫曼编码连接成的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHufmCode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            String c = str.charAt(i) + <span class="string">""</span>;</span><br><span class="line">            search(root, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hfmCodeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在哈夫曼树里查找字符对应的结点（递归）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 需要生成编码的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(HNode root, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.equals(root.data)) &#123;</span><br><span class="line">                hfmCodeStr += root.code; <span class="comment">// 找到字符，将其哈夫曼编码拼接到最终返回二进制字符串的后面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.lChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            search(root.rChild, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存解码的字符串</span></span><br><span class="line">    String result=<span class="string">""</span>; <span class="comment">// 初始为空串</span></span><br><span class="line">    <span class="keyword">boolean</span> target = <span class="keyword">false</span>; <span class="comment">// 解码标记</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeStr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">CodeToString</span><span class="params">(String codeStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt;= codeStr.length())&#123;</span><br><span class="line">            target = <span class="keyword">false</span>;</span><br><span class="line">            String s = codeStr.substring(start, end);</span><br><span class="line">            matchCode(root, s); <span class="comment">// 解码</span></span><br><span class="line">            <span class="comment">// 每解码一个字符，start向后移</span></span><br><span class="line">            <span class="keyword">if</span>(target)&#123;</span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配字符哈夫曼编码，找到对应的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 哈夫曼树根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 需要解码的二进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">matchCode</span><span class="params">(HNode root, String code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild == <span class="keyword">null</span> &amp;&amp; root.rChild == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (code.equals(root.code)) &#123;</span><br><span class="line">                result += root.data; <span class="comment">// 找到对应的字符，拼接到解码字符穿后</span></span><br><span class="line">                target = <span class="keyword">true</span>; <span class="comment">// 标志置为true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.lChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.lChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.rChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            matchCode(root.rChild, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HuffmanTree huff = <span class="keyword">new</span> HuffmanTree();<span class="comment">// 创建哈弗曼对象</span></span><br><span class="line">        String data = <span class="string">"我喜欢用 java 实现哈夫曼编码"</span>;</span><br><span class="line">        </span><br><span class="line">        huff.creatHfmTree(data);<span class="comment">// 构造树</span></span><br><span class="line"></span><br><span class="line">        huff.output(); <span class="comment">// 显示各个字符的哈夫曼编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目标字符串利用生成好的哈夫曼编码生成对应的二进制编码</span></span><br><span class="line">        String hufmCode = huff.toHufmCode(data);</span><br><span class="line">        System.out.println(<span class="string">"编码:"</span> + hufmCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上述二进制编码再翻译成字符串</span></span><br><span class="line">        System.out.println(<span class="string">"解码："</span> + huff.CodeToString(hufmCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li>
<li>『<a href="https://www.jianshu.com/p/4716b2f49e8e" target="_blank" rel="noopener">数据结构：二叉树的原理及java实现</a>』</li>
<li>『<a href="https://blog.csdn.net/xin917480852/article/details/50503501" target="_blank" rel="noopener">树、森林与二叉树的转换总结</a>』</li>
<li>『<a href="https://blog.csdn.net/qq_34975710/article/details/78563461" target="_blank" rel="noopener">Java 实现哈夫曼树及简易编码解码</a>』</li>
</ul>
]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>概述：幽灵漏洞&amp;熔断漏洞</title>
    <url>/2020/03/20/Computer-architecture-security/Overview_Spectre&amp;Meltdown/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/header.png" width="100%" alt="header.png" /> </div>   

<p>2018年1月3日正式披露两类处理器安全漏洞：</p>
<ul>
<li><strong><code>Spectre 幽灵</code></strong>：推测执行，基本涵盖了所有使用乱序执行的高性能处理器；</li>
<li><strong><code>Meltdown 熔断</code></strong>：乱序执行，Intel 内部实现的问题，并不是所有处理器都有；</li>
</ul>
<a id="more"></a> 
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最核心的性能技术出现问题，攻击者可利用这两个漏洞实现『跨权限』、『跨进程』的非法数据访问，这样就打破了传统操作系统设计的安全底线（逻辑隔离、权限隔离）。   </p>
<p>从 <code>IoT（物联网：Internet of Things）</code> 至 <code>PC 端</code>，再至 <code>云端</code>，无一例外地受到这两类漏洞的影响，在工业界引起了一片哗然！潘多拉魔盒被打开，一年多的时间里，几乎每隔一两个月都会出现各式各样的新的变种。直至现在，人们依然认为以 Spectre 为代表的漏洞，在处理器里依然存在很大的安全隐患。</p>
<h1 id="问题：为什么需要乱序执行与推测执行？"><a href="#问题：为什么需要乱序执行与推测执行？" class="headerlink" title="问题：为什么需要乱序执行与推测执行？"></a>问题：为什么需要乱序执行与推测执行？</h1><p>首先，从体系结构的角度来看，我们知道程序中存在三大依赖关系：</p>
<ul>
<li>数据依赖：<ul>
<li>假相关（WAW 和 WAR）：重命名</li>
<li>真相关（RAW）：</li>
</ul>
</li>
<li>控制依赖：<ul>
<li>在复杂的流水线中，分支指令在取指后，到知道『怎么跳？』『往哪跳？』需要花费很大的周期数，这期间如果不进行相关操作，会存在大量的 bubble，严重影响性能。</li>
<li>推测执行</li>
</ul>
</li>
<li>资源依赖：超标量流水线、乱序执行</li>
</ul>
<p>提升处理器性能的指标：</p>
<ul>
<li>指令级并行性：这里就会大量的用到推测执行和乱序执行</li>
<li>数据级并行性</li>
<li>线程级并行性</li>
</ul>
<h2 id="推测执行"><a href="#推测执行" class="headerlink" title="推测执行"></a>推测执行</h2><p>类型：</p>
<ul>
<li>分支指令的跳转方向及是否跳转</li>
<li>ret 指令的跳转方向<ul>
<li>种类一：return 指令的返回地址在 reg 里，这样指令执行时可以直接读返回地址，比较理想；</li>
<li>种类二：return 指令的返回地址需要从栈里弹出，这时可能发生 cache miss，需要花费几百个 cycle，导致性能爆降；</li>
</ul>
</li>
<li>访存指令是否存在内存一致性</li>
</ul>
<p>实现机制：<br><img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/Speculative-execution.png" alt="推测执行"></p>
<ul>
<li>BTB：跳转目标</li>
<li>BHT：是否跳转<ul>
<li>Local History</li>
<li>Global History</li>
</ul>
</li>
<li>RSB（return stack buffer）：call压栈，res出栈</li>
<li>内存消歧：发现预测错误后，重新执行访存指令</li>
<li>对于每条分支指令，记录指令执行前的状态（checkpoint），如寄存器映射表</li>
</ul>
<p>详见：转移猜测-CA</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>实现机制：</p>
<ul>
<li>顺序进入、乱序执行、顺序提交</li>
<li>并行执行不存在依赖关系的指令</li>
<li>提升指令级并行性</li>
</ul>
<p>乱序执行对例外的处理：</p>
<ul>
<li>ROB</li>
<li>处理器不仅记录前向的寄存器映射关系，还记录后向，在发生例外后，一条条的将状态恢复</li>
</ul>
<p>详见：动态调度-CA</p>
<h2 id="瞬态指令"><a href="#瞬态指令" class="headerlink" title="瞬态指令"></a>瞬态指令</h2><p>定义：执行但未提交的指令    </p>
<p>出现原因：错误预测、例外、中断等</p>
<p>特点：</p>
<ul>
<li>不影响体系结构的状态：<ul>
<li>寄存器映射关系</li>
<li>各个指令队列中的状态位</li>
</ul>
</li>
<li>不影响程序的正确性</li>
<li>影响微体系结构状态：<ul>
<li>缓存内容</li>
<li>TLB内容</li>
</ul>
</li>
</ul>
<h1 id="安全角度看问题"><a href="#安全角度看问题" class="headerlink" title="安全角度看问题"></a>安全角度看问题</h1><p>最核心的就是看：<mark>微体系结构状态的变化是否能被感知</mark>，所谓的侧信道。</p>
<ul>
<li>功耗侧信道：不同功能单元执行</li>
<li>时间侧信道：恢复状态等需要时间</li>
<li>缓存侧信道：缓存内容的改变<ul>
<li>FLUSH + RELOAD</li>
<li>PRIME + PROBE</li>
<li>EVICT + TIME</li>
<li>EVICT + RELOAD</li>
<li>FLUSH + FLUSH</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>攻击种类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLUSH + RELOAD</td>
<td>1. Flush a cache line. <br> 2. Executing victim process.<br>3. Judge whether the cache line is reloaded back to cache by victim</td>
</tr>
<tr>
<td>Prime + Probe</td>
<td>1. Prime a cache line.<br>2. Executing victim process.<br>3.Probe the cache line to judge whether it is evicted out by victim.</td>
</tr>
<tr>
<td>Evict + Time</td>
<td>1. Measure the execution time of victim.<br>2. Evict a cache line out.<br>3. Re-execute victim process to justify whether it is affected by this cache line.</td>
</tr>
<tr>
<td>Evict + Reload</td>
<td>Alternative to Flush + Reload</td>
</tr>
<tr>
<td>Flush + Flush</td>
<td>1. Measure the time to flush a cache line.<br>2. Executing victim process.<br>3. Reflush the cache line to judge wheher victim touch the line.</td>
</tr>
</tbody>
</table>
</div>
<p>微体系结构状态的变化能被感知，因此，我们就可以观测瞬态指令引入所带来的变化。</p>
<h1 id="Spectre类"><a href="#Spectre类" class="headerlink" title="Spectre类"></a>Spectre类</h1><p>推测执行无处不在，现在的幽灵攻击主要是针对 cache 的侧信道攻击，但是还有类似寄存器、TLB等等所有共享的硬件资源都有可能存在侧信道信息泄露。</p>
<h2 id="分支预测错误-amp-FLUSH-RELOAD"><a href="#分支预测错误-amp-FLUSH-RELOAD" class="headerlink" title="分支预测错误 &amp; FLUSH+RELOAD"></a>分支预测错误 &amp; FLUSH+RELOAD</h2><p>受害者程序：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; array1_size)&#123;      <span class="comment">// 数组边界判断 -- 如果发生分支预测错误</span></span><br><span class="line">    a = array1[x];         <span class="comment">// 越界访问敏感数据   |</span></span><br><span class="line">    b = a * <span class="number">512</span>;           <span class="comment">//                   | -&gt; 推测窗口内</span></span><br><span class="line">    c = array2[b];         <span class="comment">// 与敏感数据相关区域 |</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>攻击过程：</p>
<ul>
<li>攻击者针对这段代码，可以先构造符合 <code>if</code> 的条件，让程序一直跳转执行。</li>
<li>然后，突然构造一个不合法的 x 值（x 就是攻击者要访问的敏感数据的地址，x 非常大，出现越界访问），按照之前的训练结果，程序会预测 <code>符合 if 条件</code> 跳转去执行。</li>
<li>这样，就导致越界访问 <code>array1</code> 拿到 a 值，然后，将 <code>b = a * 512</code> 作为 index 去访问 b。</li>
<li>之后，就能通过构造 <code>FLUSH + RELOAD</code> 攻击知道 <code>array2</code> 里面哪一个地址被访问到，进而知道 b 值，也就知道了 a 的值。这里的 a 就是敏感地址 x 所指向的数据。</li>
</ul>
<p>原理：</p>
<ul>
<li>上述过程，利用推测执行，使得非法的 x 访问了 <code>array1</code>。这种访问之后，指令并没有真正的提交，也就不会影响程序的语义。但是，我们在 recover 时，因为没有恢复 cache 微结构的状态，使得攻击者可以通过 <code>FLUSH + RELOAD</code> 来访问 <code>array2</code> 获取 b 的值，进而反推 a 的值。也就导致了侧信道的信息泄露。</li>
</ul>
<p>上述攻击过程，我们有三大前提条件：</p>
<ol>
<li>构造 <code>FLUSH + RELOAD</code> 条件：攻击者可以访问 <code>array2[b]</code> 区域，并将 <code>array2[b]</code> 移出缓存；</li>
<li>能否主动诱使错误推测地执行这段代码？<ul>
<li>分支预测器所有线程共享</li>
<li>部分信息导致不能精确预测</li>
<li>给攻击者一个机会</li>
</ul>
</li>
<li><code>x</code> 或者 <code>array1_size</code> 这两个变量，至少有一个要被构造成 cache miss 的状态，<code>array1[x]</code> 要 cache hit：来保证条件判断语句 <code>x &lt; array1_size</code> 需要较长的时间去执行，进而保证推测执行到足够的指令（上述程序的2，3，4条指令都被执行到）。</li>
</ol>
<p>攻击变种：</p>
<ul>
<li>Spectre V1 - Bounds Check Bypass， BCB</li>
<li>Spectre V2 - Branch Target Injection， BTI</li>
<li>Spectre V3 - Return Stack Buffer， RSB<ul>
<li>rsb数量有限（在RSB空时，用BTB预测结果）；</li>
<li>在上下文切换，会推测写返回地址，再跳转去执行；</li>
<li>这样，攻击者就能通过恶意训练，使程序跳转到任意的攻击者想去执行的代码区域去执行；</li>
</ul>
</li>
</ul>
<h2 id="SgxPectre"><a href="#SgxPectre" class="headerlink" title="SgxPectre"></a>SgxPectre</h2><p>Intel Software Guard Extentions；详细参考：SGX技术的分析和研究     </p>
<p>核心设计：为敏感程序创建 enclave，不能被外部访问，可以访问外部数据；</p>
<ul>
<li>但是与外部共享RSB与BTB</li>
</ul>
<p>攻击过程：<br><img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/SgxPectre.png" alt="SgxPectre"></p>
<h2 id="SpectrePrime"><a href="#SpectrePrime" class="headerlink" title="SpectrePrime"></a>SpectrePrime</h2><p>采用 <code>PRIME + PROBE</code> 缓存侧信道方法，利用<code>多核一致性协议（MetaData：MSI / MESI / MOESI）</code>，两个核共享数据（S状态），一个线程对其写（M状态），另外一个核转为（I状态）。这样，就能推测出来线程执行时，访问了哪些数据。    </p>
<p><img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/SpectrePrime.png" alt="SpectrePrime"></p>
<h2 id="Store-To-Load"><a href="#Store-To-Load" class="headerlink" title="Store To Load"></a>Store To Load</h2><p><code>load Speculation</code>：预测执行 load 指令，能将性能提高 10% 左右</p>
<ul>
<li>在先有一个 store 操作，后面一个 load 操作时，如果 store 操作的地址还不知道，怎么办？</li>
<li>通常，我认为在 store 一个值到某个地址时，程序是不会立马又去 load 这个地址的值，也即 store 后面跟 load 时，默认为这两个地址不同。</li>
<li>这样，就可以在即使前面 store 指令的地址没被解析的情况下，依然能预测先执行后面的 load 指令。</li>
</ul>
<p>内存消歧：对是否存在内存一致性（consistency）要求进行预测</p>
<ul>
<li>正确：提升吞吐率</li>
<li>错误：重新执行读取操作</li>
</ul>
<p><code>V4 Speculative Store Bypass，SSB</code>：    </p>
<ul>
<li>攻击者恶意训练内存消歧模块：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01: 88040F      mov [rdi+rcx],al         | rdi+rcx 与 rsi+rcx</span><br><span class="line">02: 4C0FB6040E  movzx r8,byte [rsi+rcx]  | 指向同一个位置</span><br><span class="line">03: 49C1E00C    shl r8,byte 0xc</span><br><span class="line">04: 428B0402    mov eax,[rdx+r8]</span><br></pre></td></tr></table></figure></li>
<li>处理器会预测 01 和 02 这两句代码的 rdi+rcx 指向不同的位置。</li>
</ul>
<h2 id="其他Spectre类变种"><a href="#其他Spectre类变种" class="headerlink" title="其他Spectre类变种"></a>其他Spectre类变种</h2><ol>
<li>V1.1 Bounds Check Bypass Store， BCBS<ul>
<li>推测的写操作可以前递给后续的读取操作</li>
<li>进而可以用来改变程序的控制流</li>
</ul>
</li>
<li>NetSpectre<ul>
<li>对远程处理器进行推测执行侧信道的攻击</li>
<li>可以利用特定执行单元的使用情况观测执行时间变化</li>
</ul>
</li>
<li>Spoiler<ul>
<li>利用STL预测错误会处理时间较长</li>
<li>在20位低地址相同时，便进行预测</li>
<li>推出8位虚拟地址与物理地址的映射关系</li>
</ul>
</li>
</ol>
<h1 id="Meltdown"><a href="#Meltdown" class="headerlink" title="Meltdown"></a>Meltdown</h1><p>基于的 Intel 处理器理论基础：</p>
<ul>
<li>内核空间都被映射到每个用户进程的虚拟地址空间</li>
<li>在页表项中标识位来区分访问权限</li>
<li>TLB 进行权限检查，若不满足页面访问权限，将产生例外</li>
<li>Intel 处理器为追求性能？它采取延后处理该例外（在 ROB 里重新提交指令时，才处理）</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/Entries-in-Page-Dictory-and-Page-Table.png" alt="Entries in Page Dictory and Page Table"></p>
<h2 id="L1TF"><a href="#L1TF" class="headerlink" title="L1TF"></a>L1TF</h2><p><code>Terminal Fault</code>：在发现访问地址的 PTE 中 Present 位（pte在不在缓存中）为0时，会导致运行程序的地址转换过程直接终止，地址转换不会完成。    </p>
<p>Intel认为大部分页的Present位都是有效的，延后Present位的判断：</p>
<ul>
<li>预测虚实地址转换PTW的结果</li>
<li>在Retire阶段判断Present位</li>
</ul>
<p>变版：</p>
<ul>
<li>L1TF-SGX</li>
<li>L1TF-OS/SGX</li>
<li>L1TF-VMM</li>
</ul>
<h2 id="其他Meltdown类变种"><a href="#其他Meltdown类变种" class="headerlink" title="其他Meltdown类变种"></a>其他Meltdown类变种</h2><ol>
<li>V3a Rogue System Register Read， RSRR:<ul>
<li>读取系统寄存器：拿系统寄存器的值（未知，这个值本身不能读，但是，由于延后处理，所以可以实现）作为 index 去访问一个在 cache 里全部 flush 了的 array，利用这种侧信道的方式，读取系统寄存器的值。</li>
</ul>
</li>
<li>LazyFP:<ul>
<li>上下文切换时，由于 FPU 及 SIMD 寄存器保存起来较为耗时</li>
<li>处理器将保存操作延后处理，在此之前会将 FPU 及 SIMD 单元设置为不可用</li>
<li>后续指令访问相关寄存器时将产生例外，这个例外被滞后处理</li>
</ul>
</li>
<li>MeltdownPrime:<ul>
<li>利用缓存一致性协议，在多核环境中触发信息泄露</li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div align="center"> <img src="http://img.thebetterkong.cn/blog/Overview_Spectre%26Meltdown/summary.png" width="100%" alt="summary.png" /> </div>        

<ul>
<li>红色部分为变种</li>
<li>蓝色部分为分类</li>
<li>浅黄色部分无法攻击</li>
</ul>
<p>Spectre:</p>
<ul>
<li>训练目标：PHT/BTB/RSB/STL</li>
<li>依据恶意训练方式不同再进行分类</li>
</ul>
<p>Meltdown:</p>
<ul>
<li>判断不同的例外处理是否被延后处理</li>
</ul>
]]></content>
      <categories>
        <category>计算机体系结构安全</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>Spectre</tag>
        <tag>Meltdown</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法（详解 + java 实现）</title>
    <url>/2020/06/15/DataStructure-Algorithm/SearchingAlgorithm/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>查找</strong>（Searching）是根据给定的某值，在查找表中确定一个其关键字等于给定值的数据或记录元素。若在表中存在这样的记录，则称查找成功，并返回整个记录的值，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找失败，这时候一般返回一个 “空” 记录或 “空” 指针。</p>
<a id="more"></a> 
<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p>查找表是由同一类型的数据元素（或记录）构成的集合。由于 “集合” 中的元素之间存在着完全松散的关系，因此它是一种非常灵便的数据结构。     </p>
<p>针对查找表，常涉及的操作如下：</p>
<ul>
<li>查询某个 “特点的” 数据元素是否在查找表中；</li>
<li>检索某个 “特定的” 数据源是的各种属性；</li>
<li>在查找表中插入或删除一个数据元素；</li>
</ul>
<h2 id="查找算法的分类"><a href="#查找算法的分类" class="headerlink" title="查找算法的分类"></a>查找算法的分类</h2><ul>
<li><strong>静态查找</strong>：对查找表的操作只涉及前两种 “查找” 操作；</li>
<li><strong>动态查找</strong>：在查找的过程中同时会涉及插入和删除操作；</li>
<li><strong>有序查找</strong>：被查找的数据元素必须有序；</li>
<li><strong>无序查找</strong>：被查找的数据元素有序无序均可；</li>
</ul>
<p>下面是常见查找算法的分类情况：</p>
<ol>
<li>静态查找：<ul>
<li>顺序表的查找：顺序查找、分块查找（索引顺序查找）</li>
<li>有序表的查找：折半查找（二分查找）、斐波那契查找、插值查找</li>
</ul>
</li>
<li>动态查找：<ul>
<li>二叉排序树和平衡二叉树查找</li>
<li>B- 树和 B+ 树查找</li>
<li>键树查找</li>
</ul>
</li>
<li>哈希查找：</li>
</ol>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>平均查找长度</strong>（Average Search Length）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度；    </p>
<p>对于含有 n 个记录的表，查找成功时的平均查找长度为：   </p>
<script type="math/tex; mode=display">ASL\ =\ \sum^n_{i=1}\ P_iC_i</script><p>其中：</p>
<ul>
<li>$P_i$ 为查找表中第 i 个记录的概率，且 $\sum^n_{i=1}\ P_i=1$；</li>
<li>$C_i$ 为找到表中期关键字与给定值相等的第 i 个记录时，和给定值已进行过比较的关键字个数。它随查找过程不同而不同；</li>
</ul>
<h1 id="静态线性表查找"><a href="#静态线性表查找" class="headerlink" title="静态线性表查找"></a>静态线性表查找</h1><p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DataStructure.png" alt="DataStructure"> </p>
<p>线性表中的元素一旦有序，就可以称为有序表；</p>
<h2 id="顺序查找（Sequential-Search）"><a href="#顺序查找（Sequential-Search）" class="headerlink" title="顺序查找（Sequential Search）"></a>顺序查找（Sequential Search）</h2><p>也称线形查找，属于无序查找算法；</p>
<p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；   </p>
<p><strong>基本思想</strong>：从表中开头或结尾元素开始，逐个进行记录的关键字和给定值比较，若某记录的关键字和给定值比较相等，则查找成功；反之，若直至线性表的另一端，都未发现某记录的关键字和给定值比较相等，则查找失败；   </p>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序查找（Sequential Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequentialSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：</p>
<ul>
<li>查找成功时的平均查找长度为：（假设每个数据元素的概率相等） $ASL = \frac{1}{n \times (1+2+3+…+n)} = \frac{n+1}{2}$;</li>
<li>查找不成功时，需要 $n+1$ 次比较;</li>
<li>时间复杂度为 $O(n)$</li>
</ul>
<h3 id="分块查找（Block-Search）"><a href="#分块查找（Block-Search）" class="headerlink" title="分块查找（Block Search）"></a>分块查找（Block Search）</h3><p>又称：索引顺序查找，是对顺序查找的改进；    </p>
<p><strong>适用场景</strong>：存储结构为 顺序存储 或 链接存储 的线性表；  </p>
<p><strong>基本思想</strong>：对需要查找的顺序表进行分块，保证 “分块有序”，然后在此基础上进行查找：</p>
<ul>
<li>除待查找表本身外，新建一个 “索引表”：<ul>
<li><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/IndexTable.png" alt="IndexTable"> </li>
<li>上图中，将 18 个记录分为了 3 个子表：$(R_1,R_2,…,R_6)$、$(R_7,R_8,…,R_{12})$、$(R_{13},R_{14},…,R_{18})$；</li>
<li>对每个子表（块）建立一个索引项，其包括两个内容：最大关键字（子表内的最大关键字）、指针项（指示该子表的第一个记录在表中的位置）；</li>
<li>索引表按关键字有序，则表要么有序要么分块有序（是指：第二个子表中所有记录的关键字均大于第一个子表中的关键字，依次类推…）</li>
</ul>
</li>
<li>接下来的查找过程分为两部分：<ul>
<li>先确定待查记录所在的块（子表），这里是有序的，可以采用顺序查找或者插入查找算法；</li>
<li>然后在块中顺序查找；</li>
</ul>
</li>
</ul>
<details>
  <summary><b>分块查找 java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分块查找算法</span></span><br><span class="line"><span class="comment">// 只是展示分块查找的思想，具体实现时，需要根据具体情况灵活运用此思想；</span></span><br><span class="line"><span class="comment">// 算法来源：参考 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引表类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexItem</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index; <span class="comment">//值比较的索引</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> start; <span class="comment">//开始位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;<span class="comment">//块元素长度(非空)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexItem</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... getter and setter</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引查找算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexSearch</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem indexItem = <span class="keyword">null</span>; <span class="comment">// 目标子表</span></span><br><span class="line">        <span class="comment">//建立索引规则：</span></span><br><span class="line">        <span class="comment">// 以 100 作为划分，每 100 项一组，子表存储范围分别为：</span></span><br><span class="line">        <span class="comment">//  indexItemList[0]：0-99</span></span><br><span class="line">        <span class="comment">//  indexItemList[1]：100-199</span></span><br><span class="line">        <span class="comment">//  ......</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//遍历索引表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="comment">//找到索引项</span></span><br><span class="line">            <span class="keyword">if</span>(indexItemList[i].index == index) &#123;</span><br><span class="line">                indexItem = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span>(indexItem == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//根据索引项，在主表中查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = indexItem.start; i &lt; indexItem.start + indexItem.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mainList[i] == key)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key,IndexItem[] indexItemList,<span class="keyword">int</span>[] mainList)</span> </span>&#123;</span><br><span class="line">        IndexItem item = <span class="keyword">null</span>; <span class="comment">// 用来保存查找的子表</span></span><br><span class="line">        <span class="comment">// 按索引规则，映射为索引</span></span><br><span class="line">        <span class="keyword">int</span> index = key / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历索引表，找到对应的索引项</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; indexItemList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexItemList[i].index == index) &#123;</span><br><span class="line">                item = indexItemList[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 索引表中不存在该索引项</span></span><br><span class="line">        <span class="keyword">if</span> (item == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据索引项将值插入到主表中</span></span><br><span class="line">        mainList[item.start + item.length] = key;</span><br><span class="line">        <span class="comment">// 更新索引表长度</span></span><br><span class="line">        indexItemList[i].length++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示开始 ********"</span>);</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 每10个数换行一次</span></span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"******** 展示结束 ********"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明一个主表，size=30</span></span><br><span class="line">        <span class="keyword">int</span>[] mainList = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">                <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">201</span>, <span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">301</span>, <span class="number">302</span>, <span class="number">303</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照前面所述的索引规则，声明一个索引表</span></span><br><span class="line">        IndexItem[] indexItemList = <span class="keyword">new</span> IndexItem[]&#123;</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>),</span><br><span class="line">                <span class="keyword">new</span> IndexItem(<span class="number">3</span>, <span class="number">20</span>, <span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"******** 索引查找 ********"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始数据："</span>);</span><br><span class="line">        display(mainList);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">203</span>;</span><br><span class="line">        System.out.println(<span class="string">"元素"</span> + key + <span class="string">"列表中的位置为："</span> + indexSearch(key,indexItemList,mainList) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按规则插入数据并查找</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">106</span>;</span><br><span class="line">        System.out.println(<span class="string">"插入数据："</span> + value);</span><br><span class="line">        <span class="comment">// 如果插入成功，则查找插入位置</span></span><br><span class="line">        <span class="keyword">if</span> (insert(value,indexItemList,mainList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"插入后的主表："</span>);</span><br><span class="line">            display(mainList);</span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"元素"</span> + value + <span class="string">"在列表中的位置为："</span> + indexSearch(value,indexItemList,mainList));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>       


<p><strong>性能分析</strong>：</p>
<ul>
<li>平均查找长度为：$ASL_{bs}=L_b+L_w$<ul>
<li>$L_b$：为查找索引表确定所在快的平均查找长度；</li>
<li>$L_w$：为在块中查找元素的平均查找长度；</li>
</ul>
</li>
<li>一般，可将长度为 n 的表均匀分为 b 块，每块含有 s 个记录（$b=\lceil n/s \rceil$）；再假定表中每个记录的查找概率相等，则每块查找的概率为 $1/b$，块中每个记录的查找概率为 $1/s$；<ul>
<li><mark>当 $s=\sqrt{n}$ 时，$ASL_{bs}$ 取最小值 $\sqrt{n}+1$；</mark></li>
</ul>
</li>
<li>若用顺序查找确定所在块，则分块查找的平均长度为：<ul>
<li>$ASL_{bs}=L_b+L_w=\frac{1}{b}\sum^b_{j=1}j+\frac{1}{s}\sum^s_{i=1}i=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}(\frac{n}{s}+s)+1$</li>
</ul>
</li>
<li>若用折半查找确定所在块，则分块查找的平均长度为：<ul>
<li>$ASL_{bs}\approx log_2(\frac{n}{s}+1)+\frac{s}{2}$</li>
</ul>
</li>
</ul>
<h2 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h2><p>也称二分查找，属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li>
</ul>
<p><strong>基本思想</strong>：先确定待查记录所在的范围（区间），然后逐渐缩小范围，直至找到或找不到该记录为止；   </p>
<ul>
<li>维护两个指针 <code>low</code> 和 <code>high</code>，他们指向线性表两端；然后再引入一个指针 <code>mid</code>，指示区间的中间位置；</li>
<li>将给定值 <code>key</code> 和 <code>mid</code> 所指示元素比较：<ul>
<li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li>
<li>若 <code>key &gt; mid</code>，把 <code>low</code> 指向 <code>mid+1</code> 位置，查找区间改为 <code>[ low(mid+1), high ]</code>；</li>
<li>若 <code>key &lt; mid</code>，把 <code>high</code> 指向 <code>mid-1</code> 位置，查找区间改为 <code>[ low, high(mid-1) ]</code>；</li>
</ul>
</li>
<li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 折半查找（Binary Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BinarySearchTreeEx.png" alt="BinarySearchTreeEx"><br>假设有如图所示的一棵深度为 h 的满二叉树，用来描述一个长度 $n=2^h-1$ 的有序表的二分查找过程。其中，层次为 h 的结点有 $2^{h-1}$ 个。 并且，假设各个节点的查找概率相等（$P_i=\frac{1}{n}$）。   </p>
<p>则，查找成功时折半查找的平均查找长度为：   </p>
<script type="math/tex; mode=display">
\begin{aligned}
ASL_{bs}&=\sum^n_{i=1}\ P_iC_i=\frac{1}{n}\ \sum^h_{j=1}\ j \cdot 2^{j-1}\\\\
&=\frac{1}{n}(\ \sum^{h-1}_{i=0}2^i+2\sum^{h-2}_{i=0}2^i+...+2^{h-1}\sum^{h-1}_{i=0}2^i\ )\\\\
&=\frac{1}{n}\ [h \cdot 2^h -(2^0+2^1+...+2^{h-1})]=\frac{1}{n}\ [(h-1)2^h+1]\\\\
&= \frac{1}{n}\ [\ (n+1)(log_2(n+1)-1)+1\ ]\\\\
&=\frac{n+1}{n}log_2(n+1)-1
\end{aligned}</script><p>当 n 较大时 (&gt;50)，可以近似为：$ASL_{bs}=log_2(n+1)-1$</p>
<h3 id="插值查找（Insertion-Search）"><a href="#插值查找（Insertion-Search）" class="headerlink" title="插值查找（Insertion Search）"></a>插值查找（Insertion Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）；   </li>
<li>需要关键字均匀分布的表；</li>
</ul>
<p><strong>基本思想</strong>：折半查找中，每次都是从中间位置开始，而插值查找就是为了避免这种 “傻瓜” 式的搜索，希望将比例因子改为自适应的，即：根据关键字在整个有序表中所处的位置，让 mid 值的变化更靠近关键字 key，进而间接地减少比较次数；</p>
<ul>
<li>新的 mid 求法：$mid=low+\frac{key-a[low]}{a[high]-a[low]}\ast(high-low)$</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertionSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; key)</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：   </p>
<ul>
<li>查找成功或者失败的时间复杂度均为 $O(log(logn))$；</li>
<li>分布均匀，且表长较大时，平均性能优于折半查找；</li>
</ul>
<h3 id="斐波拉契查找（Fibonacci-Search）"><a href="#斐波拉契查找（Fibonacci-Search）" class="headerlink" title="斐波拉契查找（Fibonacci Search）"></a>斐波拉契查找（Fibonacci Search）</h3><p>二分查找的改进，自然也属于有序查找算法；</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>元素有序的线性表（线性链表不适用）；</li>
<li>静态查找（动态查找时，要维护有序会带来很大的工作量）； </li>
</ul>
<p><strong>基本思想</strong>：类似二分查找，根据斐波那契序列的特点对有序表进行分割；它要求开始时，表中记录的个数为某个斐波那契数减 1，及 $n=F(k)-1$；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/FibonacciSegmentation.png" alt="FibonacciSegmentation"></p>
<ul>
<li>同样，维护三个指针，初始时，<code>low</code> 和 <code>high</code> 指向线性表两端，将 <code>key</code> 与第 <code>F(k-1)</code> 位置的记录进行比较（即：<code>mid=low+F(k-1)-1</code>）：<ul>
<li>若 <code>key == mid</code>，查找成功，返回 <code>mid</code>；</li>
<li>若 <code>key &gt; mid</code>，则更新：<code>low=mid+1,k-=2</code>；查找区间更新为 <code>[mid+1,high]</code>，<code>k-=2</code> 说明新的查找区间内元素个数为：$n-F(k-1)= F(k)-1-F(k-1)=F(k-2)-1$；</li>
<li>若 <code>key &lt; mid</code>，则更新：<code>high=mid-1,k-=1</code>；查找区间更新为 <code>[low,mid-1]</code>，<code>k-=1</code> 说明新的查找区间内元素个数为：$F(k-1)-1$；</li>
</ul>
</li>
<li>对刚才的过程迭代，直至找到关键字 <code>key</code>（查找成功）或 <code>low &gt; high</code>，查找失败，返回 <code>-1</code>；</li>
</ul>
<p><strong>java 实现源码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个斐波那契数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>; <span class="comment">//斐波那契数组的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波拉契查找（Fibonacci Search）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (high &lt; <span class="number">0</span> || key &lt; arr[<span class="number">0</span>] || key &gt; arr[arr.length - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 斐波那契分割数值的下标</span></span><br><span class="line">    <span class="keyword">int</span> f[] = fib(); <span class="comment">// 生成斐波那契数列</span></span><br><span class="line">    <span class="comment">// 计算获取，斐波那契分割数值的下标</span></span><br><span class="line">    <span class="comment">//  f(k) 是大于数组长度的最小值</span></span><br><span class="line">    <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f[k] 值可能大于 arr 的长度，则构造一个新的数组 temp[]，该方法不足的部分会使用 0 填充</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line">    <span class="comment">// 但是，实际上需求使用 arr 数组最后的数填充 temp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        temp[i] = arr[high];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环进行查找</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//值过小，从左半部分继续</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">//值过大，从右半部分继续</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">            k -= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//查找成功，但是因为前面扩充了数组，则需要确定，返回的是哪个下标</span></span><br><span class="line">            <span class="keyword">if</span>(mid &lt;= arr.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.length-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>性能分析</strong>：</p>
<ul>
<li>平均复杂度为：$O(longn)$，最坏情况下的时间复杂度也是 $O(longn)$；</li>
<li>平均性能优于折半查找，但最坏情况下的性能（虽然仍是 $O(longn)$）却比折半查找差；</li>
<li>另一个优势：分割时只需要进行加减运算；</li>
</ul>
<h1 id="动态树表查找"><a href="#动态树表查找" class="headerlink" title="动态树表查找"></a>动态树表查找</h1><h2 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h2><p><strong>“二叉排序树”</strong>（也称 “二叉查找树” 或者 “二叉搜索树”）：它或者是一棵空树，或者是具有下列性质的二叉树：（左小右大）</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ul>
<p>根据其定义，也就可以看出，二叉排序树具有如下<strong>性质</strong>：</p>
<ul>
<li>中序遍历的结果是一个有序序列；</li>
</ul>
<p><strong>二叉排序树查找算法基本思想</strong>：</p>
<ul>
<li><p><strong>建树</strong>：从一棵空树开始，将被查找序列的数据不断插入树中，生成一棵二叉排序树<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTBuild.png" alt="BSTBuild"></p>
<ul>
<li><strong>插入</strong>：新插入的节点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点；<ul>
<li>若当前的二叉查找树为空，则插入的元素为根节点；</li>
<li>若插入的元素值小于根节点值，则将元素插入到左子树中；</li>
<li>若插入的元素值不小于根节点值，则将元素插入到右子树中；</li>
<li>总结来说就是：首先找到插入的位置，要么向左，要么向右，直到找到空结点，即为插入位置，如果找到了相同值的结点，插入失败；</li>
</ul>
</li>
<li><strong>删除</strong>：分三种情况进行处理：<ol>
<li>p 为叶子节点：直接删除该节点（不会破坏树的整体结构），再修改其父节点的指针（注意分是根节点和不是根节点），如图 a；</li>
<li>p 为单支节点（即只有左子树或右子树）：让 p 的子树与 p 的父亲节点相连，删除 p 即可（也不会破坏树的整体结构）（注意分是根节点和不是根节点），如图 b；</li>
<li>有两个孩子的情况：当前结点与左子树中最大的元素交换，然后删除当前结点。左子树最大的元素至多只有一个左子节点，交换后，删除就可以参考上面两种的情况。另一种方法是，当前结点与右子树中最小的元素交换，然后删除当前结点。如图 c（删除 z 结点）；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BSTDelete.png" alt="BSTDelete"></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>查找</strong>：树非空时，将给定值与根节点比较，若相等则查找成功；否则，根据给定值与根节点的大小关系，分别在左子树或右子树上继续查找；迭代进行，直至查找成功，或者不再存在左右子树时查找失败；</p>
</li>
</ul>
<details>
  <summary><b>java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> testsearch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树数据结构*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        TreeNode parent;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value, TreeNode parent, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**这部分是树里面的一些操作，详细可见二叉树的操作*/</span></span><br><span class="line">    <span class="comment">// 求 BST 的最小值，即最左边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMin</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求 BST 的最大值，即最右边的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode  <span class="title">getMax</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中中序遍历的某节点的前驱节点，即查找数据值小于该结点的最大结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">preNode</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMax(x.left);</span><br><span class="line">        <span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则"x的前驱结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的右儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.left == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找 BST 中某节点的后继节点.即查找数据值大于该结点的最小结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">postNode</span><span class="params">(TreeNode x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 x 存在右孩子，则"x的后继结点"为"以其右孩子为根的子树的最小结点"。</span></span><br><span class="line">        <span class="keyword">if</span>(x.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getMin(x.right);</span><br><span class="line">        <span class="comment">// 如果x没有右孩子。则x有以下两种可能：</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个左孩子"，则"x的后继结点"为"它的父结点"。</span></span><br><span class="line">        <span class="comment">//    若 x 是"一个右孩子"，则前驱节点为x的某一个祖先节点的父节点，而且该祖先节点是作为其父节点的左儿子</span></span><br><span class="line">        TreeNode p = x.parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right == x)</span><br><span class="line">        &#123;</span><br><span class="line">            x = p;<span class="comment">//父节点置为新的x</span></span><br><span class="line">            p = p.parent;  <span class="comment">//父节点的父节点置为新的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的查找算法*/</span></span><br><span class="line">    <span class="comment">// 查找值为val的节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">searchRec</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">            <span class="keyword">return</span> searchRec(root.right,val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找值为 val 的节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">search</span><span class="params">(TreeNode root ,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.value)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点插入算法*/</span></span><br><span class="line">    <span class="comment">//BST 插入节点  --递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insertRec</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root=x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">            root.left = insertRec(root.left,  x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value)</span><br><span class="line">            root.right = insertRec(root.right,  x);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//BST 插入节点  --非递归版--</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            root = x;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>; <span class="comment">//需要记录父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位插入的位置</span></span><br><span class="line">            p = root; <span class="comment">//记录父节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value)</span><br><span class="line">                root = root.left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        x.parent = p;<span class="comment">//定位到合适的叶节点的空白处后，根据和父节点的大小比较插入合适的位置</span></span><br><span class="line">        <span class="keyword">if</span>(x.value &lt; p.value)</span><br><span class="line">            p.left = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; p.value)</span><br><span class="line">            p.right = x;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**二叉查找树的结点删除算法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(TreeNode root,TreeNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123; <span class="comment">//定位到需要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span>(x.value &lt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x.value &gt; root.value) &#123;</span><br><span class="line">                p = root; <span class="comment">//记录父节点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//找到了，root指向待删结点，p指向root的父结点</span></span><br><span class="line">                <span class="comment">// 情景一：待删除的是 叶子节点</span></span><br><span class="line">                <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)</span><br><span class="line">                            p.left = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有左孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>)<span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.left;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.left;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景二：待删除的节点只有右孩子</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="comment">//待删除的是根节点</span></span><br><span class="line">                        root = root.right;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(p.left == root)<span class="comment">//待删除的本身是一个左孩子</span></span><br><span class="line">                            p.left = root.right;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(p.right == root)</span><br><span class="line">                            p.right = root.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情景三：待删除节点同时拥有左右孩子</span></span><br><span class="line">                <span class="comment">//  方法：得到待删除节点右子树的最小值，该最小值与待删除节点进行“ 值 ”交换，删除该最小值位置处的节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此情况就不需要考虑被删结点是不是根节点了，操作都相同</span></span><br><span class="line">                    TreeNode rMin = root.right; <span class="comment">// 待删除节点的右孩子的最小值(找到的后继节点肯定没有左孩子！！！)</span></span><br><span class="line">                    TreeNode rMinP = root;<span class="comment">// 因为需要删除后继节点位置，所以需要记录父节点</span></span><br><span class="line">                    <span class="keyword">while</span>(rMin.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        rMinP=rMin;</span><br><span class="line">                        rMin = rMin.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> rootVtemp = root.value;<span class="comment">//值交换</span></span><br><span class="line">                    root.value = rMin.value;</span><br><span class="line">                    rMin.value = rootVtemp;</span><br><span class="line">                    <span class="comment">//删除rMin位置的节点，此时此位置的值已是待删节点的值</span></span><br><span class="line">                    <span class="keyword">if</span>(rMinP.left == rMin)</span><br><span class="line">                        rMinP.left = rMin.right;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(rMinP.right == rMin) <span class="comment">// 待删结点root的右孩子结点就是其右子树的最小值</span></span><br><span class="line">                        rMinP.right = rMin.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到后删了后就跳出while循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的不完全测试模块：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode node45 = <span class="keyword">new</span> TreeNode(<span class="number">45</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node24 = <span class="keyword">new</span> TreeNode(<span class="number">24</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node53 = <span class="keyword">new</span> TreeNode(<span class="number">53</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node12 = <span class="keyword">new</span> TreeNode(<span class="number">12</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node37 = <span class="keyword">new</span> TreeNode(<span class="number">37</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        TreeNode node93 = <span class="keyword">new</span> TreeNode(<span class="number">93</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        insert(node45,node24);</span><br><span class="line">        insert(node45,node53);</span><br><span class="line">        insert(node45,node12);</span><br><span class="line">        insert(node45,node37);</span><br><span class="line">        insert(node45,node93);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以写个中序遍历的函数，遍历一遍</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"查找45结果："</span>);</span><br><span class="line">        TreeNode out1 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out1 +<span class="string">":"</span>+ out1.value);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"删除45后，再次查询结果："</span>);</span><br><span class="line">        delete(node45,node45);</span><br><span class="line">        TreeNode out2 = search(node45,<span class="number">45</span>);</span><br><span class="line">        System.out.println(out2);</span><br><span class="line"></span><br><span class="line">        System.out.println(node45.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>性能分析</strong>：</p>
<ul>
<li>含有 n 个节点的二叉排序树的平均查找长度和树的形态有关；</li>
<li>和二分查找一样，插入和查找的时间复杂度均为 $O(logn)$，但是在最坏的情况下仍然会有 $O(n)$ 的时间复杂度；</li>
<li>最坏情况时，树形结构为每层一个结点，这样算法会退化为顺序查找，于是，平衡二叉查找树应运而生；</li>
</ul>
<h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p><strong>来历</strong>：前面介绍，最坏情况下，如果连续插入已经排好序的键到二叉查找树，二叉查找树会变成了一个链表，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/BadBST.png" alt="BadBST"><br>这样，相应的查找算法也就退化为了顺序查找，时间复杂度变为了 $O(n)$。而平衡二叉树就是为了避免这种情况。    </p>
<p><strong>平衡二叉树</strong>（Balance Binary Tree，Height-Balance Tree，AVL 树）：它或者是一棵空树，或者具有以下性质：</p>
<ul>
<li>首先，它是一棵二叉查找树；</li>
<li>它的左右子树也构成一棵平衡二叉树；</li>
<li>并且，左右子树的深度之差的绝对值不超过 1；</li>
</ul>
<p>若将二叉树上结点的<strong>平衡因子 BF</strong>（Balance Factor）定义为：该结点的左子树深度减去它的右子树深度，则平衡二叉树上所有结点的 BF 只可能取值为：-1、0、1，如图：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/AVLExample.png" alt="AVLExample">   </p>
<p>在一个平衡二叉树上插入结点，就可能导致失去平衡，此时仅需对最小不平衡子树进行平衡旋转处理即可。现假设由于二叉排序树上插入结点而失去平衡的最小子树根节点指针为 a（即：a 是离插入结点最近，且平衡因子绝对值超过 1 的祖先结点），则<strong>失去平衡后进行调整（旋转） 的规律</strong>可归结为以下四种情况：   </p>
<ul>
<li><strong>LL 型：单向右旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LLRotate.png" alt="LLRotate"><ul>
<li>由于在 A 结点的左子树根节点的左子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需进行一次向右的顺时针旋转操作，如上图；</li>
</ul>
</li>
<li><strong>RR 型：单向左旋平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RRRotate.png" alt="RRRotate"><ul>
<li>由于在 A 结点的右子树根节点的右子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需进行一次向左的逆时针旋转操作，如上图；</li>
</ul>
</li>
<li><strong>LR 型：双向旋转（先左后右）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/LRRotate.png" alt="LRRotate"><ul>
<li>由于在 A 结点的左子树根节点的右子树上插入结点，导致 A 的平衡因子由 1 变为 2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先左旋转再右旋转），如上图；</li>
</ul>
</li>
<li><strong>RL 型：双向旋转（先右后左）平衡处理</strong><br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RLRotate.png" alt="RLRotate"><ul>
<li>由于在 A 结点的右子树根节点的左子树上插入结点，导致 A 的平衡因子由 -1 变为 -2，以 A 为根的子树失去平衡，则需要进行两次旋转操作（先右旋转再左旋转），如上图；</li>
</ul>
</li>
</ul>
<p>以上旋转操作的正确性容易由 “保持二叉排序树的特性：中序遍历所得关键字序列自小而大有序” 证明。    </p>
<p><strong>插入和删除</strong>：与二叉查找树类似，只是额外加入了平衡操作。下面以插入算法思想来进行分类讨论：</p>
<ul>
<li>若 BBST 为空树，则插入一个数据元素为 e 的新结点作为 BBST 的根节点，树的深度增 1；</li>
<li>若 e == BBST 的根节点，则不进行插入；</li>
<li>若 e &lt; BBST 的根结点，并且 BBST 的左子树中不存和 e 相等的结点，则将 e 插入至 BBST 的左子树上，并且在插入之后的左子树深度增加（+1）时，分别就以下情况进行处理：<ul>
<li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li>
<li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 1，BBST 深度增 1；</li>
<li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：<ul>
<li>若 BBST 的左子树根结点的平衡因子为 1：则需要进行 LL 型（单向右旋）平衡处理，并且在右旋处理之后，将根节点和其右子树根结点的平衡因子改为 0，树的深度不变；</li>
<li>若 BBST 的左子树根结点的平衡因子为 -1：则需进行 LR 型（先左后右）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li>
</ul>
</li>
</ul>
</li>
<li>若 e &gt; BBST 的根结点，并且 BBST 的右子树中不存和 e 相等的结点，则将 e 插入至 BBST 的右子树上，并且在插入之后的右子树深度增加（+1）时，分别就以下情况进行处理：<ul>
<li>BBST 的根结点的平衡因子为 1（左子树的深度大于右子树的深度）：则将根节点的平衡因子更改为 0，BBST 深度不变；</li>
<li>BBST 的根结点的平衡因子为 0（左右子树的深度相等）：则将根结点的平衡因子更改为 -1，BBST 深度增 1；</li>
<li>BBST 的根结点的平衡因子为 -1（右子树的深度大于左子树的深度）：<ul>
<li>若 BBST 的右子树根结点的平衡因子为 -1：则需要进行 RR 型（单向左旋）平衡处理，并且在左旋处理之后，将根节点和其左子树根结点的平衡因子改为 0，树的深度不变；</li>
<li>若 BBST 的右子树根结点的平衡因子为 1：则需进行 RL 型（先右后左）平衡处理，并且在旋转处理之后，修改根结点和其左右子树根节点的平衡因子，树的深度不变；</li>
</ul>
</li>
</ul>
</li>
</ul>
<details>
  <summary><b>java 实现示例</b></summary> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 具体的实现依赖于前面的 二叉排序树 */</span></span><br><span class="line"><span class="comment">/** 下面给出里面的几个核心函数：BBST 的辅助旋转算法 */</span></span><br><span class="line"><span class="comment">// 其中，bf 是添加在树节点里的成员变量，代表节点的平衡因子（左子树高度-右子树高度）；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的左子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.left; <span class="comment">// p 指向 root 的左子树的根结点</span></span><br><span class="line">    root.left = p.right; <span class="comment">// p 的右子树挂载至 root 的左子树</span></span><br><span class="line">    p.right = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左旋：以 root 为根的二叉排序树进行处理；</span></span><br><span class="line"><span class="comment">//    处理完成之后，返回新的树根结点，即旋转之前的右子树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lRotate</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    p = root.right; <span class="comment">// p 指向 root 的右子树的根结点</span></span><br><span class="line">    root.right = p.left; <span class="comment">// p 的左子树挂载至 root 的右子树</span></span><br><span class="line">    p.left = root;</span><br><span class="line">    root = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在上述两种基础上，完成平衡二叉树的左右平衡处理</span></span><br><span class="line"><span class="comment">// 左平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LeftBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode rl = root.left;</span><br><span class="line">    <span class="keyword">switch</span> (rl.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的左孩子的左子树上，做单向右旋处理</span></span><br><span class="line">            root.bf = rl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的左孩子的右子树上，做双旋（先左后右）处理</span></span><br><span class="line">            TreeNode rlr = rl.right;</span><br><span class="line">            <span class="keyword">switch</span> (rlr.bf)&#123; <span class="comment">// 修改 root 及其左孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = -<span class="number">1</span>; rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rl.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">0</span>; rl.bf = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rlr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root.left); <span class="comment">// 对 root 的左子树作左旋处理</span></span><br><span class="line">            rRotate(root); <span class="comment">// 对 root 做右旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected value: "</span> + rl.bf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右平衡处理：</span></span><br><span class="line"><span class="comment">//    对 root 为根的二叉树进行平衡处理，算法结束时，root 指向新的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RightBalance</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    TreeNode rr = root.right;</span><br><span class="line">    <span class="keyword">switch</span> (rr.bf)&#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:&#123;  <span class="comment">// 新插入的节点在 root 的右孩子的右子树上，做单向左旋处理</span></span><br><span class="line">            root.bf = rr.bf = <span class="number">0</span>;</span><br><span class="line">            lRotate(root); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123; <span class="comment">// 新插入的节点在 root 的右孩子的左子树上，做双旋（先右后左）处理</span></span><br><span class="line">            TreeNode rrl = rr.left;</span><br><span class="line">            <span class="keyword">switch</span> (rrl.bf)&#123; <span class="comment">// 修改 root 及其右孩子平衡因子</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: root.bf = <span class="number">0</span>; rr.bf = -<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: root.bf = rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> -<span class="number">1</span>: root.bf = <span class="number">1</span>; rr.bf = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rrl.bf = <span class="number">0</span>;</span><br><span class="line">            rRotate(root.right); <span class="comment">// 对 root 的左子树作右旋处理</span></span><br><span class="line">            lRotate(root); <span class="comment">// 对 root 做左旋处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>


<p><strong>性能分析</strong>：</p>
<ul>
<li>在平衡二叉树上进行查找的时间复杂度为：$O(logn)$，注意，它一种动态查找算法，在树形维护上的时间复杂度还是相对较高的；</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>对比说明</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
<th>局限性</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVL 树</td>
<td>严格的平衡二叉树，平衡条件必须满足：所有节点的左右子树高度差不超过 1；</td>
<td>① 平衡调整时的旋转操作十分耗时，因此，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多；更多的地方是用追求局部而不是非常严格整体平衡的红黑树;<br>② 也就更适合用于插入与删除次数比较少，但查找多的情况；</td>
<td>windows 对进程地址空间的管理；</td>
</tr>
<tr>
<td>红黑树</td>
<td>弱平衡二叉树，相同的节点情况下，AVL 树的高度低于红黑树；</td>
<td>旋转操作更少，更适用于搜索、插入、删除等操作较多的情况；<br>但相应的，相同情况下其查找次数会略高于 AVL 树；</td>
<td>① 著名的 linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块；<br>② epoll 在内核中的实现，用红黑树管理事件块；<br>③ nginx 中，用红黑树管理 timer 等；<br>④ Java 的 TreeMap 实现；</td>
</tr>
</tbody>
</table>
</div>
<p><strong>红黑树的定义</strong>：</p>
<ul>
<li>每个结点非黑即红；</li>
<li>根结点是黑色；</li>
<li>每个叶子结点都是黑色的空结点（NIL 结点）；</li>
<li>每个红色结点的两个子结点都是黑色;<ul>
<li>可推出：从每个叶子到根的所有路径上不能有两个连续的红色结点；</li>
</ul>
</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；<ul>
<li>可推出：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li>
</ul>
</li>
</ul>
<p>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTree.png" alt="RedBlackTree">     </p>
<p><strong>红黑树总是通过 “旋转” 和 “变色” 达到自平衡</strong>：</p>
<p><strong>红黑树插入</strong>：同样与二叉树类似，也分为两部分：1.查找插入的位置；2.插入后自平衡</p>
<p>查找流程：注意，插入的位置一定是叶子结点<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackSearch.png" alt="RedBlackSearch">      </p>
<p>接下来，就是将待插结点以 “红色” 插入，此时一共有 8 中情景，如下：</p>
<ul>
<li>“红色” 原因：如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多 1，必须做自平衡；并且，如果选择红色，在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作，也可以进一步减少平衡操作；   </li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeInsertSituation.png" alt="RedBlackTreeInsertSituation">   </p>
<p><strong>红黑树删除</strong>：同样也分为两部分：1.查找删除的位置；2.删除后自平衡    </p>
<p>查找流程：直接用前述的过程替代，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除目标结点，若目标结点存在子结点，还需找到结点进行替代，之后还得进行自平衡处理；     </p>
<p>结点删除的第一步，找替代结点分为以下 3 种情景：</p>
<ul>
<li>情景 1：若删除结点无子结点，直接删除</li>
<li>情景 2：若删除结点只有一个子结点，用子结点替换删除结点</li>
<li>情景 3：若删除结点有两个子结点，用中序遍历的后继结点（大于删除结点的最小结点，也即：删除结点右子树的最左边的结点）替换删除结点；</li>
</ul>
<p>经过上述替换之后，也就是删除替换结点。这个时候删除替换结点的情景如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/RedBlackTreeDeleteSituation.png" alt="RedBlackTreeDeleteSituation"></p>
<h2 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B- 树和 B+ 树"></a>B- 树和 B+ 树</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B- 树"></a>B- 树</h3><p>B- 树是一种<strong>平衡的多路查找树</strong>，它<strong>广泛的运用于文件系统（索引）中</strong>；    </p>
<p><strong>定义</strong>：一棵 m 阶的 B- 树，要么为空树，要么为满足下列条件的 m 叉树：</p>
<ul>
<li>树中每个结点至多有 m 棵子树；</li>
<li>若根节点不是叶子结点，则至少有两棵子树；</li>
<li>除根节点之外的所有非终端结点至少有 $\lceil m/2 \rceil$ 棵子树；</li>
<li>所有的非终端节点包含以下信息数据：$(n,A_0,K_1,A_1,K_2,A_2,…,K_n,A_n)$<ul>
<li>$K_i\ (i=1,…,n)$ 为关键字，且 $K_i&lt;K_{i+1}\ (i=1,…,n-1)$；</li>
<li>$A_i\ (i=1,…,n)$ 为指向子树根节点的指针，且指针 $A_{i-1}$ 所指子树中所有结点的关键字均小于 $K_i(i=1,…,n)$，$A_n$ 所指子树中所有结点的关键字均大于 $K_n$；</li>
<li>$n\ (\lceil m/2 \rceil-1 \leq n \leq m-1)$  </li>
</ul>
</li>
<li>所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的节点，实际上这些结点不存在，指向这些结点的指针为空）；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-Tree.png" alt="B-Tree"></p>
<p><strong>查找</strong>：B- 树的查找过程是一个顺指针查找结点和在结点的关键字中进行查找交叉进行的过程；</p>
<ul>
<li><strong>查找性能分析</strong>：B- 树通常存在磁盘上，因此查找操作的主要两步：（1）在 B- 树中找结点（磁盘）；（2）在结点中找关键字（内存）；详细来说，即：在磁盘上找到指针 p 所指结点后，先将结点中的信息读入内存，然后再利用顺序查找或折半查找等于 K 的关键字。而磁盘上的查找更耗时，因此，在磁盘上进行查找的次数（即待查找关键字所在结点在 B- 树上的层次树）是觉得 B- 树查找效率的首要因素。<ul>
<li>讨论深度为 l+1 的 m 阶 B- 树所具有的最少结点数：<ul>
<li>B- 数第一层至少 1 个节点；第二次至少 2 个节点；由于除根节点外每个非终端节点至少有 $\lceil m/2 \rceil$ 棵子树，则第三层至少有 $2\lceil m/2 \rceil$ 个节点；……以此类推；第 l+1 层至少有 $2(\lceil m/2 \rceil)^{l-1}$ 个结点；并且，第 l+1 层的结点为叶子结点 ；</li>
</ul>
</li>
<li>若 m 阶 B- 树中具有 N 个关键字，则叶子结点（即查找失败）的结点为 N+1，则有：$N+1 \geq 2 \ast (\lceil m/2 \rceil)^{l-1}$，也即：<script type="math/tex">l \leq log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1</script></li>
<li>也即：在含有 N 个关键字的 B- 树上进行查找时，从根节点到关键字所在结点的路径上设计的结点数不超过：$log_{\lceil m/2 \rceil}(\frac{N+1}{2})+1$</li>
</ul>
</li>
</ul>
<p><strong>插入</strong>：规则：查找，向最底层的结点插入关键字，然后判断当前结点 key 的个数是否小于等于 m-1，如果满足，直接插入即可；如果不满足，“分裂”：按节点的中间的 key 将这个节点分为左右两部分，中间的 key 放到父节点中即可；</p>
<ul>
<li>往一个 4 阶 B- 树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4 的动图示例：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeInsert.gif" alt="B-TreeInsert"></li>
</ul>
<p><strong>删除</strong>：首先找到该关键字所在的结点，并从中删除之，然后，对需要进行 “合并” 结点的情况进行合并。这时考虑如下几种情况（$m=5，2 \leq n \leq 4$）：</p>
<ul>
<li>删除的是叶子节点的元素，并且如果删除之后，元素数还是大于等于 $\lceil m/2 \rceil -1$，这种情况只要直接删除即可:<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete1.png" alt="B-TreeDelete1"></li>
<li>删除的是叶子节点的元素，并且如果删除之后，元素数不足 $\lceil m/2 \rceil -1$：<ul>
<li>如果，它的兄弟节点的元素大于等于 $\lceil m/2 \rceil$（即：兄弟节点的元素删掉一个后仍符合要求）：将其兄弟结点中的最小（最大）的元素上移至双亲结点中，而将双亲结点中小于（或大于）且紧靠该上移元素的元素下移至双亲结点中；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete2.png" alt="B-TreeDelete2"></li>
<li>如果与被删元素所在的结点相邻的兄弟结点中元素个数均等于 $\lceil m/2 \rceil - 1$：假设该结点有兄弟结点，且其右兄弟结点地址由双亲结点中的指针 $A_i$ 所指，则在删去元素之后，它所在结点中剩余的元素和指针，加上双亲结点中的关键字 $K_i$ 一起合并到 $A_i$ 所指兄弟结点中去（若没有右兄弟结点，则合并至左兄弟结点）。之后，如果因此使双亲结点中的元素个数不足 $\lceil m/2 \rceil-1$，则依次类推左相应处理。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete3.png" alt="B-TreeDelete3"></li>
</ul>
</li>
<li>对于非叶子节点的删除，则需要用后继 key 覆盖要删除的 key，然后在后继 key 所在的位置中删除该后继 key：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B-TreeDelete4.png" alt="B-TreeDelete4"><ul>
<li>此时，26 所在的结点不符合要求，需要进行前面说过的向兄弟结点 “借” 的操作；</li>
</ul>
</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>B+ 树是应文件系统所需而出的一种 B- 树的变种；也是 MySQL 的底层数据结构；    </p>
<p><strong>定义</strong>：一棵 m 阶的 B+ 树和 m 阶的 B- 树的差异在于：</p>
<ul>
<li>有 n 棵子树的节点中含有 n 个关键字；</li>
<li>所有的叶子结点包含了全部的关键字信息（及指向这些关键字记录的指针），且叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（的根节点）中的最大（或最小）关键字；</li>
<li>补充：有关结点的元素范围<ul>
<li>非根节点元素范围：$n\ (\lceil m/2 \rceil \leq n \leq m)$</li>
</ul>
</li>
</ul>
<p>好好与 B- 树对比体会，一棵 3 阶的 B+ 树如下所示：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/B+Tree.png" alt="B+Tree">  </p>
<ul>
<li>通常，在 B+ 树上有两个头指针，一个指向根节点，另一个指向关键字最小的节点；   </li>
</ul>
<p><strong>查找</strong>：根据前面所述的两个指针，查找也就可以分为两种方式：</p>
<ol>
<li>从最小关键字起顺序查找；</li>
<li>从根节点开始进行随机查找；<ul>
<li>在 B+ 树上进行这种随机查找，不管查找成功与否，每次查找都是走了一条从根到叶子结点的完整路径；</li>
</ul>
</li>
</ol>
<p><strong>插入</strong>：仅在叶子结点上进行，当结点中的关键字个数大于 m 时，要从中间分裂为两个结点（它们所含关键字个数为：$\lceil \frac{m+1}{2} \rceil$ 和 $\lfloor \frac{m+1}{2} \rfloor$），并且，它们的双亲结点中应同时含有这两个结点的最大关键字。   </p>
<p><strong>删除</strong>：也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端节点中的值可以作为一个 “分界关键字” 继续存在。若因删除而使结点中关键字的个数少于 $\lceil m/2 \rceil$ 时，其和兄弟结点的合并过程和 B- 树类似。</p>
<h2 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h2><p><strong>定义</strong>：又称数字查找树（Digital Search Tree）。它是一棵高度 $\geq 2$ 的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。    </p>
<p>例如：如下 16 个关键字的集合。{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。逐层划分，组成一棵键树如下：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/KeyTree.png" alt="KeyTree"></p>
<ul>
<li>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字，叶子结点中的特殊符号 $ 表示字符的结束；</li>
<li>为了插入和查找的方便，会约定键树是一棵有序树，即：同一层中兄弟结点之间依所含符号自左至右有序，并约定结束符 $ 小于任何字符；</li>
</ul>
<p><strong>两种存储结构</strong>：</p>
<ol>
<li>双链树：<ul>
<li>以树的孩子兄弟链表来表示键树，则每个分支结点包括 3 个域：symbol 域（存储关键字的一个字符）、first 域（存储指向第一棵子树根的指针）、next 域（存储指向右兄弟的指针），同时，叶节点的 infoptr 域（存储指向该关键字记录的指针）。<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/DoubleLinkTree.png" alt="DoubleLinkTree"></li>
</ul>
</li>
<li>Trie 树：<ul>
<li>以树的多重链表表示键树，则树的每个结点中应含有 d 个指针域；</li>
<li>若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个 “叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息；</li>
<li>Trie 树有两种结点：<ul>
<li>分支结点：含有 d 个指针域和一个指示该结点中非空指针域的个数的整数域；<ul>
<li>分支结点中不设数据域，每个分支结点所表示的字符均有其双亲结点中（指向该结点）的指针所在位置决定；</li>
</ul>
</li>
<li>叶子结点：含有关键字域和指向记录的指针域；<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/TrieTree.png" alt="TrieTree"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="哈希查找（Hash-Search）"><a href="#哈希查找（Hash-Search）" class="headerlink" title="哈希查找（Hash Search）"></a>哈希查找（Hash Search）</h1><p>前面介绍的各种结构（线性表、树）中，记录在结构中的相对位置时随机的，和记录的关键字之间不存在确定的关系，因此，在结构中查找记录就需要一系列和关键字的比较，也就是常说的基于 “比较” 的查找算法。这样往往比较耗时。    </p>
<h2 id="哈希表和哈希函数"><a href="#哈希表和哈希函数" class="headerlink" title="哈希表和哈希函数"></a>哈希表和哈希函数</h2><p>就是为了解决上述问题而引入的一种 <strong>“以空间换时间”</strong> 的数据结构：</p>
<ul>
<li>它利用哈希函数 $f$ 在记录的存储位置和它的关键字之间建立了一个确定的对应关系 $f$，这样就使得每个关键字和结构中一个唯一的存储位置相对应。按照这种关系记录关键字的表就是哈希表；</li>
<li>在查找时，只要根据这个对应关系 $f$ 找到给定值 $K$ 的像 $f(K)$。若结构中存在关键字和 $K$ 相等的记录，则必定在 $f(K)$ 的存储位置上，由此，不需要进行比较就可以直接取得所查记录。</li>
</ul>
<p><strong>定义</strong>：综上如下描述哈希表：根据给定的哈希函数 $H(key)$ 和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的 “像” 作为记录在表中的存储位置，这种表即为<strong>哈希表</strong>，这一映像过程称为<strong>哈希造表或散列</strong>，所得的存储位置称为<strong>哈希地址或散列地址</strong>。其两大特点就是：</p>
<ul>
<li>映像：哈希函数</li>
<li>冲突：不同的关键字映射到同一地址</li>
</ul>
<h2 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h2><p>首先，“好” 的哈希函数应该具有特点：对于关键字集合中的任一关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称为均匀的哈希函数。     </p>
<p><strong>方法一：直接定址法</strong></p>
<ul>
<li>取关键字或关键字的某个线性函数值为哈希地址，即：$H(key)=key$ 或 $H(key)=a \cdot key + b$</li>
</ul>
<p><strong>方法二：数字分析法</strong></p>
<ul>
<li>假设关键字是以 r 为基的数（如：以 10 为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可 “取关键字的若干位” 组成哈希地址；</li>
<li>如：{313、323、333、343、353、363、373、383、393}，可取其第 2 位组成哈希地址；</li>
</ul>
<p><strong>方法三：平方取中法</strong></p>
<ul>
<li>取关键平方后的中间几位为哈希地址。这种方式比较常用；</li>
<li>通常在选哈希函数的时候是不一定知道所有的关键字的，因此取其中那几位也不一定合适，而一个树平方后的中间几位数和数的每一位都相关，由此可使随机分布的关键字得到的哈希地址也是随机的；</li>
</ul>
<p><strong>方法四：折叠法</strong></p>
<ul>
<li>将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后截取这几部分的叠加和（舍去进位）作为哈希地址；</li>
<li>适用于：关键字位数很多，而且关键字中每一位上数字分布大致均匀时；</li>
</ul>
<p><strong>方法五：除留余数法</strong></p>
<ul>
<li>取关键字被某个不大于哈希表表长 m 的数 p 除后所得余数作为哈希地址，即：$H(key)=key\ MOD\ p,\ p \leq m$</li>
<li>这是最简单、也最常用的方法，不仅可以直接对关键字使用 MOD，也可以在折叠、平方取中等运算之后取模；</li>
<li>但是需要注意 p 的选取，否则可能产生较高的冲突；而根据经验，一般选 p 为质数或不包含小于 20 的质因数的合数；</li>
</ul>
<p><strong>方法六：随机数法</strong></p>
<ul>
<li>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即：$H(key)=random(key)$；</li>
<li>通常适用于关键字长度不等时；</li>
</ul>
<p>针对上述提供的方法，实际工作中需要视情况采用。通常考虑的因素有：</p>
<ul>
<li>计算哈希函数所需的时间（包括硬件指令的因素）；</li>
<li>关键字的长度；</li>
<li>哈希表的大小；</li>
<li>关键字的分布情况；</li>
<li>记录的检查频率；</li>
</ul>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><p>假设哈希表的地址集为 0~(n-1)，冲突就是指有关键字得到的哈希地址为 j （$0 \leq j \leq n-1$） 的位置上已存有记录。那么冲突处理，就是为该关键字重新找的另一个 “空” 的哈希地址。在实际处理时，可能第一次冲突处理得到的地址 $H_1$ 仍旧冲突，则再进行处理得到 $H_2$，再冲突，再处理，…，这样得到了一个地址序列，最后一个地址 $H_k$ 为不发生冲突的地址；</p>
<p><strong>方法一：开放地址法</strong></p>
<ul>
<li>$H_i=(H(key)+d_i)\ MOD\ m,\ i=1,2,…,k\ (k \leq m-1)$</li>
<li>其中，$H(key)$ 为哈希函数；$m$ 为哈希表长；$d_i$ 为增量序列；</li>
<li>根据增量序列的取法，又可以分为如下方法：<ul>
<li>线性探测再散列：$d_i = 1,2,3,…,m-1$<ul>
<li>只要哈希表未填满，最终总能找到一个不发生冲突的地址；</li>
</ul>
</li>
<li>二次探测再散列：$d_i= 1^2,-1^2,2^2,-2^2,…,\pm k^2,\ (k \leq m/2)$<ul>
<li>只有在哈希表长 m 为形如 $4j+3$（j 为整数）的素数时才可能；</li>
</ul>
</li>
<li>伪随机探测再散列：$d_i = 伪随机数序列$<ul>
<li>取决于伪随机数列；</li>
</ul>
</li>
</ul>
</li>
<li>这种处理方式可能带来一个问题：二次聚集（即：原先不发生冲突的地址，却因为之前某个关键字进行了冲突处理，从而又导致了冲突）</li>
</ul>
<p><strong>方法二：再哈希法</strong></p>
<ul>
<li>$H_i=RH_i(key)\ \ i=1,2,…,k$</li>
<li>$RH_i$ 均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生；</li>
<li>这种方法不易产生 “聚集”，但增加了计算时间；</li>
</ul>
<p><strong>方法三：链地址法（拉链法）</strong></p>
<ul>
<li>将所有关键字为同义词的记录存储在同一线性链表中：<ul>
<li>假若某哈希函数产生的哈希地址在区间 [0,m-1] 上，则设立一个指针型变量 Chain ChainHash[m]；其每个分量的初始状态为空指针；</li>
<li>凡哈希地址为 i 的记录都插入到头指针为 ChainHash[i] 的链表中；</li>
<li>在链表中插入的位置可以是表头或表尾，也可以在中间，以保持同义词在同一线性表中按关键字有序；</li>
</ul>
</li>
<li>例如：<br><img src="http://img.thebetterkong.cn/blog/SearchingAlgorithm/ChainAddressMethod.png" alt="ChainAddressMethod"></li>
</ul>
<p><strong>方法四：建立一个公共溢出区</strong></p>
<ul>
<li>假设哈希函数的值域为 [0,m-1]，则设向量 HashTable[0,m-1] 为基本表，每个分量存放一个记录，另设立向量 OverTable[0..v] 为溢出表；</li>
<li>所有关键字和基本表中关键字为同义的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表；</li>
</ul>
<h2 id="哈希查找分析"><a href="#哈希查找分析" class="headerlink" title="哈希查找分析"></a>哈希查找分析</h2><p><strong>查找过程</strong>：给定 K 值根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找失败；否则，比较关键字，若与给定值相等，则查找成功，否则根据造表时设定的处理冲突函数的方法找 “下一地址”，直至哈希表中某个位置为 “空” 或者表中所填记录的关键字等于给定值时为止；   </p>
<ul>
<li><mark>注意：若要在非链地址处理冲突的哈希表中删除一个记录，则需要在该记录的位置上填入一个特殊的符号，以免找不到在它之后填入的 “同义词” 的记录；</mark></li>
</ul>
<p><strong>性能分析</strong>：因为 “冲突” 使得哈希表的查找过程仍是一个 “比较” 的过程，仍需以平均查找长度作为衡量哈希表的查找效率的度量；</p>
<ul>
<li>查找过程中，比较的次数取决于三个因素：<ul>
<li>哈希函数：一般情况下选取的哈希函数是 “均匀的”，则产生冲突的可能性相同，所以可以不考虑它的影响因素；</li>
<li>冲突处理方法：线性探测再散列容易产生二次聚集，而链地址法，则可以有效避免此情况；</li>
<li>哈希表的装填因子：冲突处理方法相同的哈希表，其平均查找长度就依赖于哈希表的装填因子<ul>
<li>$哈希表的装填因子\ \alpha = \frac{表中填入的记录数}{哈希表长度}$</li>
<li>$\alpha$ 越小，冲突可能性越小；$\alpha$ 越大，冲突可能性越大，则查找过程中比较的次数就越多；</li>
</ul>
</li>
</ul>
</li>
<li>几种冲突处理方法的平均查找长度：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>冲突处理方法</th>
<th>成功时</th>
<th>失败时</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性探测再散列</td>
<td>$S_{nl} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})$</td>
<td>$U_{nl} \approx \frac{1}{2}(1+\frac{1}{(1-\alpha)^2})$</td>
</tr>
<tr>
<td>随机探测再散列、二次探测再散列、再哈希</td>
<td>$S_{nr} \approx -\frac{1}{\alpha}ln(1-\alpha)$</td>
<td>$U_{nr} \approx \frac{1}{1-\alpha}$</td>
</tr>
<tr>
<td>链地址法</td>
<td>$S_{nc} \approx 1+\frac{\alpha}{2}$</td>
<td>$U_{nc} \approx \alpha + e^{-\alpha}$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li>
<li>『<a href="https://www.cnblogs.com/magic-sea/p/11391431.html" target="_blank" rel="noopener">賣贾笔的小男孩：分块查找</a>』</li>
<li>『<a href="https://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="noopener">[Data Structure &amp; Algorithm] 七大查找算法</a>』</li>
<li>『<a href="https://blog.csdn.net/sheepmu/article/details/38407221?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase" target="_blank" rel="noopener">二叉查找树BST——java实现</a>』</li>
<li>『<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a>』</li>
<li>『<a href="https://segmentfault.com/a/1190000020416577" target="_blank" rel="noopener">面试官问你B树和B+树，就把这篇文章丢给他</a>』</li>
</ul>
]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-CAD Tools：Placement</title>
    <url>/2020/05/13/FPGA-technology/FPGA-CADTools-Placement/</url>
    <content><![CDATA[<p>主要介绍 FPGA 技术里 placement 部分；</p>
<a id="more"></a> 
<h1 id="概述：FPGA-Placement"><a href="#概述：FPGA-Placement" class="headerlink" title="概述：FPGA Placement"></a>概述：FPGA Placement</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>涉及电路块网表（就逻辑集群而言）的过程，该电路表要分配到 FPGA 上的某些物理位置：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/WhatPlacement.png" alt="WhatPlacement"></p>
<ul>
<li>在 routing 之前，任何 FPGA placement 的主要目标是产生一个可以使用 FPGA 提供的<strong>有限布线资源成功进行布线</strong>的布置；<ul>
<li>利用 placement algorithms，对 CLB 进行 Placement，以便路由信号所需的互连最小化，这一步对 FPGA 的性能影响很大；</li>
</ul>
</li>
<li>布局是 FPGA 设计流程中的关键部分，大约需要一半的 “编译” 时间；</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>好的 placement 非常重要：</p>
<ul>
<li>设置可路由性的条件；</li>
<li>即使电路能布通，放置不良也会导致最大工作速度降低并增加功耗；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/GoodandBadPlacement.png" alt="GoodandBadPlacement"></p>
<p>寻找一个好的 placement 是一个挑战：</p>
<ul>
<li>大型商用 FPGA 包含超过 500,000 个功能块，这意味着它有 $500,000!$ 个可能的placements，因此不可能进行详尽的评估；</li>
</ul>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>这三个目标互相影响，很难同时对三个目标都达到最优，所以往往会进行综合考虑，不同的目标导致不同的性能表现结果：</p>
<ol>
<li>减少所需的接线：Wirelength-driven 的放置<ul>
<li>两个箱子之间有互连关系，就尽量把它们放在一起；</li>
</ul>
</li>
<li>平衡布线密度：Routability-driven 的放置<ul>
<li>有关电路 connection 的拥塞；</li>
</ul>
</li>
<li>最大化电路速度：Timing-driven 的放置<ul>
<li>延迟最小，即关键路径尽量短；</li>
</ul>
</li>
</ol>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol>
<li>Accommodation Limit（住宿限制）<ul>
<li>RAM 块必须放置在 RAM 位置，CLB 必须放置在 CLB 位置，依此类推；</li>
</ul>
</li>
<li>Specific Group（特定群体）<ul>
<li>构成进位链的算术逻辑簇必须按照进位结构要求的顺序彼此相邻放置；</li>
</ul>
</li>
<li>Routing Congestion（路由拥塞）<ul>
<li>当互连超出了 FPGA 某些部分的装配布线能力时；</li>
</ul>
</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>在放置 placement 期间，placer 尝试寻找合法的解决方案，以便将所有块都分配给目标 FPGA 芯片上的有效位置；</li>
<li>它针对<strong>多个设计目标进行了优化</strong>，例如：线长，电路延迟，布线拥塞和功耗；</li>
<li>由于<strong>块的位置通常在放置 placement 阶段之后是固定的</strong>，并且 placement 对布线质量有很大的影响，因此，放置试探法能够产生高质量的解决方案非常重要。</li>
<li>大多数 FPGA 布局算法可分为三种类型：<strong>Simulated Annealing(模拟退火)</strong>、<strong>Analytical(分析)</strong> 和 <strong>Partitioning-Based(基于分区)</strong>；<ul>
<li>“模拟退火”可能是使用最广泛的。</li>
</ul>
</li>
</ul>
<h1 id="Simulated-Annealing-Algorithm"><a href="#Simulated-Annealing-Algorithm" class="headerlink" title="Simulated Annealing Algorithm"></a>Simulated Annealing Algorithm</h1><h2 id="Physical-Annealing"><a href="#Physical-Annealing" class="headerlink" title="Physical Annealing"></a>Physical Annealing</h2><p>Annealing：一种<strong>热处理</strong>，可改变材料的物理和化学性质，以<strong>增加其延展性</strong>并<strong>降低其硬度</strong>，从而使其更易加工：</p>
<ul>
<li>Annealing(退火)：冷却热分子以形成良好的晶体结构</li>
<li>从高温开始，分子随机移动</li>
<li>按照特定的冷却时间表进行冷却，要求留出足够的时间使分子形成晶格   </li>
</ul>
<p>属于<strong>热力学问题</strong>：由于原子在固体材料中的扩散而发生，因此材料向其平衡状态发展。   </p>
<p>传统过程（例如金属）：</p>
<ul>
<li>加热：取一金属并将其加热到高温，给它一个初始温度，原子过渡到高能态；</li>
<li>冷却：使其<strong>缓慢</strong>冷却，金属退火至低温。在温度下降期间，原子缓慢地移动到低能态；</li>
<li><strong>初始温度越高，冷却越慢，金属变得越坚硬</strong>；</li>
</ul>
<h2 id="SA（Simulated-Annealing）"><a href="#SA（Simulated-Annealing）" class="headerlink" title="SA（Simulated Annealing）"></a>SA（Simulated Annealing）</h2><p>一种模拟物理退火过程的概率技术，用于逼近给定函数的全局最优值。具体来说，就是一种元启发式方法，在大型搜索空间中寻找接近全局优化的解；    </p>
<p>SA 算法用于求解组合极问题和 NP 完全问题，其步骤如下：</p>
<ul>
<li>Step 1：以初始状态和温度开始（热力学类比）；</li>
<li>Step 2：<strong>随机</strong>改变状态，创造新的状态；</li>
<li>Step 3：比较新状态和当前状态的能量：<ul>
<li><strong>「接受」</strong>：如果新状态的能量较小，或者概率函数 $e^{-\Delta C/T}$ 小于随机值（$\Delta C$表示能量变化，$T$ 表示当前温度）；<ul>
<li>添加第二个条件的目的就是为了防止出现局部最小值而引入的 hill climb 方法：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/HillClimb.png" alt="HillClimb"></li>
</ul>
</li>
<li><strong>「拒绝」</strong>：其它新状态</li>
</ul>
</li>
<li>Step 4：启发式地迭代步骤 2〜3，最后达到平衡状态（为每个温度创建一个新状态）；</li>
</ul>
<p>运用到 FPGA 实际上就是一种迭代过程：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/FPGASA.png" alt="FPGASA"></p>
<ul>
<li>placer 程序提议在 SA 过程中随机移动；</li>
<li>每个潜在的移动（可能是两个相同类型的块之间的位置交换，或者一个块向有效空白空间的移动）都将导致 placement 成本的变化；</li>
<li>Annealer（退火炉）使用此更改或 “∆C” 来做出移动决策；<ul>
<li>与金属退火过程相似，即使代价成本增高（即：“不良举动”），在较高的温度下也有较高的机会接受更高的代价；</li>
<li>在 SA 期间必须执行 “爬山”，以减少陷入局部极小值的机会；</li>
<li>总是接受降低整体成本的 “好举动”；</li>
<li>随着温度下降，Annealer 将接受较少的 “不良动作”；</li>
</ul>
</li>
<li>满足预定义的退出条件时，SA 过程最终将停止；</li>
</ul>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li><strong>温度（T）</strong>：<ul>
<li>控制算法去接受那些使解决方案变得更糟的动作的可能性（$e^{-\Delta C/T}$）；</li>
</ul>
</li>
<li><strong>成本函数（C）</strong>：<ul>
<li>一定温度下的能量状态；</li>
</ul>
</li>
<li><strong>退火时间表</strong>（时间表越好，算法就越好）：<ul>
<li>温度降低的速率；</li>
<li>终止退火的退出标准；</li>
<li>在每个温度下尝试移动的次数；</li>
<li>产生潜在移动的方法；</li>
</ul>
</li>
</ul>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ol>
<li>对参数的敏感性：<ul>
<li>状态空间，成本函数，候选生成器，接受概率函数以及退火进度温度和初始温度等等……</li>
<li>他们之间的相互作用不被理解（过于复杂，只能凭借经验去尝试）；</li>
</ul>
</li>
<li>冻结问题：<ul>
<li>有时无法逃脱局部最小值；</li>
<li>特别是在低温下，接受不良动作的可能性非常低；</li>
</ul>
</li>
</ol>
<h1 id="Place-Algorithm-VPlace"><a href="#Place-Algorithm-VPlace" class="headerlink" title="Place Algorithm: VPlace"></a>Place Algorithm: VPlace</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>基于模拟退火；</li>
<li>新的自适应退火时间表；</li>
<li>引入了边界框；</li>
<li>具有 timing 驱动版本（增加了了面积驱动）；</li>
<li>深入研究了 VTR 中使用的学术 placement 工具；</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleVplace.png" alt="ExampleVplace"></p>
<h2 id="通用伪代码"><a href="#通用伪代码" class="headerlink" title="通用伪代码"></a>通用伪代码</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/VPackPseudoCode.png" alt="VPackPseudoCode"></p>
<h2 id="Adaptive-Annealing-Schedule"><a href="#Adaptive-Annealing-Schedule" class="headerlink" title="Adaptive Annealing Schedule"></a>Adaptive Annealing Schedule</h2><h3 id="Initial-Placement"><a href="#Initial-Placement" class="headerlink" title="Initial Placement"></a>Initial Placement</h3><ul>
<li>S = InitialPlacement（），S 是当前放置状态；</li>
<li>通过将逻辑块随机分配给 FPGA 中的可用位置来创建初始放置；</li>
</ul>
<h3 id="Initial-Temperature"><a href="#Initial-Temperature" class="headerlink" title="Initial Temperature"></a>Initial Temperature</h3><ul>
<li>$N_{blocks}$ 是所需的<u>逻辑块/群集</u>的数量加上<u>所需的 IO 焊盘</u>的数量；</li>
<li>使用预定义的概率执行 $N_{blocks}$ 的<strong>移动</strong>，并针对这些关于 $N_{blocks}$ 的不同 placement <strong>计算 cost 的标准偏差</strong>；</li>
<li><strong>初始温度</strong>设置为该标准偏差的 <strong>20 倍</strong>；</li>
<li>由于高温特性，一开始就接受所有动作；</li>
</ul>
<h3 id="Temperature-Update-Strategy"><a href="#Temperature-Update-Strategy" class="headerlink" title="Temperature Update Strategy"></a>Temperature Update Strategy</h3><ul>
<li>$T_{new} = \gamma \cdot T_{old}$<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TemperatureUpdate.png" alt="TemperatureUpdate"><ul>
<li>$R_{accept}$ 是当前温度下接受的尝试移动的一部分；</li>
<li>算法开始时，几乎接受了所有的移动，因此，可以将 $\gamma$ 设置比较小，使温度变化快一些，但是随着算法的进行，接受的移动策略越来越少，此时，应该将温度的变化幅度减小；</li>
</ul>
</li>
</ul>
<h3 id="Range-Limiter"><a href="#Range-Limiter" class="headerlink" title="Range Limiter"></a>Range Limiter</h3><ul>
<li>$R_{limit}$ 是尝试交换块的范围跨度；</li>
<li>$R_{limit}$ 最初设置为整个芯片的跨度，并在温度降低到一定水平以下时缩小($R_{accept} \leq 0.44$)；<script type="math/tex; mode=display">1(single\ block) \leq R_{limit} \leq  maximum\ FPGA\ dimension\ (R_{accept} \leq 0.44)</script></li>
<li>更新方法：<script type="math/tex; mode=display">R_{limit\_new} = R_{limit\_old} \cdot \underbrace{(1-0.44+R_{accept})}_{\leq 1}(R_{accept} \leq 0.44)</script></li>
</ul>
<h3 id="Moves-per-Temperature"><a href="#Moves-per-Temperature" class="headerlink" title="Moves per Temperature"></a>Moves per Temperature</h3><script type="math/tex; mode=display">MovesPerTemperature = InnerNum \ast {N_{blocks}}^{\frac{3}{4}}</script><ul>
<li>InnerNum 的默认值为 10，以允许使用不同的 CPU 时间 / placements 质量进行权衡；</li>
<li>将 MovesPerTemperature 降低 10 倍，可将 placer 的速度提高 10 倍，并将最终 placement 质量降低不到 10％；</li>
</ul>
<h3 id="Terminate-Criterion"><a href="#Terminate-Criterion" class="headerlink" title="Terminate Criterion"></a>Terminate Criterion</h3><p>$T &lt; \epsilon \cdot Cost / N_{nets}$</p>
<ul>
<li>$N_{nets}$ 是电路中的网络数；</li>
<li>$\epsilon$＝ 0.005（经验值）；<ul>
<li>0.05 到 0.005 之间的任何值都是合理的；</li>
<li>较小的值会以稍微增加的 CPU 时间为代价提供更高的 placement 质量；</li>
</ul>
</li>
</ul>
<h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>Cost Function 主要取决于 Bounding Box，但是实际计算过程中，并没有那么简单，我们还需要考虑通道的宽度等因素，于是引入了 Linear Congestion，将 Bounding Box 的计算进一步精确</p>
<h3 id="Bounding-Box-Wirelength-Driven"><a href="#Bounding-Box-Wirelength-Driven" class="headerlink" title="Bounding Box (Wirelength-Driven)"></a>Bounding Box (Wirelength-Driven)</h3><ul>
<li>Net 是在电路网表中共享相同源的一组节点和连接（可能有多个 sinks）；</li>
<li>估算电线长度要求的模型：<script type="math/tex; mode=display">Wring_{Cost}=\sum^{N_{nets}}_{i=1}\ q(i) \cdot [\ bb_x(i)+bb_y(i)\ ]</script><ul>
<li>$bb_x(i)$ 是Net i的水平跨度；</li>
<li>$bb_y(i)$ 是Net i的垂直跨度；</li>
<li>$q(i)$ 将在后面讨论，实际考虑更复杂，是采用下一小节的办法计算的；</li>
</ul>
</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleBoundingBox.png" alt="ExampleBoundingBox"></p>
<h3 id="Linear-Congestion-Wirelength-Driven"><a href="#Linear-Congestion-Wirelength-Driven" class="headerlink" title="Linear Congestion (Wirelength-Driven)"></a>Linear Congestion (Wirelength-Driven)</h3><script type="math/tex; mode=display">Cost=\sum^{num\_nets}_{i=1}q(i)(\frac{bb_x[i]}{[C_{av,x}(i)]^\beta}+\frac{bb_y[i]}{[C_{av,y}(i)]^\beta})</script><ul>
<li>$q(i)$ 是 Net i 的权重，对于具有 3 个或更少 terminals 的 Net i，$q(i)$ 设置为 1。超过 3 个 terminals 的，线性增加的速率为：<script type="math/tex; mode=display">q(i)=2.79+0.02616 \cdot (\ Num\_Terminals-50\ )</script></li>
<li>$C_{av,x}(i)$ 和 $C_{av,y}(i)$ 分别是 Net i 边界框上 x 和 y 方向的平均信道容量（通道宽度）；</li>
<li>$\beta$ 允许调整使用窄通道和宽通道的相对成本。设置为1（经验值）；<ul>
<li>$\beta=0$，恢复为标准 bounding box cost function，上一小节的情形；</li>
<li>$\beta$ 的值越大，相对于较宽通道的布线，较窄通道的布线受到的惩罚越多（布局时，尽量选用更宽的通道）；</li>
</ul>
</li>
</ul>
<p>运用举例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/ExampleLinearCongestion.png" alt="ExampleLinearCongestion"></p>
<ul>
<li>问题：有一个映射的网表，它具有 3 个 nets，每个 nets 具有 3 个 terminals，在 x 和 y 方向上的平均信道容量为 4，计算 Cost；</li>
<li>解决方案：<ul>
<li>每个 nets 都有 3 个 terminals，$q(1)=q(2)=q(3)=1$；</li>
<li>设置 $\beta=1$，并且 $bb_x[.]$ 和 $bb_y[.]$ 的值表都有给出；</li>
<li>$Cost = 1\ast(2/4+4/4) + 1\ast(4/4+4/4) + 1\ast(6/4+4/4) = 1.5+2+2.5=6$</li>
</ul>
</li>
</ul>
<h3 id="Linear-Congestion-vs-Bounding-Box"><a href="#Linear-Congestion-vs-Bounding-Box" class="headerlink" title="Linear Congestion vs. Bounding Box"></a>Linear Congestion vs. Bounding Box</h3><ul>
<li>$\beta = 0$: Bounding box</li>
<li>$\beta &gt; 0$: Linear congestion</li>
<li>logic-bound：仅 I/O placement</li>
<li>I/O-bound：仅 logic cluster placement</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/LCVsBB.png" alt="LCVsBB"></p>
<h3 id="Bounding-Box-re-calculation-问题"><a href="#Bounding-Box-re-calculation-问题" class="headerlink" title="Bounding Box re-calculation 问题"></a>Bounding Box re-calculation 问题</h3><ul>
<li>即使制定了良好的 annealing schedule，在典型的 placement 过程中也将<strong>评估数百万个潜在的块交换</strong>，计算量太大；</li>
<li>评估 swap 上最昂贵的计算部分是计算 swap 产生的 cost 变化 $\delta C$；尽快进行此计算至关重要；</li>
<li>$\delta C$ 中唯一更改的 term 是与两个交换的块所连接的网络相对应的 term；即，计算公式里面的 $bb_x[i]$ 和 $bb_y[i]$；</li>
<li>于是引入了一种，递增式的 Incremental Bounding Box Evaluation；</li>
</ul>
<h3 id="Incremental-Bounding-Box-Evaluation"><a href="#Incremental-Bounding-Box-Evaluation" class="headerlink" title="Incremental Bounding Box Evaluation"></a>Incremental Bounding Box Evaluation</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IncrementalBoundingBoxEvaluation.png" alt="IncrementalBoundingBoxEvaluation"></p>
<ul>
<li>$X_{min}，X_{max}，Y_{min}，Y_{max}$：对于每个网络，我们存储其边界框的四个边的每一边的坐标；</li>
<li>$N_{xmin}，N_{xmax}，N_{ymin}，N_{ymax}$：位于每侧的 net terminals 数；</li>
<li>假设此网络的 terminal 通过交换从 $(x_{old},y_{old})$ 移至 $(x_{new},y_{new})$；</li>
<li>可以仅通过查看移动的 terminal 而不是所有 k terminal 来确定新的边界框；</li>
<li>如果移动的 terminal 是边界框一侧的唯一 terminal，并且现在已向内移动到边界框的中心，仅此情况需要完全重新计算；</li>
<li>这样就减少了 CPU 时间；</li>
</ul>
<p>伪代码描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IBBEPsudoCode.png" alt="IBBEPsudoCode"></p>
<h1 id="Place-Algorithm：T-VPlace"><a href="#Place-Algorithm：T-VPlace" class="headerlink" title="Place Algorithm：T-VPlace"></a>Place Algorithm：T-VPlace</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>时序驱动的 VPlace 版本；</li>
<li>新的成本函数可以在<strong>导线长度</strong>和<strong>关键路径延迟</strong>之间进行权衡；</li>
<li>对于给定的恒定输入集，无论执行程序多少次，<strong>结果都是相同</strong>的；</li>
<li><strong>良好的可重复性</strong>，可用于代码调试，错误重现/</li>
<li>客户支持和回归测试；</li>
<li>速度提高 42％，同时减少线长的 5％；</li>
</ul>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TVPackPsudoCode.png" alt="TVPackPsudoCode"></p>
<h2 id="延迟模型"><a href="#延迟模型" class="headerlink" title="延迟模型"></a>延迟模型</h2><p>计算延迟矩阵：</p>
<ul>
<li>两个块之间的延迟仅作为距离 $(\Delta x,\Delta y)$ 的函数；</li>
<li>使用 router 确定相距 $(\Delta x,\Delta y)$ 距离的两个块之间的延迟，并将其记录在位置索引 $(\Delta x,\Delta y)$ 的<strong>delay look up matrix</strong>（延迟查找矩阵）中；</li>
<li>重复此过程，直到在 FPGA 中计算出所有可能的位置 $(\Delta x,\Delta y)$；</li>
<li>由于 router 足够智能，因此只需要记录两个块之间的最小延迟，之后的按照简单的倍数相乘就能得到了；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/DelayModel.png" alt="DelayModel"></p>
<h2 id="Timing-Analysis"><a href="#Timing-Analysis" class="headerlink" title="Timing Analysis"></a>Timing Analysis</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TrequiredTarrival.png" alt="TrequiredTarrival"></p>
<p><strong>Arrival Time</strong>：</p>
<script type="math/tex; mode=display">T_{arrival}(i)=Max_{\forall j \in fanin(i)}\{T_{arrival}(j)+delay(j,i)\}</script><ul>
<li>节点 i 是当前正在计算的节点；</li>
<li>$delay(j,i)$ 是连接节点 j 到 i 的边缘的延迟值；</li>
<li>电路延迟是所有节点的最大到达时间 $D_{max}$；</li>
</ul>
<p><strong>Required Time</strong>：</p>
<script type="math/tex; mode=display">T_{required}(i)=Min_{\forall j \in fanout(i)}\{T_{required}(j)-delay(i,j)\}</script><ul>
<li>将所有接收器的 $T_{required}$ 设置为 $D_{max}$ 并向后计算；</li>
</ul>
<p><strong>Slack of a connection (i,j)</strong>：</p>
<script type="math/tex; mode=display">Slack(i,j)=T_{required}(j)-T_{arrival}(i)-delay(i,j)</script><h2 id="Cost-Function-1"><a href="#Cost-Function-1" class="headerlink" title="Cost Function"></a>Cost Function</h2><h3 id="Timing-Cost"><a href="#Timing-Cost" class="headerlink" title="Timing Cost"></a>Timing Cost</h3><p>基于每个连接的 Criticality，每个连接的 Delay 和用户定义的 Criticality_Exponent：    </p>
<script type="math/tex; mode=display">Criticality(i,j)=1-\frac{Slack(i,j)}{Dmax}</script><p>Criticality_Exponen 可以对那些重要的连接进行加权，而对其他非关键连接的加权则较小:     </p>
<script type="math/tex; mode=display">Timing\_Cost(i,j)=Delay(i,j)\ Criticality(i,j)^{Criticality\_Exponent}</script><p>总 timing cost 是所有连接的 timing cost 之和:     </p>
<script type="math/tex; mode=display">Timing\_Cost=\sum_{\forall i,j \in cricuit}\ Timing\_Cost(i,j)</script><h3 id="Auto-normalizing-Cost"><a href="#Auto-normalizing-Cost" class="headerlink" title="Auto-normalizing Cost"></a>Auto-normalizing Cost</h3><script type="math/tex; mode=display">\Delta C=\lambda \cdot \frac{\Delta Timing\_Cost}{Previous\_Timing\_Cost}+(1-\lambda)\cdot \frac{\Delta Wiring\_Cost}{Previous\_Wiring\_Cost}</script><ul>
<li>权衡变量 $\lambda$，以确定应赋予每个组件多少权重；<ul>
<li>仅使用变量 $\lambda$ 来使函数两个分量的权重，而与它们的实际值无关；</li>
</ul>
</li>
<li>Previous_Timing_Cost 和 Previous_Wiring_Cost，每个温度更新一次（规范化组件）；</li>
<li>继承 VPlace 的 annealing schedule，因为它是 “自适应的”，并且在新的成本函数中表现良好；</li>
</ul>
<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><h3 id="调整-Timing-Analysis-间隔"><a href="#调整-Timing-Analysis-间隔" class="headerlink" title="调整 Timing Analysis 间隔"></a>调整 Timing Analysis 间隔</h3><ul>
<li>将 $\lambda$ 的值设置为 1（完全由时序驱动），Criticality_Exponent 设置为 1；</li>
<li>然后，改变对电路进行时序分析的频率，并更新连接的 Criticality 和 slack；</li>
<li>扫描从执行开始时一直执行一次，一直到 placement 算法内部循环内的时序分析：</li>
</ul>
<p>分析结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningTimingAnalysisInterval.png" alt="TuningTimingAnalysisInterval">  </p>
<ul>
<li>每个温度执行一次时序分析足以获得最佳的放置结果；</li>
<li>似乎此重新分析间隔不会影响 placement 的 bounding box (wirelength) cost；</li>
</ul>
<h3 id="调整-Criticality-Exponent"><a href="#调整-Criticality-Exponent" class="headerlink" title="调整  Criticality_Exponent"></a>调整  Criticality_Exponent</h3><p><strong>取 $\lambda = 0.5$ ：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningCriticalityExponent1.png" alt="TuningCriticalityExponent1"></p>
<ul>
<li>将 criticality exponent 提高到大约 8 或 9 会改善 placement 估算的关键路径，此时不再有明显的收益；</li>
<li>大指数可改善 Wiring_Cost；</li>
<li>分析：<ul>
<li>大指数使得 connections 少的具有很大的 Timing_Cost，而其他连接具有无关紧要的Timing_Cost；</li>
<li>高 Criticality_Exponent 导致关键电路中的连接数量减少，但对于这少数几个连接，Timing_Cost 占标准化 cost 的最大部分；</li>
<li>对于其他非关键连接（随着 Criticality_Exponent 的增加，其他非关键连接会更多），Wiring_Cost 占标准化 cost 的最大部分；</li>
</ul>
</li>
</ul>
<p><strong>取 $\lambda = 1$ ：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/TuningCriticalityExponent2.png" alt="TuningCriticalityExponent2"></p>
<ul>
<li>指数值最好为 2 或 3；</li>
<li>$\lambda = 1$ 的延迟结果比 $\lambda = 0.5$ 差，Wiring_Cost 差很多。</li>
<li>分析：<ul>
<li>该算法很可能能够在外循环的一次迭代期间显着减少关键路径，但同时又无意中使其他路径变得非常关键；</li>
<li>这种振荡效应使放置算法难以收敛到最佳放置解决方案；</li>
<li>通过在成本方程中包含一个线长最小化项，我们可以减少放置的振荡；</li>
<li>这是因为 wire-length 这一项将惩罚那些大大增加 wire-length 的移动，使它们不太可能被接受，即使它们会大大减少当前的关键路径；</li>
<li>在我们的成本函数中，线长项作为延迟最小化项的阻尼器，并防止振荡；</li>
</ul>
</li>
</ul>
<h3 id="调整-lambda"><a href="#调整-lambda" class="headerlink" title="调整 $\lambda$"></a>调整 $\lambda$</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/Tuninglambda.png" alt="Tuninglambda"></p>
<p>仅由 wire-length driven 的算法可产生最佳的 Wiring_Cost；</p>
<ul>
<li>$\lambda=0.9$ 的算法产生的电路具有最佳 placement 估计的关键路径延迟；</li>
<li>$\lambda=1$ 时，对于关键路径，延迟和导线长度都不利；</li>
<li>将 $\lambda$ 设置为 0.5 可在导线长度和关键路径最小化之间取得最佳折衷；</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>先前的结果表明，使用每个温度一次的时序分析间隔，Criticality_Exponent 值为 8，$\lambda$ 为 0.5 可以提供迄今为止最好的结果</li>
<li>基于这些结果，我们将定时分析间隔设置为每个温度一次，Criticality_Exponent 设置为 8，设置不同的 $\lambda$；</li>
</ul>
<h1 id="Place-with-Multiple-I-O-Standards"><a href="#Place-with-Multiple-I-O-Standards" class="headerlink" title="Place with Multiple I/O Standards"></a>Place with Multiple I/O Standards</h1><p>以 Virtex 和 Virtex-E FPGAs 为例，设计的 I/O 对象和 core logic 的三个不同位置：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/MultipleIOStandards.png" alt="MultipleIOStandards">    </p>
<p>具有不同阴影的 I/O 对象不兼容，不能一起放置在同一存储库中，假设每个芯片边缘只有一个 I/O 库：</p>
<ul>
<li>图（a）描述了在没有与 bank 的 I/O 组织相关的约束的情况下可以实现的放置；</li>
<li>图（b）描绘了一个受约束的 I/O 布局，其中一组兼容的 I/O 对象分布在两个 banks 之间；</li>
<li>图（c），如果我们使用幼稚的方法放置 I/O 对象，即将每组兼容的 I/O 对象放置在一个 bank 中；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/IOStandardVoltage.png" alt="IOStandardVoltage"></p>
<ul>
<li>当前 FPGA 支持的 I/O 标准在几种方面彼此不同；</li>
<li>一些 I/O 标准要求使用差分放大器输入：<ul>
<li>使用此类标准时，用户必须向放大器提供外部参考电压 Vref；</li>
<li>使用差分放大器可以减少 I/O 电压摆幅，从而加快开关速度；</li>
</ul>
</li>
<li>第二个特征是某些标准要求特定的电源电压 Vcco 为 I/O 模块供电；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Placement/OrganizationVirtexEFPGA.png" alt="OrganizationVirtexEFPGA"></p>
<ul>
<li>Vref 和 Vccovoltages 由外部提供，并连接到为 I/O 模块组（称为存储体）提供服务的特殊引脚；</li>
<li>组中的所有 I/O 块均由单个 Vref 电压和单个 Vcco 电源电压供电；</li>
<li>Virtex-E FPGA 每个芯片边缘有两个 I / O bank，或者总共有八个 bank；</li>
</ul>
<p>总结来说：</p>
<ul>
<li>具有 Vref 和 Vcco 电压的 bank 在同一 bank 中进行组合的 I/O 标准的限制：<ul>
<li>两个 I/O 对象，由于其 I/O 标准而需要不同的 Vref 或不同的 Vccovoltage，它们就不能合法的放在同一 bank；</li>
</ul>
</li>
<li>我们看到，使用 GTL 标准的输入 I/O 对象不能与使用 HSTL_I 标准的输入 I/O 对象放在同一存储体中，因为这两个标准需要不同的 Vref 电压；</li>
<li>bank 组织在 I/O 灵活性和用户可用的 I/O 块数量之间提供了合理的权衡；</li>
</ul>
<p>解决方式：</p>
<ul>
<li>采用的 annealing cost function 考虑了 wirelength，timing cost 以及 非法 I/O placement 导致的违反 banking 的行为：<script type="math/tex; mode=display">PlacementCost=\alpha \cdot WirelengthCost + \beta \cdot TimingCost + \gamma \cdot BankingViolationCost</script></li>
<li>placement 期间，移动 core logic blocks 时，仅会影响wirelength cost 和 the timing cost，而 I/O 移动可能会影响所有三个项的值；</li>
<li>违反 banking rule 的 cost 是通过将每个 bank 的违规相加得出的：<script type="math/tex; mode=display">BankingViolationCost=\sum_{i \in B}BankCost_i\ ,\ B\ is\ the\ set\ of\ all\ I/O\ banks</script></li>
<li>Vref 冲突或 Vcco 冲突可能导致 bank 内部违规； </li>
<li>当 bank 包含由于其使用的标准而需要将多个 Vref 电压施加到同一 bank 的 I/O 对象时，会发生 Vref 冲突。Vcco 冲突的定义与此类似。</li>
<li>bank 的 cost i 是 Vref 冲突 cost 和 Vcco 冲突 cost 之和：<script type="math/tex; mode=display">bankCost_i=vrefConflictCost_i+vccoConflictCost_i</script></li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Background</title>
    <url>/2020/03/20/FPGA-technology/FPGA-Background/</url>
    <content><![CDATA[<p>① 总体上认识 FPGA。</p>
<a id="more"></a> 
<h1 id="VLSI"><a href="#VLSI" class="headerlink" title="VLSI"></a>VLSI</h1><p>VLSI（very large scale integrated circuit），也就是我们常说的超大规模集成电路，主要包括：</p>
<ul>
<li>通用芯片：CPU/DSP、Memory、FPGA</li>
<li>ASIC专用集成电路</li>
</ul>
<p>他们通常能并行、可重构的处理大量的数据，按照不同的性能标准对他们进行比较，如图所示：   </p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-Background/Comparison.jpeg" alt="comparison"><ul>
<li>flexibility：可编程能力</li>
<li>speed：工作频率</li>
<li>processing-capability：单位时间里数据运算的次数</li>
<li>power-efficiency：单位功耗处理能力</li>
</ul>
</li>
</ul>
<h1 id="PLD"><a href="#PLD" class="headerlink" title="PLD"></a>PLD</h1><p>PLD（programmable logic device），可编程逻辑器件；   </p>
<p>特点：</p>
<ul>
<li>具有逻辑功能的集成电路，可以根据任何用户要求进行编程或重新编程；</li>
<li>“programmable”表示在硅制造完成之后将功能编程到芯片中的能力；</li>
</ul>
<p>优势：</p>
<ul>
<li>开发周期短，产品上市时间快；</li>
<li>可重构的设计，使得其能很灵活的适应系统的改变和更新，设计bug可以快速轻松的修复；</li>
<li>高度集成，能节省板的空间；</li>
<li>可提供现成的解决方案；</li>
</ul>
<p>发展过程：</p>
<ul>
<li><p>PLA (Programmable Logic Array)：</p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-Background/PLA.jpeg" alt="PLA"><ul>
<li>红圈里的是programmable connection，是一种可编程的开关；</li>
</ul>
</li>
</ul>
</li>
<li><p>PAL (Programmable Array Logic)：</p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-Background/PAL.jpeg" alt="PAL"><ul>
<li>switch更少了，比PLA更快，但是也牺牲了灵活性；</li>
</ul>
</li>
</ul>
</li>
<li><p>CPLD (Complex Programmable Logic Device)：</p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-Background/CPLD.jpeg" alt="CPLD"><ul>
<li>随着CMOS技术的出现，可以将多个PLD集成到单个芯片上，即所谓的CPLD；</li>
<li>相当于给PAL和PLA加了限制：<ul>
<li>每个乘积项中的变量数受输入引脚数的限制；</li>
<li>独立功能的数量受输出引脚数量的限制；</li>
<li>随着输入数量的增加，规模迅速增加；</li>
<li>无法容纳大逻辑容量；</li>
</ul>
</li>
<li>与PLD内的可编程互连不同，CPLD内的开关矩阵可能完全连接，也可能未完全连接；</li>
</ul>
</li>
</ul>
</li>
<li><p>FPGA (Field Programmable Gate Array)：</p>
</li>
</ul>
<h1 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>FPGA (Field Programmable Gate Array)，是一块事先做好了电路和连线的芯片，用户可以根据自己的需求对其进行编程或重编程，在经过综合、映射、布局、布线等一系列工作之后，调整芯片内部的结构状态，进而使芯片具有完成某种特定功能的能力。</p>
<h2 id="与CPU的不同"><a href="#与CPU的不同" class="headerlink" title="与CPU的不同"></a>与CPU的不同</h2><p>FPGA与CPU最大区别在于软硬件差异：</p>
<ul>
<li>FPGA是针对电路的可重构来完成硬件可编程，而CPU是针对软件的编程，其硬件结构不会改变；</li>
<li>CPU是基于冯诺依曼结构，串行的执行一系列指令，而FPGA是针对bit位来进行并行的数据处理；</li>
<li>在简单的事务处理中FPGA的性能更高，且单位功耗的处理能力更强，但是在灵活性上FPGA不如CPU；</li>
</ul>
<h2 id="选用FPGA为什么不是ASIC？"><a href="#选用FPGA为什么不是ASIC？" class="headerlink" title="选用FPGA为什么不是ASIC？"></a>选用FPGA为什么不是ASIC？</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Background/FPGA-ASIC.jpeg" alt="FPGA-ASIC"></p>
<ul>
<li>在非循环性的工程中，ASIC的设计和生产更加昂贵；</li>
<li>ASIC与FPGA的交叉点越来越高，以至于对于大多数客户而言，units的数量不再是ASIC的合理选择；</li>
</ul>
<h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Background/FPGA.jpeg" alt="FPGA"></p>
<ul>
<li>一系列可能不同类型的可编程逻辑块，包括：<ul>
<li>CLB：General logic blocks</li>
<li>Memory blocks</li>
<li>MAC (Multiply-Accumulation) blocks：乘，加运算专用，用于数字信号处理</li>
</ul>
</li>
<li>这些块被可编程的路由结构所围绕，从而可以选择性地互连它们；</li>
<li>阵列本身被可编程的输入/输出模块包围，该模块将芯片连接到外部环境；</li>
<li>大量配置SRAM（静态随机存取存储器）单元可实现可编程性；</li>
</ul>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>Datacenter、CPU + FPGA、AI（边缘计算、云计算）等等</p>
<h2 id="为什么基于SRAM的FPGA如此流行？"><a href="#为什么基于SRAM的FPGA如此流行？" class="headerlink" title="为什么基于SRAM的FPGA如此流行？"></a>为什么基于SRAM的FPGA如此流行？</h2><p>Re-programmability：</p>
<ul>
<li>SRAM单元可以无限次编程；</li>
<li>FPGA上的专用电路会在上电时初始化所有SRAM位，并使用用户提供的配置来配置这些位；</li>
</ul>
<p>使用标准CMOS工艺技术：</p>
<ul>
<li>与其他编程技术不同，使用SRAM单元不需要标准CMOS以外的任何特殊集成电路处理步骤；</li>
<li>因此，基于SRAM的FPGA可以使用最新的CMOS技术，于是可以受益于更高集成度，更快的速度和更低的动态功耗消耗在“最小几何的新工艺的”上。</li>
</ul>
<h2 id="基于SRAM的FPGA的缺点"><a href="#基于SRAM的FPGA的缺点" class="headerlink" title="基于SRAM的FPGA的缺点"></a>基于SRAM的FPGA的缺点</h2><p>size：</p>
<ul>
<li>SRAM单元需要5个或6个晶体管，用于互连信号的可编程元件至少需要一个晶体管</li>
</ul>
<p>Volatility挥发性：</p>
<ul>
<li>SRAM单元的易变性需要在设备掉电时使用外部设备永久存储配置数据；</li>
</ul>
<p>晶体管传输的电气特性：</p>
<ul>
<li>使用晶体管传输实现多路复用器；</li>
<li>具有很大的导通电阻，并且存在相当大的电容负载；</li>
<li>随着FPGA迁移到较小的器件几何结构，这些问题可能会加剧；</li>
</ul>
<h2 id="FPGA新兴的应用趋势"><a href="#FPGA新兴的应用趋势" class="headerlink" title="FPGA新兴的应用趋势"></a>FPGA新兴的应用趋势</h2><p>解决计算问题：</p>
<ul>
<li>FPGA可用于实现软件的微处理器，例如Xilinx MicroBlaze或Altera Nios II</li>
<li>在某些应用中，FPGA具有并行性和最优性，因此对于某些应用而言，FPGA的速度显着提高；</li>
</ul>
<p>硬件加速：可以使用FPGA加速算法的某些部分，并在FPGA和通用处理器之间共享部分计算</p>
<ul>
<li>搜索引擎Bing，在2014年因采用FPGA加速作为其搜索算法而闻名；</li>
<li>截至2018年，FPGA越来越多地用作AI加速器，包括微软所谓的``Project Catapult’’以及加速用于机器学习应用的人工神经网络；</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-CAD Tools：Placement</title>
    <url>/2020/05/31/FPGA-technology/FPGA-CADTools-Routing/</url>
    <content><![CDATA[<p>主要介绍 FPGA 技术里 Routing 部分；</p>
<a id="more"></a> 
<h1 id="概述-FPGA-Routing"><a href="#概述-FPGA-Routing" class="headerlink" title="概述 FPGA Routing"></a>概述 FPGA Routing</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>一个过程，该过程确定应打开哪些可编程开关（Connections blocks 和 switch blocks），以连接电路所需的所有逻辑块输入和输出引脚。</p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/WhatRouting.png" alt="whatrouting">    </p>
<p>目的：</p>
<ul>
<li>必须用设备的互连资源，使 FPGA 中的逻辑集群良好连接，从而使电路正常工作</li>
</ul>
<p>方法:</p>
<ul>
<li>路由资源图（RRG）生成</li>
<li>路由算法</li>
</ul>
<p>目标:</p>
<ul>
<li>减少接线（wirelength 驱动）</li>
<li>最大化电路速度（timing 驱动）</li>
</ul>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>良好的路由至关重要，路由不正确会导致：</p>
<ul>
<li>导致最大运行速度降低</li>
<li>增加功耗</li>
<li>实施时间慢，甚至无法路由所有信号</li>
</ul>
<p>寻找一个好的路线是具有挑战性的：</p>
<ul>
<li>布线资源（电线和连接点）相对稀缺</li>
<li>信号将争夺相同的路由资源</li>
</ul>
<h2 id="Routing-结构"><a href="#Routing-结构" class="headerlink" title="Routing 结构"></a>Routing 结构</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingArchitecture.png" alt="RoutingArchitecture"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingResources.png" alt="RoutingResources"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/RoutingPath.png" alt="RoutingPath">    </p>
<h2 id="Routing-问题"><a href="#Routing-问题" class="headerlink" title="Routing 问题"></a>Routing 问题</h2><p>路由电路等效于在 RRG 中找到一组满足时序约束的不相交路径：</p>
<ul>
<li>路由资源图（RRG）G =（V，E）：是代表目标设备路由资源的主要数据结构</li>
<li>NP-complete 问题：NP 完全问题是无法以任何已知方式在多项式时间内求解</li>
</ul>
<p>相关术语：</p>
<ul>
<li>Input：<ul>
<li>电路里所有的 sources：$S=\{s_1,s_2,s_3,…,s_m\}$</li>
<li>电路里所有的 sinks：$T=\{T_1,T_2,T_3,…,T_m\}$，其中，$T_i=\{t_i^1,t_i^2,t_i^3,…,t_i^n\}$，代表了： $s_i$ 所通向的所有 sinks</li>
</ul>
</li>
<li>Solution：<ul>
<li>查找从每个 source $s_i$ 到 $T_i$ 中所有 sinks 的路径；</li>
<li>来自不同 source 的路径必须是不相交的（不能共享任何节点或边）；</li>
</ul>
</li>
</ul>
<p>约束关系：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Constraints.png" alt="Constraints"></p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>FPGA routing 一般经过三个步骤：RRG 生成、Global Routing、Detailed Routing  </p>
<ul>
<li>现代路由算法可以同时执行全局和详细路由；   </li>
</ul>
<p><strong>Routing Resource Graph (RRG) Generation</strong>：</p>
<ul>
<li>RRG 是表示 FPGA 全局路由架构的有向图；</li>
<li>在此图中，每条导线和每个逻辑块引脚成为一个节点，潜在连接变为边；</li>
</ul>
<p><strong>Global Routing</strong>：消除 congestions（拥堵）</p>
<ul>
<li>全局路由器执行<strong>粗路由</strong>，以确定每个连接必须通过的最小路由路径；</li>
<li>如果要路由的网络有两个以上的终端，则全局路由器会将网络分成一组两个终端的连接，并分别路由每个集合；</li>
<li>全局路由器为每个连接考虑多种路由方法，并选择通过最少拥塞路由路径的路由；</li>
<li>通过跟踪每个路由通道的使用情况，避免拥塞；并且实现了全局路由器的主要目标，即平衡路由通道的使用；</li>
<li>一旦所有连接都经过粗路由，就可以通过撕裂每个连接并重新路由几次来优化该解决方案；</li>
<li>之后，最终解决方案将传递到详细的路由器；</li>
</ul>
<p><strong>Detailed Routing</strong>：去分配 tracks/wires 和 switches</p>
<ul>
<li>细粒度</li>
<li>详细路由器为每两点连接，确定在全局路由器分配的路由通道中<strong>使用的特定布线段</strong>；</li>
<li>详细的路由算法将从路由资源中<strong>构造一个有向图</strong>，以表示 FPGA 中的 wires，C blocks，S blocks 和逻辑块之间的可用连接；</li>
<li>在此有向图上执行的搜索通常基于 <strong>Dijkstra 算法</strong>来找到两个节点之间的最短路径；</li>
<li>根据<strong>成本函数</strong>对路径进行标记，该成本函数考虑了每个线段的使用情况以及互连点的距离；</li>
<li>通过使用<strong>曼哈顿度量标准</strong>计算互连点边界框中的导线长度来估算距离；</li>
<li>大多数路由器<strong>放宽</strong>了对边界框的<strong>限制</strong>，并允许在边界框的周围路由通道中搜索可能的解决方案；<ul>
<li>这是为了避免，如果解决方案位于边界框的外部附近，则会导致后续的重复撕裂和重新路由；</li>
</ul>
</li>
</ul>
<h2 id="Route-结果"><a href="#Route-结果" class="headerlink" title="Route 结果"></a>Route 结果</h2><p>VTR 形式（.Route）：易读但不直观<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRForm.png" alt="VTRForm"></p>
<h1 id="RRG（Routing-Resource-Graph）"><a href="#RRG（Routing-Resource-Graph）" class="headerlink" title="RRG（Routing Resource Graph）"></a>RRG（Routing Resource Graph）</h1><h2 id="Circuit-到-Graph"><a href="#Circuit-到-Graph" class="headerlink" title="Circuit 到 Graph"></a>Circuit 到 Graph</h2><p>与 DAG 的 FPGA 映射不同，但也作为有向图：</p>
<ul>
<li>Node：wire / logic block pin</li>
<li>Edge：potential connection</li>
<li>Node Capacity：可以在合法路由中使用此节点的不同网络的最大数量</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/CircuitToGraph.png" alt="CircuitToGraph"></p>
<h2 id="LUT-的-inputs-等价"><a href="#LUT-的-inputs-等价" class="headerlink" title="LUT 的 inputs 等价"></a>LUT 的 inputs 等价</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/LUTInput.png" alt="LUTInput"></p>
<h2 id="软件表示"><a href="#软件表示" class="headerlink" title="软件表示"></a>软件表示</h2><h3 id="XML（eXtensible-Markup-Language）"><a href="#XML（eXtensible-Markup-Language）" class="headerlink" title="XML（eXtensible Markup Language）"></a>XML（eXtensible Markup Language）</h3><p>是在 VTR 里面使用的，一种具有可选属性的开始和结束标记的层次结构；</p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/XML.png" alt="XML"></p>
<h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><p>YAML 不是标记语言，是另一标记语言的递归形式，易于表示和阅读：   </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/YAML.png" alt="YAML"></p>
<h3 id="表示过程"><a href="#表示过程" class="headerlink" title="表示过程"></a>表示过程</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SoftwareTrans.png" alt="SoftwareTrans"></p>
<p>注意：每个供应商都有自己的 FPGA 架构形式和数据结构建立方法，这些形式不会向客户透露（属于公司的专有技术）</p>
<h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><h2 id="Maze（迷宫）路由"><a href="#Maze（迷宫）路由" class="headerlink" title="Maze（迷宫）路由"></a>Maze（迷宫）路由</h2><p>迷宫路由算法：</p>
<ul>
<li>基于波前扩展技术，该技术尝试在两点之间找到最短路径，同时避免使用任何路由资源；</li>
<li>一个迭代过程，该过程会撕裂并重新路由某些路由，以消除拥塞的路由通道；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze1.png" alt="Maze1"></p>
<p>主要缺点：它进行路由时不会考虑找到的路径会阻止后续网络的路由；</p>
<ul>
<li>这意味着算法的性能取决于网络排序，并且<strong>不同的顺序将产生不同的结果</strong>；</li>
<li>如果颠倒了下面两个网的布线顺序，则会找到更好的解决方案；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Maze2.png" alt="Maze2"></li>
</ul>
<h2 id="A-搜索路由"><a href="#A-搜索路由" class="headerlink" title="$A^*$ 搜索路由"></a>$A^*$ 搜索路由</h2><ul>
<li>迷宫路由是 $A^*$ 路由的特例；</li>
<li>$A^*$ 路由允许将路径搜索从广度优先搜索算法（BFS）调整为较短的深度优先搜索算法（DFS）；<ul>
<li>BFS 是一种详尽的搜索，它考虑了所有可能的路径，如果有任何路径，则会找到最佳路径，但缺点是速度可能很慢；</li>
<li>同时，DFS 可能找不到最小的成本路径，但可能很快；</li>
</ul>
</li>
</ul>
<p>$A^*$ 路由利用 0 到 1 之间的比例因子 α 进行加权，从而将搜索从 BFS 调整为 DFS；  </p>
<script type="math/tex; mode=display">f_i=(1-\alpha) \times (f_{i-1}+c_i)+\alpha \times d_i</script><ul>
<li>cost 用于评估每个节点 i 的有向图的成本函数：<ul>
<li>$c_i$ 是节点 cost，表示节点的当前使用情况，用于惩罚先前路由所占用的节点； </li>
<li>$f_{i-1}$是前一条路径的总成本；（函数的前半部分相当于 DFS）</li>
<li>$d_i$ 是从节点 i 到目的地的路径的估计成本；（函数的前半部分相当于 BFS）</li>
</ul>
</li>
</ul>
<h2 id="PathFinder-路由算法"><a href="#PathFinder-路由算法" class="headerlink" title="PathFinder 路由算法"></a>PathFinder 路由算法</h2><p>顾名思义，PathFinder 可在 RRG 中的两个节点之间找到路径：</p>
<ul>
<li>消除拥塞</li>
<li>最小化关键路径的延迟</li>
<li><strong>同时</strong>进行全局和详细路由</li>
<li>使用广泛：对 VTR 中使用的学术路由工具，进行了深入研究</li>
</ul>
<h3 id="知识概述"><a href="#知识概述" class="headerlink" title="知识概述"></a>知识概述</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathFinderOverview.png" alt="PathFinderOverview">    </p>
<p>RRG 里的 BFS：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/BFSInRRG.png" alt="BFSInRRG"></p>
<ul>
<li>每个正方形代表一个节点：S-source，T-sink，Number-cost</li>
</ul>
<p>逐一（source-sink）路由所有网络：</p>
<ul>
<li>为 RRG 中的每个边（可能的连接）分配取决于当前用法和历史用法的成本；</li>
<li>每个网络都由 BFS 路由，目的是使成本最低；</li>
<li>多个网络可能在 RRG 中使用相同的节点（导线/逻辑块）（标记为拥塞）；</li>
<li>于是，为拥塞节点分配更高的成本；</li>
<li>如果一条路由必须包含一个拥塞的节点，它将与其他路由“协商”，并使其绕过（翻录和重新路由）；</li>
</ul>
<p>重复固定时间：</p>
<ul>
<li>成功：为所有网络提供不相交的路由解决方案；</li>
<li>失败：经过固定次数（30）的迭代后，没有找到不相交的路由解决方案；</li>
</ul>
<h3 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h3><p><strong>Routability Cost Function</strong>：</p>
<ul>
<li>对于节点 n：<script type="math/tex; mode=display">Cost(n) = p(n)\ast[\ b(n)+h(n)\ ]</script></li>
<li>其中：<ul>
<li>$b(n)$：通过节点 n 进行路由的 <strong>Base Cost</strong>（基本成本）</li>
<li>$h(n)$：<strong>History Cost</strong>（历史成本），与通过节点 n 路由的历史成本有关（基于以前的路由器迭代）</li>
<li>$p(n)$：<strong>Penalty of congestion</strong>（拥塞处罚），与在当前迭代中通过节点 n 路由的网（信号）的数量有关</li>
</ul>
</li>
</ul>
<p><strong>Timing-Routability Cost Function</strong>：</p>
<ul>
<li>对每个结点 n：<script type="math/tex; mode=display">Cost(n) = Crit(i,j) \ast delay(n) + [\ 1-Crit(i,j)\ ] \ast p(n) \ast [\ b(n) + h(n)\ ]</script></li>
<li>其中：<ul>
<li>$delay(n)$：通过节点 n 的网络的延迟</li>
<li>$Crit(i,j) = 1- \frac{slack(i,j)}{D_{max}}$<ul>
<li>$Crit(i,j)$：从 source i 到 sink j 的路径的估计临界度</li>
<li>$D_{max}$：关键路径的延迟</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Congestion"><a href="#Congestion" class="headerlink" title="Congestion"></a>Congestion</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Congestion.png" alt="Congestion"></p>
<h3 id="Pseudo-Code"><a href="#Pseudo-Code" class="headerlink" title="Pseudo Code"></a>Pseudo Code</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PathfinderPseudoCode.png" alt="PathfinderPseudoCode"></p>
<h1 id="路由算法：VTR-Router"><a href="#路由算法：VTR-Router" class="headerlink" title="路由算法：VTR Router"></a>路由算法：VTR Router</h1><h2 id="Routability-driven-Router"><a href="#Routability-driven-Router" class="headerlink" title="Routability-driven Router"></a>Routability-driven Router</h2><h3 id="Cost-Function-1"><a href="#Cost-Function-1" class="headerlink" title="Cost Function"></a>Cost Function</h3><script type="math/tex; mode=display">PathFinder: Cost(n) = [\ b(n) + h(n)\ ] \times p(n)</script><script type="math/tex; mode=display">VTR Router:\ Cost(n)=b(n) \times h(n) \times p(n) + BendCost(n,m)</script><ul>
<li>$b(n)$，$h(n)$ 和 $p(n)$ 分别是节点 n 的基本成本，历史成本和拥塞惩罚（在PathFinder 算法中定义）；</li>
<li>$BendCost(n，m)$ 会对弯曲的全局路线造成不利影响，因为这些路线不太可能使用长导线，从而使详细（局部）路线难以实施（更容易发生拥塞）；<ul>
<li>如果建立从节点 m 到节点 n 的连接会产生弯曲，则 $BendCost(n，m)= 1$；</li>
<li>如果执行了组合的全局详细路由，则 $BendCost(n，m)= 0$；</li>
</ul>
</li>
<li>将 $b(n)$ 和 $h(n)$ 相乘可消除归一化；</li>
</ul>
<h3 id="Base-Cost"><a href="#Base-Cost" class="headerlink" title="Base Cost"></a>Base Cost</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Routing Resource，n</th>
<th>Base Cost，b(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wire segment</td>
<td>1</td>
</tr>
<tr>
<td>Logic block output pin</td>
<td>1</td>
</tr>
<tr>
<td>Logic block input pin</td>
<td>0.95</td>
</tr>
<tr>
<td>Source</td>
<td>1</td>
</tr>
<tr>
<td>Sink</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>五个 $b(n)$ 值中的四个约为 1，这鼓励路由器使用尽可能少的这些资源；</li>
<li>将逻辑块输入引脚的成本设置为略小于 1，可以使搜索更早地到达 terminal（inputs 和 sinks）；</li>
<li>将 sink 的成本设置为 0，因为在 sink 中不会发生拥塞；</li>
<li>通过这种方式为逻辑块 inputs 和 sinks 使用较低的成本，可使路由器速度提高 1.5 到 2 倍；</li>
<li>实验表明，将线段的 $b(n)$ 设置为 1 可获得最佳效果；</li>
</ul>
<h3 id="Penalty-of-Congestion"><a href="#Penalty-of-Congestion" class="headerlink" title="Penalty of Congestion"></a>Penalty of Congestion</h3><script type="math/tex; mode=display">p(n) = 1 + \max(0\ ,\ [\ occupancy(n) + 1 - capacity(n)\ ] \cdot p_{fac})</script><ul>
<li>$occupancy(n)$：使用资源（节点）n 的网络数；</li>
<li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/PenaltyExample.png" alt="PenaltyExample"></li>
<li>$p_{fac}$：routing schedule 之一；为了获得最高质量，第一次迭代时将其设置为 0.5，随后的每次迭代将其增加 1.5 倍至 2.0 倍；<ul>
<li>快速增加 $p_{fac}$ 会导致质量下降（想象一下，收取过多的交通拥堵费会导致没有人想要在城市开车）；</li>
</ul>
</li>
</ul>
<h3 id="History-Cost"><a href="#History-Cost" class="headerlink" title="History Cost"></a>History Cost</h3><script type="math/tex; mode=display">
{h(n)}^i=\begin{cases}
1,\quad i=1 \\\\
{h(n)}^{i-1}+\max(0,[occupancy(n)-capacity(n)]\cdot h_{fac}),\quad i>1
\end{cases}</script><ul>
<li>$occupancy(n)$：使用资源（节点）n 的网络数；</li>
<li>$Capacity(n)$：可以使用资源（节点）n 的最大网络数；</li>
<li>$h_{fac}$：routing schedule 之一；设置为常数，并且介于 0.2 到 1 之间的任何值都可以正常工作。</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/HistoryCostExample.png" alt="HistoryCostExample"></p>
<h3 id="Net-布线顺序"><a href="#Net-布线顺序" class="headerlink" title="Net 布线顺序"></a>Net 布线顺序</h3><p>按 fan-out 的降序排列网络，因为：</p>
<ol>
<li>高 fan-out 网络倾向于覆盖整个 FPGA<ul>
<li>在较早路由的其他网络拥塞较少的情况下，更易于路由</li>
</ul>
</li>
<li>低 fan-out 网络往往更局部化<ul>
<li>即使在某些拥挤的情况下，也相对容易布线</li>
</ul>
</li>
</ol>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/NetOrderExample.png" alt="NetOrderExample"></p>
<h3 id="算法加速：方案一"><a href="#算法加速：方案一" class="headerlink" title="算法加速：方案一"></a>算法加速：方案一</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeOneExample.png" alt="SchemeOneExample"></p>
<ul>
<li>在 source 和 sinks 周围定义一个边界框（<strong>bounding box</strong>）；</li>
<li>将每个网络的路由限制在边界框外不超过 3 个 channels；<ul>
<li>鼓励在 bounding box 里进行 routing；</li>
</ul>
</li>
<li>大大减少了 BFS 搜索时间（由于使用较少的 channels）；</li>
<li>对路由质量没有明显影响；</li>
</ul>
<h3 id="算法加速：方案二"><a href="#算法加速：方案二" class="headerlink" title="算法加速：方案二"></a>算法加速：方案二</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample.png" alt="SchemeTwoExample"><br>对于高扇出网络，重用部分路由会更有效；</p>
<ul>
<li>从波前局部的推进路由</li>
</ul>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeTwoExample2.png" alt="SchemeTwoExample2">   </p>
<h3 id="算法加速：方案三"><a href="#算法加速：方案三" class="headerlink" title="算法加速：方案三"></a>算法加速：方案三</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeThreeExample.png" alt="SchemeThreeExample"></p>
<h3 id="算法加速：方案四"><a href="#算法加速：方案四" class="headerlink" title="算法加速：方案四"></a>算法加速：方案四</h3><ul>
<li>无方向的 BFS 非常耗时；</li>
<li>引入了定向搜索（基于曼哈顿距离：source 到 sink 的距离）；</li>
</ul>
<p>但是，当障碍物是凹形的时：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SchemeFourExample.png" alt="SchemeFourExample"></p>
<ul>
<li>BFS 找到最佳路线，但很费时间；</li>
<li>Directed Search（贪婪）可节省时间，但可能找不到最佳路线；</li>
</ul>
<p>成本函数可适当平衡 BFS 和定向搜索（贪婪）:</p>
<script type="math/tex; mode=display">TotalCost(n)=PathCost(n)+ \alpha \cdot ExpectedCost(n,j)</script><ul>
<li>$PathCost(n)$：从当前部分路由树到节点 n 的路径总成本；</li>
<li>$ExpectedCost(n，j)$：从当前节点 n 到目标sink j 的估计成本；</li>
<li>$\alpha$：<ul>
<li>1 导致 $A^*$ 搜索；</li>
<li>1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li>
</ul>
</li>
</ul>
<h2 id="Timing-driven-Router"><a href="#Timing-driven-Router" class="headerlink" title="Timing-driven Router"></a>Timing-driven Router</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>相对于 “PathFinder” 的<strong>两个主要改进</strong>：</p>
<ol>
<li>在 <strong>Elmore 延迟估计</strong>下优化延迟，而不是线性延迟（在线性延迟中，每个路由资源都具有恒定的延迟）：<ul>
<li>对于任何在其路由中包含 pass transistors 的 FPGA 而言，线性延迟模型都是非常不准确的；</li>
</ul>
</li>
<li><strong>动态改变</strong>路由资源的基本成本：<ul>
<li>根据要路由的<strong>网络的跨度</strong>更改<strong>长 wire segments 的成本</strong>，以使路由器偏向于使用正确的路由资源类型（buffer 或 pass transistors）；</li>
</ul>
</li>
</ol>
<h3 id="等效电路"><a href="#等效电路" class="headerlink" title="等效电路"></a>等效电路</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/EquivalentCircuits.png" alt="EquivalentCircuits"><br>便于计算延迟；</p>
<h3 id="Elmore-延迟"><a href="#Elmore-延迟" class="headerlink" title="Elmore 延迟"></a>Elmore 延迟</h3><p>用于分布式 RC 效果；   </p>
<script type="math/tex; mode=display">ElmoreDelay_{source-sink}=\sum_{i\in(source-sink\ path)} C_i\ R_{i,sink}+T_{d,i}</script><ul>
<li>$T_{d,i}$：节点 i（缓冲区）的固有延迟；否则为 0；</li>
<li>$C_i$：节点 i 处金属和寄生电容的等效电容；</li>
<li>$R_{i,sink}$：<strong>source 到节点 i</strong> 和 <strong>source 到不带缓冲区的 sink</strong> 之间的共享路径上的等效电阻；<ul>
<li>公式表示：$R_{i,sink}=\sum R_{shared}$，其中，$R_{shared}\in [\ path(source-i) \cap path(source-sink)]$</li>
</ul>
</li>
</ul>
<p>计算示例（注意：结点 2、4 也属于 source 到 sink 路径上的结点）：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ComputingElmoreDelay.png" alt="ComputingElmoreDelay">    </p>
<p><strong>Case1：M wire segments 通过 buffers 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByBuffers.png" alt="ByBuffers"></p>
<ul>
<li>Buffer 的固有延迟：$T_{buf,intrinsic}=125ps$</li>
<li>Wire 的电阻：$R_{buf}=500 \Omega$</li>
<li>导线的金属电容和寄生电容：$C_{total}=250fF$</li>
<li>则，$T_{d,buffered}=M \cdot [\ T_{buf,intrinsic}+R_{buf}\cdot C_{total}\ ]=M \cdot 250\ (ps)$</li>
<li>在 buffer 这种情况下，Linear 和 Elmore 延迟模型相同；</li>
</ul>
<p><strong>Case2：M wire segments 通过 pass transistors 连接</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/ByPassTransistors.png" alt="ByPassTransistors"></p>
<ul>
<li>Pass transistor 的电阻：$R_{pass}=500 \Omega$</li>
<li>结点的电容：$C_{total}=250fF$</li>
<li>Linear：$T_{d,pass,linear}=M \cdot R_{pass} \cdot C_{total}=M \cdot 125(ps)$</li>
<li>Quadratic：$\sum^M_{i=1}\ i\cdot R_{pass} \cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot R_{pass}\cdot C_{total}=\frac{M\cdot(M+1)}{2}\cdot 125 (ps)$</li>
<li>在 pass transistor 的情况下，Linear 和 Elmore 延迟模型都有很大的不同；</li>
</ul>
<h3 id="具有-Elmore-延迟的-Cost-Function"><a href="#具有-Elmore-延迟的-Cost-Function" class="headerlink" title="具有 Elmore 延迟的 Cost Function"></a>具有 Elmore 延迟的 Cost Function</h3><p>考虑连接到 net i 的 sink j，包括节点 n 在内的 cost function 为：</p>
<script type="math/tex; mode=display">Cost(n)=Crit(i,j) \cdot T_{Elmore}(n,topology)+[\ 1-Crit(i,j)\ ]\cdot b(n)\cdot h(n)\cdot p(n)</script><p>其中：</p>
<ul>
<li>criticality 相当于一个权重因子，$Crit(i,j) = \max(\ [MaxCrit-\frac{slack(i,j)}{D_{max}}]^\eta,0\ )$<ul>
<li>$D_{max}$：电路关键路径的延迟</li>
<li>$Slack(i，j)$：网络 i 的 source 和 sink j 之间的连接松弛</li>
<li>$MaxCrit$ 和 $\eta$：控制松弛如何影响 拥塞-延迟 权衡的参数<ul>
<li>$MaxCrit = 1$ 和 $\eta= 1$：转换为 PathFinder 的情况</li>
<li>$\eta$ 是较大的：网络具有正松弛度，对延迟的关注较少，而对拥塞的关注更多</li>
<li>$MaxCrit = 1$：允许松弛为 0 的连接完全忽略拥塞</li>
<li>$MaxCrit = 0$：忽略延迟，使路由器完全由 routability 驱动</li>
<li>因此，将 MaxCrit 设置为 1 是危险的，根据经验，通常设置：$MaxCrit = 0.99，\eta= 1$</li>
</ul>
</li>
</ul>
</li>
<li>$b(n)$：当前结点 n 的 base cost</li>
<li>$h(n)$：当前结点 n 的 historical cost</li>
<li>$p(n)$：当前结点 n 的 congestion penalty cost</li>
<li>$T_{Elmore}(n，topology)$：Elmore 延迟，其中包含节点 n 以及信号向节点 n 传播的关联拓扑的函数；</li>
</ul>
<p>为了逐步计算将节点 n 添加到部分路由中而产生的 Elmore 延迟，我们需要知道上游电阻。则，定义：通过 routing switch 将其连接到节点 m 所达到的节点 n 的上游电阻为：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/Upstream.png" alt="Upstream"></p>
<script type="math/tex; mode=display">
R_{upstream}(n)=\begin{cases}
R(switch)+R_{metal}(n),\quad if\ switch\ is\ a\ tri-state\ buffer \\\\
R_{upstream}(m)+R(switch)+R_{metal}(n),\quad if\ a\ pass\ transistor
\end{cases}</script><p>定义 Elmore 延迟作为包含的节点 n 和信号向节点 n 传播的相关拓扑的函数：   </p>
<script type="math/tex; mode=display">T_{Elmore}(n,topology) = T_{d,intrinsic}(switch)+[\ R_{upstream}(n)-\frac{R_{metal}(n)}{2}\ ]\cdot C_{total}(n)</script><p>其中：</p>
<ul>
<li>$T_{d,intrinsic}(switch)$：通过 partial routing 到达节点 n 的 switch 的固有延迟；（对于 non-buffers，= 0）</li>
<li>$R_{upstream}(n)$：partial routing 的上游电阻，是通过 pass transistor switches 链而不是通过  buffered switches 链积累的；</li>
<li>$R_{metal}(n)$：路由资源节点 n 的金属电阻，对于所有非布线网段节点，金属电阻为 0；</li>
<li>$C_{total}(n)$：节点 n 处的总电容（金属加寄生开关电容）；</li>
<li>从 $R_{upstream}(n)$ 中减去 $R_{metal}(n)$ 的 1/2：表示金属电阻的分布</li>
</ul>
<h3 id="算法加速方案"><a href="#算法加速方案" class="headerlink" title="算法加速方案"></a>算法加速方案</h3><p>与 routability-driven router 相同：    </p>
<script type="math/tex; mode=display">TotalCost(n)=PathCost(n) + \alpha \cdot ExpectedCost(n,j)</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/SpeedEnhancement.png" alt="SpeedEnhancement">    </p>
<p>其中：</p>
<ul>
<li>$PathCost(n)$：从 source 到节点 n 的路径上每个节点的总成本，即：当 $Crit(i,j)=1$ 时，为 $T_{Elmore}(n,topology)$；</li>
<li>$ExpectedCost(n,j)$：从当前节点 n 到目标 sink j 的估计成本；</li>
<li>$\alpha$：为 1 导致 $A*$ 搜索；为 1.2（经验值）可在不影响质量的情况下获得最佳的 CPU 时间；</li>
</ul>
<h3 id="带有动态-Base-Cost-的-Cost-Function"><a href="#带有动态-Base-Cost-的-Cost-Function" class="headerlink" title="带有动态 Base Cost 的 Cost Function"></a>带有动态 Base Cost 的 Cost Function</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/DynamicBaseCostFunction.png" alt="DynamicBaseCostFunction"></p>
<p>完全用 pass transistors 相连的路由树：</p>
<ul>
<li>switches 往往会变得 heavily loaded，导致较大的延迟；</li>
</ul>
<p>尽可能趋向于使用  buffered switches，以便：</p>
<ul>
<li>最大化在以后的连接中重新使用其中一些接线的可能性；</li>
<li>最小化以后连接影响早期连接时间的可能性；</li>
</ul>
<script type="math/tex; mode=display">b_{pass\ transistor\ wires}(n)=AverageRoutingResourceDelay \cdot \sqrt{k-1}</script><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/KTerminals.png" alt="KTerminals"></p>
<ul>
<li>$k$：网络上的 terminals 数，$k\geq 2$； </li>
<li>$b_{pass\ transistor\ wires}(n)$：通过 pass transistors 连接到其他节点（线）的节点（线）n 的基本成本；<ul>
<li>通过 buffers：平均路由资源延迟</li>
<li>通过 pass transistors：延迟增加</li>
</ul>
</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Routing/VTRPseudoCode.png" alt="VTRPseudoCode"></p>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法（详解 + java 实现）</title>
    <url>/2020/06/04/DataStructure-Algorithm/SortingAlgorithm/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/header.png" width="100%" alt="header.png" /> </div>  

<p><strong>排序</strong>（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。而通常，为了查找方便，我们都会希望计算机的表是按关键字有序的。因此，熟练掌握排序算法是每一个程序猿的必备素养。</p>
<a id="more"></a> 
<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>首先，由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，我们会将排序算法分为两个大类：     </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类名</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>内部排序</td>
<td>（本文主要讨论的）待排序记录存放在计算机随机存储器中进行的排序过程；</td>
</tr>
<tr>
<td>外部排序</td>
<td>待排序记录的数量很大，以至于内存一次不能够容纳全部记录，在排序过程中尚需对外村进行访问的排序过程；</td>
</tr>
</tbody>
</table>
</div>
<p>在排序算法中，为了衡量每一种算法的性能，我们通常会提及如下概念：     </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>稳定排序</td>
<td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序；</td>
</tr>
<tr>
<td>非稳定排序</td>
<td>如果原顺序中 a 在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序；</td>
</tr>
<tr>
<td>原地排序</td>
<td>在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间来进行比较和交换，从而完成排序；</td>
</tr>
<tr>
<td>非原地排序</td>
<td>需要利用额外的数组来辅助排序；</td>
</tr>
</tbody>
</table>
</div>
<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ul>
<li><strong>依据排序原则可分为 5 大类</strong>：插入排序、交换排序、选择排序、归并排序、计数排序</li>
<li><strong>按算法时间分为 3 大类</strong>：简单排序 $O(n^2)$、先进排序 $O(nlogn)$、基数排序 $O(d \cdot n)$</li>
</ul>
<p>接下来介绍的各种排序算法都可以归入上述各个分类；</p>
<h2 id="规律总述"><a href="#规律总述" class="headerlink" title="规律总述"></a>规律总述</h2><p>排序过程中都会进行两种基本操作：</p>
<ol>
<li>比较两个关键字大小；（对大多数排序方法都是必要的）</li>
<li>将记录从一个位置移动到另一个位置；（可通过改变记录的存储方式来避免）</li>
</ol>
<p>待排序记录的 3 种存储方式：    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>存储方式</th>
<th>记录之间的次序关系</th>
<th>排序实现方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址连续的一组存储单元上（例如：线性表）</td>
<td>由存储位置决定</td>
<td>必须借助记录移动</td>
</tr>
<tr>
<td>（链表排序）静态链表中</td>
<td>指针指示</td>
<td>修改指针即可</td>
</tr>
<tr>
<td>（地址排序）记录本身存储在一组地址连续的存储单元内，同时又设一个指示各个记录存储位置的地址向量</td>
<td></td>
<td>先移动地址向量中记录的“地址”，排序结束后再按地址向量中的值调整记录的存储位置</td>
</tr>
</tbody>
</table>
</div>
<p>本文主要是介绍排序算法的思想，为方便讨论，默认所介绍的排序算法都是基于第一种存储方式，且待排序记录的关键字均为整数；</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>基于 “插入” 操作进行的排序方式；</p>
<h2 id="直接插入排序（Insertion-Sort）"><a href="#直接插入排序（Insertion-Sort）" class="headerlink" title="直接插入排序（Insertion Sort）"></a>直接插入排序（Insertion Sort）</h2><p><strong>基本操作</strong>：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</p>
<ul>
<li>整个过程可以理解为，打扑克牌时，你是怎样来捋扑克牌的顺序的？</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gInsertSort.gif" alt="InsertSort"></p>
<p><strong>缺点</strong>：无序数组排序时，为了插入元素，需要将其余所有元素在插入之前都向右移动一位；</p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的排序算法：直接插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="comment">// 开始 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">// 从当前位置向前寻找插入位置</span></span><br><span class="line">        <span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt;= <span class="number">0</span> &amp;&amp; arr[k] &gt; temp)</span><br><span class="line">            k--;</span><br><span class="line">        <span class="comment">//找到要插的位置 k + 1，移动元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i ; j &gt; k + <span class="number">1</span>; j--)</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">        arr[k+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>稳定排序，原地排序 </li>
</ul>
<h3 id="改进：折半插入"><a href="#改进：折半插入" class="headerlink" title="改进：折半插入"></a>改进：折半插入</h3><p><strong>基本思路</strong>：在直接插入排序的过程中，将 “搜索插入位置” 这一步骤利用 “折半查找实现”   </p>
<p><strong>评价</strong>：不可取，仅仅减少了直接插入排序中关键字间的比较次数，而记录的移动次数不变，时间复杂度仍为：$O(n^2)$。    </p>
<h3 id="改进：2-路插入"><a href="#改进：2-路插入" class="headerlink" title="改进：2-路插入"></a>改进：2-路插入</h3><p><strong>目标</strong>：减少排序过程中移动记录的次数    </p>
<p><strong>具体思路</strong>：</p>
<ul>
<li>假设，待排序数组为 L.r，新设一个同类型的数组 d；</li>
<li><code>d[0] = L.r[0]</code>，并将 <code>d[0]</code> 看做排好序的序列中处于中间位置的记录；</li>
<li>然后，从 <code>L.r[1]</code> 开始，依次插入到 <code>d[0]</code> 之前和之后的已排好序的有序表中</li>
<li>例子：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/2WayInsert.png" alt="2WayInsert"><ul>
<li>first 和 final 是两个指针，分别指向排序过程中得到的有序列表里第一个记录和最后一个记录在 d 中的位置；</li>
</ul>
</li>
</ul>
<p><strong>评价</strong>：不可取，带来了新的空间开销，也只是减少移动记录的次数（不能完全避免），并且如果 <code>L.r[0]</code> 就是待排序列表里最大或最小的元素，则此方法优越性完全失效；</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>采用插入排序，那么在排序过程中就不可避免的需要移动记录，否则，只能改变其存储结构（之前提及的：链式排序、地址排序）。</p>
<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>又称：缩小增量排序</p>
<p><strong>基本思想</strong>：先将整个待排记录序列分割为若干个子序列，对子序列分别进行直接插入排序，待整个序列的记录 “基本有序” 时，再对全体记录进行一次直接插入排序。    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gShellSort.gif" alt="ShellSort"></p>
<p><strong>过程举例</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/ShellSort.png" alt="ShellSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">//默认步长为数组长度除以2</span></span><br><span class="line">    <span class="keyword">int</span> step = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        step = step / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//确定分组数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;</span><br><span class="line">            <span class="comment">//对分组数据进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + step; j &lt; arr.length; j = j + step) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                <span class="keyword">int</span> k;</span><br><span class="line">                <span class="keyword">for</span>( k = j-step; k &gt;= <span class="number">0</span>; k = k-step)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                        arr[k+step] = arr[k];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k+step] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：与选取的 “增量” 序列函数直接相关，目前为止，没有人能找出最优的 “增量” 序列函数，上述算法中，复杂度为 $O(nlogn)$</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基于 “交换” 操作进行的排序方式；<strong>快排</strong>（Quick Sort）是基于<strong>冒泡排序</strong>（Bubble Sort）的一种改进排序算法。</p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p><strong>基本思想</strong>：第 i 趟冒泡排序，从 <code>L[0]</code> 到 <code>L[n-1-i]</code> 依次比较每个记录与其下一个记录的大小，并在 “逆序” 时交换这两个记录（最终结果是，这 n-i+1 个记录里，最大值被交换到 n-i 的位置）；完成整个排序过程，也就需要有 $k(1\leq k&lt;n)$ 趟，判断结束的条件为：某趟冒泡过程中不出现交换操作。</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBubbleSort.gif" alt="BubbleSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最优的冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j , k;</span><br><span class="line">    <span class="keyword">int</span> flag = a.length; <span class="comment">// flag记录每趟冒泡的尾边界，同时也作为算法结束的标志</span></span><br><span class="line">    <span class="comment">// 用 flag 标记算法是否结束</span></span><br><span class="line">    <span class="keyword">while</span> (flag &gt; <span class="number">0</span>)&#123; </span><br><span class="line">        k = flag;   <span class="comment">// k记录某趟遍历的尾边界</span></span><br><span class="line">        flag = <span class="number">0</span>;   <span class="comment">// 只要不发生交换，就不会进行下一趟冒泡，算法结束</span></span><br><span class="line">        <span class="comment">// 冒泡开始：</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="comment">//前面的数字大于后面的数字就交换a[j-1]和a[j]</span></span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">                <span class="comment">// 发生了交换，让flag重新记录新的尾边界</span></span><br><span class="line">                flag = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>稳定排序、原地排序</li>
</ul>
<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p><strong>基本思想</strong>：通过一趟排序将待排记录分割为独立的两部分，其中一部分的关键字均比另一部分的关键字小，再分别对这两部分进行排序，已达到整个序列有序的目的；</p>
<ul>
<li>设定两个指针 low 和 high，初始时指向开头和结尾位置；枢值记录关键字 key，初始为第一个元素值；</li>
<li>先从 high 指示位置向前搜索，找到第一个值小于 key 的记录，和 key 交换位置；</li>
<li>然后从 low 位置起向后搜索，找到第一个值大于 key 的记录，和 key 交换位置；</li>
<li>重复上面两步，直至 low=high；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gQuickSort.gif" alt="QuickSort">  </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span>(low &lt; index -<span class="number">1</span>)</span><br><span class="line">            quickSort(arr, low, index - <span class="number">1</span>); <span class="comment">//区间左右都是闭包</span></span><br><span class="line">        <span class="keyword">if</span> (high &gt; index + <span class="number">1</span>)</span><br><span class="line">            quickSort(arr, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排的非递归实现</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack; <span class="comment">//基于栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        stack.push(high);</span><br><span class="line">        stack.push(low);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> index = partition(a, l, h);</span><br><span class="line">            <span class="keyword">if</span> (l &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(index - <span class="number">1</span>);</span><br><span class="line">                stack.push(l);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h &gt; index + <span class="number">1</span>) &#123;</span><br><span class="line">                stack.push(h);</span><br><span class="line">                stack.push(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间函数：某一趟快排的实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//选择第一个元素作为枢纽</span></span><br><span class="line">    <span class="keyword">int</span> key = arr[low];</span><br><span class="line">    <span class="comment">// 将序列排列至枢纽两端</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//从high向前，找第一个小于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[high] &gt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//从low向后，找第一个大于key的值</span></span><br><span class="line">        <span class="keyword">while</span> (arr[low] &lt;= key &amp;&amp; high &gt; low)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在枢纽两端的元素位置都确定后，枢纽的位置也就确定了</span></span><br><span class="line">    arr[low] = key;</span><br><span class="line">    <span class="comment">// 返回枢纽位置，进行下一趟排序</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>空间复杂度：$O(logn)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h2><p><strong>主要思路</strong>：每一趟在 $n-i+1\ (i=1,2,…,n-1)$ 个记录中选取关键字最小的记录作为有序序列中第 i 个记录    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gSelectionSort.gif" alt="SelectionSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">// 共 n-1 轮选择排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从未排序的[i，n-1]的序列中，选择最小元素</span></span><br><span class="line">        <span class="keyword">int</span> min = i;  <span class="comment">//先默认a[i]是最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line">            <span class="keyword">if</span>(a[min] &gt; a[j])  <span class="comment">//找到更小的值，就更新</span></span><br><span class="line">                min = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换，使最小的元素位于a[i]位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[min];</span><br><span class="line">        a[min] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n^2)$</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
</ul>
<h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p><strong>目的</strong>：减少比较的次数</p>
<p><strong>理论基础</strong>：竞标赛比赛机制</p>
<ul>
<li>8 名运动员选出前 3 名，最多只需要 11 场比赛；</li>
<li>第一轮：7 场比赛决出冠军</li>
<li>第二轮：2 场比赛决出亚军</li>
<li>第三轮：2 场比赛决出季军</li>
</ul>
<p><strong>详情</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/TreeSelectSort.png" alt="TreeSelectSort"></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>缺点：所需的辅助空间太大、和最大值进行了多余的比较；</li>
<li>于是，进一步改进为：堆排序算法</li>
</ul>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><strong>堆</strong>：一个完全二叉树里，每个结点的值都大（小）于其左右孩子（如果存在的话）节点的值，则称这样的二叉树为大（小）顶堆    </p>
<p><strong>堆排特点</strong>：只需要一个记录大小的辅助空间，每个待排序的记录只占有一个存储空间   </p>
<p><strong>基本思想</strong>：</p>
<ul>
<li>初始建堆：<ul>
<li>将序列按层次遍历看成是一个完全二叉树，则最后一个非终端节点是第 $\lfloor n/2 \rfloor$ 个元素；</li>
<li>因此，从第 $\lfloor n/2 \rfloor$ 个元素开始，往前对每个结点，反复 “下沉” 调整：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/BuildHeap.png" alt="BuildHeap"></li>
</ul>
</li>
<li>循环删除，下沉：<ul>
<li>删除堆顶，把删除的元素放在二叉树最后一个位置；</li>
<li>“下沉” 调整；<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/Sink.png" alt="Sink"></li>
</ul>
</li>
</ul>
<p><strong>过程展示</strong>：<br><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gHeapSort.gif" alt="HeapSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 堆排序</span></span><br><span class="line"><span class="comment">*  下沉操作，执行删除操作相当于把最后</span></span><br><span class="line"><span class="comment">*  * 一个元素赋给根元素之后，然后对根元素执行下沉操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parent 要下沉元素的下标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="comment">// 从最后一个非终端节点开始，不断往前下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(arr, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶元素与最后一个元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// 把打乱的堆进行调整，恢复堆的特性</span></span><br><span class="line">        downAdjust(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆调整：下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临时保存要下沉的元素</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[parent];</span><br><span class="line">    <span class="comment">//定位左孩子节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//开始下沉，需一直下沉至堆底</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= n) &#123;</span><br><span class="line">        <span class="comment">// 如果右孩子节点比左孩子大，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="comment">// 如果孩子节点小于或等于父节点，则下沉结束</span></span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt;= temp ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 父节点进行下沉</span></span><br><span class="line">        arr[parent] = arr[child];</span><br><span class="line">        parent = child;</span><br><span class="line">        child = <span class="number">2</span> * parent + <span class="number">1</span>; <span class="comment">//更新孩子，继续下沉</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[parent] = temp; <span class="comment">//下沉完毕，完成交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$，时间主要浪费在初始建堆和堆调整时的下沉操作上</li>
<li>空间复杂度：$O(1)$</li>
<li>非稳定排序、原地排序</li>
<li>适用情景：对记录较少的文件并不提倡，但对 n 较大的文件还是很有效的；</li>
</ul>
<h1 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h1><p><strong>基本思路</strong>：（2-路归并）假设初始序列含有 n 个记录，则可以看成 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 $\lceil \frac{n}{2} \rceil$ 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止；</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gMergeSort.gif" alt="MergeSort">   </p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序（递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//递归地对左右两边进行排序</span></span><br><span class="line">        MergeSort(arr, low, mid);</span><br><span class="line">        MergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序（非递归形式）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nonRec_MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 1开始分割，与递归不同的是，递归由数组长度一分为二最后到1，</span></span><br><span class="line">    <span class="comment">// 而非递归则是从1开始扩大二倍直到数组长度 </span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;	    </span><br><span class="line">    <span class="keyword">while</span> (arr.length &gt; len) &#123;    </span><br><span class="line">        <span class="comment">// 完全二叉树一层内的遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt;= arr.length - <span class="number">1</span>; i += len * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> mid = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = i + len * <span class="number">2</span> - <span class="number">1</span>;	            </span><br><span class="line">            <span class="comment">// 防止超出数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; arr.length - <span class="number">1</span>)</span><br><span class="line">                right = arr.length - <span class="number">1</span>;	            </span><br><span class="line">            <span class="comment">// 合并排序相同</span></span><br><span class="line">            merge(arr, left, mid, right);</span><br><span class="line">        &#125;	        </span><br><span class="line">        <span class="comment">// 下一层</span></span><br><span class="line">        len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间函数：merge</span></span><br><span class="line"><span class="comment">// 将两个有序数组合并成一个有序数组；</span></span><br><span class="line"><span class="comment">//    arr[low,mif]表示一个数组，arr[mid+1,high]表示一个数组</span></span><br><span class="line"><span class="comment">// 因为数组有序，合并只要维护几个指针即可；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// temp 数组用于暂存合并的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//左半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="comment">//右半边的指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//合并后数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将记录由小到大地放进 temp 数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">        temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">        arr[low + l] = temp[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(nlogn)$</li>
<li>空间复杂度：$O(n)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h1><p><strong>适用场景</strong>：最大值和最小值的差值不是不是很大的排序</p>
<p><strong>基本思想</strong>：把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。    </p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gCountingSort.gif" alt="CountingSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中间数组，存放arr里各元素出现的次数</span></span><br><span class="line">    <span class="comment">//为节约内存空间，从0开始编号（0对应min），最后一个元素max-min（对应max）</span></span><br><span class="line">    <span class="keyword">int</span> help[] = <span class="keyword">new</span> <span class="keyword">int</span>[max-min+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mapPos = arr[i] - min;</span><br><span class="line">        help[mapPos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        <span class="comment">//把help某个位置对应的所有值全部输出（重复值）</span></span><br><span class="line">        <span class="keyword">while</span>(help[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++] = i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n+k)$，k 表示临时数组大小</li>
<li>空间复杂度：$O(k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h1><p><strong>基本思想</strong>：把最大值和最小值之间的数进行瓜分（例如分成 5 个区间，5 个区间对应 5 个桶），然后，把各元素放到对应区间的桶中去，再对每个桶中的数进行排序（可以采用前面提过的排序算法）。之后每个桶里面的数据就是有序的了，最后再进行合并汇总；</p>
<p><strong>适用场景</strong>：数据基本呈均匀分布的情况，这样才能保证各个桶里的数据量基本相同，不至于浪费 “桶” 所带来的时间和空间开销；</p>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gBucketSort.gif" alt="BucketSort"></p>
<p><strong>问题</strong>：桶排序是怎样优化性能的？</p>
<ul>
<li>举个例子：<ul>
<li>我们假设有 100 个待排序的呈均匀分布的数，如果我们直接采用冒泡排序（时间复杂度为 $O(n^2)$），那么我们的时间开销将在 $100^2=10000$ 量级上；</li>
<li>现在，我们采用桶排序，划分出 10 个桶，因为数据呈均匀分布，那么每个桶里也就是 10 个数据，在每个桶里再单独进行冒泡排序，将 10 个桶都排好序的时间开销也就是  $10^2 \times 10=1000$ 量级上，即使算上桶划分、桶合并的时间，也远远低于 10000；</li>
</ul>
</li>
<li>经过这个例子，应该也就基本了解桶排序的优势所在，用普遍的数学公式表示：<ul>
<li>假设有 n 个数据，采用某种排序方式（时间复杂度为$O(n^i)$），这样直接排序的时间开销也就是：$n^i$</li>
<li>现在，我们分为 k 个桶进行桶排序，桶内仍然采用同样的排序算法:<ul>
<li>如果原数据呈均匀分布，那么时间开销也就是：$({\frac{n}{k})}^i \times k + f(k,n)= \frac{n^i}{k^{i-1}} + f(k,n)$，其中，$f(k,n)$ 为划分桶和合并桶的时间开销，它是一个和 k，n 有关的一阶函数，可以暂且忽略不考虑，将时间开销定为：$\frac{n^i}{k^{i-1}}$，对比 $n^i$，优势就很明显了；</li>
<li>那如果数据不呈均匀分布，我们考虑极端的情况，也就是这 n 个数据全部被分到 k 个桶里的同一个，那么现在的时间开销也就是：$n^i + f(k,n)$，对比 $n^i$，也就没了任何优势，并且还带来额外的时间、空间上的开销；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//桶划分</span></span><br><span class="line">    <span class="comment">// 定义桶数</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>; </span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将每个元素放入桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min) / (arr.length); <span class="comment">//某个元素所属桶号</span></span><br><span class="line">        bucketArr.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每个桶进行排序（排序算法也可以自己定义）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//System.out.println(bucketArr.toString());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把每个桶排序好的数据进行合并汇总放回原数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer t : bucketArr.get(i)) &#123;</span><br><span class="line">            arr[k++] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(n+k)$，k 表示桶个数</li>
<li>空间复杂度：$O(n+k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h1><p>是一种借助多关键字排序的思想（“分配” 和 “收集” 两种操作）对单逻辑关键字进行排序的方法；有两种排序方式：最高位优先（MSD）、最低位优先（LSD）   </p>
<p><strong>基本思想</strong>：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位，最终得到的序列就是一个有序序列；</p>
<ul>
<li>在具体到某一位的排序时，是利用 “桶” 排序来实现的。数据的某一位取值情况为：0-9，需要 10 个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照 0 号桶到 9 号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/SortingAlgorithm/gRadixSort.gif" alt="RadixSort"></p>
<p><strong>java 实现源码</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radioSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值位数num</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每位数值从0-9，10 种取值，创建 10 个桶 </span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 初始化桶，是一个两层的嵌套动态链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从个位数开始，循环，对每一位排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取每个数最后第 i 位是数组</span></span><br><span class="line">            <span class="keyword">int</span> radio = (arr[j] / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放进对应的桶里</span></span><br><span class="line">            bucketList.get(radio).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并放回原数组</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : bucketList.get(j)) &#123;</span><br><span class="line">                arr[k++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出来合并了之后把桶清光数据</span></span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>评价</strong>：</p>
<ul>
<li>时间复杂度：$O(kn)$，k 表示最大数位数</li>
<li>空间复杂度：$O(n+k)$</li>
<li>稳定排序、非原地排序</li>
</ul>
<h1 id="排序算法对比分析"><a href="#排序算法对比分析" class="headerlink" title="排序算法对比分析"></a>排序算法对比分析</h1><div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最好时间</th>
<th>最坏时间</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(nlogn)$</td>
<td></td>
<td></td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n^2)$</td>
<td>$O(logn)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n^2)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(n \times k)$</td>
<td>$O(n \times k)$</td>
<td>$O(n \times k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
</div>
<p>注意：以上时间复杂度，供参考，有些算法还需要根据具体情况实际分析；</p>
<p><strong>总结</strong>：</p>
<ul>
<li>从平均时间性能上看，快排是最优选择，但是其最坏情况下性能不如堆排和归并排序。对后两者来说，如果 n 较大，选择归并排序更省时，但是比较废空间；</li>
<li>直接插入排序时最简单的排序，当记录数较少，或基本有序时，是最佳选择。因此，它也常和其他排序方式结合使用；</li>
<li>一般来说，排序过程中的 “比较” 在 “相邻的两个记录关键字” 间进行的排序方法是文档的；稳定性由方法本身决定，总能找出反例；如果排序按主关键字进行，那么算法稳定性不重要，但如果按次关键字进行，则需要重点考虑；</li>
<li>因此，排序算法没有好坏之分，要根据实际情况选择最合适的方法；</li>
<li>经研究表明：所有借助于 “比较” 进行排序的算法在最坏情况下能达到的最好的时间复杂度为：$O(nlogn)$</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>『<a href="https://www.cnblogs.com/kubidemanong/p/10404197.html" target="_blank" rel="noopener">十大排序算法，看这篇就够了(附完整代码/动图/优质文章)</a>』</li>
<li>《数据结构（c语言版）》—-严蔚敏、吴伟民 编著</li>
<li>另：文中动图均来源网络，最终出处没能找到，如原作者看到，可联系我加入参考地址</li>
</ul>
]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Clock Network</title>
    <url>/2020/04/10/FPGA-technology/FPGA-ClockNetwork/</url>
    <content><![CDATA[<p>介绍 FPGA 里时钟信号的产生与传输；</p>
<a id="more"></a> 
<h1 id="分布式时钟网络"><a href="#分布式时钟网络" class="headerlink" title="分布式时钟网络"></a>分布式时钟网络</h1><h2 id="时钟分布式网络构成"><a href="#时钟分布式网络构成" class="headerlink" title="时钟分布式网络构成"></a>时钟分布式网络构成</h2><p>时钟分配网络由金属走线和缓冲器组成，将时钟信号传播到所有时钟元件：</p>
<ul>
<li>使用中继器缓冲时钟信号并均衡延迟；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockDistributionNetwork.png" alt="Clock Distribution Network"></p>
<h2 id="PLL（Phase-Locked-Loop，锁相环）"><a href="#PLL（Phase-Locked-Loop，锁相环）" class="headerlink" title="PLL（Phase Locked Loop，锁相环）"></a>PLL（Phase Locked Loop，锁相环）</h2><p><mark>PLL（锁相环）</mark>作为时钟发生器，是所有时钟信号的来源；   </p>
<h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/PLL.png" alt="PLL"></p>
<h3 id="PLL-基本频率的可编程性"><a href="#PLL-基本频率的可编程性" class="headerlink" title="PLL 基本频率的可编程性"></a>PLL 基本频率的可编程性</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/BasicFrequency.png" alt="basic frequency">   </p>
<p>PLL 增强了频率可编程性:<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/EnhancedFrequencyProgrammability.png" alt="enhanced frequency programmability"></p>
<h2 id="两种时钟生成方式"><a href="#两种时钟生成方式" class="headerlink" title="两种时钟生成方式"></a>两种时钟生成方式</h2><h3 id="基于-PLL-的时钟生成"><a href="#基于-PLL-的时钟生成" class="headerlink" title="基于 PLL 的时钟生成"></a>基于 PLL 的时钟生成</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/PLLBasedClockGeneration.png" alt="PLL based clock generation"></p>
<ul>
<li>宽频率合成范围</li>
<li>精细分辨率的相位选择</li>
<li>有效降低抖动</li>
</ul>
<h3 id="基于-DLL-的时钟生成"><a href="#基于-DLL-的时钟生成" class="headerlink" title="基于 DLL 的时钟生成"></a>基于 DLL 的时钟生成</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/DLLBasedClockGeneration.png" alt="DLL based clock generation"><br>DCM (Digital Clock Manager)，即：数字时钟管理器，提供：</p>
<ul>
<li>DLL（Delay Lock Loop）：延迟锁定循环</li>
<li>DFS（Digital Frequency Synthesis）：数字频率合成</li>
<li>DPS（Digital Phase Shifter）：数字移相器</li>
</ul>
<h2 id="Clock-uncertainty"><a href="#Clock-uncertainty" class="headerlink" title="Clock uncertainty"></a>Clock uncertainty</h2><p><mark>Clock uncertainty</mark>：$\Delta = skew \pm jitter$   </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockUncertainty.png" alt="Clock uncertainty"></p>
<h3 id="Clock-skew"><a href="#Clock-skew" class="headerlink" title="Clock skew"></a>Clock skew</h3><p>定义：每个触发器的时钟到达时间的确定性差异    </p>
<p>产生原因：主要是由于时钟树/网格的不平衡引起的；（Buffering 时钟信号可以减少但不能消除 skew）；    </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockSkew.png" alt="Clock skew"></p>
<h3 id="Clock-jitter"><a href="#Clock-jitter" class="headerlink" title="Clock jitter"></a>Clock jitter</h3><p>定义：每个触发器的时钟到达时间的确定性或随机性差异；     </p>
<p>产生原因：由管芯上的工艺，电源噪声，温度变化，PLL 抖动，串扰等引起；    </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockJitter.png" alt="Clock jitter"></p>
<h2 id="时钟分布拓扑结构"><a href="#时钟分布拓扑结构" class="headerlink" title="时钟分布拓扑结构"></a>时钟分布拓扑结构</h2><p>主要有两种结构：<code>tree-based structure</code>、<code>grid/mesh-based structure</code>   </p>
<p>对于同步操作，时钟到达时钟控制的元件，必须满足如下要求：</p>
<ul>
<li>极低的时钟 <code>skew（偏斜）</code>：<ul>
<li>确保最小的内部 hold-time 问题</li>
</ul>
</li>
<li>低时钟 <code>jitter（抖动）</code>：<ul>
<li>允许最高性能</li>
</ul>
</li>
<li>占空比保持：<ul>
<li>对双倍数据速率（DDR）应用非常重要</li>
</ul>
</li>
<li>低插入延迟：<ul>
<li>对同步输入和输出接口很重要</li>
</ul>
</li>
</ul>
<h3 id="基于树的结构"><a href="#基于树的结构" class="headerlink" title="基于树的结构"></a>基于树的结构</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/TreebasedStructure.png" alt="Tree-based structure"></p>
<ul>
<li>广泛应用于 ASICs（专用集成电路，Application Specific Integrated Circuits）；</li>
<li>要保证时钟信号同时送往每个末梢；</li>
<li>优点：<ul>
<li>在接线、电容、功耗上，低开销；</li>
<li>易于进行时钟门控（不用时，可以随时关闭）；</li>
</ul>
</li>
<li>缺点：<ul>
<li>FF 分布不均等导致难以平衡路径延迟（难以保证时钟信号同时到达末梢）；</li>
<li>对 PVT（过程，电压，温度）变化敏感；</li>
</ul>
</li>
</ul>
<h3 id="基于网格-网格的结构"><a href="#基于网格-网格的结构" class="headerlink" title="基于网格/网格的结构"></a>基于网格/网格的结构</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/Mesh-basedStructure.png" alt="Mesh-based structure"></p>
<ul>
<li>结构特点：<ul>
<li>$n \times n$ 的均匀网格；</li>
<li>由 $k \times k$ 个 buffers 组成的分布式数组驱动网格;</li>
<li>Buffers 由全局 H 树驱动;</li>
<li>Flip-flops 触发器直接连接到最近的网格段;</li>
</ul>
</li>
<li>用于现代微处理器；</li>
<li>优点：<ul>
<li>非常适合低 skew（偏斜：时钟到达不同位置的时差）；</li>
<li>强大的变化能力；</li>
</ul>
</li>
<li>缺点：<ul>
<li>更大的布线面积，大的负载电容，更多的功耗；</li>
<li>难以分析：循环和冗余</li>
</ul>
</li>
</ul>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/AllTopologies.png" alt="All Topologies"> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Topologies</th>
<th>应用</th>
<th>特点</th>
<th>Advantage</th>
<th>Disadvantage</th>
</tr>
</thead>
<tbody>
<tr>
<td>H-tree</td>
<td>Altera, Stratix</td>
<td>树状的高度对称的架构</td>
<td>可提供出色的时钟偏斜控制</td>
<td>需要更多的路由资源来实现所需的对称性；<br>更大的插入延迟；</td>
</tr>
<tr>
<td>Rip-spine</td>
<td>Xilinx, Virtex 4~7</td>
<td>包含类似于鱼骨头的主网络和子网络</td>
<td>易于实现</td>
<td>子分支中存在较大的时钟偏斜</td>
</tr>
<tr>
<td>Hybrid</td>
<td>Altera, Stratix V</td>
<td>H-树和 Rip-spine 结构的结合；<br>将 H-tree 作为主网络，将 Rip-spine 作为子网络；</td>
<td>综合</td>
<td>综合</td>
</tr>
</tbody>
</table>
</div>
<p><mark>最坏情况下的偏斜约为数百皮秒；</mark>     </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockNetworkRange.png" alt="clock network范围"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制范围</th>
<th>特点</th>
<th>优点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Global clock network</td>
<td>时钟驱动整个芯片</td>
<td></td>
</tr>
<tr>
<td>Regional clock network</td>
<td>时钟仅适用于他们进入的特定区域</td>
<td>较低的时钟插入延迟和偏斜</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三个网络阶段"><a href="#三个网络阶段" class="headerlink" title="三个网络阶段"></a>三个网络阶段</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/FirstStage.png" alt="first stage"><br>时钟网络的第一级以可编程方式将芯片外围的时钟源连接到每个区域的中心:</p>
<ul>
<li>第一阶段包括两个并行网络：一个用于全局时钟，一个用于本地时钟</li>
<li>将全局时钟信号总数表示为：$W_{global}$</li>
<li>全局时钟网络从每一侧的每个 $\frac{n_{source}}{4}$ 个潜在时钟源中选择 $\frac{W_{global}}{4}$ 个信号</li>
<li>所有 $W_{global}$ 信号均通过专用线路路由到芯片中心</li>
</ul>
<p>优势：由于信号源均来自芯片外围，因此信号源与芯片中心之间的连接几乎不会或根本不会产生偏斜;</p>
<ul>
<li>在某些来源来自芯片内部的架构中，可以调整驱动器的大小以使歪斜最小化</li>
</ul>
<p>通过带有 ny_region 肋的脊柱和肋骨分配网络，从芯片的中心开始将所有 $W_{global}$ 时钟分配到所有区域的中心；    </p>
<p>尽管 H 型树拓扑具有较低的偏斜度，但将这种拓扑网格划分到具有任意行数和列数的平铺 FPGA 上更加困难；</p>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/SecondStage.png" alt="Second stage"><br>时钟网络第二级以可编程方式将时钟信号从每个区域的中心连接到该区域内的逻辑块：</p>
<ul>
<li>每个第二级网络的输入均由第一级的 $W_{global}$ 全局时钟和 $W_{local}$ 本地时钟组成：<ul>
<li>这些时钟使用脊柱和肋骨拓扑分布</li>
<li>脊柱包含 $W_{global}+W_{local}$ 导线</li>
</ul>
</li>
<li>在每一行中，都使用 concentrator（集中器）网络从脊柱中选择任意一组 $W_{rib}$ clocks：<ul>
<li>这些时钟通过局部肋骨分配到该行中的逻辑块</li>
</ul>
</li>
<li>行中的每个逻辑块都通过另一个集中器网络连接到肋，集中器再从肋骨中选择任意一套 $W_{lb}$ 时钟</li>
</ul>
<h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ThirdStage.png" alt="Third stage"><br>最后，第三级网络将 $W_{lb}$ 逻辑块时钟可编程地连接到逻辑块内的 N 个 logic elements:</p>
<ul>
<li>为了给群集工具提供灵活性，我们假设逻辑块的时钟引脚使用完整的交叉网络连接到逻辑元件（在该逻辑块内）的时钟引脚；<ul>
<li>因此，N 个逻辑元素中的任意一个都可以由任意 $W_{lb}$ 个逻辑块时钟提供时钟</li>
</ul>
</li>
<li>注意：这只是时钟网络中使用完整  crossbars（交叉开关）的阶段，其他阶段使用集中器交叉开关来减少开关数量；</li>
</ul>
<hr>
<h1 id="时钟网络中的功耗降低"><a href="#时钟网络中的功耗降低" class="headerlink" title="时钟网络中的功耗降低"></a>时钟网络中的功耗降低</h1><p>时钟网络由于其<strong>高扇出和切换频率</strong>而在FPGA中占很大一部分功耗。   </p>
<ul>
<li>约占 FPGA 总功率的 20-39％：<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/DynamicPower.png" alt="Dynamic Power">  </li>
</ul>
<p>主要是两种技术：<code>by spine reduction</code>、<code>by clock gating</code></p>
<h2 id="逻辑块的功耗感知布局"><a href="#逻辑块的功耗感知布局" class="headerlink" title="逻辑块的功耗感知布局"></a>逻辑块的功耗感知布局</h2><p>“功耗感知布局”：一种以功耗为导向的布局方法，来减少 spines 的数目；</p>
<ul>
<li>减少时钟网络上的互连资源使用</li>
<li>考虑优化时钟功耗的布局</li>
</ul>
<p>“脊柱减少”：</p>
<ul>
<li>将相同时钟的 CLB 放在一起；<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/SpineReduction.png" alt="Spine Reduction"></li>
<li>实际例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/MoreExample.png" alt="more example">  </li>
</ul>
<p>将时钟功耗添加到成本函数中：</p>
<ul>
<li>$Cost = \alpha \cdot WireLength + \beta \cdot ClockPower$</li>
<li>WireLength：两个 CLB 之间互连线的长度；</li>
<li>通常交换 CLB 时，spines 减少了，但是 WireLength 长度也会随之增加（时钟功率的降低是以增加电线段数为代价的）；</li>
<li>通过 Trade off 得到 minimum cost：spine reduction 60%，WireLength increase 4%</li>
</ul>
<h2 id="Clock-gating"><a href="#Clock-gating" class="headerlink" title="Clock gating"></a>Clock gating</h2><p>主要思想：在设计中为那些空闲区域禁用时钟，以最大程度地减少信号转换，从而减少动态功耗；     </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockGatedCircuit.png" alt="clock gated circuit">   </p>
<p>已广泛用于 VLSI（超大规模集成）的电源优化；    </p>
<p>固定式预制时钟互连网络：<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockGatingArchitecture.png" alt="Clock gating architecture">     </p>
<p>进一步精细化划分：<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/FinegrainedArchitecture.png" alt="Fine-grained architecture">    </p>
<p>实验结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>不同Gating style的结构</th>
<th>描述</th>
<th>功耗降低%<br>limited gating</th>
<th>功耗降低%<br>substantial gating</th>
</tr>
</thead>
<tbody>
<tr>
<td>NONE</td>
<td>No gating</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>CG REGION</td>
<td>Gating on a regional basis</td>
<td>-0.8</td>
<td>6.6</td>
</tr>
<tr>
<td>CG COLUMN</td>
<td>Gating on half-columns in regions</td>
<td>0.8</td>
<td>7.7</td>
</tr>
<tr>
<td>FG REGION</td>
<td>Gating on a sub-region</td>
<td>-1.4</td>
<td>6.2</td>
</tr>
<tr>
<td>FG COLUMN</td>
<td>Gating on quarter-columns in sub-regions</td>
<td>1.1</td>
<td>6.7</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>limited gating（有限的门控）：大部分区域资源被使用</li>
<li>substantial gating（大量门控）：大部分区域资源闲置</li>
</ul>
<p>Enable 实现方式 VS. Clock Gating 实现方式：<br><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/EnableImplementationChoices.png" alt="Enable implementation choices"></p>
<ul>
<li>比较这些功率值，仅当 $\alpha_A+ \alpha_B &lt; 1$ 时才应选择选项 ＃1。否则，我们应该使用 ungated 的时钟;</li>
</ul>
<p>门控时钟主要用在 ASIC（专用集成电路），<mark>为什么在FPGA设计中不建议使用时钟门控？</mark></p>
<ul>
<li>因为时钟门控将逻辑放在 FPGA 内部的时钟网络上；</li>
<li>时钟具有自己优化的低偏斜总线，在时钟源和时钟线之间引入逻辑将导致欺骗斜总线无法轻松使用；</li>
</ul>
<p>例子：Virtex V</p>
<ul>
<li>全局时钟缓冲器（BUFGs）从外部或内部源接收时钟信号，并将这些信号馈入专用的全局时钟互连网络：<ul>
<li>全局时钟互连网络以低偏斜，低抖动和低功耗在整个 FPGA 中分配时钟信号；</li>
<li>每个芯片包含32个全局时钟缓冲器，因此可以支持设计中存在 32 个全局时钟信号；</li>
<li>架构上的限制限制了设备上每个触发器都具有 32 个单独的全局时钟信号的可能性；</li>
<li>时钟区域高 20 个CLB，水平跨过 Virtex-5 芯片的一半；</li>
<li>最多 10 个全局时钟信号可以馈入任何给定区域；</li>
<li>一个区域内的 10 个全局时钟可以从设计中存在的（最多）32 个全局时钟信号中的任何一个中选择；</li>
</ul>
</li>
<li>Virtex-5 内置的两种时钟使能机制可用于实现时钟门控：<ul>
<li>SLICE 内的寄存器具有时钟使能引脚，允许以精细的粒度实现时钟使能；<ul>
<li>SLICE 中的所有寄存器必须接收相同的时钟使能信号；</li>
</ul>
</li>
<li>将时钟信号驱动到专用时钟互连网络中的全局时钟缓冲器（BUFG）具有使能引脚<ul>
<li>当 BUFG 与启用一起使用时，称为 BUFGCE；</li>
<li>使能引脚可以由来自 I/O 的信号或内部信号驱动；</li>
<li>取消使能时，BUFG 驱动的时钟网络将变为静音，并且不会消耗任何动态功率；</li>
</ul>
</li>
<li>一个主要的观察结果是：<ul>
<li>使用 SLICE 上的时钟使能引脚并不能消除全局时钟网络上的切换，因此不能节省全局时钟网络上的动态功耗；</li>
<li>但是，使用 BUFG 上的时钟使能引脚将停止在 BUFG 驱动的全局时钟网络上的所有切换；</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="时钟网络的设计"><a href="#时钟网络的设计" class="headerlink" title="时钟网络的设计"></a>时钟网络的设计</h1><h2 id="拓扑建模"><a href="#拓扑建模" class="headerlink" title="拓扑建模"></a>拓扑建模</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/TopologyModeling.png" alt="Topology Modeling">  </p>
<p>FPGA 本身几何分布的参数：</p>
<ul>
<li>$n_x$：BLK 列的数目</li>
<li>$n_y$：BLK 行的数目</li>
<li>$N$：每个逻辑块的逻辑元素（LE）数</li>
</ul>
<p>FPGA 时钟网络的参数：</p>
<ul>
<li>$n_{x_region}$：X 维时钟区域数目</li>
<li>$n_{y_region}$：Y 维时钟区域数目</li>
<li>$n_{source}$：潜在时钟源的数量</li>
<li>$W_{glb}$：一次可传送到 fabric 的 global 时钟数目</li>
<li>$W_{loc}$：一次可传送到 fabric 的 local 时钟数目</li>
<li>$W_{rib}$：一次可以路由到一个区域的一行中的所有逻辑块的时钟数目</li>
<li>$W_{lb}$：可以连接到每个逻辑块的时钟数目</li>
<li>$W_{le}$：可以连接到 LE 的时钟数目</li>
</ul>
<h2 id="时钟网络组件"><a href="#时钟网络组件" class="headerlink" title="时钟网络组件"></a>时钟网络组件</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/ClockNetworkComponents.png" alt="Clock network components"></p>
<ul>
<li>Spine-Rib switch</li>
<li>Rib-LB switch</li>
<li>LB-LE switch</li>
<li>clock buffers</li>
</ul>
<p>正是因为这些 switchs，实现了时钟网络的可编程性；</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="面积和功耗-vs-W-lb"><a href="#面积和功耗-vs-W-lb" class="headerlink" title="面积和功耗 vs. $W_{lb}$"></a>面积和功耗 vs. $W_{lb}$</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/vsWlb.png" alt="vs. Wlb"></p>
<h3 id="面积和功耗-vs-W-rib"><a href="#面积和功耗-vs-W-rib" class="headerlink" title="面积和功耗 vs. $W_{rib}$"></a>面积和功耗 vs. $W_{rib}$</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-ClockNetwork/vsWrib.png" alt="vs. Wrib"></p>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-CLB-Architecture</title>
    <url>/2020/03/23/FPGA-technology/FPGA-CLB-Architecture/</url>
    <content><![CDATA[<p>详细介绍 PFPGA 的逻辑集模块；</p>
<a id="more"></a> 
<h1 id="总体认识"><a href="#总体认识" class="headerlink" title="总体认识"></a>总体认识</h1><p>FPGA Tiles &amp; Fabrics<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/FPGATilesFabrics.png" alt="FPGATilesFabrics"></p>
<p>FPGA 的基本组件，能提供逻辑和存储功能;    </p>
<p>CLB包含通过本地路由网络连接的 <mark>BLEs 群集</mark>;   </p>
<p>每一个 BLE 又包括：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/BLE.png" alt="BLE"></p>
<ul>
<li>逻辑元素（LUT）</li>
<li>存储元件（D-FlipFlop，Latch，RAM）</li>
<li>加法器和进位逻辑</li>
</ul>
<p>芯片上可配置处理元件的粒度:</p>
<ol>
<li>细粒度（按位操作，如逻辑门、LUT 等）</li>
<li>粗粒度（按字节操作，如 BRAM、DSP 块等）</li>
</ol>
<h1 id="CLB-的四种配置方式"><a href="#CLB-的四种配置方式" class="headerlink" title="CLB 的四种配置方式"></a>CLB 的四种配置方式</h1><p>CLB配置的四种方式：NAND gate based、PAL style wide input gate based、Multiplexor based、Look-Up Table (LUT) based</p>
<h2 id="NAND-gate-based"><a href="#NAND-gate-based" class="headerlink" title="NAND gate based"></a>NAND gate based</h2><p>受限于工业标准（FPGA设计中尽量使用制成同一种门，来降低工艺复杂性），于是所有逻辑功能只能由“与非”门实现；    </p>
<p>理论基础：De Morgan的定律，所有逻辑功能都可以通过一系列NAND操作表示；</p>
<ul>
<li>摩根定律：$\overline{A\cup B} = \overline A \cap \overline B$、$\overline{A\cap B} = \overline A \cup \overline B$</li>
</ul>
<p>例子：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ExampleNAND.png" alt="ExampleNAND"></p>
<p>FPGA 具体实现工艺：</p>
<ul>
<li>基于 NAND 的门阵列：预制晶体管（与非门）、通过金属连接、仅定制金属化层<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/GateArray.png" alt="GateArray"></li>
</ul>
<h2 id="PAL-style-wide-input-gate-based"><a href="#PAL-style-wide-input-gate-based" class="headerlink" title="PAL style wide input gate based"></a>PAL style wide input gate based</h2><p>理论基础：布尔规范表达式：乘积之和/和的乘积<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/PAL.png" alt="PAL"></p>
<p>设计思想：利用Programmable switch来组合电路，由可编程元件（显示为保险丝）将真实输入和互补输入都连接到与门，这些“与”门（也称为乘积项）进行“或”运算以形成乘积和逻辑阵列。其示意图：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/PALStyle.png" alt="PALstyle"></p>
<p>PAL种类的逻辑块架构：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/PALArchi.png" alt="PAL架构"></p>
<h2 id="Multiplexor-based"><a href="#Multiplexor-based" class="headerlink" title="Multiplexor based"></a>Multiplexor based</h2><p>理论基础：香农扩展定理，任何逻辑函数都能被扩展成 bool 变量</p>
<ul>
<li>香农扩展定理：$F = (A + \overline A) \cdot F = A \cdot F + \overline A \cdot F$</li>
<li>例子：<ul>
<li>$F = A \cdot B + \overline B \cdot C + D = B \cdot (A \cdot B + \overline{B} \cdot C + D) + \overline{B} \cdot (A \cdot B + \overline{B} \cdot C + D)=A \cdot B +B \cdot D + \overline{B} \cdot C + \overline{B} \cdot D=B\cdot(A+D)+\overline{B} \cdot (C+D)$</li>
<li>其中：$F_1 = A+D$ , $F_2=C+D$</li>
</ul>
</li>
</ul>
<p>与或非、异或的实现：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/AndOrNotXnot.png" alt="与或非、异或"></p>
<p>应用举例及其逻辑结构：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/MultiplexorCLB.png" alt="Multiplexor CLB"></p>
<p>Actel’s ACT-1 FPGA：</p>
<ul>
<li>使用反熔丝来编程；</li>
<li>每个逻辑模块包含三个2：1-MUX，在最终MUX的选择上具有OR逻辑；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ACT-1.png" alt="ACT-1"><br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ACT-1-transistor.png" alt="ACT-1-晶体管">   </li>
<li>$C1 = SA \cdot A1+ \overline{SA} \cdot A0$，$C0 = SB \cdot B1+ \overline{SB} \cdot B0$；$Y = (S0+ S1) \cdot C1+ \overline{S0+ S1}\cdot C0$</li>
<li>可以实现全部 2 个输入功能，最多3个输入和许多 4 个输入功能；</li>
<li>对布线要求比较高；</li>
<li>低延迟，但功能受限；</li>
</ul>
<h2 id="Look-Up-Table-LUT-based"><a href="#Look-Up-Table-LUT-based" class="headerlink" title="Look-Up Table (LUT) based"></a>Look-Up Table (LUT) based</h2><p><mark>大多数商用 FPGA 使用基于 LUT 的 CLB</mark>,基于 LUT 的 CLB 包含一组本地互连的 BLE；   </p>
<p><mark>查找表（LUT）</mark>：一组多路复用器，用于评估存储在SRAM单元中的真值表</p>
<ul>
<li>在配置FPGA时，也就是填写其真值表输出值，称为<mark>“LUT-Mask”</mark>，实际上是由 SRAM 位组成的</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/LUTBased.png" alt="LUT based"></p>
<h3 id="Look-Up-Table"><a href="#Look-Up-Table" class="headerlink" title="Look-Up Table"></a>Look-Up Table</h3><p>一个k输入LUT包含$2^k$个SRAM单元和$(2^k-1)$个2：1多路复用器；延迟取决于关键路径长度；   </p>
<p>LUT用于实现逻辑函数发产生器，k输入LUT可以实现k变量的任何布尔函数：   </p>
<p>逻辑结构：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/LUT.png" alt="LUT"></p>
<p>LUT中逻辑函数的实现:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/MinimumMapping.png" alt="minimum mapping"></p>
<ul>
<li>这样就引入了一个问题 minimum mapping，怎样去找一个最优的映射方案？</li>
<li>一个 k 输入 LUT 可以分解为两个（k-1）输入 LUT 复用在一起</li>
</ul>
<p><mark>最佳策略：LUT 大小为 4 至 6，簇大小为 3-10，这为 FPGA 提供了最佳的面积延迟产品</mark></p>
<h3 id="Fracturable（可拆分）-LUT"><a href="#Fracturable（可拆分）-LUT" class="headerlink" title="Fracturable（可拆分） LUT"></a>Fracturable（可拆分） LUT</h3><p>在先进的Altera FPGA产品（也称为<mark>ALM：Adaptive Logic Module自适应逻辑模块</mark>）中可用；    </p>
<p>目的：提高逻辑资源的利用率<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/FLUT8inVs3.png" alt="FLUT 8-in vs 3"></p>
<ul>
<li>用延迟换资源利用率</li>
</ul>
<p>Fracturable LUT（FLUT） 是一种 LUT，可以由一些具有部分共享输入的较小尺寸的 LUT 来实现；</p>
<ul>
<li>目标：在保持较小 LUT 的面积效率的同时，获得较大 LUT 的延迟优势</li>
<li>优点：大的LUT尺寸、延迟小、高效率</li>
</ul>
<p>Traditional LUT vs Fracturable LUT：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/VsFLUT.png" alt="vs FLUT"></p>
<ul>
<li>更灵活，可以分为两个独立的 LUT</li>
</ul>
<p><span id = "anchor">Stratix II中的ALM</span>（自适应逻辑模块）结构:</p>
<p>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/StratixII-ALM.png" alt="Stratix II-ALM"></p>
<ul>
<li>8 输入 FLUT，包含两个 4-LUT 和两个 4-FLUT，可以实现最多 6 个输入和一定数量的 7 个输入功能的任何功能</li>
<li>六种不同的 ALM 操作模式：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/6Model.png" alt="6 model"></li>
<li>在 ALM 里再嵌入加法器：（虽然 8-input FLUT 可实现加法，但是这样能加快计算）<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/StratixII-ALM-2.png" alt="Stratix II-ALM-2"></li>
</ul>
<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><p>带有快速进位链的专用加法器：</p>
<ul>
<li>使用LUT进行加减法会导致速度慢和区域效率低下；于是，逻辑块中包含1位加法器，以加快算术运算速度</li>
<li>进位链：连接相邻逻辑模块的快速路由路径。它能在专用的1位加法器之间提供快速进位功能</li>
</ul>
<p>基本原理图示：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ArithmeticOperation.png" alt="Arithmetic Operation"></p>
<h2 id="加法和进位逻辑（Xilinx-FPGA中）"><a href="#加法和进位逻辑（Xilinx-FPGA中）" class="headerlink" title="加法和进位逻辑（Xilinx FPGA中）"></a>加法和进位逻辑（Xilinx FPGA中）</h2><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/XilinxFPGAArchi.png" alt="Xilinx FPGA-Ari"></p>
<h2 id="进位选择逻辑（Intel-Altera-FPGA中）"><a href="#进位选择逻辑（Intel-Altera-FPGA中）" class="headerlink" title="进位选择逻辑（Intel / Altera FPGA中）"></a>进位选择逻辑（Intel / Altera FPGA中）</h2><ul>
<li>每个单元格都会预先计算求和与进位，进位 = 1 和进位 = 0；</li>
<li>进位选择使用哪种预计算；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/CarrySelectLogic.png" alt="Carry Select logic"></li>
</ul>
<h1 id="商业-FPGA-中主流产品的-CLB"><a href="#商业-FPGA-中主流产品的-CLB" class="headerlink" title="商业 FPGA 中主流产品的 CLB"></a>商业 FPGA 中主流产品的 CLB</h1><h2 id="Xilinx’s-Virtex-SLICE"><a href="#Xilinx’s-Virtex-SLICE" class="headerlink" title="Xilinx’s Virtex SLICE"></a>Xilinx’s Virtex SLICE</h2><p>包含 4 个切片，CLB 中具有快速的本地反馈；   </p>
<p>每个 Slice 均可配置为执行以下功能（可配置出这些功能，但不是加油这么多电路结构）：</p>
<ul>
<li>两个 4 输入 LUT</li>
<li>两个 16 位移位寄存器（SRL）</li>
<li>两个 16 位分布式 RAM 存储器</li>
<li>多路复用器（MUX）</li>
<li>一个2 位乘法器</li>
</ul>
<p>每个 Slice 还具有：</p>
<ul>
<li>快速提前进位逻辑</li>
<li>算术逻辑</li>
</ul>
<p>slice 中的专用逻辑功能：</p>
<ul>
<li>Multiplexer Logic：连接切片和 LUT</li>
<li>Carry Chains：加速算术运算</li>
<li>Shift Register LUT：基于 LUT 的移位寄存器</li>
<li>Multiplier AND gate：将乘法运算放在 LUT 里，加速基于 LUT 的乘法</li>
</ul>
<p>Multiplexer Logic：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/MultiplexerLogic.png" alt="Multiplexer Logic"></p>
<p>Carry Chains:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/CarryChains.png" alt="Carry Chains"></p>
<ul>
<li>专用的异或门，用于单和运算</li>
<li>专用多路复用器用于单进位操作</li>
<li>专用路由资源</li>
<li>所有综合工具都可以推断进位逻辑</li>
</ul>
<p>LUT-based Shift Register (SRLC16):<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/SRLC8.png" alt="SRLC8"></p>
<ul>
<li>原理：数据放在 LUT 里不变，A0、A1、A2 受 clk 影响来改变值（相当于改变地址），一次读取 SRAM 里的内容，进而在逻辑上实现 shift。</li>
<li>可动态寻址的串行移位寄存器</li>
<li>每个 LUT 的最大延迟为 16 个时钟周期（每个 CLB 为 128 个）</li>
<li>可级联至其他LUT或CLB，以获得更长的移位寄存器</li>
<li>从 MC15 到下一个 SRLC16 的 D 输入的专用连接</li>
<li>可以通过切换地址 A 异步更改移位寄存器的长度</li>
</ul>
<p>Multiplication:</p>
<ul>
<li>早期的 FPGA 每位需要两个 LUT 来执行乘法和加法</li>
<li>MULT_AND 门通过在一个 LUT 里执行每位的乘加运算来实现面积减小<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/Multiplication.png" alt="Multiplication"></li>
</ul>
<h2 id="Altera’s-Stratix-ALM"><a href="#Altera’s-Stratix-ALM" class="headerlink" title="Altera’s Stratix ALM"></a>Altera’s Stratix ALM</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/AlteraStratixALM.png" alt="Altera’s Stratix ALM"></p>
<p>ALM 功能资源:</p>
<ul>
<li>两个或四个可编程寄存器</li>
<li>8 输入 FLUT</li>
<li>两个专用的全加法器</li>
<li>Register chain</li>
</ul>
<p>LAB 架构：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/LAB.png" alt="LAB"></p>
<p>四种工作模式：</p>
<ul>
<li>Normal mode（普通模式）：实现通用逻辑应用程序和组合功能</li>
<li>Extended LUT mode（扩展的 LUT 模式）：可实现一组特定的七输入功能</li>
<li>Arithmetic mode（算术模式）：实现加法器，计数器，累加器，宽奇偶校验功能和比较器</li>
<li>Shared arithmetic mode（共享算术模式）：实现三位加法器</li>
</ul>
<h3 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h3><p>（参考：<a href="#anchor">Stratix II中的ALM</a>）可以在一个 ALM 中实施：</p>
<ol>
<li>一种具有 6 个输入的完整功能</li>
<li>3〜5 个输入的两种完整功能</li>
<li>8 种输入的三种完整功能</li>
</ol>
<p>来自 LAB 本地互连的最多八个数据输入已连接到 ALM；   </p>
<p>在一个 ALM 中实现两个六个输入功能的情况下，必须共享四个输入；   </p>
<p>通过将无关的寄存器和组合逻辑打包到一个ALM中，提高了设备利用率：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/RegisterPackingInALM.png" alt="Register packing in ALM"></p>
<h3 id="Extended-LUT-Mode"><a href="#Extended-LUT-Mode" class="headerlink" title="Extended LUT Mode"></a>Extended LUT Mode</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ExtendedLUTMode.png" alt="Extended LUT Mode"></p>
<ul>
<li>某些7输入功能可以通过扩展 LUT 模式实现</li>
<li>集合必须是 2 对 1 多路复用器，由两个任意的五个输入功能共享四个输入</li>
</ul>
<h3 id="Arithmetic-Mode"><a href="#Arithmetic-Mode" class="headerlink" title="Arithmetic Mode"></a>Arithmetic Mode</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/ArithmeticMode.png" alt="Arithmetic Mode"></p>
<ul>
<li>ALM使用两组两个 4 输入 LUT 来实现两个专用的全加法器；</li>
<li>加法器的存在释放了 LUT，以便它们可以执行预加逻辑；</li>
</ul>
<h3 id="Shared-Arithmetic-Mode"><a href="#Shared-Arithmetic-Mode" class="headerlink" title="Shared Arithmetic Mode"></a>Shared Arithmetic Mode</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/SharedArithmeticMode.png" alt="Shared Arithmetic Mode"></p>
<ul>
<li>可以在相邻 LUT 之间实现 2 功能加法；</li>
<li>用四个 4 输入 LUT 配置 ALM；</li>
<li>包含一个称为共享算术链的专用连接；</li>
<li>一种实现 3〜4 位加法器的有效方法；$y=d0+d1+d2$ 或者 $y=d0+d1+d2+d3$</li>
</ul>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-Architecture/Example3bitAddALMs.png" alt="Example3bitAddALMs"></p>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Hard Blocks</title>
    <url>/2020/03/25/FPGA-technology/FPGA-HardBlocks/</url>
    <content><![CDATA[<p>介绍 FPGA 里常见的硬件模块；</p>
<a id="more"></a> 
<p>异构的 FPGA 体系结构，其 Hard Blocks 包括：</p>
<ul>
<li>Memory blocks （BRAMs）</li>
<li>Multipliers （DSPs）</li>
<li>Clock generators，时钟发生器 （PLLs）</li>
<li>Transceivers（SerDes）：收发器，在 I/O 里</li>
</ul>
<h1 id="Embedded-SRAM"><a href="#Embedded-SRAM" class="headerlink" title="Embedded SRAM"></a>Embedded SRAM</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/EmbeddedSRAM.png" alt="EmbeddedSRAM"></p>
<p>组成：</p>
<ul>
<li>SRAM cell array</li>
<li>Precharge circuit </li>
<li>Decoder</li>
<li>W/R controller</li>
<li>Sense amplifier/Write driver</li>
</ul>
<h2 id="SRAM-cell"><a href="#SRAM-cell" class="headerlink" title="SRAM cell"></a>SRAM cell</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/SRAMcell.png" alt="SRAMcell"> </p>
<ul>
<li>读写都是读 0 写 0 的强传输；</li>
</ul>
<h2 id="SRAM-array"><a href="#SRAM-array" class="headerlink" title="SRAM array"></a>SRAM array</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/SRAMarray.png" alt="SRAMarray"></p>
<h2 id="Dual-port-BRAM"><a href="#Dual-port-BRAM" class="headerlink" title="Dual-port BRAM"></a>Dual-port BRAM</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/DualportBRAM.png" alt="DualportBRAM">  </p>
<p>双端口有时候会存在一个问题：</p>
<ul>
<li>当两个端口同时写一个位置时，如果电路中没有想过的冲突解决电路，就需要认为的给两个端口的写操作设置延迟；</li>
</ul>
<h2 id="BRAM在HDL中的实现"><a href="#BRAM在HDL中的实现" class="headerlink" title="BRAM在HDL中的实现"></a>BRAM在HDL中的实现</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/InferBRAMHDL.png" alt="InferBRAMHDL"></p>
<h1 id="DSP-Block"><a href="#DSP-Block" class="headerlink" title="DSP Block"></a>DSP Block</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/DSPBlock.png" alt="DSPBlock">    </p>
<p>组成：</p>
<ul>
<li>A multiplier block，乘法器块</li>
<li>An adder/subtractor/accumulator block，加法器/减法器/累加器块</li>
<li>A summation block，求和块</li>
<li>An output interface，输出接口</li>
<li>Output register，输出寄存器</li>
<li>Routing and control signals，路由和控制信号</li>
</ul>
<p>特点：</p>
<ul>
<li>Dedicated Multiplier：省去了必须使用 lut 来实现乘法，从而提高了性能</li>
<li>Parallel Multiplication：不同于传统 DSP 的串行进位计算逻辑，FPGA 采用并行计算，以空间换取了时间上的性能</li>
<li>Programmable Multiplication：不同乘法模式之间的速度/面积权衡<br><img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/SpeedAreaTradeoff.png" alt="SpeedAreaTradeoff"></li>
</ul>
<h1 id="SerDes"><a href="#SerDes" class="headerlink" title="SerDes"></a>SerDes</h1><p>认识：</p>
<ul>
<li>SerDes：SERializer（并-&gt;串）/DESerializer（串-&gt;并），它是一个将并行数据转换为串行数据的收发器，反之亦然。</li>
<li>是一种时分复用和点对点串行通信技术；</li>
</ul>
<p>Chip-to-Chip Signaling Trends：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/SignalingTrends.png" alt="SignalingTrends"></p>
<p>信道传输电路模型：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/Model.png" alt="model"></p>
<p>收发器框图:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-HardBlocks/TransceiverBlockDiagram.png" alt="TransceiverBlockDiagram"></p>
<p>一些高速串行协议：</p>
<ul>
<li>例如常说的：HSSL 高速串行接口</li>
<li>大多数产品只支持一种协议；而基于 Altera Stratix GX 的板支持所有这些协议；</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-CLB-DesignMethodology</title>
    <url>/2020/03/23/FPGA-technology/FPGA-CLB-DesignMethodology/</url>
    <content><![CDATA[<p>介绍 FPGA 逻辑集群的设计方法；</p>
<a id="more"></a> 
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>它实际上是在下面三个问题中的权衡，也就是我们常说的：<mark>Trade-off</mark></p>
<ol>
<li>LUT 的最优尺寸是多少？</li>
<li>一个 logic block 的输入 input 应该有多少个？</li>
<li>一个 logic block 应该有多少个 LUTs？</li>
</ol>
<h1 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h1><p>调查 FPGA 架构对芯片面积、速度和功耗的影响，确定设计的参数是：</p>
<ul>
<li>cluster size (N) of Logic Cluster (BLEs 的数量)</li>
<li>input number (I) of Logic Cluster (from routing channels)</li>
<li>input number (K) of LUT</li>
</ul>
<h1 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/approach.png" alt="approach">   </p>
<p><strong>Try-Measure-&amp;-Compare</strong>：一种研究和探索不同 FPGA 架构的经验方法；       </p>
<p><strong>Measure Model</strong>：area evaluation、speed evaluation、power evaluation</p>
<p><strong>Benchmark circuits</strong>：一组标准设计，代表各个 FPGA 终端市场的可能应用；</p>
<h2 id="FPGA-CAD-Computer-Aided-Design-Flow"><a href="#FPGA-CAD-Computer-Aided-Design-Flow" class="headerlink" title="FPGA CAD (Computer-Aided Design) Flow"></a>FPGA CAD (Computer-Aided Design) Flow</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/FPGACAD.png" alt="FPGACAD">    </p>
<p>常用软件：<strong>VTR (Verilog To Routing)</strong>   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CAD Flow</th>
<th>Tool</th>
</tr>
</thead>
<tbody>
<tr>
<td>Elaboration</td>
<td>Odin II</td>
</tr>
<tr>
<td>Logic Synthesis Tech Mapping</td>
<td>ABC</td>
</tr>
<tr>
<td>Packing、Placement、Routing</td>
<td>VPR</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ODIN II：是 VTR 流程的 HDL 编译器。它将给定的 Verilog 代码转换为 BLIF 电路，执行代码和电路优化，可视化电路，并将逻辑部分映射到给定架构的可用硬块。而且，它可以模拟电路的执行，以进行验证以及功率，性能和热量分析。ODIN II由the University of New Brunswick维护。<ul>
<li>BLIF（伯克利逻辑交换格式）以文本形式描述逻辑级分层电路。</li>
</ul>
</li>
<li>ABC 通过执行逻辑优化和技术映射来优化 BLIF 电路。ABC 由加州大学伯克利分校维护</li>
<li>多功能布局和路线（VPR）是 VTR 的最终组成部分。它的输入是 BLIF 电路，它在输入 FPGA 架构上打包，放置和布线。 VPR 由多伦多大学开发。</li>
</ul>
<p>FPGA 架构建模：</p>
<ul>
<li>描述特定的 FPGA 架构，包括：<ul>
<li>Basic Blocks: LUT, flip-flop, memory…</li>
<li>Interconnects: switch, wire segment</li>
<li>Delay information</li>
<li>Power specification</li>
<li>Clocks</li>
<li>Inter-block Connections</li>
</ul>
</li>
<li>VTR 使用基于 XML 的体系结构描述语言来描述 FPGA 体系结构（XML：可扩展标记语言）<ul>
<li>XML 是一种标记语言，它定义了一组规则，用于以人类和机器可读的格式对文档进行编码。<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/ExampleFPGAArchiDescription.png" alt="ExampleFPGAArchiDescription"></li>
</ul>
</li>
</ul>
<h2 id="Benchmark-circuits"><a href="#Benchmark-circuits" class="headerlink" title="Benchmark circuits"></a>Benchmark circuits</h2><p>Benchmark circuits：HDL 中的一组应用程序，代表了 FPGA 产品的某些目标市场；   </p>
<p>Benchmarks for traditional FPGA：</p>
<ul>
<li>VPR</li>
<li>MCNC (Microelectronics Center of North Carolina)</li>
<li>IWLS (International Workshop on Logic &amp; Synthesis) 2005</li>
<li>PREP (Programmable Electronics Performance Corporation)</li>
</ul>
<p>Benchmarks for Hybrid（混合）-FPGA：</p>
<ul>
<li>Benchmark for FPGA-based DSP systems<ul>
<li>BDTI communications</li>
<li>MediaBench</li>
</ul>
</li>
<li>Benchmark for FPGA-based biological systems<ul>
<li>OpenFPGA .org</li>
<li>BLAST</li>
</ul>
</li>
<li>Benchmark for FPGA-based embedded systems (SoCs)<ul>
<li>EEMBC</li>
<li>MiBench</li>
</ul>
</li>
</ul>
<h2 id="Measure-Model"><a href="#Measure-Model" class="headerlink" title="Measure Model"></a>Measure Model</h2><h3 id="Area-model"><a href="#Area-model" class="headerlink" title="Area model"></a>Area model</h3><p>一种流行的面积模型：是基于计算实现 FPGA 所需的最小宽度晶体管面积的数量；</p>
<ul>
<li>最小宽度晶体管面积：最小（最小长度和宽度）晶体管所占的布局面积，加上与另一个晶体管的最小间距<br><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/MinimumArea.png" alt="MinimumArea"></li>
</ul>
<p>例子：四输入 LUT 所需面积<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/4InputLUT.png" alt="4InputLUT"></p>
<ul>
<li>16 SRAM cells:<ul>
<li>$2^4 \times 6 = 96$ transistors</li>
</ul>
</li>
<li>15 Muxes:<ul>
<li>$(2^4-1) \times 2 = 30$ transistors</li>
</ul>
</li>
<li>20 equivalent minimum sized inverter buffers（反向器）:<ul>
<li>$20 \times 2 = 40$ transistors</li>
</ul>
</li>
<li>最小transistor个数：$A_{LUT} = A_{SRAM} + A_{MUX} + A_{buffer} = 96+30+40 = 166$</li>
</ul>
<p>FPGA的面积效率:</p>
<ul>
<li>给定一组目标benchmark circuits:$B_i$</li>
<li>给定一组FPGA架构:$F_j$</li>
<li>每个benchmark circuits $B_i$ 综合到架构 $F_j$，然后测量所需的结果区域并将其标记为$A_{i,j}$:<ul>
<li>$A_{i,j} = N_{i,j} \times {LR}_{i,j}$</li>
<li>$N_{i,j}$：在体系结构 $F_j$ 上实现电路 $B_i$ 所需的逻辑块数</li>
<li>${LR}_{i,j}$：去实现那些 blocks 时，所需的 logic block 区域和周围布线区域的面积总和</li>
</ul>
</li>
<li>FPGA 的面积效率可以定义为：针对特定架构的<strong>通过所有benchmarks $B_i$ 的 $A_{i,j}$ 的几何平均值值</strong>：<ul>
<li>Area efficiency：$F_j = (\prod_{B_i} A_{i,j})^{\frac{1}{n}}$</li>
</ul>
</li>
</ul>
<p>FPGA面积效率的实验结果：</p>
<ul>
<li><mark>LUT 大小为 4~6 是所有簇大小中面积效率最高的</mark></li>
</ul>
<h3 id="Speed-model"><a href="#Speed-model" class="headerlink" title="Speed model"></a>Speed model</h3><p>Logic Cluster 中的延迟组件：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/SpeedModel.png" alt="SpeedModel"></p>
<ul>
<li>取决其关键路径长</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$t_{A-&gt;B}$</td>
<td>Input connection buffer and mux</td>
</tr>
<tr>
<td>$t_{B-&gt;C}$</td>
<td>Local buffer and routing mux</td>
</tr>
<tr>
<td>$t_{C-&gt;D}$</td>
<td>LUT delay</td>
</tr>
<tr>
<td>$t_{D-&gt;C}$</td>
<td>Local feedback delay</td>
</tr>
</tbody>
</table>
</div>
<p>FPGA 延迟的实验结果：</p>
<ul>
<li><mark>通过增加 N 或 K，有助于减少关键路径延迟（cluster size：N ；LUT size：K）</mark>；</li>
</ul>
<h3 id="Area-Delay-product"><a href="#Area-Delay-product" class="headerlink" title="Area-Delay product"></a>Area-Delay product</h3><p>在 FPGA 设计中，面积和速度通常是两个相互冲突的指标：</p>
<ul>
<li>通过调整 buffers 和晶体管的大小，可以提高 FPGA 的速度，但代价是增加面积；</li>
<li>通过减小 buffers 和晶体管的大小，可以使 FPGA 变得更小，但这会降低 FPGA 的性能；</li>
</ul>
<p>于是，将这两个指标相乘组合成一条曲线，以评估不同 FPGA 架构的性能；</p>
<p>基于实验结果：</p>
<ul>
<li><mark>从面积延迟积来看，cluster size 在 3 以后性能图基本重合，4~6 的 LUT size 是最好的；</mark></li>
</ul>
<p>ALM 进一步将 LUT 大小为 6 的面积-延迟乘积最小化：</p>
<ul>
<li><mark>ALM 的 fracturability 在 4-6 之间可以获得最小 delay；</mark></li>
</ul>
<h3 id="Power-model"><a href="#Power-model" class="headerlink" title="Power model"></a>Power model</h3><p>FPGA 的功耗分为动态功耗和静态功耗两大类：</p>
<ul>
<li>动态功耗：<ul>
<li>充/放电功耗：$Power = C \cdot V^2 \cdot f$</li>
<li>短路功耗</li>
</ul>
</li>
<li>静态功耗：<ul>
<li>reverse-bias leakage power（反向偏压泄漏功率）</li>
<li>sub-threshold leakage power（亚阈值泄漏功率)</li>
</ul>
</li>
</ul>
<h4 id="Static-power-model"><a href="#Static-power-model" class="headerlink" title="Static power model"></a>Static power model</h4><p><img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/StaticPowerModel.png" alt="StaticPowerModel">  </p>
<p>大多数泄漏功率来自亚阈值电流：$I_{drain}(weak inversion)= I_{on} \cdot e^{\frac{(V_{gs}-V_{on}) \cdot q}{nkT}}$</p>
<p>总泄漏功率：$Leakage Power = I_{drain}(weak inversion) \cdot V_{suppy -voltage}$</p>
<h4 id="Dynamic-power-model"><a href="#Dynamic-power-model" class="headerlink" title="Dynamic power model"></a>Dynamic power model</h4><p>转移密度模型（The Transition Density Model）是一种精确的估计动态功率的概率方法;</p>
<ul>
<li>transition density（跃迁密度）：单位时间内信号跃迁的平均次数</li>
<li>使用跃迁密度确定开关活动：</li>
</ul>
<p>LUT输出的跃迁密度：</p>
<ul>
<li>LUT：输入为$x_1,x_2,…,x_n$，输出为$y$；</li>
<li>公式：$D(y) = \sum_{all-input} P(\frac{\partial y}{\partial x_i}) \cdot D(x_i)$<ul>
<li>$D(y)$：y处的跃迁密度</li>
<li>$P(\frac{\partial y}{\partial x_i})$：由 xi 引起的 y 处跃迁概率 </li>
<li>$D(x_i)$：xi处的跃迁密度</li>
</ul>
</li>
<li>使用转移密度算法计算每个节点的转移密度，则总动态功率为：<ul>
<li>$Dynamic-Power = \sum_{all-nodes} 0.5 \cdot C_y \cdot V_{supply} \cdot V_{swing} \cdot D(y) \cdot f_{clk}$</li>
<li>其中$C_y$是负载电容</li>
</ul>
</li>
</ul>
<p>FPGA 功耗实验结果：</p>
<ul>
<li><mark>cluster size = 8 时，功耗低；</mark></li>
<li><mark>LUT size 在 4-5 时，功耗低；</mark></li>
</ul>
<p>功率感知：将功率变量包含在成本函数中，以优化 CAD 流程;</p>
<ul>
<li>是一种布局布线优化后的结果</li>
</ul>
<p>Power sequencing:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-CLB-DesignMethodology/PowerSequencing.png" alt="PowerSequencing"></p>
<ul>
<li>Duty cycling 不是一个完美的解决方案：<ul>
<li>较高的静态功率（仅禁用时钟是不够的）</li>
<li>慢并且高功耗去进行重配置；</li>
<li>如果静态电源消失，内存就会丢失；</li>
</ul>
</li>
</ul>
<p>FPGA 软件可以估计功耗（例如：Xilinx 的 XPE），在设计周期的早期阶段进行精确的功率计算将减少后期出现的问题；    </p>
<p>功率计算可在设计周期的三个不同阶段进行：</p>
<ol>
<li>Concept phase（概念阶段）：可以根据逻辑容量和活动率的估计来计算功率的粗略估计（例如，使用 Xilinx 功率估计电子表格）；</li>
<li>Design phase（设计阶段）：基于在 FPGA 中如何实现设计的详细信息（例如使用XPower分析器），可以更精确地计算功率 ；</li>
<li>System integration phase（系统集成阶段）：在实验室环境中计算功率（使用实际仪器）；</li>
</ol>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-CAD Tools：Synthesis</title>
    <url>/2020/04/13/FPGA-technology/FPGA-CADTools-Synthesis/</url>
    <content><![CDATA[<p>主要介绍 FPGA 技术里综合部分，涉及：HLS、LS、Mapping、Packing，以及它们相应的算法。</p>
<a id="more"></a> 
<h1 id="概述：FPGA-CAD-Tools"><a href="#概述：FPGA-CAD-Tools" class="headerlink" title="概述：FPGA CAD Tools"></a>概述：FPGA CAD Tools</h1><h2 id="完整的-FPGA-CAD-流程图"><a href="#完整的-FPGA-CAD-流程图" class="headerlink" title="完整的 FPGA CAD 流程图"></a>完整的 FPGA CAD 流程图</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/FullFlow.png" alt="FullFlow"></p>
<h2 id="CAD-和-EDA"><a href="#CAD-和-EDA" class="headerlink" title="CAD 和 EDA"></a>CAD 和 EDA</h2><p>『计算机辅助设计(CAD)』是使用计算机系统来帮助设计的创建、修改、分析或优化。</p>
<ul>
<li>在电子工程领域，也称为『电子设计自动化(EDA)』；</li>
<li>1981年标志着 EDA 作为一个独立行业的开始；</li>
</ul>
<h2 id="FPGA-CAD-Tools"><a href="#FPGA-CAD-Tools" class="headerlink" title="FPGA CAD Tools"></a>FPGA CAD Tools</h2><p>因为摩尔定律，工艺越来越先进，设计越来越复杂，这给 FPGA 的设计带来了巨大挑战，因此，FPGA 的 CAD 工具也就在 FPGA 的开发过程中起到了关键性的作用。   </p>
<p>按需进行分类：</p>
<ul>
<li>对于制造商/对于客户/对于研究人员；</li>
<li>工业用途（Virtuoso、Precision、ModelSim…）/学术用途（VTR、JHDL…）；</li>
</ul>
<h1 id="概述：FPGA-Synthesis"><a href="#概述：FPGA-Synthesis" class="headerlink" title="概述：FPGA Synthesis"></a>概述：FPGA Synthesis</h1><h2 id="Input-to-Synthesis"><a href="#Input-to-Synthesis" class="headerlink" title="Input to Synthesis"></a>Input to Synthesis</h2><p><strong>Hardware Description Language (HDL)：</strong></p>
<ul>
<li><code>HDL</code> 是一种专用语言，用于描述电子电路（最常见的是数字逻辑电路）的结构和行为；（例如：Verilog / VHDL）</li>
<li>Verilog 简洁大方（与 VHDL 相比），易于学习（类似于 C 语言），因此在数字电路设计中得到了广泛的应用；</li>
<li>Verilog 设计可能是『多层次』描述的组合，电子工程师经常在各个层次上工作，但必须确保其可综合性；</li>
<li>三种类型的 Verilog HDL：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/VerilogHDL.png" alt="VerilogHDL">  </li>
</ul>
<p><strong>High Level Language (HLL)：</strong></p>
<ul>
<li><code>HLL</code> 是具有更高抽象级别（比 HDL）更高，并且更关注行为和算法而不是硬件组件的任何编程语言。 （例如：C / System C）</li>
</ul>
<h2 id="Output-from-Synthesis"><a href="#Output-from-Synthesis" class="headerlink" title="Output from Synthesis"></a>Output from Synthesis</h2><p><strong>五个电路抽象级别：</strong>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Levels</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Behavioral Level</td>
<td>模拟硬件所需功能、行为或算法的设计抽象（逻辑不一定是可综合的）</td>
</tr>
<tr>
<td>Register Transfer Level (RTL)</td>
<td>根据硬件寄存器之间的数字信号流以及对这些信号执行的逻辑运算，对同步数字电路建模的设计抽象（完全逻辑可综合）</td>
</tr>
<tr>
<td>Gate Level</td>
<td>逻辑门的设计实现</td>
</tr>
<tr>
<td>Cell Level</td>
<td>逻辑单元的设计实现，通常是在 FPGA 中通过 LUT 实现</td>
</tr>
<tr>
<td>Cluster Level</td>
<td>逻辑集群的设计实现，通常是在 FPGA 中通过 CLB 实现</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>从上往下，不断综合，越来越细，项目时间和实现难度也越来越高；</li>
<li>FPGA 用户通常在 <code>行为级别/RTL/门级</code> 来设计电路，而在 <code>单元/集群级</code> 的设计只能由 CAD 工具完成；</li>
</ul>
<p><strong>网表 Netlist：</strong></p>
<ul>
<li>网表描述了电子电路的连通性，它通常只提供实例（电子组件），网络（互连）以及某些属性；</li>
<li>可以处于不同的抽象级别：<ul>
<li>在综合的每个步骤之后，网表将从一个抽象级别转换为另一个抽象级别，然后最终可以在FPGA上实现；</li>
</ul>
</li>
<li>具有多种格式标准：<ul>
<li><code>EDIF / BLIF</code> 是行业或学术界常用的流行格式；<ul>
<li>Electronic Design Interchange Format（EDIF，电子设计交换格式）与供应商无关，因此可以在共同的基础上代表不同的专有电子设计。（工业用途）；</li>
<li>Berkeley Logic Interchange Format（BLIF，伯克利逻辑交换格式）由加利福尼亚大学伯克利分校开发。（学术用途）已被最流行的学术 FPGA CAD 工具 - VTR 所使用；</li>
</ul>
</li>
<li><code>VQM</code> 是 Quartus 中使用的 Intel / Altera 定义的格式；</li>
<li><code>XDL</code> 是 ISE 中使用的 Xilinx 定义的格式；</li>
</ul>
</li>
</ul>
<h2 id="什么是-FPGA-综合？"><a href="#什么是-FPGA-综合？" class="headerlink" title="什么是 FPGA 综合？"></a>什么是 FPGA 综合？</h2><p><strong>定义</strong>：根据可以放置和布线的逻辑集群，从『电路描述』转换为『设计实现』的过程。     </p>
<p>通常，此复杂过程包括<strong>四个阶段：</strong>    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Num</th>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stage0</td>
<td>High Level Synthesis</td>
<td>技术独立<br>（与FPGA架构无关）</td>
</tr>
<tr>
<td>Stage1</td>
<td>Logic Synthesis</td>
<td>技术独立<br>（与FPGA架构无关）</td>
</tr>
<tr>
<td>Stage2</td>
<td>Mapping</td>
<td>技术依赖<br>（与FPGA体系结构相关）</td>
</tr>
<tr>
<td>Stage3</td>
<td>Packing</td>
<td>技术依赖<br>（与FPGA体系结构相关）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注意：阶段 0 ~ 2 也存在于 ASIC CAD 流程中，而第 3 阶段特定于 FPGA CAD；</li>
</ul>
<p><strong>Synthesis vs. Compilation（编译）：</strong>  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Synthesis tool</th>
</tr>
</thead>
<tbody>
<tr>
<td>-以正式定义的程序语言识别所有可能的构造；<br>-将它们翻译成执行过程的机器语言表示；</td>
<td>-识别硬件描述语言的目标相关子集；<br>-映射到具体的硬件资源集合；<br>-设计流程中的迭代工具</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Synthesis（综合） vs. Simulation（仿真）：</strong></p>
<ul>
<li>在像 Verilog 和 VHDL 这样的 HDL 中，并不是所有可被仿真的东西都是可被综合的；</li>
<li>仿真和综合的语义是不同的，仿真语义基于程序的顺序执行，并带有一些并发同步过程的观念。而并不是所有的这样的程序都是可以综合的，指定HDL的可合成子集并不容易；</li>
</ul>
<h2 id="综合过程的颗粒度分析"><a href="#综合过程的颗粒度分析" class="headerlink" title="综合过程的颗粒度分析"></a>综合过程的颗粒度分析</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/LogicGranularity.png" alt="LogicGranularity"></p>
<ul>
<li>由最开始的 HLS 粗颗粒度（coarse）描述，逐步综合磨碎（Grind）成门级网表，此时颗粒度就很小，以门为单位（fine）；</li>
<li>然后，进一步综合，mapping 后，成为了 LUT 网表，再经过 packing，颗粒度不断增大（Bind）；</li>
</ul>
<h1 id="技术独立的综合：HLS、LS"><a href="#技术独立的综合：HLS、LS" class="headerlink" title="技术独立的综合：HLS、LS"></a>技术独立的综合：HLS、LS</h1><p>这些技术独立程序不仅用于FPGA，而且用于所有 IC（集成电路设计）领域。</p>
<h2 id="High-Level-Synthesis-HLS"><a href="#High-Level-Synthesis-HLS" class="headerlink" title="High Level Synthesis (HLS)"></a>High Level Synthesis (HLS)</h2><p>解释所需行为的『算法描述』并『创建实现该行为的数字硬件』的过程。   </p>
<ul>
<li><code>HLL ---&gt; HDL</code>，例如：C —-&gt; Verilog</li>
</ul>
<p>HLS 的作用：</p>
<ol>
<li>基于 C 语言的规范：<u>加速</u>仿真和早期误差检测；</li>
<li>创建 RTL：<u>缩短</u>了以前的手动过程，避免了翻译错误；</li>
<li>架构优化：<u>自动</u>优化 RTL 架构，从而可以快速轻松地评估多个架构</li>
</ol>
<p>在 FPGA 实现所需的开发时间超出了典型软件开发工作的范围，使用 HLS 有时候能大大缩短软件开发的时间。虽然有时，HLS 会带来一定的性能下降，但是它所带来的好处远超于性能的下降，而且 HLS 还处于不断的发展当中。</p>
<h2 id="Logic-Synthesis（LS）"><a href="#Logic-Synthesis（LS）" class="headerlink" title="Logic Synthesis（LS）"></a>Logic Synthesis（LS）</h2><p>通常在寄存器传输级别（RTL）处，所需『电路的抽象形式』『通过逻辑门转换为设计实现』的过程。     </p>
<ul>
<li><code>HDL ---&gt; Netlist</code>，例如：Verilog —-&gt; BLIF</li>
</ul>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/LSExample.png" alt="LSExample">           </p>
<h2 id="Logic-Synthesis-Explained"><a href="#Logic-Synthesis-Explained" class="headerlink" title="Logic Synthesis Explained"></a>Logic Synthesis Explained</h2><p><strong>逻辑综合中一些常规和临时（特殊情况）方法：</strong></p>
<ul>
<li>『实例化』：维护原始模块（AND，OR等）和用户定义模块的库</li>
<li>『“宏扩展” /替换』：大量的语言运算符（+，-，布尔运算符等）和构造（if-else，case）扩展为特殊电路</li>
<li>『推论』：在语言描述中检测到特殊模式并对其进行特殊处理（例如，从变量声明和读/写语句推导存储块，从“ always @（posege clk）”块中进行 FSM 检测和生成）</li>
<li>『逻辑优化』：布尔运算通过逻辑最小化技术进行分组和优化</li>
<li>『结构重组』：先进的技术，包括共享操作，重新计时电路（移动FF）以及其他</li>
</ul>
<p><strong>将『非可合成代码』转换为『可合成代码』示例：</strong></p>
<ul>
<li>最基本的不可合成代码是延迟语句；</li>
<li>FPGA 没有时间概念，因此不可能告诉 FPGA 等待 10 纳秒；</li>
<li>取而代之，需要使用时钟和触发器来实现目标；</li>
</ul>
<p><strong>『循环语句中不可合成代码』的示例：</strong></p>
<ul>
<li>新的数字设计人员经常滥用的另一段代码是循环语句，例如：while，for，repeat等；</li>
<li>不能像使用 C 之类的软件语言那样实际使用可合成代码中的循环；</li>
<li>这是新硬件开发人员面临的一个巨大问题；</li>
<li>他们在 C 语言中见过数百次循环，因此他们认为在 Verilog 和 VHDL 中它们是相同的；</li>
<li>这里要明确：循环在硬件中的行为不同于在软件中的行为；</li>
<li>在您了解循环语句如何工作之前，请勿使用它们。</li>
</ul>
<p><strong>组合电路的逻辑综合：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/LogicDSynthesisombinedCircuit.png" alt="LogicDSynthesisombinedCircuit">     </p>
<p><strong>时序电路的逻辑综合：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/LogicSynthesisSequentialCircuit.png" alt="LogicSynthesisSequentialCircuit"></p>
<p><strong>技术独立综合的优化：</strong></p>
<ul>
<li><u>两级布尔最小化</u>:基于一个假设，减少方程中乘积项的数量和减少每个乘积项的大小将导致更小/更快实现；</li>
<li><u>优化有限状态机</u>:寻找等效的FSM；<ul>
<li>例如，在给定相同输入序列的情况下产生相同输出的 FSMs 具有更少的状态；</li>
</ul>
</li>
<li><u>选择状态机状态编码</u>：最小化实现面积 = 状态存储的大小 + 实现下一个状态和输出功能的逻辑的大小</li>
<li>这些操作都没有完全脱离目标技术。但是经验表明，在开始依赖技术之前尽可能减小问题的规模是有利的，在某些地方(例如，存储元件的大小与逻辑门的大小之比)，我们的假设在几代技术中都是有效的。</li>
</ul>
<p><strong>两级布尔最小化：</strong></p>
<ul>
<li>多输出布尔函数的两级表示：<ul>
<li>乘积和</li>
</ul>
</li>
<li>优化标准：<ul>
<li>product terms（乘积项）的数目：优化 FLUT</li>
<li>literals（文字）的数目：优化 LUT</li>
</ul>
</li>
<li>给定一个函数的最小化步骤：<ul>
<li>生成函数的一组 prime（主要）乘积项；</li>
<li>选择最少的 prime 项来覆盖该功能；</li>
</ul>
</li>
<li>最先进的逻辑最小化算法都是基于 Quine-McCluskey 方法，并且遵循上面两个步骤；<blockquote>
<ol>
<li><strong>Prime term generation：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PrimeTermGeneration.png" alt="PrimeTermGeneration"></li>
<li><strong>Prime term table：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PrimeTermTable.png" alt="PrimeTermTable"><br>举例 C 的两种情况：“0111”可被 B 覆盖，“1111”可被 E 覆盖；</li>
<li><strong>Dominated columns：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/DominatedColumns.png" alt="DominatedColumns"></li>
<li><strong>The Quine-McCluskey Method：</strong><br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Quine-McCluskey.png" alt="Quine-McCluskey"></li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="技术不独立的综合：Mapping"><a href="#技术不独立的综合：Mapping" class="headerlink" title="技术不独立的综合：Mapping"></a>技术不独立的综合：Mapping</h1><h2 id="总体认识"><a href="#总体认识" class="headerlink" title="总体认识"></a>总体认识</h2><p>一种从库（通常为LUT）中选择『一组逻辑 cells』以实现『逻辑门级网表』，同时优化面积、延迟或二者结合的过程;<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/mapping1.png" alt="mapping1">      </p>
<p>在VTR中将『门级 BLIF』转换为『单元级 BLIF』;<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/mapping2.png" alt="mapping2">   </p>
<ul>
<li>Why？<ul>
<li>使电路网表适合当前 FPGA 架构定义的逻辑单元（通常基于 LUT）；</li>
</ul>
</li>
<li>目标：<ul>
<li>面积：最大限度地减少LUT的总数；</li>
<li>延迟：最小化网表的逻辑深度；</li>
</ul>
</li>
<li>约束：<ul>
<li>FPGA 上 LUT 的输入数；</li>
</ul>
</li>
<li>方法：<ul>
<li>Map 算法；</li>
<li>将网表转换为图形，然后可以将其转换为数学模型，以便在软件中进行处理；</li>
</ul>
</li>
</ul>
<h2 id="Area-Delay-Trade-off"><a href="#Area-Delay-Trade-off" class="headerlink" title="Area/Delay Trade-off"></a>Area/Delay Trade-off</h2><p>减少 LUT（面积）可能会增加深度（延迟）；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/AreaDelay.png" alt="AreaDelay"></p>
<h2 id="DAG-表示"><a href="#DAG-表示" class="headerlink" title="DAG 表示"></a>DAG 表示</h2><blockquote>
<p>DAG：有向无环图；    </p>
</blockquote>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/DAGRepresentation.png" alt="DAGRepresentation">    </p>
<p>由于LUT是可配置的且基于真值表，因此我们无需担心映射过程中每个门的逻辑功能。    </p>
<p>术语：</p>
<ul>
<li>『Vertex/Edge』（顶点/边）：每个门都是一个顶点，每个连接都是一个边</li>
<li>『Primary Input』（PI，主要输入）：没有传入边的节点</li>
<li>『Primary Output』（PO，主要输出）：没有传出边的节点</li>
<li>『Topological Ordering』（拓扑排序）：$\{a,b,c,d,e,f,g,h,i,j,k,l\}$<ul>
<li>顶点的线性顺序，使得从顶点 u 到顶点 v 的每个有向边（u，v），u 都在 v 之前</li>
</ul>
</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="K-feasible-Cuts"><a href="#K-feasible-Cuts" class="headerlink" title="K-feasible Cuts"></a>K-feasible Cuts</h3><p>具有 K 个输入节点的 cone（圆锥体）（多个输入一个输出的结构）是 K-feasible（可行）的，并且可以用 K-LUT 实现。     </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/K-feasibleCuts.png" alt="K-feasibleCuts">      </p>
<p>注意：切割的输入数量必须小于或等于当前技术中指定的 LUT 输入的输入数量；</p>
<h3 id="Edge-Cut-Size-和-Height"><a href="#Edge-Cut-Size-和-Height" class="headerlink" title="Edge Cut Size 和 Height"></a>Edge Cut Size 和 Height</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Example3-feasibleCut.png" alt="Example3-feasibleCut"><br><strong>Edge Cut Size</strong>：横切的等效前边的总和，即横切处的输入数；</p>
<ul>
<li>例如：上图中：n(edge cut size) = 3<br><strong>Height</strong>：X 中最大的标签，指示最大延迟。</li>
<li>$h(X,\overline{X})=max\{l(x):x \in X\}$</li>
<li>例如：上图中：$h(height) = 2$</li>
</ul>
<h2 id="Phase1：FlowMap-Labelling"><a href="#Phase1：FlowMap-Labelling" class="headerlink" title="Phase1：FlowMap_Labelling"></a>Phase1：FlowMap_Labelling</h2><p><code>Pre-mapping process</code>：根据一组特定规则为DAG中的每个节点计算标签。  </p>
<h3 id="First-know"><a href="#First-know" class="headerlink" title="First know"></a>First know</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Subnetwork.png" alt="Subnetwork">     </p>
<p>『Subnetwork of a Node（节点的子网）』：虚线网络中的圆锥网络 $Ct$ 是专用于节点 t 的子网；    </p>
<p>『Label』：在任何  K-feasible 解决方案中，节点的最小可能深度；</p>
<ul>
<li>$l(t)$ 是节点 t 的标签；</li>
<li>按照拓扑顺序标记每个节点；</li>
<li>根据节点的前任节点计算节点的标签；</li>
<li>label 代表了深度，同 label 一般可以放在同一个 LUT 中；</li>
</ul>
<p>『引理』：令 $l(t)$ 为节点 t 的标签，则 $l(t) = p$ 或 $l(t) = p + 1$;</p>
<ul>
<li>p 是 $input(t)$ 中的最大标签;（$input(t)$：所有输入到节点 t 的节点）</li>
<li>任何节点的标签不能小于其前身;</li>
</ul>
<h3 id="伪代码描述"><a href="#伪代码描述" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PseudoCode.png" alt="PseudoCode"></p>
<h3 id="过程-1：初始化"><a href="#过程-1：初始化" class="headerlink" title="过程 1：初始化"></a>过程 1：初始化</h3><p>『对于给定的节点 t，其子网被转换为 DAG 网络 $N_t$』：</p>
<ul>
<li>插入一个源节点 s，其输出连接到 $N_t$ 的所有输入；</li>
<li>标记 $PI$，$l(PI) = 0$； </li>
</ul>
<h3 id="过程-2：Collapsing"><a href="#过程-2：Collapsing" class="headerlink" title="过程 2：Collapsing"></a>过程 2：Collapsing</h3><p>将 $N_t$ 中共享 max-label p 的所有节点与节点 t 合并为一个新节点 t’。然后，这样的新网络称为 $N_t$’;    </p>
<p>『引理』：当且仅当 $N_t$’ 有 K-feasible cut 时，$N_t$ 才在 p-1 高度处有 K-feasible cut。      </p>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Collapsing.png" alt="Collapsing"></p>
<h3 id="补充：Max-flow-Min-cut-Theorem"><a href="#补充：Max-flow-Min-cut-Theorem" class="headerlink" title="补充：Max-flow Min-cut Theorem"></a>补充：Max-flow Min-cut Theorem</h3><p>解决问题：怎样去知道在 $N_t$’ 里是否存在一个 K-feasible cut？    </p>
<p><code>Max-flow Min-cut Theorem</code>: </p>
<ul>
<li>Min cut = Max flow，即：在任何网络中，最大流量的值等于最小切割能力的值；</li>
<li>流量相当于 K（K输入到切割）；</li>
</ul>
<p>示例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Max-flow.png" alt="Max-flow"></p>
<h3 id="过程-3：Splitting"><a href="#过程-3：Splitting" class="headerlink" title="过程 3：Splitting"></a>过程 3：Splitting</h3><p>将节点拆分开，来建立边容量，即：将 $N_t$’ 转换为 $N_t^”$；      </p>
<p>方法：</p>
<ul>
<li>对于 $N_t$’ 中的每个节点 v（s 和 t’ 除外）：<ul>
<li>将 v 拆为：v1 和 v2；</li>
<li>通过边（v1，v2）连接它们；</li>
</ul>
</li>
<li>设置容量值：<ul>
<li>对于桥接边：$1$</li>
<li>对于非桥接边：$\infty$</li>
</ul>
</li>
</ul>
<p>确保如果 $N_t^”$ 里存在一个 $capacity &lt; K$ 的切割，则：仅桥接边穿过切口；</p>
<ul>
<li>『引理』：如果 $N_t^”$ 有 $cut \ size \leq K$ 的切割，则 $N_t$’ 有  K-feasible cut。</li>
</ul>
<p>示例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Splitting.png" alt="Splitting"></p>
<h3 id="过程-4-：计算label"><a href="#过程-4-：计算label" class="headerlink" title="过程 4 ：计算label"></a>过程 4 ：计算label</h3><p>检查 $N_t$ 中是否存在 p 的高度处的 K-feasible 切割 $(X，X_b)$ ：</p>
<ul>
<li>如果是：$l(t) \leftarrow p$;</li>
<li>如果否：$l(t) \leftarrow p+1$;</li>
</ul>
<p>其中：</p>
<ul>
<li>p 是 $input(t)$ 中的最大标签；</li>
<li>K 是初始指定，由 FPGA 的 LUT 的输入位数决定；</li>
</ul>
<p>举例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/ComputeLabels.png" alt="ComputeLabels"></p>
<h3 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/LabelingExample.png" alt="LabelingExample"></p>
<h2 id="Phase2：FlowMap-Mapping"><a href="#Phase2：FlowMap-Mapping" class="headerlink" title="Phase2：FlowMap_Mapping"></a>Phase2：FlowMap_Mapping</h2><p><code>Finding an “LUT-netlist”</code>：根据先前计算的节点标签生成K-LUT映射解决方案。</p>
<h3 id="伪代码描述-1"><a href="#伪代码描述-1" class="headerlink" title="伪代码描述"></a>伪代码描述</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/MappingPseudoCode.png" alt="MappingPseudoCode"></p>
<h3 id="算法例子-1"><a href="#算法例子-1" class="headerlink" title="算法例子"></a>算法例子</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/MappingExample.png" alt="MappingExample"></p>
<ul>
<li>从 11 个减少为了 7 个；</li>
</ul>
<h1 id="技术不独立的综合：Packing"><a href="#技术不独立的综合：Packing" class="headerlink" title="技术不独立的综合：Packing"></a>技术不独立的综合：Packing</h1><h2 id="总体认识-1"><a href="#总体认识-1" class="headerlink" title="总体认识"></a>总体认识</h2><p>将<strong>经过 mapped 的电路</strong>的元素打包到可用的 FPGA 硬件<strong>逻辑集群</strong>资源（通常为 CLB 或硬 IP 块）中的过程；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PackingStructure.png" alt="PackingStructure">        </p>
<p>NET 是 VTR（最流行的学术 FPGA CAD 工具）中使用的网表格式：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PackingFile.png" alt="PackingFile"></p>
<ul>
<li>why？<ul>
<li>降低布局和路线的复杂性（集群数 &lt; LUT 数）；</li>
</ul>
</li>
<li>目标：<ul>
<li>减少逻辑集群号。 （面积）</li>
<li>减少群集之间的连接。 （可路由性/延迟）</li>
<li>减少关键路径上的连接。 （延迟）</li>
</ul>
</li>
<li>约束：<ul>
<li>集群容量 / 集群输入数 / 集群时钟数 / LUT 输入数 / 承载…<ul>
<li>BLE 的数量必须小于群集大小 N；</li>
<li>在群集外部生成并用作群集内 BLE 的输入的不同输入的数量必须小于或等于群集输入的数量；</li>
</ul>
</li>
</ul>
</li>
<li>方法：<ul>
<li>Packing algorithms</li>
</ul>
</li>
</ul>
<h2 id="算法模型"><a href="#算法模型" class="headerlink" title="算法模型"></a>算法模型</h2><p>Pack 方案：贪婪</p>
<ul>
<li>步骤 1：分析目标和约束</li>
<li>步骤 2：定义标准（贪婪策略）</li>
<li>步骤 3：根据条件对所有候选人（LUT）进行排序</li>
<li>步骤 4：按照上述顺序一次尝试一次候选人</li>
<li>步骤 5：如果该候选人在所有限制条件下都能帮助实现目标，则接受该目标，否则，拒绝该目标并尝试下一个</li>
<li>步骤 6：继续尝试，直到所有候选人都精疲力尽</li>
</ul>
<p>一个简单的 Packing 问题：</p>
<ul>
<li>一包的最大负荷为 L = 150kg。 现在，我有 7 个项目，每个项目都无法拆分。</li>
<li>尽力将这些物品装满包装，并最大程度地提高总价值。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>item</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>$\sum$</th>
</tr>
</thead>
<tbody>
<tr>
<td>weight</td>
<td>35kg</td>
<td>30kg</td>
<td>6kg</td>
<td>50kg</td>
<td>40kg</td>
<td>10kg</td>
<td>25kg</td>
<td>196kg</td>
</tr>
<tr>
<td>value</td>
<td>$10</td>
<td>$40</td>
<td>$30</td>
<td>$50</td>
<td>$35</td>
<td>$40</td>
<td>$30</td>
<td>$235</td>
</tr>
<tr>
<td>value/weight</td>
<td>0.3</td>
<td>1.3</td>
<td>5</td>
<td>1</td>
<td>0.9</td>
<td>4</td>
<td>1.2</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Packing 策略：<ul>
<li>步骤1：分析目标和约束。<ul>
<li>目标：$\sum v$ 最大化</li>
<li>限制条件：$\sum w \leq L（L = 150）$</li>
</ul>
</li>
<li>步骤2：选择一个条件。<ul>
<li>准则1：每次都选择价值最大的项目</li>
<li>准则2：每次都选择重量最大的物品</li>
<li>准则3：<strong>每次选择具有最大价值 / 重量的物品</strong></li>
</ul>
</li>
<li>步骤3：按值 / 重量对所有项目进行排序;</li>
<li>步骤4：根据上述顺序一次尝试一项;</li>
<li>第5步：如果该物品适合放在包装中，则将其放入，否则，请拒绝并尝试下一个。</li>
<li>步骤6：继续尝试，直到尝试所有项目。</li>
</ul>
</li>
</ul>
<p>一个 FPGA packing 问题：</p>
<ul>
<li>典型的 CLB 具有 2 个和 4 个 IN 引脚的容量。 我们需要将 3 个 BLE / LUT（每个都有4个输入）打包到 2 个 CLB 中，并优化 FPGA 的面积和可布线性。<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/FPGAPackExample.png" alt="FPGAPackExample"></li>
<li>FPGA packing 策略：<ul>
<li>步骤 1：分析目标和约束<ul>
<li>目的：减少逻辑集群数量 / 减少集群间连接</li>
<li>约束：每个 CLB 中的 BLE 数量 $ \leq 2$ / 集群输入数量 $\leq 4$</li>
</ul>
</li>
<li>步骤 2：选择条件<ul>
<li>标准：<strong>每次选择具有公共输入的 BLE</strong></li>
</ul>
</li>
<li>步骤 3：按公共输入对所有 BLE 排序</li>
<li>步骤 4：按照上述顺序一次尝试 BLE</li>
<li>步骤 5：如果此 BLE 适合群集，请吸收它，否则，拒绝它并尝试下一个</li>
<li>步骤 6：迭代排序其余的 BLE，并继续尝试直到当前群集已满或所有 BLE 用尽</li>
</ul>
</li>
</ul>
<h2 id="Pack-Algorithm-VPack"><a href="#Pack-Algorithm-VPack" class="headerlink" title="Pack Algorithm: VPack"></a>Pack Algorithm: VPack</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>包装每个群集以达到最佳容量：</p>
<ul>
<li>减少集群数量</li>
</ul>
<p>最小化每个集群的输入数量：</p>
<ul>
<li>减少外部连接的数量（通常来说，集群间延迟大于集群内延迟）<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/ReduceExternalConnections.png" alt="ReduceExternalConnections"></li>
</ul>
<h3 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h3><p><strong>Stage 0</strong>：将寄存器和 LUT 打包到一个 BLE 中；</p>
<ul>
<li>这称为「预打包」，它可以识别与“打包模式”匹配的网表子图；</li>
<li>「压缩模式」将 LUT 和触发器原子对在压缩期间视为一个不可拆分的单元；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/RegisterAndLUT.png" alt="RegisterAndLUT"></li>
</ul>
<p><strong>Stage 1</strong>：通过选择 seed（种子） BLE 从新集群开始</p>
<ul>
<li>将被使用输入最多的未集群的 BLE 作为“种子”；</li>
<li>然后，将此“种子”放入群集 C；</li>
</ul>
<p><strong>Stage 2</strong>：添加与当前集群共享最多输入的 BLE</p>
<ul>
<li>根据 B 对 C 的吸引力，选择一个新的 BLE，B 装入 C；</li>
<li>吸引力取决于 B 和 C 共有的输入和输出的数量：$Attraction(B)=|Nets(B) \cap Nest(C)|$</li>
</ul>
<p><strong>Stage 3</strong>：继续添加，直到集群已满或输入引脚全部占用</p>
<ul>
<li>每个群集达到其容量后，打包将在新群集上开始；</li>
</ul>
<p><strong>Stage 4</strong>：如果集群中未使用某些 BLE，则 Hill climbing（爬山）</p>
<ul>
<li>即使集群的输入计数暂时溢出，也要添加另一个 BLE</li>
<li>如果最终没有减少输入数量，请从爬坡之前选择最佳选择</li>
</ul>
<p><strong>最后</strong>：当不再有未聚类的 BLE 时，该过程终止</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/VPackPseudoCode.png" alt="VPackPseudoCode"></p>
<h2 id="Pack-Algorithm-T-VPack"><a href="#Pack-Algorithm-T-VPack" class="headerlink" title="Pack Algorithm: T-VPack"></a>Pack Algorithm: T-VPack</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><p>这里的 T 就是 timing；   </p>
<p>减少关键路径上的外部连接（集群之间的连接）数量；</p>
<ul>
<li>外部连接比内部连接（集群中的连接）具有更高的延迟；</li>
<li>通过减少关键路径上的外部网络数量，可以减少电路延迟；</li>
</ul>
<p>算法的第一阶段涉及计算<strong>关键路径</strong>上的哪些连接，然后沿着关键路径依次将 BLE 打包到逻辑集群中，并重新计算以确定哪些 BLE 变得关键；</p>
<h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>针对同一节点来说：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/ExampleTiming.png" alt="ExampleTiming"></p>
<ul>
<li>「Arrival Time」：信号到达的时间</li>
<li>「Required Time」：要求数据稳定的时间（必须满足设置要求）</li>
<li>「Slack」：到达时间与所需时间之间的时差</li>
</ul>
<h4 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h4><p>时序电路中：Slack = Required Time – Arrival Time    </p>
<ul>
<li>如果 Slack 为负，则路径违反了两个顺序元素之间的设置关系；</li>
<li>换句话说，Slack 定义为在不增加整个电路延迟的情况下可以添加到连接的延迟量；</li>
</ul>
<p>注意：我们在这里讨论同一节点的松弛。对于不同的节点，必须考虑传播延迟。（将在以后讨论）</p>
<h4 id="Slack-计算"><a href="#Slack-计算" class="headerlink" title="Slack 计算"></a>Slack 计算</h4><p><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/SlackComputation.png" alt="SlackComputation"></p>
<h4 id="Delay-Models"><a href="#Delay-Models" class="headerlink" title="Delay Models"></a>Delay Models</h4><p>在算法中，为了上述概念计算的方便，这里设置了一些模型，所以我们所求的延迟都是相对值：</p>
<ol>
<li>逻辑延迟：<ul>
<li>通过 BLE 延迟；</li>
<li>从时序模型获得（设置为 0.1）；</li>
</ul>
</li>
<li>IntraClusterConnectionDelay（逻辑集群内部延迟）：<ul>
<li>同一集群内BLE之间的延迟；</li>
<li>从时序模型获得（设置为 0.1）；</li>
</ul>
</li>
<li>InterClusterConnectionDelay（逻辑集群外部延迟）：<ul>
<li>不同集群中的 BLE 之间的延迟；</li>
<li>放置和布线后获得（设置为 1.0，将导致不准确）；</li>
</ul>
</li>
</ol>
<h3 id="关键度-Criticalities"><a href="#关键度-Criticalities" class="headerlink" title="关键度 Criticalities"></a>关键度 Criticalities</h3><p>对于 VPack 的时序驱动版本（即：T-VPack），cost function 现在还从 connection critical 中考虑了 timing critical。</p>
<p><strong>「Connection Criticality」</strong>：</p>
<ul>
<li>计算公式：$ConnectionCriticality(i) = 1 - \frac{slack(i)}{MaxSlack}$</li>
<li>它的取值范围为：(0,1)</li>
<li>slack 越小， criticality 越大；</li>
<li>MaxSlack 是整个电路中所有点对点连接中最大的 slack；</li>
<li>衡量了整个电路中某个连接的关键度；</li>
</ul>
<p><strong>「BaseBLECriticality(B)」</strong>：</p>
<ul>
<li>每个 unclustered 的 BLE B 的 base criticality 定义为：<ul>
<li>将 B 与当前正在打包的群集 C 中的 BLE 相连接，所有可能的连接中最大的 Connection_Criticality 值；</li>
</ul>
</li>
<li>如果 B 与 C 没有任何连接，则 base criticality = 0；<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/BaseCriticalityAssignment.png" alt="BaseCriticalityAssignment"></li>
</ul>
<h3 id="Criticality-Tie-breaker"><a href="#Criticality-Tie-breaker" class="headerlink" title="Criticality Tie-breaker"></a>Criticality Tie-breaker</h3><h4 id="Tie-breaker-Mechanism"><a href="#Tie-breaker-Mechanism" class="headerlink" title="Tie-breaker Mechanism"></a>Tie-breaker Mechanism</h4><p>选择要吸收到集群中的 BLE 时，多个 BLE 具有相同的基本临界值的可能性很大：</p>
<ul>
<li>使用 tie-breaker mechanism（决胜局机制）选择最适合打包的 BLE；</li>
<li>该机制基于以最有效地减少关键路径上剩余的 BLE 数量的方式，将 BLE 打包在一起；</li>
</ul>
<p>举例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Tie-breakerMechanism.png" alt="Tie-breakerMechanism"></p>
<ul>
<li>加粗的黑线表示关键路径，方框里面数字表示 BLE 所在的关键路径数；</li>
<li>在这种情况下，吸收 BLE H，I 和 J 比吸收 BLE A，D 和 F 更有益；</li>
<li>可以看到，吸收 H，I 和 J 影响七个 BLE（A，B，C，D，E，F 和 G）的关键性，而吸收 A，D 和 F 仅影响三个 BLE 的关键性 BLE（H，I 和 J）；</li>
<li>显然，最好对 BLE 进行群集，以降低大多数其他 BLE 的关键性；</li>
</ul>
<h4 id="运用至-Criticality"><a href="#运用至-Criticality" class="headerlink" title="运用至 Criticality"></a>运用至 Criticality</h4><p><strong>「InputPathsAffected」</strong>：</p>
<ul>
<li>电路中的源与当前标记为BLE之间的关键路径数；</li>
<li>计算：$InputPathsAffected(B)=\sum_{\forall D \in critical \ inputs(B)}InputPathsAffected(D)$</li>
<li>关键输入（B）指的是 BLE 驱动关键路径上 B 输入的连接；</li>
</ul>
<p><strong>「OutputPathsAffected」</strong>：</p>
<ul>
<li>电路中的接收器与当前标记的 BLE 之间的关键路径数；</li>
<li>计算：$OutputPathsAffected(B)=\sum_{\forall D \in critical \ outputs(B)}OutputPathsAffected(D)$</li>
<li>关键输出（B）是指由关键路径上的 B 输出驱动的 BLE；</li>
</ul>
<p><strong>「TotalPathsAffected」</strong>：</p>
<ul>
<li>$TotalPathsAffected(B)=InputPathsAffected(B)+OutputPathsAffected(B)$</li>
</ul>
<p>例子：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/CriticalityTie-breaker.png" alt="CriticalityTie-breaker"></p>
<h3 id="标准-Criteria"><a href="#标准-Criteria" class="headerlink" title="标准 Criteria"></a>标准 Criteria</h3><p>更新 <strong>「Criticality(B)」</strong>:</p>
<ul>
<li>$Criticality(B) = BaseBLECriticality(B) + \epsilon \cdot TotalPathsAffected(B)$</li>
<li>其中 ε 是一个非常小的值，可确保 TotalPathsAffected 值仅充当平局机制；</li>
</ul>
<p>吸引力 <strong>「Attraction」</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Attraction.png" alt="Attraction"></p>
<ul>
<li>G 是归一化因子，设置为任何 BLE 可以连接的最大网络数；</li>
<li>如果 λ = 0，则我们仅专注于与集群共享输入引脚（即：VPack）；</li>
<li>如果 λ = 1，则我们仅专注于最小化关键路径，而无需担心共享输入的数量；</li>
<li>λ 由实验确定，并根据经验设置为 0.75；</li>
</ul>
<h2 id="分析对比"><a href="#分析对比" class="headerlink" title="分析对比"></a>分析对比</h2><ul>
<li>T-VPack 算法不管是在面积还是延迟，还是面积与延迟的乘积上，性能都要优于 VPack；</li>
<li>对 T-VPack 算法来说，随着 cluster size 的增大，external 逐渐减少，internal 逐渐增加，一般的商用 FPGA 都选择 8-10；</li>
</ul>
<h2 id="运用举例"><a href="#运用举例" class="headerlink" title="运用举例"></a>运用举例</h2><p>结构图：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/Packing-Virtex5FPGA.png" alt="Packing-Virtex5FPGA"></p>
<p>特点：</p>
<ul>
<li>O6 直接驱动 SLICE 输出 A，而 O5 必须在到达 SLICE 输出 AMUX 之前通过附加的多路复用器，这会使输出 O5 慢于输出 O6；</li>
<li>因此，为了获得高性能，不应在时序关键的组合路径中使用 O5；</li>
<li><strong>如果要保持高速性能，在将 LUT 打包到 Virtex-5 SLICE 中时，必须考虑 O5 的相对慢度</strong>；</li>
</ul>
<p>Packing 方法：</p>
<ul>
<li>除了开放第二个 LUT 输出之外，还更改了成本函数以鼓励双输出 LUT 打包，并增加了逻辑密度，从而减少了所用 6-LUT 的总数：<br><img src="http://img.thebetterkong.cn/blog/FPGA-CADTools-Synthesis/PackingForVirtex5Cost.png" alt="PackingForVirtex5Cost"><ul>
<li>其中，$L_i$ 是占用 $LUT_i$ 的程度，它有三种不同的取值：<ul>
<li>$L_i = 1$，如果 O5 和 O6 输出都被使用；</li>
<li>$L_i = 2$，如果仅有 O6 输出被使用；</li>
<li>$L_i = 3$，如果仅有 O5 输出被使用；</li>
</ul>
</li>
</ul>
</li>
<li>注意：<ul>
<li>对于将两个 LUT 封装在单个双输出 6-LUT 中的情况，Li 是最小的成本；</li>
<li>下一个最小的成本分配给单个 LUT 放置在 6-LUT 插槽中的情况，LUT 使用 O6 输出；</li>
<li>回想一下，O6 是更快的 LUT 输出；</li>
<li>最后，最高成本与使用缓慢的 O5 LUT 输出的 6-LUT 插槽中的单个 LUT 的场景相关；</li>
</ul>
</li>
</ul>
<p>提高 SLICE 利用率：</p>
<ul>
<li>前面给出的成本函数的目的是为了减少所使用的 6-LUT 的总数，该目标本身将有助于减少所使用的 SLICE 的总数。这里还扩展了成本功能，以更直接地减少 SLICE 数量：<ul>
<li>$Cost = a\cdot W + b\cdot T+ c\cdot L + d\cdot S$，其中：a,b,c,d 是 scalers；</li>
</ul>
</li>
<li>为了计算 S，令 $SL = {SLICE_1 … SLICE_m}$ 代表设备中所有 SLICE 的集合，包括已使用和未使用的 SLICE：<ul>
<li>$S = \sum_{SLICE_i \in SL}S_i$<ul>
<li>其中 $S_i$ 表示 $SLICE_i$ 的 LUT 利用率。 </li>
</ul>
</li>
<li>分别计算 6-LUT 的两个子 LUT：<ul>
<li>$S_i=\begin{cases}0,\quad N_i=0 \\\\1-\frac{N_i}{8},\quad N_i \geq 0\end{cases}$</li>
<li>$N_i$ 代表当前包装中 $SLICE_i$ 中已使用的 LUT 的数量（$N_i$ 最多为 8）；</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Routing Architecture</title>
    <url>/2020/03/29/FPGA-technology/FPGA-RoutingArchitecture/</url>
    <content><![CDATA[<p>FPGA 内部各个逻辑模块和外部逻辑模块见的互连方式；</p>
<a id="more"></a> 
<p>除了可编程逻辑单元外，FPGA 还具有可编程互连，如下图所示：<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ProgrammableInterconnect.png" alt="ProgrammableInterconnect">   </p>
<h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>FPGA 互连是<strong>逻辑块</strong>和<strong>I/O 块</strong>之间可编程连接的网络;     </p>
<h2 id="FPGA-Interconnection-体系"><a href="#FPGA-Interconnection-体系" class="headerlink" title="FPGA Interconnection 体系"></a>FPGA Interconnection 体系</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ExampleStructure.png" alt="结构示例"></p>
<ul>
<li>Wires (pre-fabricated metal tracks)</li>
<li>Programmable switches</li>
</ul>
<h2 id="FPGA-Interconnection-专有名词"><a href="#FPGA-Interconnection-专有名词" class="headerlink" title="FPGA Interconnection 专有名词"></a>FPGA Interconnection 专有名词</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/Terminology.png" alt="terminology"></p>
<ul>
<li>track（轨道）：用于互连的金属线</li>
<li>channel（通道）：分布均匀的一组相同轨道</li>
<li>通道宽度（W）：通道中的轨道数</li>
<li>通道长度（L）：通道中轨道的长度（通常是指逻辑簇数跨度，是一种相对长度，不是绝对长度）</li>
</ul>
<h2 id="FPGA-Interconnection-组成"><a href="#FPGA-Interconnection-组成" class="headerlink" title="FPGA Interconnection 组成"></a>FPGA Interconnection 组成</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/Components.png" alt="components"></p>
<ul>
<li>Connection Block（连接块）：逻辑集群和通道之间的连接<ul>
<li>输出连接块、输入连接块</li>
</ul>
</li>
<li>Switch Block（开关块）：通道之间的连接</li>
<li>Local Interconnect（本地互连）：逻辑集群内的连接</li>
</ul>
<h2 id="FPGA-Interconnection-优化"><a href="#FPGA-Interconnection-优化" class="headerlink" title="FPGA Interconnection 优化"></a>FPGA Interconnection 优化</h2><p>考虑的六个问题：</p>
<ol>
<li>wires 和 switches 在 FPGA 中是如何分布的？<ul>
<li>FPGA互连架构：层次样式（基于树）、岛式（基于网格）</li>
</ul>
</li>
<li>如何在电路中实现 wires 和 switches？<ul>
<li>Switch Box and Connection Box</li>
</ul>
</li>
<li>逻辑块之间需要多少 wires？<ul>
<li>通道宽度</li>
</ul>
</li>
<li>电线跨越逻辑块有多长？<ul>
<li>Wire segment length</li>
</ul>
</li>
<li>每个逻辑块必须有多少个输入/输出？<ul>
<li>逻辑块的扇入/扇出</li>
</ul>
</li>
<li>什么样的利用效率是我们能接受的？<ul>
<li>FPGA 互连的灵活性</li>
</ul>
</li>
</ol>
<p><strong>Programmable interconnects == Routing resources</strong>：</p>
<ul>
<li>FPGA 的路由资源由预制导线段和可编程开关组成；</li>
<li>FPGA 设计的可行性更多地受到路由资源的限制，而不是逻辑资源的限制；</li>
<li>路由延迟极大地限制了 FPGAs 的性能；</li>
<li>仔细设计开关模块非常重要；</li>
<li>水平和垂直通道的交叉区域称为 switch module，其中填充有  programmable switches；</li>
<li>需要在区域（total # of switches）约束下最大化可路由性；<ul>
<li>trade-off：more switchs（routability） vs. less switchs（delay、area）；</li>
</ul>
</li>
</ul>
<h1 id="两种-FPGA-Interconnection-构造"><a href="#两种-FPGA-Interconnection-构造" class="headerlink" title="两种 FPGA Interconnection 构造"></a>两种 FPGA Interconnection 构造</h1><h2 id="Hierarchical-Network"><a href="#Hierarchical-Network" class="headerlink" title="Hierarchical Network"></a>Hierarchical Network</h2><p>基于树的互连结构、多级分层互连（不常用）：<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/HierarchicalNetwork.png" alt="Hierarchical Network"></p>
<ul>
<li>优点：延迟好预估</li>
<li>缺点：类似图中红线，比较局限（即使在两个相邻的 CLB 之间也可能经历多个互连阶段）</li>
</ul>
<h2 id="Island-style-Network"><a href="#Island-style-Network" class="headerlink" title="Island-style Network"></a>Island-style Network</h2><p>CLBs 布置在二维网格上，路由资源均匀分布在网格中；<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/IslandStyleNetwork.png" alt="Island-style Network">   </p>
<p><mark>是目前常用的结构，其基本原理</mark>：</p>
<ul>
<li>Routing wires 通过 Switch Blocks 连接；</li>
<li>CLBs 通过 Connection Blocks 访问路由资源；</li>
</ul>
<h3 id="Connection-Block"><a href="#Connection-Block" class="headerlink" title="Connection Block"></a>Connection Block</h3><p><mark>Connection Block 提供：CLB 和互连线之间可编程连接；</mark>    </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ConnectionBlock.png" alt="Connection Block"></p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ConnectionBlock1.png" alt="Connection Block1">  </p>
<p>Switch 实现（相同的输入数 $N_{in}=n \times m$）：</p>
<ol>
<li>一级多路复用器：<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/1stageMultiplexer.png" alt="1-stage multiplexer"><ul>
<li>CRAMs 的数量：$n \times m$</li>
<li>路径延迟短</li>
</ul>
</li>
<li>两级多路复用器：<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/2stageMultiplexer.png" alt="2-stage multiplexer"><ul>
<li>CRAM 数量：$m+n$，减少了 CRAM 的数量</li>
<li>长路径延迟</li>
<li>电压恢复切断缓冲器短路电流：<br> <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/VoltageLevelRestoring.png" alt="Voltagelevelrestoring"></li>
</ul>
</li>
<li>性能与面积的平衡：混合使用<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/MixedUse.png" alt="混合使用"><ul>
<li>使用包含快速路径的路由多路复用器：通过将关键路径路由放到快速输入部分来提高性能</li>
</ul>
</li>
</ol>
<h3 id="Switch-Block"><a href="#Switch-Block" class="headerlink" title="Switch Block"></a>Switch Block</h3><p>Switch Block 出现在水平和垂直布线通道之间的每个交叉点处，定义这些通道之间的所有可能连接;    </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/SwitchBlock.png" alt="Switch Block">   </p>
<p>Routability：定义一条进线可以链接到多少条出线；</p>
<ul>
<li>允许所有可能的互连？<ul>
<li>Too big、Too slow</li>
</ul>
</li>
<li>优化 Switch Blocks，于是出现了三种结构：Disjoint Switch Block、Universal Switch Block、Wilton Switch Block<br> <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/3SwitchBlock.png" alt="3 Switch Block"></li>
</ul>
<p>Switch Block 的线段长度：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>较长的导线段（跨越多个块）</td>
<td>需要更少的交换机，从而减少路由区域和延迟</td>
<td>降低了路由灵活性</td>
</tr>
<tr>
<td>较短的导线段</td>
<td>让路由更加灵活</td>
<td>需要更多的路由区域和延迟</td>
</tr>
</tbody>
</table>
</div>
<p>基于上述特点，于是将这两种类型的导线段混合使用，来平衡routability、area and delay：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ChannelSegmentDistribution.png" alt="Channel segment distribution"></p>
<ul>
<li>在 long wire segments 引入 Internal (midpoint) population，即：内部（中点）填充：如果导线段可以从其端点以外的任何点连接到其他导线段，则在内部填充开关块<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/InternalPopulation.png" alt="internal population"></li>
</ul>
<p>wire segments 的“<strong><mark>lane changing</mark></strong>”:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/LaneChanging.png" alt="lane changing"></p>
<p>Disjoint switch block 在 midpoint 里需要的 switchs 更少：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/SubBlock.png" alt="sub block"></p>
<p>使用 <mark>mapping functions（$f_{e,1}…f_{e,6}$)</mark>，描述 endpoint population：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/MappingFunction.png" alt="mapping function"></p>
<p>Programmable switch（使用 6 个晶体管）：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/ProgrammableSwitch.png" alt="Programmable switch"></p>
<p>Switch Block 的电路实现（Pass transistor、Tri-state buffer）：</p>
<ol>
<li>Pass transistor：<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/PassTransistor.png" alt="Pass transistor"><ul>
<li>SRAM 控制晶体管开或关</li>
<li>双向信号传播</li>
<li>产生压降</li>
</ul>
</li>
<li>Tri-state buffer:<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/TristateBuffer.png" alt="Tri-state buffer"></li>
<li>Switch implementation：逻辑功能相当，但可能有不同的驱动强度和延迟<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/SwitchImplementation.png" alt="Switch implementation"></li>
</ol>
<h3 id="Global-Interconnect"><a href="#Global-Interconnect" class="headerlink" title="Global Interconnect"></a>Global Interconnect</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/GlobalInterconnect.png" alt="Global Interconnect"></p>
<ul>
<li>Horizontal channels</li>
<li>Vertical channels</li>
</ul>
<h3 id="Local-Interconnect"><a href="#Local-Interconnect" class="headerlink" title="Local Interconnect"></a>Local Interconnect</h3><p>Local Interconnect 在同一个 CLB 中的 LEs 之间传输信号，更高的性能和灵活性：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/LocalInterconnect.png" alt="Local Interconnect"></p>
<ul>
<li>反馈路径：CLB 内的本地连接</li>
<li>与相邻 CLB 的直接连接：两个相邻 CLB 之间的专用连接</li>
</ul>
<h1 id="Altera-FPGA-Interconnect-Model"><a href="#Altera-FPGA-Interconnect-Model" class="headerlink" title="Altera FPGA Interconnect Model"></a>Altera FPGA Interconnect Model</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingArchitecture/AlteraFPGAInterconnectModel.png" alt="Altera FPGA Interconnect Model"></p>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Lab Exercise</title>
    <url>/2020/06/11/FPGA-technology/FPGA-LabExercise/</url>
    <content><![CDATA[<p>主要介绍 FPGA 具体的实验操作；</p>
<a id="more"></a> 
<h1 id="概述：FPGA-构建工具链"><a href="#概述：FPGA-构建工具链" class="headerlink" title="概述：FPGA 构建工具链"></a>概述：FPGA 构建工具链</h1><p>实验开始之前，我们应该熟悉 CAD（计算机辅助设计）工具，该工具可将 HDL（Verilog）转换为 FPGA 上的工作电路：</p>
<ul>
<li>这些工具将使您的设计经历多个阶段，每个阶段都使其更接近于具体的实现；</li>
<li>在过去的几年中，较旧的评估平台（ML505）使用较旧的 FPGA（Xilinx Virtex-5 LX110T）和较旧的软件套件（Xilinx ISE）；</li>
<li>尽管有一个 GUI，也可有 Makefiles 来调用工具链中的每个后续程序，以进行完整的综合并进行分析；</li>
</ul>
<p>Xilinx 更新后的设计软件：Vivado Design Suite</p>
<ul>
<li>Vivado 强调了其强大的集成脚本功能（使用 Tcl 语言）以及与其他高级设计工具（例如，高级综合）的集成；</li>
<li>它还支持等效的 Makefiles 和 Tcl 自动化；</li>
</ul>
<p>GUI 本身的缺点是使用起来非常手工：</p>
<ul>
<li>反复更改和运行参数很快变得乏味；</li>
<li>最终的目标是使设计过程尽可能自动化；</li>
<li>但是，对于学习而言，GUI 具有宝贵的属性，可以指导我们完成流程的每个步骤；</li>
</ul>
<h1 id="FPGA-设计流程"><a href="#FPGA-设计流程" class="headerlink" title="FPGA 设计流程"></a>FPGA 设计流程</h1><p><strong>① 综合 Synthesis</strong>：</p>
<ul>
<li>要在 Vivado Design Suite 中运行综合步骤（即，将 HDL 转换为组合逻辑和顺序逻辑），请在 “Flow Navigator（流导航器）” 窗格的其他左侧界面中选择 “ Run<br>Synthesis”；</li>
<li>如果之前已经运行过，则可以通过选择 “Open Synthesized Design” 来检查综合设计；</li>
</ul>
<p><strong>② 实现 Implementation</strong>：</p>
<ul>
<li>Vivado GUI 中的实现步骤等效于手动 pipeline 中的 translation，mapping 以及 place 和 route 步骤；</li>
<li>同样，这将采用先前综合的逻辑电路，并将其映射到我们特定的 FPGA 实际具有的物理逻辑设备；</li>
<li>在 “Flow Navigator” 中选择 “Run Implementation” 以运行它，然后选择 “Open Implementation” 以检查其输出；</li>
</ul>
<p><strong>③ Xilinx 设计约束（XDC）</strong>：</p>
<ul>
<li>我们如何将信号之一连接到物理设备？</li>
<li>我们如何指定电路的特殊性质，这可能对正确性和时序至关重要？</li>
<li>Xilinx 设计约束文件（具有 <code>.xdc</code> 扩展名）指定了设计的必要属性（就像旧的 User Constraints 文件），并且是实施阶段的关键输入。</li>
<li>XDC 受 Synopsis ASIC 综合工具链的启发，旨在实现某种程度的兼容性；</li>
<li>以 TCL 形式为 Vivado TCL 解释器编写；</li>
<li>例子：<code>set_property -dict{ PACKAGE_PIN L19 IOSTANDARD LVCMOS33 } [get_ports{ BUTTONS[3] }];</code><ul>
<li>此语法分别将属性 LACK 和 LVCMOS33 的值 PACKAGE_PIN 和 IOSTANDARD 分配给端口 BUTTONS [3]，这是我们在 Verilog 源中定义的信号。这些属性中的每一个在合成过程中都有单独的结果：</li>
<li>BUTTONS [3] 信号应连接到的引脚与 FPGA 封装上的物理引脚 L19 相连；</li>
<li>该端口的逻辑约定（最大电压，什么范围构成高低，等等）将为 LVCMOS33；</li>
</ul>
</li>
</ul>
<p><strong>④ Bitstream generation</strong>：</p>
<ul>
<li>为了生成 FPGA 可以理解的编程文件，我们在 “Flow Navigator” 中调用 “Generate Bitstream”；</li>
</ul>
<p><strong>⑤ Timing Analysis</strong>：</p>
<ul>
<li>通过展开 “Open Synthesized Design” 并选择 “Report Timing Summary”，可以在 “Flow Navigator” 中的 “Synthesis” 下生成时序分析报告；</li>
</ul>
<p><strong>⑥ Design Reports</strong>：</p>
<ul>
<li>在构建流程的每个步骤都会自动生成报告。</li>
<li>您应该能够在 “Flow Navigator” 的每个扩展阶段下找到它们；</li>
<li>“Project Summary” 窗口（在 “Window” 菜单下）显示了每个步骤生成的报告的摘要；</li>
</ul>
<p><strong>⑦ Programming the FPGA</strong>：</p>
<ul>
<li>要使用 Vivado GUI 将 bitstream 发送到 FPGA，必须使用 Hardware Manager；</li>
<li>可以在 “Flow Navigator” 中的 “Program and Debug” 下的 “Generate Bitstream” 下进行访问；</li>
<li>通过 USB JTAG 接口连接到 FPGA 后，您可以在 “Flow Navigator”（或在打开的Hardware Manager 窗格中）中选择 “Program Device” 来执行编程；</li>
</ul>
<h1 id="Verilog-基础"><a href="#Verilog-基础" class="headerlink" title="Verilog 基础"></a>Verilog 基础</h1><p><strong>基本格式</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> &lt;module_name&gt; (&lt;module_terminal_list&gt;);</span><br><span class="line">    &lt;module_terminal_definitions&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;functionality_of_module&gt;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="简单运用举例"><a href="#简单运用举例" class="headerlink" title="简单运用举例"></a>简单运用举例</h2><p><strong>全加器</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FullAdder.png" alt="FullAdder">   </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,cout,sum);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;      <span class="comment">//inputs</span></span><br><span class="line">    <span class="keyword">output</span>  cout,sum;    <span class="comment">//outputs</span></span><br><span class="line">    <span class="keyword">wire</span>    w1,w2,w3,w4;   <span class="comment">//internal nets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (w1,a,b)</span>; <span class="comment">//delay time of 10 units</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="variable">#(10)   (sum,w1,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w2,a,b)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w3,a,cin)</span>;</span><br><span class="line">    <span class="keyword">and</span> <span class="variable">#(8)    (w4,b,cin)</span>;</span><br><span class="line">    <span class="keyword">or</span>  <span class="variable">#(10,8) (cout,w2,w3,w4); // (rise time of 10, fall 8)</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>全加器另一中实现方式（时序）</strong>：   </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdder(a,b,cin,sum,cout);</span><br><span class="line">    <span class="keyword">input</span>   a,b,cin;</span><br><span class="line">    <span class="keyword">output</span>  cout,sum;</span><br><span class="line">    <span class="keyword">reg</span>     sum,cout;   <span class="comment">//registers retain value</span></span><br><span class="line">    <span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> cin) <span class="comment">//Any time a or b or cin change,run the process</span></span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            sum &lt;= a ^ b ^ cin;</span><br><span class="line">            cout &lt;= ( a &amp; b ) |  ( a &amp; cin ) |  ( b &amp; cin );</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中：两种赋值号 <code>=</code> 和 <code>&lt;=</code> 区别：<ul>
<li>Verilog 中的所有语句都是并发的（除非它们在顺序块中），并发表示每行中描述的操作并行进行；<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Concurrent.png" alt="Concurrent"></li>
<li>Nonblocking：<code>&lt;=</code>，代表按顺序执行；</li>
<li>Blocking：<code>=</code>，代表并发执行；</li>
</ul>
</li>
</ul>
<p><strong>纹波进位加法器（ripple carry adder）</strong>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4-bit Adder</span></span><br><span class="line"><span class="keyword">module</span> adder4(A,B,cin,S,cout)</span><br><span class="line">    <span class="keyword">input</span>[<span class="number">3</span>:<span class="number">0</span>]  A,B;</span><br><span class="line">    <span class="keyword">input</span>   cin;</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">3</span>:<span class="number">0</span>] S;</span><br><span class="line">    <span class="keyword">output</span>  cout;</span><br><span class="line">    <span class="keyword">wire</span> c1,c2,c3;</span><br><span class="line">    <span class="comment">// 4 instantiated 1-bit Full Adders</span></span><br><span class="line">    FullAdder fa0(A[<span class="number">0</span>], B[<span class="number">0</span>], cin, c1, S[<span class="number">0</span>]);</span><br><span class="line">    FullAdder fa1(A[<span class="number">1</span>], B[<span class="number">1</span>], c1, c2, S[<span class="number">1</span>]);</span><br><span class="line">    FullAdder fa2(A[<span class="number">2</span>], B[<span class="number">2</span>], c2, c3, S[<span class="number">2</span>]);</span><br><span class="line">    FullAdder fa3(A[<span class="number">3</span>], B[<span class="number">3</span>], c3, cout, S[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述"></a>具体描述</h2><p>HDL（Hardware descrip languages）提供了一种通过使用文本文件来描述电路的方式；</p>
<ul>
<li>通过 keywords 和 expressions 来描述硬件：<ul>
<li>共用的形式：logic expression、truth table、functions、logic gates</li>
<li>任何的组合或者时序电路都可以描述；</li>
</ul>
</li>
<li>两个目标：<ul>
<li>通过计算机仿真（时序，延迟）来测试/验证；</li>
<li>综合：可综合的 HDL</li>
</ul>
</li>
<li>两种主要的硬件描述语言：VHDL、Verilog（主要）</li>
</ul>
<p><strong>HDL</strong>（verilog）：</p>
<ul>
<li>代表硬件结构和行为；</li>
<li>逻辑仿真：生成波形图</li>
</ul>
<p><strong>keywords 和 syntax（语法、词法）</strong>：</p>
<ul>
<li><code>//</code> 开始的表述注释；</li>
<li>一般有 100 个 keywords，是大小写敏感的（通常小写）；</li>
<li><code>module</code> 一个模块，以 <code>endmodule</code> 结束；</li>
<li><code>module</code> 后面跟电路名和端口（输入或输出）列表；</li>
</ul>
<p>两种基本的<strong>声明形式</strong>：</p>
<ul>
<li>Concurrent（同时）声明，常用在组合电路，执行与声明顺序无关；<ul>
<li>gate 实例化：<code>and (z,x,y)</code>，<code>or (c,a,b)</code>，<code>xor (S,x,y)</code>，etc</li>
<li>连续 assign：<code>assign Z=x&amp;y, c=a|b, S=x^y;</code></li>
</ul>
</li>
<li>Procedural（程序）声明，常用在时序电路，按书写的顺序执行；<ul>
<li><code>always @</code>：当 event 激活时连续执行</li>
<li><code>initial</code>：只执行一次（用在仿真里）</li>
<li><code>if then else</code></li>
</ul>
</li>
</ul>
<p><strong>wire</strong> 和 <strong>gate-level</strong>：</p>
<ul>
<li><code>wire</code>：定义为电路内部的连接点</li>
<li><code>and g1(e,A,B)</code>：一行定义一个 gate（and，or，xor），并为其指定名字，第一个参数为输出；</li>
</ul>
<p><strong>boolean 表达式</strong>；</p>
<ul>
<li>OR:<code>|</code>，AND:<code>&amp;</code>，NOT:<code>~</code></li>
</ul>
<p><strong>UDP</strong>（user defined primitives）用户自定义原语：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/UDP.png" alt="UDP"></p>
<p><strong>Modeling Circuit Delay</strong>：</p>
<ul>
<li>为了 simulation（不是 synthesis，synthesis 的延迟是不可控的）；</li>
<li>可以利用 <code>timescale 1ns/100ps</code>，定义仿真时间的单位；<ul>
<li><code>#(30)</code> 指示，gate 从输入到输出的延迟为 30ns；</li>
</ul>
</li>
</ul>
<p><strong>Test bench Stimulus（激励）</strong>：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/TBStimulus.png" alt="TBStimulus"></p>
<ul>
<li>然后就可以通过仿真波形图，观察电路是否满足预期要求；</li>
</ul>
<p><strong>Modiling Sequential Elements</strong>：</p>
<ul>
<li>D Latch：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DLatch.png" alt="DLatch"></li>
<li>D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/DFlipflop.png" alt="DFlipflop"></li>
<li>带有同步 reset 的 D Flip-flop：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/RDFlipflop.png" alt="RDFlipflop"></li>
</ul>
<p><strong>Assignment</strong>：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/Assignment.png" alt="Assingment"></p>
<p><strong>Finite State Machines（有限状态机）</strong>：</p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSM.png" alt="FSM"><br>利用状态图来展示：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FSMStateDiagrams.png" alt="FSMStateDiagrams"></p>
<p>例：序列检测器 Sequence Detector</p>
<ul>
<li>电路功能：当收到 3 个连续的 1 时，输出 1；其余时候输出 0；</li>
<li>FSM 类型：Moore<ul>
<li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSequenceDetector.png" alt="MooreSequenceDetector"></li>
<li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MooreSynthesizedSimulation.png" alt="MooreSynthesizedSimulation"></li>
</ul>
</li>
<li>FSM 类型：Mealy<ul>
<li>状态图及 Verilog 描述：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySequenceDetector.png" alt="MealySequenceDetector"></li>
<li>综合 + 仿真查看结果：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/MealySynthesizedSimulation.png" alt="MealySynthesizedSimulation"></li>
</ul>
</li>
</ul>
<h1 id="FPGA-设计工具"><a href="#FPGA-设计工具" class="headerlink" title="FPGA 设计工具"></a>FPGA 设计工具</h1><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>下面的介绍都是在 Vivado 平台上介绍；</p>
<h3 id="组合电路：AND"><a href="#组合电路：AND" class="headerlink" title="组合电路：AND"></a>组合电路：AND</h3><p>① 写 Verilog 代码（comb.v）：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_comb(data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//combinational circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (*)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out = data_1 &amp;&amp; data_2; <span class="comment">// binary bit-wise:&amp;, binary logic:&amp;&amp;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>② 创建 project：</p>
<ul>
<li>Flow Navigator 里点击 <kbd>File-Project-New</kbd>，<kbd>next</kbd>；</li>
<li>输入 Project name, Project location，<kbd>next</kbd>；</li>
<li>选择 RTL Project，<kbd>next</kbd>；</li>
<li>选择 <kbd>Add Files</kbd>，添加 comb.v 文件，<kbd>next</kbd>；</li>
<li>如果需要的话，添加或者创建 Constraints Files，<kbd>next</kbd>；</li>
<li>选择 FPGA device，例如：xa7a12tcpg238-2l，<kbd>next</kbd>；</li>
<li>回顾：Project Summary，点击 <kbd>Finish</kbd>；</li>
</ul>
<p>③ 写 Verilog testbench（comb_sim.v)：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> data_1, data_2;        <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line">    and2_comb and2_comb_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span>               <span class="comment">//signal flow</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>;                  <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>④ 综合逻辑电路，并进行仿真</p>
<ul>
<li>Flow Navigator 里点击 <kbd>SYNTHESIS</kbd>，<kbd>Run Synthesis</kbd>；</li>
<li>之后就能得到一个 netlist，就可以以后进行 functional simulation；</li>
<li>在 source 窗口里，右键 Simulation Sources，选择 <kbd>Add Sources</kbd>；</li>
<li>选择 <kbd>Add or Create Simulation Sources</kbd>，添加编写好的 comb_sim.v 文件；</li>
<li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Functional Simulation</kbd></li>
</ul>
<p>⑤ 检查仿真结果</p>
<ul>
<li>仿真结束后，点击 Flow Navigator 里的 <kbd>Window</kbd> —&gt; <kbd>Waveform</kbd> 来查看波形图；</li>
</ul>
<h3 id="时序电路：AND"><a href="#时序电路：AND" class="headerlink" title="时序电路：AND"></a>时序电路：AND</h3><p>① 写 Verilog 代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> and2_seq(clk,data_1,data_2,data_out); <span class="comment">// port-list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   clk,data_1,data_2;</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sequential circuit description</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        data_out &lt;= data_1 &amp;&amp; data_2; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>② 创建 project：</p>
<p>③ 写 Verilog testbench：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">    <span class="keyword">reg</span> clk,data_1, data_2;    <span class="comment">//define input registers</span></span><br><span class="line">    <span class="keyword">wire</span> data_out;             <span class="comment">//define output type</span></span><br><span class="line"></span><br><span class="line">    and2_seq and2_seq_dut(   <span class="comment">//instantiate ports</span></span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.data_1</span>(data_1),</span><br><span class="line">        <span class="variable">.data_2</span>(data_2),</span><br><span class="line">        <span class="variable">.data_out</span>(data_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> <span class="comment">//signal flow</span></span><br><span class="line">        clk = <span class="number">1</span>; data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">1</span>;data_2 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">200</span><span class="variable">.1</span></span><br><span class="line">        data_1 = <span class="number">0</span>;data_2 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">200</span></span><br><span class="line">        <span class="built_in">$stop</span>; <span class="comment">//cease system tasks</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>④ 综合逻辑电路，并进行仿真</p>
<ul>
<li>综合，添加仿真文件；</li>
<li>右键：<kbd>sim_1</kbd> —&gt; <kbd>Run Simulation</kbd> —&gt; <kbd>Run Post-Synthesis Timing Simulation</kbd></li>
</ul>
<p>⑤ 检查仿真结果</p>
<h3 id="基于-IP-的电路：32-bit-Multiplier"><a href="#基于-IP-的电路：32-bit-Multiplier" class="headerlink" title="基于 IP 的电路：32-bit Multiplier"></a>基于 IP 的电路：32-bit Multiplier</h3><p>下面会从使用 DSP-IP 和不使用 DSP-IP 两个角度实现；   </p>
<p>① 写 verilog 代码（mul32.v）：   </p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mul32(mula,mulb,product,clk,rst);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mula;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>]mulb;</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>]product;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulaq;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>]mulbq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= <span class="number">0</span>;</span><br><span class="line">                    mulbq &lt;= <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    mulaq &lt;= mula;</span><br><span class="line">                    mulbq &lt;= mulb;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> rst)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(~rst)</span><br><span class="line">                product &lt;= <span class="number">64'h0123_4567_89ab_cdef</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                product &lt;= mulaq * mulbq;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>② 创建 project：   </p>
<p>③ 写 Verilog testbench：略   </p>
<p>④ 综合逻辑电路：</p>
<ul>
<li>Flow Navigator 里点击 <kbd>Tools</kbd>，<kbd>Settings</kbd>；</li>
<li>找到 <kbd>Synthesis</kbd> 选项，设置 <kbd>max_dsp</kbd>为 -1（只用 DSP），0（不用 DSP）；</li>
</ul>
<p>⑤ 仿真：   </p>
<p>⑥ 检查仿真结果；   </p>
<p>⑦ 比较资源利用报告；</p>
<h2 id="执行时序分析"><a href="#执行时序分析" class="headerlink" title="执行时序分析"></a>执行时序分析</h2><p>定义时钟：</p>
<ul>
<li>在 Flow Navigator 里的 Project Manager section 里选择 <kbd>Add Source</kbd>；   </li>
<li>在对话框里，选择 <kbd>Add or Create Constraints</kbd>，点击 <kbd>next</kbd>；    </li>
<li>在接来下的对话框里，选择 <kbd>Create File</kbd>，File type：XDC，输入 File name，点击 <kbd>OK</kbd>，就会产生一个 xdc 的文件；    </li>
<li>在 Netlist Analysis section 下的 Flow Navigator 里找到 Implement，选择 Edit Timing Constraints；然后就会展示出一个时序约束的编辑窗口；    </li>
<li>双击 <kbd>Create Clock</kbd>，定义 clock：<ul>
<li>clock name：可以随便定义，这里定为：clk，它不会和设计中的任何成分匹配；</li>
<li>Source Object：点击 <kbd>…</kbd>：<ul>
<li>将后面的 <code>*</code> 改为 <code>*clk</code>，接着 clk 就会出现在 Find result 块里；</li>
<li>选择 clk，将其拖到 Selected 块里；</li>
</ul>
</li>
<li>OK，finish</li>
</ul>
</li>
<li>接来下就会返回到之前的窗口，会显示刚刚所定义的 clock 的信息；    </li>
<li>点击 <kbd>Save Constraints</kbd> 保存，双击 timing.xdc 文件，查看；   </li>
</ul>
<p>查看时序结果：</p>
<ul>
<li>接下来，也是在 Implement 下选择，<kbd>Report Timing Summary</kbd>，会出现一个窗口来显示之前的 timing 的定义，也可以在这里进行修改，之后点击 OK；    </li>
<li>会在 Design Timing Summary 里显示一些信息，例如：Worst Negative Slack，Worst Hold Slack 和 WPSN 等；    </li>
<li>也可以为所有的路径都产生一个 timing report：<ul>
<li>选择 <kbd>Tools</kbd> &gt; <kbd>Timing</kbd> &gt; <kbd>Report Timing</kbd>；</li>
<li>在产生的窗口里，点击 OK，就会生成一个十分详细的 timing report</li>
</ul>
</li>
</ul>
<h2 id="执行功耗分析"><a href="#执行功耗分析" class="headerlink" title="执行功耗分析"></a>执行功耗分析</h2><p>在 Synthesis 列里找到 <kbd>Report Power</kbd>，出现一个窗口显示相关的定义，可以修改一些参数等，点击 OK 后，就可以看到一个 Power Analythesis 的窗口，改窗口就显示了一些功耗信息；   </p>
<h1 id="设计约束与优化"><a href="#设计约束与优化" class="headerlink" title="设计约束与优化"></a>设计约束与优化</h1><p>Constraints 用于影响 FPGA 设计实现工具，包括：synthesizer 以及 place 和 route 工具；</p>
<ul>
<li>它们使设计团队可以指定设计性能要求，并指导工具满足这些要求；</li>
</ul>
<p>Implementation tools 会根据综合的优化级别，指定的时序，引脚分配以及设计团队提供给工具的逻辑分组来确定其操作的优先级；    </p>
<p>约束的四种主要类型包括：synthesis，I/O，timing 和 area/location 约束    </p>
<ul>
<li><strong>Synthesis constraints</strong>：影响如何将HDL代码合成为RTL的细节。 有多种综合约束，它们的上下文，格式和使用通常在不同工具之间有所不同。</li>
<li><strong>I/O constraints</strong>（通常也称为引脚分配）：用于将信号分配给特定的 I/O（引脚）或 I/O bank。I/O 约束还可用于为各个 I/O 和 I/O 组指定用户可配置的 I/O 特性；</li>
<li><strong>Timing constraints</strong>：用于指定设计的时序特性。时序约束可能会影响所有内部时序互连，逻辑和 LUT 以及触发器或寄存器之间的延迟。时间约束可以是全局约束，也可以是路径约束。</li>
<li><strong>Area constraints</strong>：用于将特定电路映射到 FPGA 内的一系列资源。位置约束指定相对于另一个设计元素或相对于 FPGA 中特定固定资源的位置；</li>
</ul>
<h2 id="Synthesis-Constraints"><a href="#Synthesis-Constraints" class="headerlink" title="Synthesis Constraints"></a>Synthesis Constraints</h2><p>综合约束的类型，语法和上下文通常在工具之间有所不同；   </p>
<p>下表列出了 Xilinx 综合工具（XST）的一些综合约束：<br><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/XST.png" alt="XST">    </p>
<p>Synthesis Constraints 用于指导综合工具执行特定操作：</p>
<ul>
<li>例如，考虑综合约束 CLOCK_BUFFER。该约束用于指定时钟端口上使用的时钟缓冲区的类型；</li>
<li>可用于优化设计实现的两个重要综合约束是 REGISTER_BALANCING 和 INCREMENTAL_SYNTHESIS<ul>
<li>REGISTER_BALANCING 寄存器平衡用于优化性能</li>
<li>INCREMENTAL_SYNTHESIS 增量合成可减少合成时间</li>
</ul>
</li>
</ul>
<p><strong>Register balancing</strong>：用于通过跨寄存器边界移动布尔逻辑功能的位置来满足设计时序要求。</p>
<ul>
<li>寄存器平衡会增加电路时钟频率；</li>
<li>通过调整相对路径延迟可以获得改进的性能；</li>
<li>寄存器平衡分为两类，分别称为：forward 正向和 backward 反向平衡<ul>
<li>前向寄存器平衡旨在将位于 LUT 输入处的一组寄存器移至 LUT 输出处的单个寄存器；</li>
<li>后向寄存器平衡基于相反的原理，综合工具可将位于 LUT 输出处的寄存器移至 LUT 输入处的一组触发器。</li>
</ul>
</li>
<li>在该过程结束时，可以增加或减少设计中寄存器的总数（不确定）；</li>
</ul>
<p><strong>Incremental synthesis</strong>：的主要目的是减少编译设计所需的总时间：</p>
<ul>
<li>通过仅综合设计中已更改的部分来执行此操作；</li>
<li>综合工具在综合阶段可能具有不同的开关或约束，以支持此方法；</li>
<li>可能会严重影响综合阶段的其他两个因素包括保留已实现的设计层次结构以及正确使用设计约束；</li>
</ul>
<h2 id="Pin-Constraints"><a href="#Pin-Constraints" class="headerlink" title="Pin Constraints"></a>Pin Constraints</h2><p>重要的是要注意，引脚分配对于所有设计或设计中的所有引脚并不重要：</p>
<ul>
<li>I/O 余量较大或工作速度较慢的设计可能不需要仔细分配引脚；</li>
<li>但是，如果设计余量受到以下任何 FPGA 设计因素的限制，则引脚分配可能会成为关键因素：<ul>
<li>I/O 引脚可用性</li>
<li>FPGA 架构级逻辑资源</li>
<li>片内路由资源</li>
<li>所需逻辑速度与最大 FPGA 速度</li>
<li>所需的逻辑速度与实施设计所需的逻辑层之间的关系</li>
</ul>
</li>
</ul>
<p>设计时钟注意事项：</p>
<ul>
<li>时钟抖动影响会严重降低已实现系统的性能。时钟抖动的影响包括时序预算余量和性能的降低；</li>
<li>时钟偏差描述了相关信号和时钟到达时间之间的差异。信号和时钟偏斜的影响包括保持时间故障，数据错误和减少的 I/O 时序裕量；</li>
<li>时钟占空比失真会导致脉冲宽度减小，数据错误和电路性能不可靠；</li>
<li>时钟抖动，偏斜和占空比失真的影响会影响 FPGA 电路性能的所有水平，应仔细管理和控制；</li>
<li><strong>将 FPGA 时钟分成优先级组</strong>；<ul>
<li>使用约束条件来更清楚地表征设计工具的时钟。</li>
<li>约束可用于指定时钟速率，相位关系和占空比。</li>
<li>约束还可用于将高优先级时钟与其驱动的电路相关联。</li>
<li>时钟优先级组：<ul>
<li>高频率，高扇出</li>
<li>中频或低频，高扇出</li>
<li>高频率，低扇出</li>
<li>中频或低频，低扇出</li>
</ul>
</li>
</ul>
</li>
<li><strong>首先分配最高优先级的时钟</strong>。FPGA 时钟最重要的两个挑战是高速和高扇出。具有这些特征的时钟应分配给更高性能的全局资源。高性能缓冲区和路由资源的数量有限，因此应谨慎管理。</li>
<li><strong>分配时钟块管理资源</strong>。Xilinx’s 的数字时钟管理器（DCM）等时钟模块可以实现高级时钟电路功能，包括分频和乘法，相移，基于反馈的调整和同步时钟生成。时钟块是 FPGA 组件中有限的资源。设计团队应监视和控制如何分配这些资源。</li>
<li><strong>管理优先级较低的时钟</strong>。尽管较低优先级的时钟可以在完整的 FPGA 全局资源上实现（如果可用），它们也可以通过标准 FPGA 路由结构进行路由。有可能将全局时钟路由分成多个较小的高性能时钟路由。</li>
</ul>
<h2 id="Timing-Constraints"><a href="#Timing-Constraints" class="headerlink" title="Timing Constraints"></a>Timing Constraints</h2><p>时序约束可用于影响和指导设计元素的放置以及所放置元素之间的信号路径，以满足设计性能要求；   </p>
<p>时序约束的两种常规类型是全局约束和特定于路径的：</p>
<ul>
<li>全局时序约束涵盖了逻辑设计中的所有路径；</li>
<li>特定于路径的约束涵盖特定路径；</li>
</ul>
<p>指定时钟和数据信号的关系以及时序，以确保不违反内部 FPGA 寄存器的设置和保持时间要求；   </p>
<p>以下两个约束的时序关系为实施工具提供了最佳实施设计所需的信息：</p>
<ul>
<li>OFFSET_IN_BEFORE 约束用于定义在系统时钟的上升沿到达 FPGA 时钟引脚之前，数据信号应有效的时间；</li>
<li>VALID 约束用于指定系统时钟上升沿之后数据信号有效的时间量和数据信号有效的时间量；</li>
</ul>
<p>使用系统同步定时方法将信号从 FPGA 内部的寄存器发送到外部组件：</p>
<ul>
<li>了解 FPGA 对外部设备时序的要求是约束过程的第一步；</li>
<li>必须确定外部组件接口 I/O 标准，到外部组件的路由延迟以及 FPGA I/O 引脚的负载；</li>
<li>了解详细的时序值可以支持时序约束的分配，从而指定数据信号必须从内部 FPGA 寄存器的输出传播到 FPGA 输出引脚的最长时间；</li>
<li>FPGA 的内部延迟包括时钟路径延迟，寄存器时钟到输出时间以及从寄存器到输出引脚的数据路径延迟；</li>
</ul>
<p>基于这些约束，实现工具可以确定满足指定时序要求的路径路由。</p>
<h2 id="Area-Constraints"><a href="#Area-Constraints" class="headerlink" title="Area Constraints"></a>Area Constraints</h2><p>Area 限制了引导和控制布局布线工具可能将 FPGA 设计元素放置在何处：</p>
<ul>
<li>区域约束还可以定义设计元素的潜在放置区域。</li>
<li>区域约束的好处是可以减少布局布线工具的实施时间。</li>
<li>如果 block element 受区域限制，则放置和布线工具不必搜索放置 block element 的位置；</li>
<li>将多个设计元素块布置到目标 FPGA 架构上的过程通常称为布局规划；</li>
</ul>
<h2 id="Design-Optimization"><a href="#Design-Optimization" class="headerlink" title="Design Optimization"></a>Design Optimization</h2><p>设计优化是一个增量过程，需要增加工程量和工具计算时间来利用设计来满足时序要求。</p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-LabExercise/FPGAOptimization.png" alt="FPGAOptimization"></p>
<h1 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h1><p>设计练习1：组合电路 ⎯ 1 位加法器<br>设计练习2：组合电路 ⎯ 2 位乘法器<br>设计练习3：时序电路 ⎯ 1 位计数器<br>设计练习4：时序电路 ⎯ 4 位移位寄存器  </p>
<p>提示：在 Vivado 上执行 FPGA 设计:</p>
<ul>
<li>编写 Verilog 代码</li>
<li>创建项目</li>
<li>编写 Verilog testbench</li>
<li>综合逻辑电路</li>
<li>检查仿真结果 </li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核设计 | （1）从开机到 main 函数执行</title>
    <url>/2020/06/29/Linux/LinuxKernelDesign-1.PowerOnToMainFunction/</url>
    <content><![CDATA[<p>这里提到的 linux 版本是 0.11，在当时，操作系统都是存在软盘里的，而 CPU 的逻辑电路被设计为只能运行内存中的程序。电路刚通电时，内存（RAM）里什么都没有，那么计算机是怎样将操作系统运行起来的呢？</p>
<a id="more"></a>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>这里约定的计算机是基于 IA-32 系列 CPU，安装了标准单色显示器、标准键盘、一个软盘、一块硬盘、16 MB 内存，在内存中开辟了 2 MB 内存作为虚拟盘，并在 BIOS 中设置软驱为启动设备。    </p>
<p>为什么选 Linux 0.11 内核？</p>
<ul>
<li>Linux 0.11 内核代码虽然只有约两万行，但却实实在在的撑起了一个现代OS，更便于初学者学习理解；</li>
<li>它是 Linux 其他后续版本的鼻祖，这样我们能更容易的看清设计者最初的、最根本的设计意图和设计指导思想；</li>
</ul>
<p>系列参考资料：</p>
<ul>
<li>《Linux 内核设计的艺术-图解 Linux 操作系统架构设计与实现原理（第 2 版）》</li>
<li>《IA-32-3》</li>
<li>《Linux 内核完全注释》- 内核版本0.11 - 赵炯</li>
</ul>
<p>说明：该系列是本人结合国科大相关课程总结的笔记心得，按书籍教程主要分为三大部分：</p>
<ol>
<li>分析从开机加电到 OS 启动完成并进入怠速状态的整个过程：<ul>
<li>开机加电启动 BIOS，通过 BIOS 加载操作系统程序，对主机的初始化，打开保护模式和分页，调用 main 函数，创建进程 0、进程 1、进程 2 以及 shell 进程，并且具备用文件的形式与外设交互。</li>
</ul>
</li>
<li>OS 进入系统怠速后，在执行用户程序的过程中，OS 和用户进程的实际运行过程和状态：<ul>
<li>利用几个设计好的简单的又具有代表性的应用程序，以其执行作为引导，详细讲解安装文件系统、文件操作、用户进程与内存管理、多个进程对文件的操作以及进程间的通信。</li>
</ul>
</li>
<li>整个 Linux 的设计指导思想，从微观到宏观的回归分析：<ul>
<li>重点部分：详细阐述主奴机制以及实现主奴机制的三项关键技术（保护和分页、特权级、中断），分析保障主奴机制实现的决定性因素—先机，详细讲解缓冲区、共享页面、信号、管道的设计指导思想。（作者尝试从操作系统设计者的视角讲解操作系统的设计指导思想。希望帮助读者用体系的思想理解、把握、驾驭整个操作系统以及背后的设计思想和设计意图）</li>
</ul>
</li>
</ol>
<h1 id="BIOS-启动"><a href="#BIOS-启动" class="headerlink" title="BIOS 启动"></a>BIOS 启动</h1><p>前面说到 CPU 只能执行内存里的程序，而刚通电时，计算机内存为空，OS 处在软盘。那么，自然就需要由某个部分将 OS 加载到内存，而完成这项工作的就是 <strong>BIOS</strong>。    </p>
<p>问题就来了，BIOS 自身也是一段程序，那它最开始又是如何执行的呢？      </p>
<p>这一过程得益于硬件 CPU 强制执行 BIOS。CPU 都被设计为<strong>加电即进入 16 位实模式状态运行</strong>，其硬件逻辑在加电瞬间就会设置 CS（<code>0xF000</code>）和 IP（<code>0xFFF0</code>），这样 CS:IP 也就指向 <strong><code>0xFFFF0</code></strong> 这个地址，而这里就处在 BIOS 中，是 <strong>BIOS 程序的入口地址</strong>。    </p>
<div class="note warning">
            <ul><li>CPU 将要执行的指令的内存地址是由 IP（偏移）和 CS（段基址）组合来指定。实模式下该地址为绝对地址，指令指针为 16 位；保护模式下为线性地址，指令指针为 32 位，即 EIP。    </li><li>BIOS 是固化在计算机主板上一块很小的 ROM 芯片里的程序。不同主板会有所不同，这里的 BIOS 是 8KB，所占地址段为 <code>0xFE000 ~ 0xFFFFF</code>。</li></ul>
          </div>
<h1 id="BIOS-执行"><a href="#BIOS-执行" class="headerlink" title="BIOS 执行"></a>BIOS 执行</h1><p>BIOS 启动后，开始执行一系列 BIOS 代码，完成自检等操作。检测显卡、内存等，并在屏幕上显示这些机器系统数据（显卡信息、内存信息等）。而这个过程需要重点说的就是：<strong>BIOS 在内存里建立中断向量表和中断服务程序</strong>。     </p>
<p>具体来说就是：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Mem-BIOS.png" alt="Mem-BIOS"></p>
<ul>
<li>在 <code>0x00000 ~ 0x003FF</code> 这 1 KB 的内存空间里构建<strong>中断向量表</strong>；<ul>
<li>一共有 256 个中断向量，每个占 4 B（2 B 为 CS 的值，2 B 为 IP 的值）；</li>
</ul>
</li>
<li>在紧接着的 <code>0x00400 ~ 0x004FF</code> 这 256 B 的内存空间里构建 <strong>BIOS 数据区</strong>（存放机器系统数据）；</li>
<li>在接着大约 57 KB 之后的位置 <code>0x0E05B</code> 处加载了 8 KB 左右的与中断向量表相对应的<strong>中断服务程序</strong>；</li>
</ul>
<p>在上述自检过程完成后，计算机硬件（体系结构的设计）和 BIOS 一同产生一个 <strong><code>int 0x19</code></strong> 中断。CPU 收到此中断后，查找中断向量表，并找到 <code>int 0x19 中断向量</code>。这个中断向量就将 CPU 指向 <strong><code>0x0E6F2</code></strong> 这个地址执行（<code>int 0x19</code> 对应的中断服务程序的入口地址）。这个中断服务程序是 BIOS 事先设计好的（代码固定，与 OS 无关），它的工作就是：<strong>把软盘第一扇区中的程序 <code>bootsect.s</code>（512 B，因此两个扇区为 1 KB）加载到内存指定位置（<code>0x07C00</code>）</strong>。    </p>
<div class="note warning">
            <p>这个过程就需要 OS 设计者和 BIOS 的设计者完成一种两头约定：   </p><ul><li>操作系统：必须把最开始执行的程序 “定位” 在启动扇区（软盘中的 0 盘面 0 磁道 1 扇区）；   </li><li>BIOS：“约定” 接到启动操作系统的命令，就 “定位识别” 只从启动扇区把代码加载到 <code>0x7C00</code>（BOOTSEG）这个位置；</li></ul>
          </div>
<h1 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h1><p>在实模式下，指令指针 CS 和 IP 都是 16 位的，它们组合的内存寻址最大范围为 1 MB（20 位）。而 <strong>bootsect.s 首先的工作就是对这 1 MB 的内存空间进行规划</strong>，来确保后续代码的加载与已加载的代码互不干扰，并且都有足够大的内存空间可用；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemPlanning-bootsect.png" alt="MemPlanning-bootsect"></p>
<ul>
<li>bootsect.s 的开头会设定一段代码来设置相应的内存位置：<ul>
<li>将要加载的 setup 程序的扇区数（<code>SETUPLEN</code>）以及它要被加载到的位置（<code>SETUPSEG</code>）；</li>
<li>启动扇区 bootsect 被 BIOS 重新加载的位置（<code>BOOTSEG</code>）及将要移动到的新位置（<code>INITSEG</code>）；</li>
<li>内核（kernel）被加载的位置（<code>SYSSEG</code>）、内核的末尾位置（<code>ENDSEG</code>）；</li>
<li>根文件系统设备号（<code>BOOT_DEV</code>）；    </li>
</ul>
</li>
</ul>
<p>接着，booesect 按之前的内存规划将自己全部（512 B）的内容从 <code>0x07C00</code>（<code>BOOTSEG</code>） <strong>拷贝到新的内存位置</strong> <code>0x90000</code>（<code>INITSEG</code>）。    </p>
<ul>
<li>由于之前说过的 OS 设计和 BIOS 设计的约定，才会在开始时 bootsect 被迫被加载到 <code>0x07C00</code> 的位置。现在将自身拷贝的 <code>0x90000</code> 处，则说明 OS 已经开始根据自身需要安排内存了；</li>
</ul>
<p>拷贝完成后，但是 CPU 的 CS 还在原先的 <code>0x07C0</code>（BOOTSEG）处，于是需要<strong>修改 CS</strong> 值为 <code>0x9000</code>（INITSEG），并<strong>修改 IP</strong> 偏移值至下一条指令。这样，使程序在新的地方接着原先的过程执行。此时，代码整体位置改变，代码中的各个段也会随之改变，所以还需要<strong>设置 DS、ES、SS、SP 的值</strong>。这也是个分水岭，至此，程序可以开始执行更为复杂的数据运算类指令。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/JumpAndSSSPDSES-bootsect.png" alt="JumpAndSSSPDSES-bootsect">   </p>
<p>接下来，bootsect 还需要负责<strong>将 os 剩余的代码（<code>setup.s</code> 和 <code>system 模块</code>）拷贝进内存中</strong>。整个拷贝过程分两次进行：</p>
<ul>
<li>拷贝 <code>setup.s</code>：<ul>
<li><strong>传参</strong>：事先将指定的扇区、加载的内存位置等信息传递给服务程序；</li>
<li>参数传递完毕后，<strong>执行 <code>int 0x13</code> 指令</strong>，产生 <code>int 0x13</code> 中断，通过中断向量表找到对应的中断服务程序（<code>0x0E6FE</code>），将软盘<strong>第二个扇区开始的 4 个扇区（setup.s，2 KB）加载至内存的 SETUPSEG（0x90200）处</strong>，紧挨着重新拷贝后的 bootset.s；（注意：它还不足以影响到栈的内存空间）；</li>
</ul>
</li>
<li>拷贝 <code>system 模块</code>（包括 head.s 和 main 函数开始的 os 内核程序）：<ul>
<li>bootsect 同样借助 BIOS 的 <code>int 0x13</code> 中断，<strong>调用 <code>read_it</code> 子程序</strong>，将软盘第六扇区开始的 <strong>240 个扇区</strong>的 sysytem 模块加载至内存的 <strong>SYSSEG（0x10000）处</strong>往后的 <strong>120 KB 空间</strong>中；</li>
<li>整个加载过程时间较长，所以也会有一段用汇编编写的程序，使显示器显示 “Loading system…”，也涉及到其他 BIOS 中断；</li>
</ul>
</li>
</ul>
<div class="note warning">
            <ul><li><strong>system 模块</strong>是整个 OS 的核心部分，它由两部分构成：head.s 和 main 函数。</li><li><strong>head.s</strong> 同之前加载的 bootsect.s 和 setup.s 一样，是由汇编代码生成的程序，它处在 system 的开头位置，在内存中占有 25 KB + 184 B 的空间；</li><li><strong>main 函数</strong>紧接着 head.s 存在，它是由 c 语言编写的内核程序，可以说它才是真正的操作系统，在它之前执行的 bootsect.s、setup.s 和 head.s 都是为它做准备的；</li><li>这种特殊性，也让 syetem 模块和 bootsect.s、setup.s 的加载方式不同。<strong>大致的过程</strong>是：先将 head.s 汇编成目标代码，将用 c 语言编写的内核程序编译成目标代码，然后再将它们链接成 system 模块。</li></ul>
          </div>
<p>至此，<mark>整个 OS 的代码都已被加载进内存</mark>。最后，由 bootsect 确认根设备号。根据开始处假设的计算机组成，这里经过一系列检测后，会确认计算机中实际安装的软盘驱动器为根设备，并将此信息写入机器系统数据。    </p>
<p>bootsect.s 的工作已全部完成。</p>
<h1 id="setup-s"><a href="#setup-s" class="headerlink" title="setup.s"></a>setup.s</h1><p>在 bootsect.s 完成它所有的任务后，会<strong>执行 <code>jmpi 0,SETUPSEG</code> 跳转</strong>至 <code>0x90200</code> 处（setup.s 所在的位置），也即 CS:IP 指向 setup 程序的第一条指令，<strong>setup.s 开始执行</strong>。</p>
<p>首先，setup.s 会利用 BIOS 提供的中断服务从设备上<strong>提取内核运行所需的机器系统数据 510 B</strong>（注意这里加载的不是 BIOS 数据区里的），并将这些数据加载到内存的 <code>0x90000 ~ 0x901FC</code> 位置。<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/LoadMachineSystemData-setup.png" alt="LoadMachineSystemData-setup"></p>
<ul>
<li>注意：加载的这部分机器系统数据是覆盖了原先已经执行完的 512 B 的 bootsect.s，只有 2 B 未被覆盖，这样很好的利用了内存空间，使内存利用率更高；</li>
</ul>
<p>至此，<mark>整个操作系统内核程序所需的加载工作都已完成，通过内存中的这些代码数据，将开始实现从实模式到保护模式的转变</mark>。</p>
<p>之前，我们所有用到的中断服务都是由 BIOS 提供，而之后 OS 会接管整个系统，它自身也会提供一套的中断服务系统。为了完全这个转变，不让接下来的工作出错，此时就得<strong>先关中断（cli）</strong>。即：<strong>将 CPU 的标志寄存器（EFLAGS）中的中断允许标志（IF）置 0</strong>；</p>
<div class="note warning">
            <ul><li>关中断（cli）和开中断（sti）它们在 OS 里总是成对出现的，目的就是为了防止中断在某个过程中介入；   </li><li>此处，即将进行的是实模式下中断向量表和保护模式下中断描述符表（IDT）的交接。如果在此期间，用户不小心碰到键盘等引入了中断，就会导致不可预估的后果；</li></ul>
          </div>
<p>接下来，setup 程序会<strong>将位于 <code>0x10000</code> 的内核程序复制至内存的起始地址 <code>0x00000</code> 处</strong>（由 DS 和 ES 配合完成）。</p>
<ul>
<li>这个过程也就意味着，原先 BIOS 提供的中断向量表、BIOS 数据区以及相应的中断服务程序都完全被覆盖，旧的中断体系已经失效，系统准备向 32 位的保护模式转变；</li>
</ul>
<p>然后，setup 程序利用自身提供的数据信息<strong>对中断描述符表寄存器（IDTR）和全局描述符表寄存器（GDTR）进行初始化设置</strong>，进而完成<strong>中断描述符比表（IDT）和全局描述符表（GDT）的初始化</strong>；   </p>
<div class="note ">
            <ul><li><strong>GDT（全局描述符表）</strong>：是一个存放段寄存器内容（段描述符）的数组，用来配合程序进行保护模式下的段寻址。在 OS 中进程切换具有重要意义，可理解为所有进程的总目录表，其中存放着每一个任务（task）局部描述符表（LDT）地址和任务状态段（TSS）地址，完成进程中各段的寻址、现场保护与现场恢复；   </li><li><strong>GDTR（GDT 基址寄存器）</strong>：GDT 可以存放在内存中任意位置，而 GDTR 的内容就是标识 GDT 的入口地址；</li><li><strong>IDT（中断描述符表）</strong>：保存保护模式下所有中断服务程序的入口地址；</li><li><strong>IDTR（IDT 基址寄存器）</strong>：保存 IDT 起始地址；</li></ul>
          </div>
<ul>
<li>这个过程可以理解为：内核设计时，已经将两个表（包括所需的初始数据）写好，随着 OS 代码一起已经被加载到了内存，之后程序通过 <code>lidt</code> 和 <code>lgdt</code> 指令将两个专用寄存器指向这两个表（即 idt_48 和 gdt_48 对应的标号处）即可；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetGDTRAndIDTR.png" alt="SetGDTRAndIDTR"><ul>
<li>由图可以看到：IDTR 指向了 <code>0x00000</code> 位置（IDT 基址），此时出于关中断状态，IDT 还是一张空表；</li>
<li>GDTR 指向了 <code>0x90200+</code> 位置（现在创建的 GDT 基址），此时内核还未运行没有进程，GDT 的内容也就如图所示，其余项全为空；</li>
</ul>
</li>
</ul>
<p>接下来的工作就是：<strong>打开 A20</strong>，<strong>这也就意味着 CPU 可以进行 32 位寻址，最大寻址空间为 4 GB</strong>。下图显示了此时内存寻址空间的变化（注意区别）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemAddressingChange.png" alt="MemAddressingChange"></p>
<ul>
<li>此时，物理地址空间虽然受限于 16 MB，但是其线性地址空间已经变成了 4 GB；</li>
<li>实模式下，CPU 寻址范围为 <code>0 ~ 0xFFFFF</code>，共 1 MB，需要 0 ~ 19 号（20 根）地址线。进入保护模式，使用 32 位寻址，自然也就需要打开剩余的 20 ~ 31 号地址线；</li>
<li>实模式下，CS 和 IP 的最大值都为 <code>0xFFFF</code>，这两者组合而成的最大绝对地址为 <code>0x10FFEF</code>（16*CS+IP），而此时 CPU 最大寻址为 <code>0xFFFFF</code>。对于超出的这 16 KB 地址，CPU 会将其 “回滚” 至内存起始处寻址。而启用 A20 后，相当于关闭了 CPU 在实模式下的 “回滚” 机制，也就正好可以利用这个特点验证 A20 地址线是否已经打开；</li>
</ul>
<p>为了建立保护模式下的中断机制，setup 开始<strong>对可编程中断控制器 8259A 进行重新编程</strong>；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/Pragram8259A.png" alt="Pragram8259A">    </p>
<p>之后，setup 还需要<strong>将 CR0（0 号 32 位控制寄存器，存放系统控制标志）寄存器的第 0 位（PE）置 1</strong>，即开启 CPU 的工作方式为保护模式；此后，寻址方式变化如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/ChangeToAddressing.png" alt="ChangeToAddressing">    </p>
<p>至此，setup 的工作全部完成，它还有最后一行<strong>代码 <code>jmpi 0,8</code>，跳转至 head 程序起始地址开始执行</strong>；</p>
<ul>
<li>关于 <code>0,8</code>，对应到二进制也就为：<code>0000,1000</code>：<ul>
<li>最后两位 <code>00</code>：表示内核特权级，对应的 <code>11</code> 就是用户特权级，其他形式无效；</li>
<li>第三位 <code>0</code>：表示 GDT，如果为 <code>1</code> 则表示 LDT；</li>
<li>再接下来的 <code>1</code>：表示所选的表（GDT）的 1 项（GDT 表项从 0 开始）；</li>
<li>由这些信息就可以推算出：<strong>内核代码段（0x08）、内核数据段（0x10）、用户代码段（0x17）、用户数据段（0x0F）</strong>；</li>
</ul>
</li>
<li>再对整个的跳转指令寻址进行解读：<ul>
<li><code>jmpi 0,8</code>：它是处在内核级，会选择 GDT 的 1 项（代码段），这一项的解读如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/GDT1item.png" alt="GDT1item"></li>
<li>由此确定段基址为 <code>0x00000000</code>，偏移为 0，也即 head 程序的起始位置处；</li>
</ul>
</li>
</ul>
<h1 id="head-s"><a href="#head-s" class="headerlink" title="head.s"></a>head.s</h1><p>经过前面一连串的准备工作，这里终于进入到了 system 模块，但是这并不意味着就进入到了 main 函数的执行。前面加载时说过，在 system 模块的开头还有一段叫做 head.s 的代码。此时的 system 在内存的分布情况如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SystemInMem.png" alt="SystemInMem">      </p>
<p>head 程序的除了<strong>做一些调用 main 函数的准备工作</strong>之外，还会<strong>用程序自身的代码在程序自身所在的内存空间创建内核分页机制</strong>，即在 <code>0x000000</code> 的位置创建页目录表、页表、缓冲区、GDT、IDT，并将 head 程序已经执行过的代码所占内存空间覆盖（自身边执行，边自我覆盖）。具体过程如下：</p>
<p><strong>标号 <code>_pg_dir</code></strong> 标识内核分页机制完成后的内核起始位置，即物理内存起始位置 <code>0x000000</code>；</p>
<p>前面的 <code>jmpi 0,8</code>，已经使得 CS 和 GDT 第二项关联（CS 不再是代码段基址而是代码段选择符），并且使代码段基址指向 <code>0x000000</code>。相应的，也需要<strong>修改 DS、ES、FS 和 GS 的值为 0x10</strong>（内核数据段）；具体内容如下图：<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS-head.png" alt="DSESFSGS-head"></p>
<p><strong>SS</strong> 也需要变为栈段选择符（也是 <code>0x10</code>），栈顶指针也由 16 位的 SP 变为 32 位的 <strong>ESP</strong>（并且起始位置大概在 <code>0x1E25C</code>）<br>  <img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SSESP-head.png" alt="SSESP-head">   </p>
<p><strong>设置 IDT，搭建中断机制的整体框架</strong>，具体内容如下：</p>
<ul>
<li>IDT 有 256 个表项，每个表项占 64 位，因此其大小为 2 KB。每个表项（中断描述符）结构如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/InterruptDescriptor.png" alt="InterruptDescriptor"></li>
<li>设置相关的 IDT 寄存器：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/IDT-head.png" alt="IDT-head"></li>
<li>让所有的中断描述符默认指向 ignore_int 这个位置（将来 main 函数再让中断描述符对应到具体的中断服务程序），即此时所有的中断服务程序都是指向同一段只显示一行提示信息就返回的服务程序（这样，既可以避免无意中覆盖代码数据，也可给开发过程中的误操提供提示）；</li>
</ul>
<p><strong>废除旧的 GDT，并在内核新的位置重新创建 GDT</strong>：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/RebuildGDT-head.png" alt="RebuildGDT-head"></p>
<ul>
<li>重新设置一方面是设置新的位置，另一方面是修改段限长，这样做的目的也明显：旧 GDT 由 setup.s 设置，处在 <code>0x90200+</code> 的位置，而现在它已经执行完毕，未来它所处的内存位置必然会被替换为别的用途（缓冲区），这样只好重新将它放在 head.s 已经执行完的位置最好，物尽其用。</li>
</ul>
<p>段限长被修改了，那么相应的 <strong>DS、ES、FS、GS 及 SS</strong> 的段选择符也需要重新设置（再来一遍 <code>0x10</code>，重新加载 GDT 相应表项，这只是在原有基础上将<strong>段限长扩大为 16 MB</strong>，其他内容并未发生改变）；ESP 不需要；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/DSESFSGS2-head.png" alt="DSESFSGS2-head">    </p>
<p><strong>检验 A20 地址线是否打开</strong>，检验方法就是之前提及的 “回滚法”，具体如下：</p>
<ul>
<li>通过在内存 <code>0x000000</code> 位置写入一个数据，然后比较此处和 1 MB（<code>0x100000</code>，已超过实模式寻址范围）处数据是否一致；</li>
</ul>
<p>head 程序如果检测到数学协处理器，则将其设置为保护模式工作状态；</p>
<ul>
<li>486 处理器以前，为弥补 CPU 浮点运算不足设置的外置可选芯片。486 处理器之后，CPU 就都基本内置了协处理器，也就不需要此步；</li>
</ul>
<p>接下来，就是 head.s <strong>为调用 main 函数做最后的准备工作</strong>：</p>
<ul>
<li><strong>将 envp、argv、argc 压栈：将 L6 标号（也就是 main 函数异常退出后返回的执行位置）和 main 函数入口地址压栈</strong>。此时，栈顶为 main 函数的入口地址，这样在 head.s 执行完毕后，就可以直接通过 ret 指令执行 main 函数；<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PushForMain.png" alt="PushForMain"></li>
<li>压栈完成后，head.s 跳转至 <code>setup_paging:</code> 执行，开始<strong>创建分页机制</strong>（下面创建的 4 个页表是内核专属页表，将来每个用户进程也会有它们自己的专属页表）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/SetPageTable.png" alt="SetPageTable"></li>
<li>页表设置完毕，但分页机制还没完全建立，还需要<strong>设置页目录表基址寄存器 CR3</strong>（3 号 32 位控制寄存器，高 20 位存放页目录表基址，当 CR0 的 PG=1 时，CPU 使用 CR3 指向的页目录表和页表进行虚拟地址到物理地址的映射）<strong>使之指向页目录表</strong>，再将 <strong>CR0 寄存器的最高位（PG</strong>，分页机制控制位，它必须在 PE=1 的保护模式下才能开启）<strong>置 1</strong>。此时分页机制完成后，总体状态如下：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/PageTableStatus.png" alt="PageTableStatus"><ul>
<li>注意：标号 pg_dir 标识的 <code>0x0000</code> 这个位置是内核通过分页机制能够实现线性地址等于物理地址的唯一起始位置；</li>
</ul>
</li>
<li>此时的内存分布情况如下（注意 head.s 的大小和内存分布的情况）：<br><img src="http://img.thebetterkong.cn/blog/LinuxKernelDesign-1.PowerOnToMainFunction/MemDistribution-head.png" alt="MemDistribution-head"></li>
</ul>
<p>现在，就是 head.s 的最后一步，<strong>通过 ret 指令，将压入栈的 main 函数的执行入口地址弹出给 EIP</strong>，跳入 main 函数开始执行；</p>
<ul>
<li>这里需要说明一下，OS 的 main 函数和其他普通函数的调用过程不太一样；</li>
<li>通常函数：都是通过 call 指令调用，它会将 EIP 的值自动压栈，保护返回现场，然后执行被调函数的程序。等到执行被调函数的 ret 指令时，自动出栈给 EIP 并还原现场，继续执行 call 的下一条执行；</li>
<li>而操作系统则不同，它是用 ret 实现的调用操作系统的 main 函数。事先由 OS 的设计者手工编写代码压栈（压栈的 EIP 值为 main 函数的入口地址）和跳转，来模仿 call 的全部动作，进而去调用 <code>setup_paging</code> 函数。然后，当 <code>setup_paging</code> 函数执行到 ret 时，从栈中将 main 函数的入口地址 _main 弹出给 EIP，构成 CS:EIP，这也就等价于 CPU 开始执行 main 函数程序；</li>
</ul>
<p>之后，操作系统 main 函数开始执行，但是注意：此时仍然是关中断的状态！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Routing Design Methodology</title>
    <url>/2020/03/31/FPGA-technology/FPGA-RoutingDesignMethodology/</url>
    <content><![CDATA[<p>FPGA 路由设计，即布线设计方法；</p>
<a id="more"></a> 
<h1 id="FPGA-Interconnect-的灵活性"><a href="#FPGA-Interconnect-的灵活性" class="headerlink" title="FPGA Interconnect 的灵活性"></a>FPGA Interconnect 的灵活性</h1><p>定义 FPGA 互连结构灵活性的参数：</p>
<ul>
<li>Channel width，通道宽度（W）：路由通道中的轨道数</li>
<li>Wire segment length，导线段长度（L）：导线段经过的逻辑块数</li>
<li>Population of Switch Box（Fs）：一条轨道可以通过 switches 连接到的轨道数量</li>
<li>Population of Connection Box（Fc）：连接到 CLB 引脚的相邻信道中的路由轨道的比例：<ul>
<li>Fc（in）：CLB 的输入部分灵活性，注意，这里的 in/out 是针对 CLB 来说的</li>
<li>Fc（out）：CLB 的输出部分灵活性</li>
</ul>
</li>
</ul>
<p>例子：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/ExamplesFsAndFc.png" alt="ExamplesFsAndFc"></p>
<h1 id="Design-of-Connection-Block"><a href="#Design-of-Connection-Block" class="headerlink" title="Design of Connection Block"></a>Design of Connection Block</h1><h2 id="认识回顾"><a href="#认识回顾" class="headerlink" title="认识回顾"></a>认识回顾</h2><p>Connection Block：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/ConnectionBlock.png" alt="ConnectionBlock"></p>
<p>如果采取 fully connected CB：</p>
<ul>
<li>需要 $n \times m$ 个 switchs；</li>
<li>面积更大，延迟更长</li>
</ul>
<p>设计目标：</p>
<ul>
<li>增加路由能力</li>
<li>限制条件：开关数量最少，面积较小，延时较短</li>
</ul>
<h2 id="相关概念定义"><a href="#相关概念定义" class="headerlink" title="相关概念定义"></a>相关概念定义</h2><p>Connection Block 的邻接矩阵：<mark>$A_G=[a_{i,j}]_{n \times m}$</mark><br>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/AdjacencyMatrix.png" alt="AdjacencyMatrix"></p>
<p>Connection Block 的设计参数：</p>
<ul>
<li><mark>$fan_{out}(i)$</mark>：对于输入 i，它所能连接到的输出的数量；（邻接矩阵中，i 行有多少个 1）</li>
<li><mark>$fan_{in}(j)$</mark>：对于输出 j，它所能连接到的输入的数量；（邻接矩阵中，j 列有多少个 1）</li>
<li><mark>$\delta_c=\max_{1\leq i \leq n}(fan_{out}(i))-\min_{1\leq i \leq n}(fan_{out}(i))$</mark>；（对所有行：1 数量最大值减去最小值）</li>
<li><mark>$\delta_p=\max_{1\leq j \leq m}(fan_{in}(j))-\min_{1\leq j \leq m}(fan_{in}(j))$</mark>；（对所有列：1 数量最大值减去最小值）</li>
<li><mark>w</mark>：CB 中的开关总数<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/ExampleParametersOfConnectionBlock.png" alt="ExampleParametersOfConnectionBlock"></li>
</ul>
<p>Connection Block 的设计约束：</p>
<ul>
<li>最小化：$\delta_c$ 和 $\delta_p$</li>
</ul>
<p>评估 CB 结构：</p>
<ol>
<li>Routability<ul>
<li>对于具有 n 个输入和 m 个输出的 CB，<mark>可路由路径的总数（total routable path）</mark>：输入到输出路由的所有可能组合的计数。（注意：是组合的计数，只要是从同样的输入到输出就只算一条）<ul>
<li>计算方法：取 m，n 中的较小者，例如下图是 m=2，然后将所有可能的组合方式用元组形式罗列出来，注意：如果元组内元素相同，顺序不同，也是对于同一种相同方式。</li>
<li>例如：图二的所有可能组合为：$(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)$；</li>
</ul>
</li>
<li><mark>$Routability=\frac{total\ routable\ path}{C_n^m}$</mark>，其中 $C_n^m=\frac{n!}{m!(n-m)!}$<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/ExampleRoutability.png" alt="ExampleRoutability"></li>
</ul>
</li>
<li>Area-delay product</li>
</ol>
<h2 id="设计-CB-架构的总体模型"><a href="#设计-CB-架构的总体模型" class="headerlink" title="设计 CB 架构的总体模型"></a>设计 CB 架构的总体模型</h2><ol>
<li>给定 $n \times m$ 的 CB 的邻接矩阵：$A_G=[a_{i,j}]_{n \times m}$</li>
<li>给定约束，关于：固定的 w 和最小化 $\delta_c$，$\delta_p$ 的约束；</li>
<li>获得最优的 routability 和 area-delay product；</li>
</ol>
<ul>
<li><mark>$Cost function=\frac{\alpha}{routability}+\frac{\beta}{area-delay\  product}$</mark></li>
</ul>
<h2 id="算法：Simulated-Annealing-Algorithm"><a href="#算法：Simulated-Annealing-Algorithm" class="headerlink" title="算法：Simulated Annealing Algorithm"></a>算法：Simulated Annealing Algorithm</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/SimulatedAnnealingAlgorithm.png" alt="SimulatedAnnealingAlgorithm"></p>
<h2 id="用-Simulated-Annealing-Algorithm-寻找最佳的-routability"><a href="#用-Simulated-Annealing-Algorithm-寻找最佳的-routability" class="headerlink" title="用 Simulated Annealing Algorithm 寻找最佳的 routability"></a>用 Simulated Annealing Algorithm 寻找最佳的 routability</h2><ul>
<li>Inputs: n, m, w</li>
<li>Constraint(约束): 最小化的 $\delta_c$，$\delta_p$</li>
<li>Cost function: CB 的可路由性</li>
<li>Output: 最优化的邻接矩阵 $A_G$<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/ExampleAlgorithm.png" alt="Example:Algorithm"></li>
</ul>
<h2 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h2><h3 id="Routability-vs-w-n-m"><a href="#Routability-vs-w-n-m" class="headerlink" title="Routability vs. w, n, m"></a>Routability vs. w, n, m</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/results1.png" alt="results1"><br>$(n-m+1) \times m$ 是 full Routability 所需的最小 switches 数</p>
<ul>
<li>当 $\frac{w}{(n-m+1)\times m}  \geq 0.7$，$Routability \geq 90\%$；</li>
<li>当 $\frac{w}{(n-m+1)\times m}  = 0.8$，$Routability \approx 100\%$；</li>
<li>当 $\frac{w}{(n-m+1)\times m}  = 1$，$Routability = 100\%$；</li>
</ul>
<h3 id="Routability-vs-delta-c-，-delta-p"><a href="#Routability-vs-delta-c-，-delta-p" class="headerlink" title="Routability vs. $\delta_c$，$\delta_p$"></a>Routability vs. $\delta_c$，$\delta_p$</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/results2.png" alt="results2"></p>
<ul>
<li>40% populations 就是我们能接受的范围了；</li>
</ul>
<h1 id="Design-of-Switch-Block"><a href="#Design-of-Switch-Block" class="headerlink" title="Design of Switch Block"></a>Design of Switch Block</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Switch Block 拓扑结构：</p>
<ul>
<li>Disjoint</li>
<li>Wilton</li>
<li>Combined structure</li>
</ul>
<p>Switch Block 设计参数：</p>
<ul>
<li>Channel width(W)</li>
<li>Segment length(L)</li>
<li>Population of switch block and connection clock</li>
</ul>
<h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/DesignFlow.png" alt="DesignFlow"></p>
<h2 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h2><h3 id="Circuits-speed-vs-Switch-block-topology"><a href="#Circuits-speed-vs-Switch-block-topology" class="headerlink" title="Circuits speed vs. Switch block topology"></a>Circuits speed vs. Switch block topology</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/CircuitsSpeedVsSwitchBlockTopology.png" alt="Circuits speed vs. Switch block topology"></p>
<h3 id="Area-vs-Switch-block-topology"><a href="#Area-vs-Switch-block-topology" class="headerlink" title="Area vs. Switch block topology"></a>Area vs. Switch block topology</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/AreaVsSwitchBlockTopology.png" alt="Area vs. Switch block topology"></p>
<h2 id="长导线互连驱动设计"><a href="#长导线互连驱动设计" class="headerlink" title="长导线互连驱动设计"></a>长导线互连驱动设计</h2><blockquote>
<p>带有周围电路的长度为 2 的电线的附加细节;<br>与一般的 ASIC repeater(中继器) insertion 问题不同的是：FPGA 互连设计使用一根长的、直的导线，沿着导线的内部点扇出;<br>这些被称为“早期转向”的 taps 或 turns 始终存在，但不一定总是使用；<br>FPGA 互连也有“可编程”的要求;<br>这是通过位于信号驱动器前面的 front-end multiplexer 实现的;</p>
</blockquote>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/DriverDesign.png" alt="driver design">  </p>
<p>长导线互连延迟：</p>
<ul>
<li>分段驱动；<br><img src="http://img.thebetterkong.cn/blog/FPGA-RoutingDesignMethodology/DistributedBuffering.png" alt="distributed buffering"></li>
<li>使用称为 “path delay profile”（PDP）的度量；<ul>
<li>这些 path delay profile 表明：分布式 buffering 更快，因为沿着线路的几个内部点更早地接收到信号；</li>
</ul>
</li>
<li>分布式设计比一端集中 buffering 更快，因为信号在中间点之前提前到达导线位置；</li>
</ul>
<h2 id="互连延迟最小化"><a href="#互连延迟最小化" class="headerlink" title="互连延迟最小化"></a>互连延迟最小化</h2><ul>
<li>给定金属导线RC特性和目标总物理导线长度L;    </li>
<li>找出 inverters 的最佳数量 N，每个 inverter 的尺寸 ($B_0…B_{N-1}$) 和每个 inverter 之间的导线数量 ($L_0…L_{N-1}$)，以使从互连导线开始到结束的信号传播延迟最小;</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基础入门</title>
    <url>/2020/06/07/Git/GitStart/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/GitStart/header.png" width="100%" alt="header.png" /> </div>   

<p>使用 git 已经挺长时间了，也在网上看过不少的学习教程。但是怎么说呢，git 的操作实在是太杂了，某一种目标可能就有好多种不同的实现方式，而且这些不同的实现方式又可能产生不同的结果。以至于，每次在网上查找到的解决方案可能都不同，然后不停地往 OneNote 里记笔记，时间久了，笔记越来越乱，再加上记忆力本就不好，原先不会的现在还是不会。于是寻思着简单的梳理一下。</p>
<a id="more"></a>
<h1 id="认识-git"><a href="#认识-git" class="headerlink" title="认识 git"></a>认识 git</h1><h2 id="什么是-git？"><a href="#什么是-git？" class="headerlink" title="什么是 git？"></a>什么是 git？</h2><p>它是一个<strong>分布式版本控制系统</strong>，用于项目开发中的版本控制；</p>
<ul>
<li>从本质上来讲 Git 是一个<strong>内容寻址（content-addressable）文件系统</strong>，并在此之上提供了一个版本控制系统的用户界面；</li>
<li>它的核心其实就是<strong>键值对数据库（key-value data store）</strong>，</li>
</ul>
<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>git 管理下的项目的文件分为：<strong>已跟踪</strong>和<strong>未跟踪</strong>两种状态</p>
<ul>
<li>已跟踪的文件：是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区；</li>
<li>工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区；</li>
<li>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态；</li>
</ul>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ul>
<li>Git 保存的不是文件的变化或者差异，而是一系列不同时刻的<strong>文件快照</strong>；</li>
<li>在进行提交操作时，Git 会保存一个<strong>提交对象（commit object）</strong>；</li>
<li>该提交对象会包含一个指向暂存内容快照的指针，但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针；</li>
</ul>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p><img src="http://img.thebetterkong.cn/blog/GitStart/gitmemory.png" alt="gitmemory">   </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>区域</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Workspace</td>
<td>工作区</td>
<td>当前用户操作修改的区域</td>
</tr>
<tr>
<td>Index/Stage</td>
<td>暂存区</td>
<td>add 后的区域</td>
</tr>
<tr>
<td>Repository</td>
<td>仓库区或本地仓库</td>
<td>commit 后的区域</td>
</tr>
<tr>
<td>Remote</td>
<td>远程仓库</td>
<td>push 后的区域</td>
</tr>
</tbody>
</table>
</div>
<h1 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真要说起来 git 里的难点也就是分支的使用。之前在同学的 blog 里找到了一个很好的学习 git 分支的平台：<a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">learnGitBranching</a>。与其说是学习，你更可以在无聊的时候把它当作一个 “游戏”，一边玩耍一边学习。其实最主要的，还是它能动态的帮助你理解 git 命令。</p>
<p><img src="http://img.thebetterkong.cn/blog/GitStart/Learngitbranching.png" alt="Learngitbranching">   </p>
<p>接下来的描述也会对它的一些操作进行梳理，毕竟复习或者查阅的时候，再去网站操作一遍，效率比较低。    </p>
<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>在正式介绍命令之前，先对 git 里常用的<strong>符号或者关键字</strong>进行说明：  </p>
<ul>
<li>分支名后带有符号 <code>*</code>：表示当前分支 </li>
<li><code>HEAD</code>：通常会和当前分支绑定在一起，总是指向当前分支上最近一次提交记录；<ul>
<li>但是也可以 <code>git checkout c1</code> 来<mark><strong>分离 HEAD</strong></mark>（c1 是某次提交记录的 hash 值，通常会很长，可以使用 <code>git log</code> 查看；当然了，也可以利用 tag 实现），使其指向某次具体的提交记录；分离之后的提交将不属于任何分支，一般的做法是在此处再创建一个新的分支，然后再 commit 进行后续的操作；</li>
<li>大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的；</li>
</ul>
</li>
<li>相对引用 <code>^</code>：向上移动一个提交记录，可叠加使用，如：HEAD^^^<ul>
<li>要注意：引用可以是分支名或者 HEAD，提交记录（如 c1）不算引用</li>
</ul>
</li>
<li>相对引用 <code>~&lt;num&gt;</code>：向上移动 num 个提交记录，如：~3</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">******************************************************</span><br><span class="line">##### git 配置</span><br><span class="line">$ git config --global user.name &quot;&lt;用户名&gt;&quot;</span><br><span class="line">$ git config --global user.email &quot;&lt;电子邮件&gt;&quot;</span><br><span class="line"></span><br><span class="line">## git 配置信息查看</span><br><span class="line">$ git config --system --list    &#x2F;&#x2F; 查看系统config</span><br><span class="line">$ git config --global  --list   &#x2F;&#x2F; 查看当前用户（global）配置</span><br><span class="line">$ git config --local  --list    &#x2F;&#x2F; 查看当前仓库配置信息</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 初始化仓库</span><br><span class="line">$ git init </span><br><span class="line">$ rm -rf .git   &#x2F;&#x2F; 删除本地仓库</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看当前缓存区状态</span><br><span class="line">$ git status    </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看历史提交记录</span><br><span class="line">$ git log</span><br><span class="line">$ git log --decorate        &#x2F;&#x2F; 显示包含标签资料的历史记录；</span><br><span class="line">$ git log --pretty&#x3D;oneline  &#x2F;&#x2F; 只看版本号和提交的版本信息</span><br><span class="line">$ git log --graph            &#x2F;&#x2F; 查看分支合并图</span><br><span class="line"></span><br><span class="line">### 查看分支图信息</span><br><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">$ git log --graph --decorate --oneline --all </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 查看文件的修改</span><br><span class="line">$ git diff &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 将修改添加到缓存区</span><br><span class="line">$ git add -A    &#x2F;&#x2F; 所有文件都添加，也可以使用 $ git add .</span><br><span class="line">$ git rm --cached &lt;file&gt;  &#x2F;&#x2F; 删除缓存，撤销 git add 的操作</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 提交变更</span><br><span class="line">$ git commit -m &quot;version 1.2&quot;   &#x2F;&#x2F; 引号内是本次提交的命名</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 克隆远程数据库 </span><br><span class="line">$ git clone &lt;repository&gt; &lt;directory&gt;</span><br><span class="line">  &#x2F;&#x2F; 在&lt;repository&gt;指定远程数据库的URL；</span><br><span class="line">  &#x2F;&#x2F; 在&lt;directory&gt;指定新目录的名称，省略时默认为当前目录；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 从远程数据库拉取更新至本地 </span><br><span class="line">$ git pull &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">  &#x2F;&#x2F; &lt;repository&gt; 处输入远程数据库地址；</span><br><span class="line">  &#x2F;&#x2F; &lt;refspec&gt; 处指定远程数据库的分支；</span><br><span class="line">$ git pull                &#x2F;&#x2F; github 上常用的抓取最新提交的方式</span><br><span class="line">$ git pull origin develop &#x2F;&#x2F; 从远程 origin 数据库的 develop 分支抓到本地的当前分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 将本地数据推送至远程数据库</span><br><span class="line">$ git push &lt;repository&gt; &lt;refspec&gt;...</span><br><span class="line">$ git push origin master &#x2F;&#x2F; 将本地的当前分支推送至远程 origin 数据库的 master 分支</span><br><span class="line">$ git push -u origin master </span><br><span class="line">  &#x2F;&#x2F; 第一次推送 master 分支时，远程库是空的，加上了-u 参数，</span><br><span class="line">  &#x2F;&#x2F; Git 不但会把本地 master 分支内容推送至远程新的 master </span><br><span class="line">  &#x2F;&#x2F; 分支，还会把本地 master 分支和远程 master 分支关联起来，</span><br><span class="line">  &#x2F;&#x2F; 以后就可以直接 git pull &#x2F; git push 简化命令</span><br><span class="line">$ git push --set -upstream &lt;远程仓库名称&gt; &lt;远程仓库中分支名称&gt;</span><br><span class="line">  &#x2F;&#x2F; 手动将本地当前分支与远程仓库的分支关联</span><br><span class="line">$ git push -f origin master  &#x2F;&#x2F; 强制推送</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">##### 添加远程数据库</span><br><span class="line">$ git remote add &lt;name&gt; &lt;url&gt;  </span><br><span class="line">  &#x2F;&#x2F; 添加的同时，给远程数据库命名，以后不用再输入URL；</span><br><span class="line">  &#x2F;&#x2F; 默认为：origin</span><br><span class="line">$ git remote set-url &lt;name&gt; &lt;url&gt;  &#x2F;&#x2F; 修改 git 的 remote url</span><br><span class="line">$ git config -e                    &#x2F;&#x2F; 从配置里修改 git 的 remote url</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的创建&#x2F;查看&#x2F;修改</span><br><span class="line">$ git branch                   &#x2F;&#x2F; 显示分支列表（带*的为当前分支）；</span><br><span class="line">$ git branch &lt;branchname&gt;      &#x2F;&#x2F; 创建分支并命名；</span><br><span class="line">$ git branch -d &lt;branchname&gt;   &#x2F;&#x2F; 删除本地分支；</span><br><span class="line">$ git push origin --delete &lt;branchname&gt; &#x2F;&#x2F; 删除远程分支；</span><br><span class="line">$ git branch -f master HEAD~3  &#x2F;&#x2F; 将 master 分支强制指向 HEAD 的第 3 级父提交；</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支的退出&#x2F;切换</span><br><span class="line">$ git checkout &lt;branchname&gt;     &#x2F;&#x2F; 退出当前分支并切换到其他分支；</span><br><span class="line">$ git checkout -b &lt;branchname&gt;  &#x2F;&#x2F; 创建分支并进行切换；</span><br><span class="line">$ git checkout commit_id&#x2F;tag    &#x2F;&#x2F; 分离 HEAD 至 commit_id&#x2F;tag 的提交处 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支合并 merge</span><br><span class="line">$ git merge &lt;branch&gt;           &#x2F;&#x2F; 将指定分支合并到当前分支</span><br><span class="line">$ git merge --squash &lt;branch&gt;  &#x2F;&#x2F; 将目标分支的所有提交压缩为一个，并添加到当前分支；</span><br><span class="line">$ git merge --abort            &#x2F;&#x2F; 取消当前合并，重建合并前状态 </span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 分支重定向 rebase（也可用来分支合并）</span><br><span class="line"> &#x2F;&#x2F; Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去；</span><br><span class="line"> &#x2F;&#x2F; 若用在分支合并，相比于 merge，可以创造更线性的提交历史</span><br><span class="line">$ git rebase &lt;branch&gt;   &#x2F;&#x2F; 把当前分支重定向到目标分支;</span><br><span class="line">$ git rebase --abort    &#x2F;&#x2F; 取消 rebase；</span><br><span class="line">$ git rebase -i HEAD~2  &#x2F;&#x2F; 编辑模式修改分支基准（修改pick，实现压缩squash&#x2F;修改edit等）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 选择重构 cherry-pick</span><br><span class="line">$ git cherry-pick &lt;commit&gt;...   &#x2F;&#x2F; 取出选择的提交并添加到当前分支</span><br><span class="line">  </span><br><span class="line">*******************************************************</span><br><span class="line">#### 还原 revert</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git revert HEAD   &#x2F;&#x2F; 取消某次提交（会新增否定的历史记录来实现）</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 重置 reset</span><br><span class="line"> &#x2F;&#x2F; 版本回退</span><br><span class="line">$ git reset --hard HEAD^  &#x2F;&#x2F; 重置结构 &#x2F;（删除）提交等（历史记录会消失）</span><br><span class="line">$ git reset --hard commit_id</span><br><span class="line">&#x2F;&#x2F; 如果想让服务器也回退到该版本的话：$ git push origin HEAD --force</span><br><span class="line"></span><br><span class="line">*******************************************************</span><br><span class="line">#### 标签 tag</span><br><span class="line">$ git tag                       &#x2F;&#x2F; 显示标签列表；</span><br><span class="line">$ git tag -n                    &#x2F;&#x2F; 显示标签列表及注解；</span><br><span class="line">$ git tag &lt;tagname&gt; &lt;commit_id&gt; &#x2F;&#x2F; 新建一个轻标签，默认为 HEAD，也可以指定commit id</span><br><span class="line">$ git tag -am &lt;注释&gt; &lt;tagname&gt;  &#x2F;&#x2F; HEAD 指向的提交里打上注释标签；</span><br><span class="line">$ git tag -d &lt;tagname&gt;          &#x2F;&#x2F; 删除本地标签；</span><br><span class="line">$ git checkout &lt;tagname&gt;        &#x2F;&#x2F; 切换到对应标签的提交点，会分离 HEAD</span><br><span class="line">$ git push origin &lt;tagname&gt;     &#x2F;&#x2F; 想远程仓库推送一个 tag</span><br><span class="line">$ git push origin --tags        &#x2F;&#x2F; 推送全部未推送过的本地 tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt; &#x2F;&#x2F; 删除一个远程标签</span><br></pre></td></tr></table></figure>
<p>更多详情：『<a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git 官方手册</a>』</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>总结常用命令，还是免不了量越来越大，变得混乱的问题。所以，再加上一个模块，记录一些可能不那么常用的组合操作；   </p>
<p>这一块内容以后会慢慢不断更新；</p>
<p>先扔一个 Git 常用操作的索引：『<a href="https://backlog.com/git-tutorial/cn/reference/" target="_blank" rel="noopener">Git 操作索引</a>』</p>
<h3 id="修改-commit-注释"><a href="#修改-commit-注释" class="headerlink" title="修改 commit 注释"></a>修改 commit 注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase -i HEAD~2    &#x2F;&#x2F; 选择至所需修改的节点</span><br><span class="line">&#x2F;&#x2F; 会出现 pick: commit_id &lt;注释&gt;， 将要改的那行的 pick 改成 edit 然后退出</span><br><span class="line">&#x2F;&#x2F; 此时使用 $ git log，可以版本已经变成了你想改的那个</span><br><span class="line">&#x2F;&#x2F; 修改版本提交注释</span><br><span class="line">$ git commit --amend      &#x2F;&#x2F; 接受，保存修改，并提交</span><br><span class="line">$ git rebase --continue   &#x2F;&#x2F; 接受 rebase 的执行</span><br></pre></td></tr></table></figure>
<h3 id="取消-track-某一文件"><a href="#取消-track-某一文件" class="headerlink" title="取消 track 某一文件"></a>取消 track 某一文件</h3><p><code>git rm -r --cache &lt;file_name&gt;</code></p>
<ul>
<li>untrack 后，使用 commit -a 时，不会将其添加到暂存区中；</li>
<li>之后会在 .ignore 文件中将该 untrack 的文件添加进去，完成；</li>
</ul>
<h3 id="文件暂存（栈）"><a href="#文件暂存（栈）" class="headerlink" title="文件暂存（栈）"></a>文件暂存（栈）</h3><p>你要把现在正在工作的分支保存下来，等处理完其他的再回来接着当前分支的修改工作：</p>
<ol>
<li>将当前分支的修改暂存起来（此处不等于 add+commit）：<code>git stash</code><ul>
<li>备份当前的工作区的内容，从最新的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区修改的内容保存到 Git 栈中暂存起来。</li>
</ul>
</li>
<li>切换到别的分支工作，完成后切换回原来的工作分支，查看暂存列表 <code>git stash list</code>：<ul>
<li>显示 Git 栈内的所有备份，可以利用这个列表来决定从那个地方恢复</li>
</ul>
</li>
<li>恢复暂存的修改到工作区 <code>git stash apply &lt;stash_name&gt;</code> 恢复暂存之后不删除暂存：<ul>
<li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容。</li>
</ul>
</li>
<li>或者 <code>git stash pop</code> 恢复暂存之后删除暂存：<ul>
<li>从 Git 栈中读取最新一次保存的内容，恢复工作区的相关内容；</li>
<li>之后 pop 会删除最新的暂存；</li>
</ul>
</li>
<li>删除 “暂存”：<code>git stash drop &lt;stash_name&gt;</code><ul>
<li>从 Git 栈删除最旧的一个暂存</li>
</ul>
</li>
<li>结束</li>
</ol>
<h1 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h1><h2 id="Branch-管理"><a href="#Branch-管理" class="headerlink" title="Branch 管理"></a>Branch 管理</h2><p>推荐使用如下 5 个分支开发管理：</p>
<p><img src="http://img.thebetterkong.cn/blog/GitStart/BranchManage.png" alt="BranchManage"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分支</th>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>master 分支</td>
<td>主分支(保护分支)</td>
<td>只负责管理发布的状态，在提交时使用标签记录发布版本号</td>
</tr>
<tr>
<td>develop 分支</td>
<td>开发分支</td>
<td>针对发布的日常开发分支</td>
</tr>
<tr>
<td>feature 分支</td>
<td>特性分支</td>
<td>- 这个分支是针对<strong>新功能的开发</strong>，在 bug 修正的时候从 develop 分支分叉出来的；<br>- 基本上不需要共享特性分支的操作，所以不需要远端控制，完成开发后，把分支合并回 develop 分支后发布；</td>
</tr>
<tr>
<td>release 分支</td>
<td>发布分支</td>
<td>- 一般的开发是在 develop 分支上进行的，到了可以发布的状态时再创建 release 分支，为 release 做最后的 bug 修正；<br>- 到了可以 release 的状态时，把 release 分支合并到 master 分支，并且在合并提交里添加 release 版本号的标签；<br>- 注意：要导入在 release 分支所作的修改，也要合并回 develop 分支；</td>
</tr>
<tr>
<td>fix 分支</td>
<td>bug 修复分支</td>
<td>需要根据实际情况对已发布的版本进行漏洞修复；</td>
</tr>
</tbody>
</table>
</div>
<p>详见：『<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">原文</a>』</p>
<h2 id="Tag-管理"><a href="#Tag-管理" class="headerlink" title="Tag 管理"></a>Tag 管理</h2><p>通常 Tag 采用三段式：<code>v版本.里程碑.序号（v2.3.1）</code></p>
<ul>
<li>架构升级或架构重大调整，修改第 1 位</li>
<li>新功能上线或者模块大的调整，修改第 2 位</li>
<li>bug 修复上线，修改第 3 位</li>
</ul>
<h2 id="Commit-管理"><a href="#Commit-管理" class="headerlink" title="Commit 管理"></a>Commit 管理</h2><p>不管采用怎样的表述方式，最终目标都是：<strong>表达清楚、格式统一、方便快速阅读和定位</strong></p>
<p>建议格式（type：scope：body：issue） ：</p>
<ul>
<li><code>&lt;|新功能|修改|Bug修复|重构|测试&gt;（影响模块）提交描述信息（#issue?）</code></li>
</ul>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>这个模块先仍在这，之前遇到的问题也没怎么记录，这篇文章已经把我总结的有点头大了。以后，再遇到问题再在这里更。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">Learngitbranching</a></li>
<li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的 Git</a></li>
<li>另，本篇文章是根据以前的笔记写的，以前的笔记也有参考网上资料，但是记不清来源了</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>《anc_ndss17》阅读笔记</title>
    <url>/2020/03/15/Literature-reading-notes/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/</url>
    <content><![CDATA[<p>ALSR是当今现代软件中防止内存相关安全漏洞的第一道防线，它在受保护进程的虚拟地址空间中选择随机位置放置代码或数据，这给攻击者带来了很大的麻烦。本文提出来一种基于代码高效执行的硬件行为（通过页表的方法实现在MMU中虚拟地址到物理地址的快速转换）的<strong>AnC攻击</strong>，主要描述了基于现代处理器MMU执行的虚实地址转换的<strong>EVICT+Time缓存攻击</strong>。</p>
<a id="more"></a> 
<p>『<a href="http://www.cs.vu.nl/~herbertb/download/papers/anc_ndss17.pdf" target="_blank" rel="noopener">论文地址</a>』</p>
<h1 id="文章大纲"><a href="#文章大纲" class="headerlink" title="文章大纲"></a>文章大纲</h1><ul>
<li>第二部分介绍威胁模型，第三部分介绍背景和方法，主要详细介绍地址转换和存储架构，并提出了一些挑战和应对措施；</li>
<li>第四至第六节详细讨论了针对每种挑战的解决方案；</li>
<li>第七部分中，针对在最新Linux操作系统上运行的Chrome和Firefox评估AnC。（与当时最新的derandomization attacks相比，更快，要求也更低）</li>
<li>第八章讨论对一些高级防御的影响，并在第九章介绍了一些缓解措施；</li>
<li>最后其他章节做为结束；</li>
</ul>
<h1 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h1><ul>
<li>假设攻击者可以通过诱使受害者访问恶意网站或破坏受信任的网站来在受害者的浏览器中执行JavaScript代码；</li>
<li>假设在浏览器中启用了所有常见防御措施（例如DEP），则攻击者旨在通过内存破坏漏洞逃脱JavaScript沙盒；</li>
<li>为了成功攻破JavaScript沙箱，假设攻击者需要首先破解ASLR，并在地址空间中去随机化一些代码或数据指针的位置（这是针对现代防御的一种常见攻击模型）；</li>
<li>为此，我们假设攻击者不能依赖临时公开的漏洞或特殊应用程序或OS行为。尽管这里主要是针对JavaScript沙箱，但相同的原理也适用于其他沙箱环境（例如：Google的Native Client）；</li>
</ul>
<h1 id="攻击相关的背景知识和方法"><a href="#攻击相关的背景知识和方法" class="headerlink" title="攻击相关的背景知识和方法"></a>攻击相关的背景知识和方法</h1><h2 id="虚拟地址转换"><a href="#虚拟地址转换" class="headerlink" title="虚拟地址转换"></a>虚拟地址转换</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Address-translation.png" alt="地址转换">  </p>
<p>转换过程：</p>
<ul>
<li>在x86上架构，CPU的CR3控制寄存器指向页面表层次结构的最高级别，称为4级或PTL4。虚拟地址的高9位索引单个PTL4页面，在这种情况下选择PTE200。</li>
<li>此PTE（页表项）索引了第3级页面（即PTL3），虚拟地址索引的后9位查找目标PT条目（这次位于偏移300）。</li>
<li>重复相同的操作，然后，对于PTL2和PTL1的PT页面，MMU最终可以在PTL1上找到PT上0x644b321f4000的对应物理页面。</li>
</ul>
<p>注意，每个PTE将位于cache line中，如图中不同的颜色和样式所示。<mark>X86-64上的每个PTE为8 B，因此，每个64 B的cache line存储8个PTE</mark>。</p>
<h2 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h2><p>在最近的英特尔酷睿微体系结构中，MMU在虚拟地址到物理地址转换期间使用此内存层次结构：<br><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Storage-organization.png" alt="存储组织"></p>
<p>Knowledge 1：</p>
<ul>
<li>在虚拟机上load和store以及取指令的相关地址是从正在执行的进程的核心发出的。</li>
<li>MMU在访问数据或指令之前使用TLB执行从虚拟地址到物理地址的转换，这是因为存储数据的cache是用物理地址标记的（即：物理标记的缓存）。</li>
<li>如果虚拟地址在TLB中，则可以继续执行load/store或取指令。 如果虚拟地址不在TLB中，则MMU需要像我们在之前中讨论的地址转换那样遍历PT并填写TLB。</li>
<li>TLB可能包含用于不同PTL转换的缓存：<ul>
<li>例如：如果TLB包括用于PTL2的转换缓存，则MMU仅需要遍历PTL1即可找到目标物理地址。</li>
</ul>
</li>
</ul>
<p>Knowledge 2：</p>
<ul>
<li>在PT遍历期间，MMU在各个PTL上读取PT pages使用的都是他们各自的物理地址；</li>
<li>MMU使用与内核相同的路径来加载数据，以在转换期间加载PTE。</li>
<li>于是，每次PT遍历后，<mark>在各个PTL上存储了PTE的cache line在L1 data cache（L1D）里都是可获取的</mark>。</li>
</ul>
<h2 id="Cache架构"><a href="#Cache架构" class="headerlink" title="Cache架构"></a>Cache架构</h2><p>本块知识可详细参考本人blog里：《计算机体系结构》-高速缓存   </p>
<p>CPU的cache组织：</p>
<ul>
<li>在英特尔酷睿微体系结构中，CPU缓存分为三个级别：<ul>
<li>靠近CPU的缓存较小且较快，而远离CPU的缓存较慢，但可以存储大量数据</li>
<li>第一级有两个高速缓存 <strong>L1D</strong> 和 <strong>L1I</strong> ，分别用于高速缓存数据和指令 </li>
<li>第二级缓存 <strong>L2</strong> 是数据和指令的统一缓存</li>
<li>L1和L2对于每个内核都是专用的，但是所有内核都共享 <strong>L3（LLC）</strong></li>
</ul>
</li>
</ul>
<p>Cache的重要属性：包容性</p>
<ul>
<li><mark>L2不包括L1，即L1中存在的数据不一定存在于L2中。 但是，L3包含L1和L2，这意味着如果数据存在于L1或L2中，则它也必须存在于L3中</mark></li>
</ul>
<p>Cache架构：</p>
<ul>
<li>每个分区（常称为：cache set）只能存储物理内存的一个子集；</li>
<li>根据缓存体系结构，存储位置的物理地址或虚拟地址决定其cache set；</li>
<li>常将cache set与wayness联系起来：<ul>
<li>N路关联cache可以在每个cache set中存储n个项目。然后，替换策略决定在cache set未命中的情况下替换n个项目中的哪一个。 </li>
<li>例如，Intel Skylake处理器上的L2高速缓存为256 KB，具有4路关联，cache line大小为64 B。 这意味着有1024个cache set，${256 KB}\div(4路×64 B)$，物理地址的第6至16位决定了其相应的cache set（低6位决定了cache line内的偏移量）。</li>
<li><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/cache.png" alt="cache"></li>
</ul>
</li>
</ul>
<p>在 Intel Core 微体系结构中，处理器的所有内核都共享LLC，但是微体系结构将其划分为多个片，每个片对应一个内核，其中<mark>每个内核对自己的片的访问比对其他内核的访问要快</mark>。</p>
<ul>
<li>每个切片都有不同的 cache set；</li>
<li>不同于靠物理地址的地位来决定其相应 cache set 的L1和L2，它有一个复杂的寻址功能（基于XOR方案），可以为每个物理内存地址确定分片：<ul>
<li>例如，一个四核 Skylake i7-6700K 处理器具有一个8 MB 16路关联LLC，cache line大小为64 B，该LLC具有4个片，则每个片具有2048个cache set；</li>
</ul>
</li>
</ul>
<h2 id="Derandomizing-ASLR"><a href="#Derandomizing-ASLR" class="headerlink" title="Derandomizing ASLR"></a>Derandomizing ASLR</h2><p>如前所述，任何导致TLB丢失的内存访问都需要进行PT遍历，（如果尚未存在）PT遍历会从主内存中读取四个PTE，并将它们存储在L1D中的四个不同的 cache line中：</p>
<ul>
<li>如果知道了页面中这些 cache line 的偏移量，就相当于已经完成了对每个PTL的虚拟地址的9位中的6位进行了去随机化处理；</li>
<li>cache line中PTE的偏移量未知，因此最后三位仍将未知；</li>
</ul>
<p>综上所述，为了完成对ASLR去随机化处理，我们就需要解决以下三个问题：</p>
<ol>
<li>在PT遍历期间从内存中加载了哪些cache line？</li>
<li>这些cache line属于哪些页面偏移量？</li>
<li>这些cache line中的目标PTE的偏移量是多少？ </li>
</ol>
<h3 id="Q1-识别host-PTEs的cache-line"><a href="#Q1-识别host-PTEs的cache-line" class="headerlink" title="Q1-识别host PTEs的cache line"></a>Q1-识别host PTEs的cache line</h3><p>由于LLC包含L1D，因此，如果四个PTE cache line位于L1D中，它们也将位于LLC中。</p>
<ul>
<li>因此，（假设没有L2条目）我们不需要一个计时器来分辨L1D和LLC之间的差异，只需要一个可以通过从LLC而不是从L1D中驱逐目标cache line的计时器来分辨L1D和内存之间的差异。   </li>
</ul>
<p>PTE cache line最多可以位于四个不同的cache set中。</p>
<ul>
<li>尽管我们无法通过监视（或控制）LLC上各种cache set的状态来直接识别host PTE的cache line，但是由于在受影响的cache set处的PT遍历，我们可以检测到MMU活动。 </li>
<li>尽管对cache set上的MMU活动的了解比对cache line的了解要粗，但仍然足以识别页面内PTE cache lines的偏移，如之后所述；</li>
</ul>
<h3 id="Q2-识别cache-line的页面偏移量"><a href="#Q2-识别cache-line的页面偏移量" class="headerlink" title="Q2-识别cache line的页面偏移量"></a>Q2-识别cache line的页面偏移量</h3><p>理论：给定两个不同的（物理）内存页面，如果它们的第一个cache line（即，前64 B）属于同一cache set，则它们的其他63个cache line也共享（不同的）cache sets；（一个内存页大小为4KB，占用64个cache line）</p>
<ul>
<li>依据：要使第一个cache line位于同一cache set中，那么决定cache set的页和片的物理地址的所有位必须相同，并且内存页面内的偏移量将共享低12位。</li>
<li><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/cache-color.png" alt="cache color"><ul>
<li>例如，给定8192的唯一的cache set，这意味着对它们所覆盖的cache set而言，共有128（8192/64）个唯一页面颜色。</li>
</ul>
</li>
</ul>
<p>则，对于AnC攻击来说，给定已识别的具有PT活动的cache set，我们可以直接确定其页面颜色，更重要的是，确定host了PT条目的cache line的偏移量。</p>
<h3 id="Q3-识别PT条目的cache-line偏移量"><a href="#Q3-识别PT条目的cache-line偏移量" class="headerlink" title="Q3-识别PT条目的cache line偏移量"></a>Q3-识别PT条目的cache line偏移量</h3><p>在这一阶段，我们已经确定了每个PTL的PTE的cache set。为了完全取消给定虚拟地址的ASLR随机化，我们仍然需要识别:</p>
<ol>
<li>cache line（位于标识的cache set内部）内的PTE偏移;</li>
<li>将每个标识的cache set映射到PTL;</li>
</ol>
<p>通过访问与 目标虚拟地址v 分开 x bytes 的页面来实现这两个目标：</p>
<ul>
<li>例如：与v分开4 KB，8 KB，…，32 KB的页面（在PTL1上与v分开1至8个PTE），如果我们访问它们，可以确保看到显示MMU活动的四个cache set之一发生更改（即，新的cache set将直接跟随先前的cache set）。</li>
<li>因此，移动的cache set唯一地标识PTL1上host了 PT条目的cache set，并且发生cache set更改的时间点唯一地标识v的PT条目在其cache line内的偏移量，从而对 PTL1中未知的3个最低有效位进行去随机化处理。</li>
<li>我们可以应用相同的原理来查找其他PT level的PT入口偏移。我们称此技术为<mark>滑动技术</mark>，并在第V-E节中进一步讨论。</li>
</ul>
<h2 id="现代系统的ASLR"><a href="#现代系统的ASLR" class="headerlink" title="现代系统的ASLR"></a>现代系统的ASLR</h2><p>现代Linux系统中与位置无关的可执行文件的映射虚拟区域具有28位的ASLR entropy:</p>
<ul>
<li>这意味着PTL1，PTL2和PTL3完全有助于创建27位的entropy，但是只有PTL4中PTE偏移量的最后一位对ASLR entropy有贡献。</li>
<li>如果我们要标识最后一位，因为它落入了PTE偏移的最低3位（即在cache line内），我们需要在PTL4处设置交叉cache set。 <ul>
<li>PTL4上的每个PTE映射512 GB的虚拟地址空间，因此，我们需要一个跨越4 TB标记的虚拟映射，以便在PTL4上进行cache更改。请注意，PTL4中的cache set更改也会导致其他级别的缓存集也发生更改。将在第六节中描述如何通过利用各种浏览器中的内存分配器的行为来实现这一目标。</li>
</ul>
</li>
</ul>
<p>请注意，Linux中ASLR的entropy高于其他流行的操作系统，例如Windows 10，后者仅为堆提供24位的entropy，为可执行文件提供17-19位的entropy。</p>
<ul>
<li>这意味着在Windows 10上，PTL4对堆区域不构成ASLR。<ul>
<li>由于PTL3中的每个条目都覆盖1 GB的内存，因此跨越8 GB的映射将导致PTL3的缓存集发生更改，从而导致ASLR的去随机化。</li>
</ul>
</li>
<li>较低的可执行文件的entropy意味着，仅跨两个较低级别（即16 MB）时，就有可能在Windows 10上对可执行文件位置进行随机化处理。因此本文着重讨论Linux下更难的案例。</li>
</ul>
<p>这里说明一下：我理解的所谓的entropy也就是ASLR的地址位数</p>
<h2 id="挑战与方法"><a href="#挑战与方法" class="headerlink" title="挑战与方法"></a>挑战与方法</h2><p>前面已经讨论了现代x86 64处理器上的内存层次结构以及攻击者可以监控MMU活动以耗尽ASLR entropy的方式。 本文的其余部分围绕着成功实施攻击所需克服的三个主要挑战。   </p>
<p>这三个问题也会在接下来的三个章节里详细描述。</p>
<h3 id="C1：计时器精度"><a href="#C1：计时器精度" class="headerlink" title="C1：计时器精度"></a>C1：计时器精度</h3><p>在现代浏览器中由MMU执行时，区分内存访问和缓存访问。 为了对抗来自沙盒JavaScript代码的计时攻击，浏览器降低了可访问计时器的精度，以使攻击者很难（即使不是不可能）观察执行特定操作所花费的时间。</p>
<ul>
<li>在JavaScript中创建了一个新的合成计时器，以检测内存和缓存访问之间的差异。</li>
<li>利用的事实：可用的计时器虽然粗略，但却是精确的，并允许使用CPU内核作为计数器来测量每个操作花费的时间。</li>
<li>接下来的一章中，会详细介绍作者的设计及其对基于浏览器的定时攻击的影响。</li>
</ul>
<h3 id="C2：观察MMU的PT遍历对数据缓存状态的影响"><a href="#C2：观察MMU的PT遍历对数据缓存状态的影响" class="headerlink" title="C2：观察MMU的PT遍历对数据缓存状态的影响"></a>C2：观察MMU的PT遍历对数据缓存状态的影响</h3><p>可以通过JavaScript构建缓存逐出集，以使知名的PRIME + PROBE攻击的末级缓存（LLC）进入已知状态。在典型的PRIME + PROBE攻击中，受害者是在内核上运行的进程，而在我们的攻击中，受害者是行为不同的MMU。</p>
<ul>
<li>构建了PRIME + PROBE攻击，以观察MMU对商用英特尔处理器中LLC的修改。</li>
<li>注意到，在每一轮攻击中监视整个LLC的PRIME PROBE其噪声性质使得很难观察到（微弱）MMU信号，而一种更具针对性和低噪声的EVICT + TIME攻击，它可以一次监视一个cache set，这样就可以可靠地检测到MMU信号。</li>
<li>接下来第二章中，讨论了用于对JavaScript的堆进行非随机化和ASLR代码的攻击的详细信息</li>
</ul>
<h3 id="C3：PTE的区分与识别"><a href="#C3：PTE的区分与识别" class="headerlink" title="C3：PTE的区分与识别"></a>C3：PTE的区分与识别</h3><p>即：区分存储在同一cache line中的多个PTEs，并唯一标识属于不同PTL的PTE。 </p>
<ul>
<li>需要确保可以分配和访问跨越足够PTL的虚拟连续缓冲区，以完全解除ASLR的随机化。<ul>
<li>例如，在用于浏览器堆的64位Linux系统ASLR entropy上，JITed代码为28位，在x86 64处理器上，存在4个PT级别，每个级别提供9位entropy（每个PTL分别存储512个PTE）。因此，我们需要一个跨越所有四个PTL的几乎连续的区域，以实现ASLR的完全去随机化。</li>
</ul>
</li>
<li>接下来第三章中，讨论ASLR⊕Cache如何利用Chrome和Firefox的低级内存管理属性来访问这些区域。</li>
</ul>
<h1 id="TIMING-BY-COUNTING"><a href="#TIMING-BY-COUNTING" class="headerlink" title="TIMING BY COUNTING"></a>TIMING BY COUNTING</h1><p>可以在浏览器中利用计时侧信道泄漏敏感信息，例如随机指针或鼠标移动。这些攻击依靠精确的JavaScript计时器来区分通过缓存或主存储器满足的访问之间的区别。为了阻止这些攻击，主要的浏览器供应商降低了计时器的精度。根据作者的测量，Firefox和Chrome都将performance.now（）的精度降低到恰好5µs。   </p>
<p>因此，作者设计了一个小型的微基准测试，以更好地了解目标浏览器中JavaScript计时器（即performance.now（））的质量。</p>
<ul>
<li>该微基准测试测量了我们可以在Performance.now（）的两个后续滴答之间的紧密循环中执行一百次的Performance.now（）的次数。</li>
<li>根据实验结果：Firefox的performance.now（）恰好在5µs时滴答作响，而Chrome大约在5µs的间隔内引入了一些抖动。降低的精度使我们难以区分需要AnC工作的缓存访问或内存访问（数十纳秒的数量级）之间的差异。</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/timer.png" alt="timer"></p>
<ul>
<li>图4.1：如何使用旧计时器来区分缓存访问或内存访问（CT表示缓存时间，MT表示内存时间）；</li>
<li>图4.2：在低精度计时器下不再可以通过简单地调用计时器来分辨出差异；</li>
<li>图4.3：共享内存数（SMC）<ul>
<li>它依靠一种实验性功能，该功能允许在JavaScript的Web worker2之间共享内存。</li>
<li>SMC构建了一个高分辨率计数器，该计数器可用于在实现AnC的所有浏览器中可靠地实现AnC。</li>
<li>Firefox和Chrome当前都支持此功能，但是由于其实验性质，需要对其进行显式启用。</li>
</ul>
</li>
<li>图4.4：滴答时间（TTT）<ul>
<li>它依赖于当前的低精度性能。</li>
<li>now（）用于构建计时器，该计时器使我们能够测量缓存的引用和内存引用之间的差异，并允许在Firefox等低抖动浏览器中实现AnC。</li>
</ul>
</li>
</ul>
<p>接下来介绍两种通过计算执行内存引用花费的时间而不是计时来测量执行内存引用花费的时间的技术。这两种技术都依赖于CPU内核比performance.now（）更高的精度这一事实。</p>
<h2 id="Time-to-Tick（TTT）"><a href="#Time-to-Tick（TTT）" class="headerlink" title="Time to Tick（TTT）"></a>Time to Tick（TTT）</h2><p>不再计算计时器使用内存引用的时间（不再可能），而是计算内存引用发生后计时器tick所花费的时间：</p>
<ul>
<li>更准确地说，首先等待performance.now（）tick，然后执行内存引用，然后通过循环计数直到下一次Performance.now（）tick为止。如果内存引用是快速的cache访问，那么与需要通过主内存的内存引用相比，在直到下一次ticks时我们有时间去更多的计数。</li>
</ul>
<p>在Performance.now（）没有抖动和有固定时间间隔tick的情况下（例如在Firefox中），TTT的性能很好。但是，TTT也可以用于具有抖动的performance.now（），只要它不会drift即可，但它需要更多的测量值才能消除抖动。</p>
<h2 id="Shared-Memory-Counter（SMC）"><a href="#Shared-Memory-Counter（SMC）" class="headerlink" title="Shared Memory Counter（SMC）"></a>Shared Memory Counter（SMC）</h2><p>SMC计数器使用专用的JavaScript web worker，在JavaScript主线程和counting web worker之间的共享内存区域进行计数。这意味着在攻击过程中，我们实际上使用了单独的内核进行计数。   </p>
<p>具体做法：</p>
<ul>
<li>想要执行测量的线程（在我们的示例中为主线程）读取计数器并将其存储在c1中，执行内存引用，然后再次读取计数器并将其存储在c2中。</li>
<li>由于在执行内存引用期间另一个线程正在递增计数器，因此在进行慢速存储器访问的情况下，与进行更快的高速缓存访问的情况相比，我们看到了更大的c2 - c1。</li>
</ul>
<h1 id="ANC的实现"><a href="#ANC的实现" class="headerlink" title="ANC的实现"></a>ANC的实现</h1><p>在解决了计时器问题后，回到之前讨论的 Derandomizing ASLR，来进一步实现AnC攻击。    </p>
<p>接下来：</p>
<ul>
<li>在第1小节中，将展示作者如何在访问目标堆以及在目标JIT区域上执行代码时触发MMU遍历。 </li>
<li>在第2、3、4节中讨论如何识别存储目标虚拟地址的页表项的页偏移。 </li>
<li>在第5、6节中，将讲解用于观察信号和唯一地识别存储它们的cache line内的页表项的位置的技术。 </li>
<li>在第7、8节中，讨论了通过激活页表缓存和消除噪声来清理MMU信号的技术。</li>
</ul>
<h2 id="触发MMU页表遍历"><a href="#触发MMU页表遍历" class="headerlink" title="触发MMU页表遍历"></a>触发MMU页表遍历</h2><p>为了观察CPU cache上的MMU活动，我们需要确保：</p>
<ol>
<li>当我们访问目标时，我们知道缓冲区中页偏移；</li>
<li>我们能够驱逐TLB以触发MMU在目标内存位置上遍历；</li>
</ol>
<p>下面就是讨论如何从堆内存和JIT代码中实现这些目标。</p>
<ol>
<li>堆：</li>
</ol>
<ul>
<li>使用ArrayBuffer类型来回退我们试图去随机化的堆内存。<ul>
<li>ArrayBuffer总是页对齐的，这使我们能够预测目标ArrayBuffer中任何索引的相对页偏移量；</li>
<li>最近Intel处理器有两个级别的TLB。<mark>第一级包括指令TLB（iTLB）和数据TLB（dTLB），而第二级是更大的unified（统一）的TLB缓存</mark>。</li>
<li>为了同时flush数据TLB和unified TLB，我们访问TLB驱逐缓冲区中的每个页面，其大小大于unified TLB。</li>
<li>后面会展示该TLB驱逐缓冲区也可以用于在期望的偏移处驱逐LLC cache set。</li>
</ul>
</li>
</ul>
<ol>
<li>代码：</li>
</ol>
<ul>
<li>为了分配足够大的JIT代码区域，在一个asm.js模块中喷射 $2^{17}$ 个JavaScript函数。这里可以通过改变由JIT引擎编译的语句的数量来调整这些函数的大小。</li>
<li>这些函数的机器码从一个依赖于浏览器但是在页面中已知的偏移开始，并且在内存中彼此跟随，并且由于我们可以在目标浏览器上预测它们（机器码）的大小，我们知道每个函数从asm.js对象开始位置的偏移。</li>
<li>为了最小化这些函数对cache的影响但不影响它们的大小，我们在所有函数的入口添加一个if语句，以便我们可以不执行函数。为了不遮蔽页表cache line信号，我们的目标是一旦执行就击中单个cache line，但这样做仍然会让函数之间存在大块偏移。</li>
<li>为了在执行我们的一个函数时触发页表遍历，我们需要去flush iTLB和unified TLB。<ul>
<li>为了flush iTLB，我们使用一个单独的asm.js对象，并执行一些函数，这些函数跨越了超过iTLB大小的页面。</li>
<li>为了flush unified TLB，我们使用我们用于堆的相同的TLB驱逐缓冲区。</li>
</ul>
</li>
<li>正如稍后将讨论的，AnC将会在每一轮中观察到一个页偏移量。这允许我们以不会干扰测量中的页偏移的方式为unified TLB驱逐缓冲区选择iTLB驱逐函数和页偏移。</li>
</ul>
<h2 id="PRIME-PROBE和MMU信号"><a href="#PRIME-PROBE和MMU信号" class="headerlink" title="PRIME+PROBE和MMU信号"></a>PRIME+PROBE和MMU信号</h2><p>AnC的主要思想是观察MMU的页表遍历对LLC的影响。为此可实现两种攻击：<mark>PRIME+PROBE（灌注+探测）</mark>或 <mark>EVICT+TIME（驱逐+时间）</mark>。    </p>
<p>要实施 PRIME+PROBE 攻击，需要遵循以下几个步骤：</p>
<ol>
<li>为所有可用的页颜色构建最佳LLC驱逐集。<ul>
<li>最佳驱逐集是一次访问的memory locations的精确数目（取决于LLC set-associativity），确保目标cache line从host了目标cache line的LLC cache set中被驱逐；</li>
</ul>
</li>
<li>通过访问所有驱逐集来prime LLC；</li>
<li>访问我们想要去随机化的目标虚拟地址，使其页表项进入LLC；</li>
<li>通过访问所有驱逐集并测试其中哪个执行需要更长时间来probe LLC；</li>
</ol>
<p>需要较长时间执行的驱逐集据推测需要从内存中取一个（或者多个）entries，由于在prime阶段，驱逐集中的条目已经被传入LLC，并且唯一的内存引用（除了TLB驱逐集之外）是目标虚拟地址，因此这些“probed”驱逐集合中的四个已经host了目标虚拟地址的页表项。如前所述，这些cache set唯一地标识每个PTL的页表项偏移的高6位。   </p>
<p>这时，会有两个问题：</p>
<ol>
<li>从JavaScript建立最优的LLC驱逐集对 PRIME+PROBE 是必需的，而最近已经被证明这可能需要花费很多时间，特别是在没有精确的计时器时。</li>
<li>不能可靠的执行 PRIME+PROBE 攻击，因为我们试图测量的目标会在测量中产生噪声（更确切地说，我们需要在访问目标虚拟地址之前flush TLB）。<ul>
<li>我们可以在priming之前或之后这样做，但是在任一情况下，驱逐TLB将导致MMU执行一些我们不想要的页表遍历：<ul>
<li>假设我们在prime之前执行TLB驱逐：在执行prime步骤期间访问LLC驱逐集的中间，很有可能会发生许多TLB未命中，导致页表遍历可能在我们不知情的情况下填充已经被primed的cache set，在probe步骤中会产生许多错误信息。</li>
<li>假设我们在prime之后执行TLB驱逐：类似的情况可能会发生：TLB驱逐集中的一些页面将导致页表遍历，导致填充已经被primed的cache set，并且再次在probe中产生错误信息。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Cache颜色对AnC来说不重要"><a href="#Cache颜色对AnC来说不重要" class="headerlink" title="Cache颜色对AnC来说不重要"></a>Cache颜色对AnC来说不重要</h2><p>基于cache的侧信道攻击受益于在后端操作之后的缓存状态中可用的整合信息，即：受害者访问过的缓存集。     </p>
<p>Cache set由：颜色（即页颜色）和页（cache line）偏移量唯一标识。</p>
<ul>
<li>例如，具有8192个cache set的LLC中的缓存集可以由（颜色，偏移）元组标识，其中0≤color&lt;128并且0≤offset&lt;64。</li>
</ul>
<p>ASLR对页偏移中的secret（即，随机化指针）进行编码。可以为页面的64个cache line偏移量中的每一个构建一个驱逐集，驱逐每个集合的cache line偏移量的所有颜色。</p>
<ul>
<li>唯一的问题是：同页表级的页表项可能使用不同的页面颜色，因此，我们就会看到重叠的偏移信号。但是考虑到我们可以相对于目标虚拟地址来控制观察到的虚拟地址，我们可以控制不同页表级内的页表项的偏移，如章节：“Derandomizing ASLR”所述，来解决这个问题。</li>
</ul>
<p>下面描述的 EVICT+TIME 攻击不依赖驱逐集的执行时间。</p>
<ul>
<li>这意味着我们不需要构建最佳驱逐集。加上ASLR对颜色不可知的事实，我们可以使用任何页面作为驱逐集合的一部分。</li>
<li>没法使用特定的颜色布局方案来分配页表来避免显示这个信号，因为它们都会出现在我们的驱逐集中。<ul>
<li>这意味着，在足够大量的内存页的情况下，我们可以在给定页偏移量下从LLC（和L1D和L2）逐出任何页表项，而不依赖于需要很长时间构建的最佳驱逐集。</li>
</ul>
</li>
</ul>
<h2 id="MMU上的EVICT-TIME攻击"><a href="#MMU上的EVICT-TIME攻击" class="headerlink" title="MMU上的EVICT+TIME攻击"></a>MMU上的EVICT+TIME攻击</h2><p>对加密密钥或窃听的传统侧信道攻击有利于观察整个LLC的状态。这就是为什么诸如 PRIME+PROBE 和 FLUSH+RELOAD 是允许攻击者观察LLC的整个状态的侧信道攻击的原因。    </p>
<p>与这些攻击相比，EVICT+TIME 只能在每个测量周期获得一个cache set的信息，与 PRIME+PROBE 等攻击相比，减少了带宽。    </p>
<p>EVICT+TIME 进一步做了假设：</p>
<ul>
<li>攻击者可以在受害者执行secret运算时观察受害者的performance。</li>
<li>虽然这些属性经常使 EVICT+TIME 比其他的缓存攻击差，但是它容易地适用于AnC： <ul>
<li>AnC不需要高带宽（例如，破解加密密钥），并且它可以监视受害者（即，MMU），因为其执行后台（即，页表遍历）。</li>
</ul>
</li>
</ul>
<p>要实施 EVICT+TIME 攻击，需要遵循以下几个步骤：</p>
<ol>
<li>使用一个足够大的内存页集作为驱逐集。</li>
<li>对于在64个可能偏移中的偏移t处的目标cache line，通过读取驱逐集里所有内存页中的相同偏移量来驱逐cache line。<ul>
<li>访问此集合还会flush dTLB和unified TLB。 如果我们是目标代码，通过在偏移量t处执行函数来调用iTLB。</li>
</ul>
</li>
<li>通过（目标为堆的情况下）dereference，或者（目标为代码的情况下）在该位置执行函数，Time访问我们想要的在与t不同的cache line偏移处去随机化的目标虚拟地址。<ul>
<li>这里触发页表遍历，操作将需要更长还是更短的时间取决于偏移t处是否host了页表项cache line</li>
</ul>
</li>
</ol>
<p>EVICT+TIME 解决了我们面对 PRIME+PROBE 的问题：</p>
<ul>
<li>首先，我们不需要创建最佳的LLC驱逐集，因为我们不依赖驱逐集提供信息；</li>
<li>其次，LLC驱逐集和TLB驱逐集统一了，减少由于较少的页表遍历产生的噪声。</li>
<li>更重要的是，这些页表遍历（由于TLB未命中）显着减少了错误信息，因为我们不依赖于probe驱逐集来获得时间信息。</li>
</ul>
<p>由于这些改进，当在解引用堆地址和执行JIT函数时，在JavaScript中的所有64个可能的cache line偏移上尝试 EVICT+TIME 时，可以观察到与目标虚拟地址的页表项对应的cache line偏移。接下来，描述如何可以唯一地标识由 EVICT+TIME 标识的cache line内的页表项的偏移量。</p>
<h2 id="Sliding-PT-Entries"><a href="#Sliding-PT-Entries" class="headerlink" title="Sliding PT Entries"></a>Sliding PT Entries</h2><p>这个阶段，我们已经识别了不同PTL的页表项的（可能重叠的）cache line偏移。但对于ASLR仍然保留两个entropy源：</p>
<ul>
<li>不可能区分哪个cache line偏移属于哪个PTL；</li>
<li>cache line内页表项的偏移量尚未知道；</li>
</ul>
<p>我们通过分配一个足够大的缓冲区（在我们的这种情况下是分配一个2G的空间）和访问这个缓冲区中的不同位置来解决这两个熵源，以便对已经分配了缓冲区的虚拟地址去随机化。   </p>
<p>对PTL1和PTL2去随机化的方法不同于对PTL3和PTL4去随机化的方法。这两种技术：</p>
<ol>
<li><p>将PTL1和PTL2去随机化：</p>
<ul>
<li>从PTL1上host了目标虚拟地址v的页表项的cache line开始。</li>
<li>在访问v + i×4KB，for i={1,2，…，8}，观察（可能的）4个cache line之一改变的时刻。</li>
<li>如果其中一个cache line在i处改变，它立即向我们提供两条信息：<ul>
<li>改变的cache line正在host PTL1的页表项；</li>
<li>PTL1的v的页表项偏移是8-i；</li>
</ul>
</li>
<li>下图示例出了改变PTL1处的页表项的cache line时AnC观察到的MMU活动：<ul>
<li><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/MMU-activities.png" alt="MMU活动"></li>
</ul>
</li>
<li>可以执行相同的技术在PTL2对页表项去随机化，但是现在我们需要每次增加2MB而不是4KB来观察PTL2。</li>
</ul>
</li>
<li><p>将PTL3和PTL4去随机化：</p>
<ul>
<li>如在“章节：现代系统的ASLR”讨论：<ul>
<li>为了使PTL3去随机化，在我们分配的2GB的虚拟地址空间中进行一个的8GB交叉；</li>
<li>为了对PTL4去随机化，需要在我们分配的空间内进行一个4TB虚拟地址空间交叉。</li>
</ul>
</li>
<li>依赖于“章节：ALLOCATORS AND ANC”讨论的内存分配器在浏览器中的行为，以确保我们的（许多）分配之一满足这个属性。</li>
<li>但是假设我们在PTL3或PTL4改变了cache line，则我们希望检测和去随机化相对的级别。注意，在PTL4处交叉的cache line将不可避免地导致cache line在PTL3处交叉。</li>
<li>记住PTL3上的每个页表项都覆盖1GB的虚拟内存。<ul>
<li>因此，如果在PTL3处的cache line交叉在分配的2GB空间内发生，则当交叉正好在缓冲区的中间时，我们的分配可以覆盖两个或三个PTL3页表项。</li>
<li>但是完全在中间的交叉是不可能的，我们考虑具有三个页表项的情况：三个页表项中的两个或一个在新的cache line中。<ul>
<li>在访问分配的第一页，中间页和最后一页时观察PTL3 cache line，我们可以很容易地区分这两种情况，并完全去随机化PTL3。</li>
</ul>
</li>
</ul>
</li>
<li>仅当PTL3处的cache line位于其相应PT页的最后一个slot中时，才会发生PTL4处的cache line交叉。<ul>
<li>通过执行类似的技术（即，访问分配中的第一和最后一页），如果观察到页表项cache line PTE2从最后一个slot改变到第一个slot，并且另一个页表项cache line PTE1向前移动一个slot，我们可以得出一个PTL4交叉的结论，并将PTE2唯一地标识为PTL3上的PT条目，并将PTE1唯一地标识为PTL4上的PT条目。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="解决ASLR"><a href="#解决ASLR" class="headerlink" title="解决ASLR"></a>解决ASLR</h2><p>我们创建了一个简单的求解器，以便在2GB分配空间中搜索不同的页面时，对可能的解决方案进行排名。求解器在分配的缓冲区里的第一页给每个PTL假设了512个可能的页表项，并且在每个页表级独立于其他级别对解决方案进行排名。    </p>
<p>当我们使用我们在“章节： Sliding PT Entries”描述的方法在缓冲区中探索更多页面时，我们的求解程序在其中一个解决方案中获得显着的置信度，或者放弃并开始一个新的2GB分配。如果在这些页表级存在缓存行交叉，则解决方案会始终对PTL1和PTL2以及PTL3和PTL4进行去随机化。</p>
<h2 id="Evicting-Page-Table-Caches"><a href="#Evicting-Page-Table-Caches" class="headerlink" title="Evicting Page Table Caches"></a>Evicting Page Table Caches</h2><p>如 “章节：内存组织” 所述，一些处理器可以将针对不同页表级的转换结果缓存在其TLB中。AnC需要驱逐这些缓存以便观察来自所有页表级的MMU信号。</p>
<ul>
<li>这很简单：我们可以访问一个大于这些缓存大小的缓冲区作为TLB和LLC驱逐的一部分。</li>
<li>例如，Skylake i7-6700K内核可以缓存32个项用于PTL2查找。假设我们探测在页表页的第i个cache line中是否存在页表活动，在0 + i×64 , 2MB + i×64, 4MB + i×64，…，62MB + i×64处访问64MB（即，32×2MB）buffer将驱逐PTL2页表缓存。<br>虽然我们需要natively实现这种机制去观察所有页表级的信号，我们注意到由于JavaScript  runtime activity，这些页表缓存在我们的测量期间会被自然驱逐。</li>
</ul>
<h2 id="处理噪声"><a href="#处理噪声" class="headerlink" title="处理噪声"></a>处理噪声</h2><p>实现侧信道攻击的主要问题是噪声。一些办法：</p>
<ol>
<li>随机探测：<ul>
<li>为了避免硬件预取器引起的错误，我们在我们（仍然）需要探索的可能剩余的偏移量中随机选择t（我们正在驱逐的页面偏移量）。这种随机选择也有助于均匀由系统事件引起的局部噪声。</li>
</ul>
</li>
<li>每个偏移量多次采样：<ul>
<li>为了增加探测的可靠性，我们对每个偏移量进行多次采样（“回合”），并考虑用于决定缓存与存储器访问的中值。这个简单的策略大大降低了假阳性和假阴性。</li>
</ul>
</li>
</ol>
<h1 id="ALLOCATORS-AND-ANC"><a href="#ALLOCATORS-AND-ANC" class="headerlink" title="ALLOCATORS AND ANC"></a>ALLOCATORS AND ANC</h1><p>如“章节： Sliding PT Entries”描述的依靠浏览器中内存分配器的行为来获得在虚拟地址空间中跨越PTL3和PTL4的分配。这里简要讨论了Firefox和Chrome中内存分配器的行为以及如何在AnC中利用它们。   </p>
<p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/mem-allocation-strategies.png" alt="mem allocation strategies"></p>
<h2 id="Memory-Allocation-in-Firefox"><a href="#Memory-Allocation-in-Firefox" class="headerlink" title="Memory Allocation in Firefox"></a>Memory Allocation in Firefox</h2><p>在Firefox中，内存分配基于需求分页。来自浏览器堆中JavaScript应用程序的大对象分配由mmap支持，而没有MAP_POPULATE。这意味着仅在touch存储器中的相应页面时才分配存储器。   </p>
<p>分配机制：</p>
<ul>
<li>Firefox使用Linux内核提供的通用mmap，以便使用28位熵将JIT代码和堆的位置随机化。</li>
<li>mmap的（随机）基地址仅（由操作系统）选择一次，然后Firefox的后续分配从以前的分配向后（向低）虚拟内存增长。</li>
<li>如果删除了对象，则Firefox将其虚拟内存重新用于后续分配。因此，为了在虚拟地址空间中继续向后移动，JavaScript应用程序应坚持使用其旧的分配。</li>
</ul>
<p>现象：</p>
<ul>
<li>只要不被touched，JavaScript应用程序就可以为其对象分配TB的（虚拟）内存。 AnC充分利用了这一事实，并分配了2 GB的缓冲区以强制在PTL3处更改cache line（即，剩余1比特的熵），或者，如果请求，则将2 GB的大量对象强制在PTL4处更改cache line（即， 完全非随机化）。</li>
</ul>
<p>方法：</p>
<ul>
<li>要获得JIT代码指针，依赖于上一步中获得的堆指针。Firefox在JIT和堆之间保留一些虚拟内存。在分配我们的堆之前，我们首先喷射一些JITed对象以耗尽该区域。这样可以确保在堆之前分配最后一个JITed对象。</li>
<li>但是，Firefox的JavaScript引擎在我们的最后一个JITed对象和堆之间分配了许多其他对象，从而引入了额外的熵。我们可以使用堆指针来预测目标JIT指针的PTL3和PTL4插槽，但是PTL1和PTL2插槽仍然未知。于是，部署AnC的代码版本以查找代码指针的PTL1和PTL2插槽，从而实现完全的随机化。</li>
</ul>
<h2 id="Memory-Allocation-in-Chrome"><a href="#Memory-Allocation-in-Chrome" class="headerlink" title="Memory Allocation in Chrome"></a>Memory Allocation in Chrome</h2><p>内存分配策略：</p>
<ul>
<li>在Chrome中，内存分配由mmap支持并初始化。这意味着一定大小的每次分配都将消耗相同数量的物理内存（加上几页来支持其PT页）。这禁止我们使用类似于Firefox的多个分配。</li>
<li>Chrome内部会为mmap选择随机位置，这意味着对于每个新的大对象（即新堆）。这允许硬件提供的36位可用熵中的大约35位（Linux内核始终映射在地址空间的上部）。</li>
<li>设计了对每个新堆进行随机化的设计，以防止利用常常依赖于可预测的堆重用的“先用后用”漏洞。</li>
</ul>
<p>方法：</p>
<ul>
<li>AnC利用这一非常的保护来获取穿过PTL3或PTL4缓存行的对象。</li>
<li>我们首先分配一个缓冲区，然后使用AnC查看是否存在PTL3或PTL4缓存行交叉。如果不是这种情况，我们将删除旧缓冲区，并从新分配开始。</li>
<li>根据给定的概率p，AnC的第i次分配将交叉PTL3，基于以下公式：使用Bernoulli试验（假设分配2 GB）$\sum_{1}^{i}\frac{1}{4}{\frac{3}{4}}^i \geq p$。</li>
<li>计算平均值（即p = 0.5），AnC需要大约6.5次分配才能获得PTL3穿越。</li>
<li>对于PTL4穿越求解相同的方程式，AnC平均需要1421.2分配才能获得穿越。</li>
<li>在Chrome的综合实验中，我们在1235次试验后观察到了所需的分配。 尽管没有什么可以阻止AnC对PTL4进行去随机化处理，但大量的试验使它对攻击者的吸引力降低了。</li>
</ul>
<p>对于堆和JITed对象的分配，此技术的工作原理相同。 AnC的当前版本使用此技术在Chrome上实现了堆指针的非随机化。</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><h2 id="成功率"><a href="#成功率" class="headerlink" title="成功率"></a>成功率</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/success-rate.png" alt="success rate"></p>
<h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Feasibility.png" alt="Feasibility"></p>
<h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Noise.png" alt="Noise"><br>这些结果表明，采用我们选择的配置（置信度= 10，舍入= 20），这些技术可以有效地抑制噪声。</p>
<h2 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Generalization.png" alt="Generalization"></p>
<h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p><img src="http://img.thebetterkong.cn/blog/ASLR-on-the-Line-Practical-Cache-Attacks-on-the-MMU/Comparison.png" alt="Comparison"></p>
<h1 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h1><ul>
<li>检测：可以使用性能计数器检测正在进行的AnC攻击。但是，这些类型的基于异常的防御本质上容易产生false positives 和 false negatives。</li>
<li>缓存着色：可以对共享LLC进行分区，以将应用程序（例如浏览器）与系统的其余部分隔离，但除了内核帧分配器的复杂性之外，它还对操作系统和应用程序的性能都有影响。</li>
<li>安全的计时器：降低计时器的准确性会使攻击者更难区分缓存访问和内存访问之间的区别，但是此选项的实施通常很昂贵。此外，还有许多其他可能的来源可以制作新的计时器。先前的工作显示，即使在简单的微内核环境下，也很难甚至不可能全部删除它们。对于更加复杂和功能臃肿的浏览器而言，这甚至更加复杂。</li>
<li>隔离的缓存：将PT条目缓存在单独的缓存中，而不是在数据缓存中缓存，可以缓解AnC。仅为页表页面使用单独的缓存在硬件上非常昂贵，采用这种解决方案作为对策无法达到ASLR提供低成本第一道防线的目的。</li>
</ul>
<p>AnC攻击利用基于缓存的体系结构的基本属性，该基础属性通过将hot对象保留在更快但更小的缓存中来提高性能。即使CPU制造商愿意为PT条目实现完全隔离的缓存，但软件中还有其他缓存可被利用来发起类似于AnC的攻击。例如，操作系统经常根据需要分配和缓存页表页。此优化可能会在适用于AnC式攻击的内存管理操作上产生一个时序侧通道。总而言之，我们认为ASLR在基于缓存的体系结构上的使用从根本上是不安全的，尽管确实存在对策，但它们只能限制但不能消除潜在的问题。</p>
]]></content>
      <categories>
        <category>文献阅读笔记</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>ASLR</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-ProgrammingTechnologies</title>
    <url>/2020/03/26/FPGA-technology/FPGA-ProgrammingTechnologies/</url>
    <content><![CDATA[<p>讲述 FPGA  能实现自由编程的主要原因；</p>
<a id="more"></a> 
<h1 id="How-to-Program-an-FPGA"><a href="#How-to-Program-an-FPGA" class="headerlink" title="How to Program an FPGA?"></a>How to Program an FPGA?</h1><h2 id="Anti-fuse-based"><a href="#Anti-fuse-based" class="headerlink" title="Anti-fuse based"></a>Anti-fuse based</h2><p>Anti-fuse：</p>
<ul>
<li>反熔丝技术是基于在正常情况下表现出很高电阻的结构，但是可以被“烧坏”（实际上，连接起来）以产生低电阻连接；</li>
<li>可编程性体现在：可从高阻抗状态到低阻抗或“熔丝”状态；</li>
</ul>
<p>处理：</p>
<ul>
<li>在 FPGA 中利用反熔丝配置逻辑和路由；</li>
<li>在防熔丝的两个节点之间施加高电流密度，形成金属层之间的连接；</li>
<li>需要特殊处理以实现可靠的防熔丝；</li>
</ul>
<p>缺点：</p>
<ul>
<li>设备为一次性可编程（OTP），导通后不可再恢复；</li>
</ul>
<p>优点：</p>
<ul>
<li>关闭电源后保留配置，可靠性高；</li>
<li>与基于SRAM的FPGA相比，对SEU（单事件扰乱）效应的敏感度更低；</li>
</ul>
<p>两种突出的方法是：</p>
<ol>
<li>Poly to Diffusion (Dielectric)，即：聚对扩散（电介质）<ul>
<li>结构简单，但占面积大；</li>
</ul>
</li>
<li>Metal to Metal (Via Link)，即：金属对金属（通过连接）<ul>
<li>直接金属对金属消除聚和金属之间的连接或扩散到金属，从而减少寄生电容和互连空间要求；</li>
<li>电阻低；</li>
<li>目前使用的比较多；</li>
</ul>
</li>
</ol>
<h2 id="Flash-E2PROM-based"><a href="#Flash-E2PROM-based" class="headerlink" title="Flash/E2PROM based"></a>Flash/E2PROM based</h2><p>在 FPGA 里用 flash memory 配置逻辑和路由；    </p>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/FlashBaseSwitch.png" alt="FlashBaseSwitch">   </p>
<p>特点：</p>
<ul>
<li>使用 floating gate 存储编程信息；</li>
<li>两个晶体管共用 floating gate：<ul>
<li>感应晶体管：写入并验证 floating gate 电压</li>
<li>开关晶体管：连接或分离布线网络</li>
</ul>
</li>
</ul>
<p>VS. SRAM：</p>
<ul>
<li>可通过写入 floating gate 电压来重新配置；</li>
<li>断电时能保留其配置；</li>
<li>需要支持 floating gate 的技术，且其擦写次数有限，不像 SRAM 无限；</li>
<li>与基于 SRAM 的相比，消耗的面积更小；</li>
</ul>
<p>虽然它看起来有许多的优点，但是受其工艺的限制，它只能在特殊芯片的特殊位置上使用，导致其应用受限，目前大多数 FPGA 还是基于 SRAM 的；</p>
<h2 id="SRAM-based"><a href="#SRAM-based" class="headerlink" title="SRAM-based"></a>SRAM-based</h2><p>cell 由两个交叉耦合的反向器构成，采用标准 CMOS 工艺；   </p>
<p>结构特点：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/CRAM.png" alt="CRAM"></p>
<p>配置内存阵列：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/ConfigurationMemoryArray.png" alt="ConfigurationMemoryArray"></p>
<h2 id="Comparisons"><a href="#Comparisons" class="headerlink" title="Comparisons"></a>Comparisons</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>SRAM</th>
<th>Flash</th>
<th>Anti-fuse</th>
</tr>
</thead>
<tbody>
<tr>
<td>Volatile?（挥发性，断电数据还在？）</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Reprogrammable?</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Are(storage element size)</td>
<td>High(6 transistors)</td>
<td>Moderate(1 transistor)</td>
<td>Low(0 transistor)</td>
</tr>
<tr>
<td>manufacturing process(制造工艺)</td>
<td>Stadard CMOS</td>
<td>Flash Process</td>
<td>Anti-fuse needs special development</td>
</tr>
<tr>
<td>In-system programmable?</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Switch resistance电阻</td>
<td>~500-1000Ω</td>
<td>~500-1000Ω</td>
<td>20-100Ω</td>
</tr>
<tr>
<td>Switch capacitance电容</td>
<td>~1-2fF</td>
<td>~1-2fF</td>
<td>&lt;1fF</td>
</tr>
</tbody>
</table>
</div>
<p>Programming yield编程配置成功率|100%|100%|&gt;90%|</p>
<h1 id="Bit-stream-Configuration"><a href="#Bit-stream-Configuration" class="headerlink" title="Bit-stream Configuration"></a>Bit-stream Configuration</h1><p>FPGA 配置：将数据（位流）加载到 FPGA，来启用 FPGA 功能的过程；    </p>
<p>配置发生时间：</p>
<ul>
<li>FPGA 上电时；</li>
<li>FPGA 中断时；</li>
</ul>
<h2 id="Configuration-Mode"><a href="#Configuration-Mode" class="headerlink" title="Configuration Mode"></a>Configuration Mode</h2><p>配置模式：定义 FPGA 如何与数据源交互的细节</p>
<ul>
<li>Master serial mode（主-串）</li>
<li>Slave serial mode（从-串）</li>
<li>Parallel mode（并行）</li>
<li>JTAG (Joint Test Action Group) Mode（一种标准）<ul>
<li>JTAG接口：TDI（input）, TDO（output）, TCK（clk）, TMS（控制）</li>
</ul>
</li>
</ul>
<p>有了这些配置模型，只需要将数据按照对应模型的方式，通过 download cable（下载电缆），下载至 FPGA 即可；   </p>
<p>下面将分别介绍这四种 model；</p>
<h3 id="Master-serial-mode（主-串）"><a href="#Master-serial-mode（主-串）" class="headerlink" title="Master serial mode（主-串）"></a>Master serial mode（主-串）</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/Model1.png" alt="model1"></p>
<ul>
<li>FPGA驱动配置时钟（CCLK，配置时钟）；</li>
<li>FPGA提供所有控制逻辑；</li>
</ul>
<h3 id="Slave-serial-mode（从-串）"><a href="#Slave-serial-mode（从-串）" class="headerlink" title="Slave serial mode（从-串）"></a>Slave serial mode（从-串）</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/Model2.png" alt="model2"></p>
<ul>
<li>生成CCLK所需的外部控制逻辑;</li>
</ul>
<h3 id="Parallel-mode（并行）"><a href="#Parallel-mode（并行）" class="headerlink" title="Parallel mode（并行）"></a>Parallel mode（并行）</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/Model3.png" alt="model3"></p>
<ul>
<li>CCLK 由外部逻辑驱动</li>
<li>每个 CCLK 按字节加载数据</li>
</ul>
<h3 id="JTAG-Mode（一种标准）"><a href="#JTAG-Mode（一种标准）" class="headerlink" title="JTAG Mode（一种标准）"></a>JTAG Mode（一种标准）</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/Model4.png" alt="model4"></p>
<ul>
<li>控制信号和数据显示在边界扫描引脚（TDI、TMS、TCK）上</li>
<li>数据每 TCK 加载 1 位</li>
</ul>
<h2 id="Configuration-Process"><a href="#Configuration-Process" class="headerlink" title="Configuration Process"></a>Configuration Process</h2><p>4 个配置阶段：</p>
<ol>
<li>Configuration memory clear</li>
<li>Initialization</li>
<li>Load configuration data</li>
<li>Start-up</li>
</ol>
<p>配置数据流入串行输入/并行输出的移位寄存器链：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/SIPO.png" alt="SIPO">      </p>
<p>比特流和帧：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/BitstreamFrames.png" alt="BitstreamFrames"></p>
<ul>
<li>通过在 CRAM 中写入位来重新编程 FPGAs；</li>
<li>以小块 “frams” 组织起结构；</li>
<li>编写 tiles 的列/行程序需要多个帧合并起来；</li>
<li>包含路由和逻辑 tile 配置<ul>
<li>例如，Virtex 6 帧大小：81×32 位（81 字）</li>
<li>Virtex6 的典型比特流在 43Mb 到 190Mb 之间</li>
</ul>
</li>
</ul>
<p>配置时间取决于，配置频率和配置 bitstream 的长度；</p>
<h3 id="Configuration-memory-clear"><a href="#Configuration-memory-clear" class="headerlink" title="Configuration memory clear"></a>Configuration memory clear</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/P1.png" alt="P1"></p>
<ul>
<li>在此过程中禁用了非配置 I/O 管脚</li>
<li>配置 SRAM（CRAM）逐行清除</li>
<li>继续初始化</li>
</ul>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/P2.png" alt="P2"></p>
<ul>
<li>INIT pin 被释放</li>
<li>Mode pins 采样</li>
<li>继续加载配置数据</li>
</ul>
<h3 id="Load-configuration-data"><a href="#Load-configuration-data" class="headerlink" title="Load configuration data"></a>Load configuration data</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/P3.png" alt="P3"></p>
<ul>
<li>FPGA 开始接收数据</li>
<li>校验：在数据帧传输期间检查 CRC（循环冗余码）</li>
<li>如果通过 CRC 检查，则继续启动</li>
</ul>
<h3 id="Start-up"><a href="#Start-up" class="headerlink" title="Start-up"></a>Start-up</h3><p>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/P4.png" alt="P4"></p>
<ul>
<li>从配置过渡到正常运行</li>
<li>默认顺序为：<ul>
<li>释放 DONE pin</li>
<li>All I/O pins 激活</li>
<li>释放 Global write enable</li>
<li>释放 Global reset</li>
</ul>
</li>
<li>FPGA 可操作</li>
</ul>
<h1 id="Partial-Re-onfiguration-for-real-time-update"><a href="#Partial-Re-onfiguration-for-real-time-update" class="headerlink" title="Partial Re-onfiguration for real time update"></a>Partial Re-onfiguration for real time update</h1><p>认识 partial reconfiguration：</p>
<ul>
<li>通过下载部分位文件动态修改逻辑块的能力，而其余的逻辑继续运行而不中断；</li>
<li>允许设计人员动态更改功能，无需完全重新配置和重新建立链接，显著增强了 FPGAs 提供的灵活性；</li>
</ul>
<p>优势：</p>
<ul>
<li>允许在单个 FPGA 上使用多个应用程序；</li>
<li>在不影响芯片其他区域工作的情况下修复“损坏”的芯片模块；</li>
<li>节省重新配置时间，加快系统启动速度；</li>
</ul>
<p>两组 partial reconfiguration：</p>
<ol>
<li>Static partial reconfiguration<ul>
<li>设备在重新配置过程中不活动<br><img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/StaticPartialReconfiguration.png" alt="StaticPartialReconfiguration"></li>
</ul>
</li>
<li>Dynamic partial reconfiguration<ul>
<li>在剩下的 FPGA 仍在运行时更改设备的一部分</li>
<li><img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/DynamicPartialReconfiguration.png" alt="DynamicPartialReconfiguration"></li>
</ul>
</li>
</ol>
<p>动态部分重构的概念:<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/ConceptDynamicPartialReconfiguration.png" alt="ConceptDynamicPartialReconfiguration"></p>
<ul>
<li>可以实现快速的功能切换</li>
</ul>
<p>要确定可重构区域，不是所有的都可以 reconfiguration；</p>
<p>Module-based PR：</p>
<ul>
<li>将每个可重构模块作为一个单独的项目来实现；</li>
<li>将每个 PR 模块限制在给定的分区中；</li>
<li>最初加载全比特流，按需加载完整PR模块的部分比特流；</li>
<li>PR区域平面图；</li>
</ul>
<p>Difference-based PR：</p>
<ul>
<li>计算可重构模块的比特流差分，得到差分部分比特流；</li>
<li>仅包含有关当前设计结构（和 FPGA 的新内容）之间差异的信息；</li>
<li>在诸如更改查找表（LUT）公式或专用内存块内容之类的小更改中很有用；</li>
</ul>
<p>PR Specific Design Flow Comparison：<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-ProgrammingTechnologies/Comparison.png" alt="Comparison"></p>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>高等代数笔记</title>
    <url>/2020/04/18/Math-Basic-Notes/Advanced-Algebra/</url>
    <content><![CDATA[<p>本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p>
<p><strong><center><mark>多图警告！</mark></center></strong></p>
<a id="more"></a> 
<h1 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h1><p><img src="https://img-blog.csdnimg.cn/20200418204910161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">      </p>
<p><img src="https://img-blog.csdnimg.cn/20200418204945211.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200418204958865.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">         </p>
<p><img src="https://img-blog.csdnimg.cn/20200418205013693.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418205025697.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200418205037899.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418205049244.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418205103552.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p>
<h1 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h1><p><img src="https://img-blog.csdnimg.cn/2020041821124045.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210545462.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210623217.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210644273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821065966.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210711984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210726168.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210747249.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418210759378.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211403905.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">   </p>
<h1 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418211507676.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211544584.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211556347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211605407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211614824.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211625194.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211635285.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211645591.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8"></p>
<h1 id="向量空间与空间解析几何"><a href="#向量空间与空间解析几何" class="headerlink" title="向量空间与空间解析几何"></a>向量空间与空间解析几何</h1><p><img src="https://img-blog.csdnimg.cn/20200418211755382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211807381.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211821654.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418211836885.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821193096.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212011608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p>
<h1 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418212104459.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">      </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212116323.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212132817.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212220565.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212233608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212306524.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212323449.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p>
<h1 id="多元函数积分学"><a href="#多元函数积分学" class="headerlink" title="多元函数积分学"></a>多元函数积分学</h1><p><img src="https://img-blog.csdnimg.cn/20200418212408322.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212423141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212500133.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212529908.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212607639.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212617833.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212628700.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212639496.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212650823.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212700601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">     </p>
<h1 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h1><p><img src="https://img-blog.csdnimg.cn/20200418212758762.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212809544.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212848933.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212904319.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212915589.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212926165.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212936277.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418212947311.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">     </p>
<h1 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h1><p><img src="https://img-blog.csdnimg.cn/20200418213034307.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213047568.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">    </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213057543.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213107356.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">     </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821311791.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">     </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213145251.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">     </p>
]]></content>
      <categories>
        <category>数学基础笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《Morpheus:A Vulnerability-Tolerant Secure Architecture Based on EMTDs with Churn》阅读笔记</title>
    <url>/2020/05/25/Literature-reading-notes/Morpheus-EMTDsWithChurn/</url>
    <content><![CDATA[<p>目前，主要安全措施都是通过检测异常行为，实现被动防御。<br>而本文主要针对控制流劫持，提出了一种 Morpheus 架构的主动防御机制，它结合移动目标防御将那些正常程序不需要而攻击需要的信息进行随机化和加密处理，以此提高攻击难度，让攻击者需要更多的时间完成 probe，同时，采用一种 churn 方式进一步打乱攻击者攻击节奏。</p>
<a id="more"></a> 
<p><a href="https://dl.acm.org/doi/10.1145/3297858.3304037" target="_blank" rel="noopener">《Morpheus：A Vulnerability-Tolerant Secure Architecture Based on Ensembles of Moving Target Defenses with Churn》</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>通过观察现有的许许多多的攻击例子，我们可以发现一个大致的规律：<strong>正常程序一般使用给定的程序级语义，但是恶意程序会严重依赖于未定义的语义去完成攻击</strong>。所以，可以说正是因为程序中这些未定义的语义，带来了很大的脆弱性！ </p>
<ul>
<li><strong>Undefined semantics</strong>：程序运行时，因底层实现的差异没有被明确定义的语义，比如：数据越界访问、未初始化变量、执行时间、架构共享（如：LLC）。程序员因为各种底层实现的不同，它们不会关注这些语义，但攻击者则会利用这些语义实现攻击。</li>
</ul>
<h1 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h1><p>针对这种脆弱性，作者就提出来 Morpheus 架构来主要防御针对控制流的攻击，它主要有两个特点：</p>
<ol>
<li>利用 <strong>EMTDs（ensembles of moving target defenses）</strong>，类似 ALSR 对关键性的程序数据进行<strong>随机化</strong>和<strong>加密</strong>；</li>
<li>采取 <strong>churn 机制</strong>，在运行中对程序进行随机化处理；</li>
</ol>
<p>具体来说：以往，ASLR 是在程序运行时完成随机化处理，但是这种一次性的处理方式，攻击者在程序运行期间可以实现类似 AnC 的攻击来获取目标值。   </p>
<p>对此 Morpheus 采用 EMTDs，提供了一个 504 位（熵）的随机地址空间，即随机化指针存储的位置，同时加密指针的内容。这样，攻击者就需要花费更多大量的时间和精力去 probe。<br>但这肯定还不够，于是又引入了 churn 机制，它最大的特点就是可以在程序运行期间再次进行随机化，它有两种触发方式：</p>
<ol>
<li>按初始化的周期，周期性发生（为了短于攻击者 probe 的时间，这个周期会在保证性能的情况下尽量短，文章选为 50ms）；</li>
<li>被一些潜在的攻击（未定义语义）触发（因为这种时候程序往往正在被攻击，例如攻击者频繁的probe），这一点得益于<strong>攻击检测器</strong>，它有两种规则：「<strong>ABORT 规则</strong>」监视特别严重的操作（明确的攻击行为），并触发终止程序的异常；「<strong>CHURN 规则</strong>」检测到可能正利用未定义行为在进行攻击，针对这些违规行为，启动更改 churn cycle。（攻击检测器逻辑图如下）：<br><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/AttackDetector.png" alt="AttackDetector"></li>
</ol>
<p>通过这两种方式来触发 churn，使得攻击者花费大量时间和精力去 probe 想要获取信息（还未获得）时，重新对关键值进行随机化和加密，于是攻击者只能重新开始攻击，但是下一次同样的情况仍会发生，最终攻击失败。这就是 Morpheus 架构的主要防御原理。见图：   </p>
<p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/EMTDsChurn.png" alt="EMTDsChurn"></p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/MorpheusSecureArchitecture.png" alt="MorpheusSecureArchitecture"></p>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>EMTDs 依赖于域标记机制来精确跟踪运行时所有内存对象的域。</p>
<p>基于 Morpheus LLVM 的编译器收到未修改的 C 源文件。 然后，在全局变量域分析，将静态初始化的数据部分中的每个内存对象标记为数据，代码指针或数据指针（使用 2 位域标记跟踪四个不同的域：代码(C)、代码指针(CP)、数据指针(DP)、其他数据(D)），之后，生成一个带标签的二进制文件和一个域标签文件，其中包含内存对象的初始标签。   </p>
<p>对此，为体系结构也做出改变：所有寄存器都扩展 2 bit tags，并将 tag 附加到每个 64 位 aligned word；将 DRAM 和 cache 也搭配上 tag 域，其中，将标签集中到 DRAM 中的固定位置，以简化 churn 过程；所有 data cache blocks 都以每 64 位字扩展 2 位的方式扩展，以在每个缓存块中存储增加的域标签位。</p>
<h2 id="EMTDs"><a href="#EMTDs" class="headerlink" title="EMTDs"></a>EMTDs</h2><h3 id="PART1：指针移位（Pointer-Displacement）"><a href="#PART1：指针移位（Pointer-Displacement）" class="headerlink" title="PART1：指针移位（Pointer Displacement）"></a>PART1：指针移位（Pointer Displacement）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/PointerDisplacement.png" alt="PointerDisplacement"></p>
<p>如图所示，就是在指针原来的位置上加上了一个 $d_{CODE}(DAS_C)$ 或 $d_{DATA}(DAS_D)$ 的偏移量，并且这个偏移量是随机产生的。</p>
<h3 id="PART2：域加密（Domain-Encryption）"><a href="#PART2：域加密（Domain-Encryption）" class="headerlink" title="PART2：域加密（Domain Encryption）"></a>PART2：域加密（Domain Encryption）</h3><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/DomainEncryption.png" alt="DomainEncryption"></p>
<p>使用强密码（由域标记选择的它们自己的域密钥，分别对应 $K_C、K_{CP}、K_{DP}$，并且他们会在内存里受到保护）将内存中的代码，代码指针和数据指针的表示随机化。</p>
<p>如图所示，当在 L1-L2 边界之间读取内存（加载或取指令）时，将对受保护域进行解密，并在 L1-L2 边界之间写入（存储）内存时对受保护域进行加密，从而使 L2 缓存和 DRAM 保持加密状态。</p>
<p>由 tag 选择适当的密码密钥，密钥和物理地址通过密码进行组合，让包含相同值的内存位置不相关。对地址进行加密后，就可以使用反向模式的密码，在这种模式下，会生成密钥流，并与受保护的 value 进行 XOR 运算，以对其进行加密或解密。</p>
<h2 id="Churn"><a href="#Churn" class="headerlink" title="Churn"></a>Churn</h2><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Churn.png" alt="Churn"></p>
<p>在程序运行过程中，会周期性的经历 churn，每一次的 churn 又包含如下四个阶段：</p>
<ol>
<li>管道刷新；</li>
<li>新密钥生成和寄存器更新；</li>
<li>使用阈值寄存器来协调新位移和加密密钥下存储器中的更新值；</li>
<li>churn 完成时，所有域都已更新，有效地处置了攻击者先前可能已获取的任何信息；</li>
</ol>
<p>总的来说，就是 churn 会周期性的更新加密用的域秘钥（$K_C、K_{CP}、K_{DP}$）和指针移位（$d_{CODE}$、$d_{DATA}$），但是更新后的这两项会与原先的旧值产生冲突，于是引入了一个<strong>阀值寄存器</strong>来协调，它将使用新 key 和 displacement 状态记为 “clean”，而旧值的记为 “stale”，以此进行区分。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Effect.png" alt="Effect"></p>
<ul>
<li>可以防御表 4 所示的所有攻击，并且他们都能触发攻击感测器进一步提高了防御效果；</li>
<li>在没有加入 Morpheus 防御机制的情况下，完成 probe 穿透所需的时间就已经是 churn cycle（50ms）的很多倍（5020），所以说，在加入了EMTDs 后，完全可以保证在攻击者彻底完成 probe 穿透前，触发 churn。</li>
</ul>
<h1 id="性能影响"><a href="#性能影响" class="headerlink" title="性能影响"></a>性能影响</h1><p><img src="http://img.thebetterkong.cn/blog/Morpheus-EMTDsWithChurn/Performance.png" alt="Performance"></p>
<p>自古 「安全-性能」 就很难两全其美，前面看到了 Morpheus 在防御上的优势，那么这种机制对性能的影响也肯定是一个需要考量的因素。   </p>
<p>文中提到，将 50ms 作为正常的 churn 周期，由图一可看到，平均情况下，它对处理器性能的影响只下降了 1% 左右，这是一个很好的结果。</p>
<p>即使在 SPEC’06 基准测试的最坏情况下，由图二我们也能看出它仅仅只是在 403-gcc 这一项上造成了相对高的性能损耗，这也是我们能接受的范围。</p>
<p>所以，总的来说就是，Morpheus 采用 EMTDs 和 churn 这两种机制，以较低的性能损耗大大提高了安全性。</p>
<h1 id="不成熟的两个小想法"><a href="#不成熟的两个小想法" class="headerlink" title="不成熟的两个小想法"></a>不成熟的两个小想法</h1><ol>
<li>文中并未具体谈论到 churn cycle 初始值（50ms）如何设置，攻击者似乎可以先攻击 churn cycle，人为修改它的值？</li>
<li>攻击检测器的存在，会因为检测到攻击而触发 churn 或者直接中断程序，对此，如果攻击者起初的目标不是获取信息，那么他也可以利用这个性质不断地“伪造攻击”，进而不断触发攻击检测器，这样大大拖低处理器性能，甚至导致程序瘫痪。</li>
</ol>
]]></content>
      <categories>
        <category>文献阅读笔记</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>ASLR</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-Outlook：New FPGA</title>
    <url>/2020/06/09/FPGA-technology/FPGA-Outlook-NewFPGA/</url>
    <content><![CDATA[<p>这是 FPGA 学习的最后一章。未来 FPGA 的发展也必定会迎合前沿时代的需求，例如：大数据时代的高性能计算、还有 AI 智能等等。</p>
<a id="more"></a> 
<h1 id="FPGA-高级综合（HLS）"><a href="#FPGA-高级综合（HLS）" class="headerlink" title="FPGA 高级综合（HLS）"></a>FPGA 高级综合（HLS）</h1><h2 id="HLS-发展动机"><a href="#HLS-发展动机" class="headerlink" title="HLS 发展动机"></a>HLS 发展动机</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLS.png" alt="HLS"></p>
<ul>
<li><strong>片上系统（SoC）设计</strong>复杂性的迅速增加鼓励了设计社区寻求比 RTL 更好的生产率的设计抽象； </li>
<li>电子系统级（ESL）设计的自动化已被广泛认为是半导体行业提高生产率的下一个推动力，HLS（例如 C 语言或 SystemC） 在其中发挥着核心作用;<ul>
<li>它可以实现 high-level 到 low-level 的自动综合，以在 FPGA（或 ASIC）中高效实现；</li>
<li>high-level 时只需 untimed 或 partially-timed 的规范，而像 RTL（寄存器传输级） 的 low-level 则需要考虑精确的时钟周期（延迟）；</li>
</ul>
</li>
<li>可以综合考虑特定系统的性能，功耗和成本要求来优化此综合；</li>
<li>这样，设计者只需利用 HLS 来设计电路，而精确的电路优化等工作就可以完全交由其他的综合软件来自动化完成，提高开发设计效率；</li>
</ul>
<h2 id="相关现状"><a href="#相关现状" class="headerlink" title="相关现状"></a>相关现状</h2><p>基于上述原因，也就迫使 FPGA 设计人员更快地采用 HLS 工具：</p>
<ol>
<li>减少正式验证的压力：<ul>
<li>纳米 IC 技术的 ASIC 制造成本超过 100 万美元，这就使 ASIC 设计人员要保证流片后一次成功，将承受巨大压力；</li>
<li>然而，要实现上述的要求，就依赖于 HLS 的正式验证工具，而这种工具的发展还不成熟，并且对于数百万 gate SOC 设计的仿真覆盖范围可能会受到限制；</li>
<li>这是在 ASIC 界采用 HLS 的重大障碍；</li>
<li>但是，对于 FPGA 设计，系统内仿真（直接在 FPGA 芯片上进行仿真，如果出现问题再进行调整，因为 FPGA 是可重配置的，所以这样的 cost 比较低）可以获得更广泛的仿真范围；</li>
<li><strong>设计迭代可以快速，廉价地完成，而无需付出巨大的制造成本</strong>；</li>
</ul>
</li>
<li>基于平台综合的理想选择：<ul>
<li>现代 FPGA 嵌入了许多预定义/制造的 IP 组件，例如：算术功能单元，嵌入式存储器，嵌入式处理器和嵌入式系统总线；</li>
<li>可以为每个 FPGA 平台提前对这些预定义的构建模块进行精确建模，并在很大程度上限制了设计空间；</li>
<li>因此，现代 HLS 工具可以应用基于平台的设计方法，获得更高的结果质量（QoR）</li>
</ul>
</li>
<li>上市时间的压力更大：<ul>
<li>FPGA 平台通常被选择用于十分看重上市时间的系统，以避免长时间的芯片设计和制造周期；</li>
<li>因此，设计人员可能会接受牺牲性能，功耗或成本，来减少设计时间；</li>
<li>现代的 HLS 工具将这种 tradeoff 的权利交给了设计人员，从而大大减少了设计时间，或者通过额外的努力，获得了与手写 RTL 相当的结果质量；</li>
</ul>
</li>
<li>加速或可重构的计算要求，需要 FPGA 可以基于 C/C ++ 进行编译/综合：<ul>
<li>FPGA 的最新发展使可重构计算平台，能用于加速许多高性能计算（HPC）应用程序，例如：图像和视频处理，财务分析，生物信息学和科学计算应用程序；</li>
<li>由于 VHDL 或 Verilog 中的 RTL 编程对于大多数应用软件开发人员来说是不可接受的，因此必须提供从 C/C++ 到 FPGA 的高度自动化的编译/综合流程；</li>
</ul>
</li>
</ol>
<h2 id="实现更高层次的设计"><a href="#实现更高层次的设计" class="headerlink" title="实现更高层次的设计"></a>实现更高层次的设计</h2><ul>
<li>从更高层次的描述性语言生成高质量的 RTL<ul>
<li>有益于功能验证和架构探索；</li>
<li>RTL 设计过程中不断迭代带来的时间开销可以被消除；</li>
<li>RTL 目标转向技术和频率；</li>
</ul>
</li>
<li>C++ 提供了更好的抽象级；SystemC 则可以提供时序上的设计；</li>
<li>许多关键应用已经开始使用 HLS 实现：<ul>
<li>Video Compression / Decompression (H.265/HEVC,VP9)</li>
<li>Image Processing ( Mobile/Ultra HD/3D)</li>
<li>Wireless/Wireline (5G,802.11x,Gb optical)</li>
</ul>
</li>
</ul>
<h2 id="FPGA-HLS-案例"><a href="#FPGA-HLS-案例" class="headerlink" title="FPGA HLS 案例"></a>FPGA HLS 案例</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/HLSExample.png" alt="HLSExamp"></p>
<ul>
<li>缺少直接的仿真工具；</li>
<li>在用 c/c++ 等高级语言描述时，并不是所有的语句都是可综合的，在遇到不可综合的语句时，需要我们改变语句写法；</li>
</ul>
<h1 id="面向深度神经网络（DNN）的-FPGA-设计"><a href="#面向深度神经网络（DNN）的-FPGA-设计" class="headerlink" title="面向深度神经网络（DNN）的 FPGA 设计"></a>面向深度神经网络（DNN）的 FPGA 设计</h1><p>FPGA 的主频虽然不高（不超过 1G），但是它可做大量的并行计算；</p>
<h2 id="FPGA-vs-GPU"><a href="#FPGA-vs-GPU" class="headerlink" title="FPGA vs. GPU"></a>FPGA vs. GPU</h2><ul>
<li>GPU（Graphics Processing Unit）—&gt; 通过软件编程的 ALU 阵列架构（粗粒度） —&gt; 具有统一数据类型（32位对应32位，64位对应64位）的常规计算<ul>
<li>功耗比较高</li>
</ul>
</li>
<li>FPGA —&gt; 通过硬件配置的并行数据处理架构（细粒度） —&gt; 具有自定义数据类型的常规和不规则计算（可以很好的适应神经网络中稀疏和细粒度的计算要求）<ul>
<li>因此，FPGA 可定制性更强，单位功耗的处理能力优于 GPU；</li>
</ul>
</li>
</ul>
<h2 id="迈向百亿分之一计算的并行性胜利"><a href="#迈向百亿分之一计算的并行性胜利" class="headerlink" title="迈向百亿分之一计算的并行性胜利"></a>迈向百亿分之一计算的并行性胜利</h2><ul>
<li>卷积神经网络（CNN）可在各种 AI 任务中提供最先进的准确性，但计算量大且耗能！</li>
<li>摩尔定律已经快到达极限，技术扩展速度变慢；</li>
<li>多核芯片达到了性能功耗比的上限；</li>
<li>处理器与内存之间的性能差距，形成了 wall；</li>
<li>需要去寻找高性能的计算芯片；</li>
<li>并行性在高性能计算中，占比越来越高；</li>
<li>期望通过<strong>并行性</strong>获得更多的系统性能（通过增加更多的处理核心）</li>
</ul>
<h2 id="机器学习和神经网络中的-FPGA-表现"><a href="#机器学习和神经网络中的-FPGA-表现" class="headerlink" title="机器学习和神经网络中的 FPGA 表现"></a>机器学习和神经网络中的 FPGA 表现</h2><ul>
<li>FPGA 是一种具有竞争性的 HPC（高性能计算）加速器技术；</li>
<li>FPGA 在人工智能计算中的性能比 CPU、GPU 和 ASIC 高几倍；</li>
<li>FPGA 实现了峰值性能的高利用率；</li>
<li>每瓦特的性能：FPGA 非常节能，同时非常灵活</li>
</ul>
<h2 id="why-FPGA-power-efficient"><a href="#why-FPGA-power-efficient" class="headerlink" title="why FPGA power efficient"></a>why FPGA power efficient</h2><p>为了减少能量消耗，少移动数据：</p>
<ul>
<li>数据移动会消耗更多的能量，FPGA 每次计算执行的数据移动较少；</li>
<li>互连消耗的能量（每毫米）的降低速度比计算消耗的能量的降低速度慢，片上数据移动消耗的能量将开始占主导地位；</li>
</ul>
<p>对于 FPGA 来说，并行性本质上是导致能量效率缩放的原因：</p>
<ul>
<li>随着工艺的先进，FPGA 的性能功耗比不断上升，而 CPU/GPU 的性能功耗比却呈下降趋势</li>
</ul>
<h2 id="解决-FPGA-设计问题的途径"><a href="#解决-FPGA-设计问题的途径" class="headerlink" title="解决 FPGA 设计问题的途径"></a>解决 FPGA 设计问题的途径</h2><p>FPGA 也需要迅速发展以拥抱新的尖端技术：</p>
<ul>
<li>计算问题：传统的 FPGA 体系结构不能很好地匹配 DNN（深度神经网络）算法的执行</li>
<li>需要面向 DNN 的 FPGA 数据处理架构设计</li>
</ul>
<p>CNN Algorithm：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNAlgorithm.png" alt="CNNAlgorithm"></p>
<ul>
<li>通过图层重复操作：Convolutional + Fully Connected + Pooling</li>
</ul>
<p>两种策略：<br><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/TwoApproaches.png" alt="TwoApproaches"></p>
<ul>
<li>当前的 FPGA 综合流程并未考虑 CNN 的并行计算属性-<strong>非优化的实现</strong>（完全取决于设计人员精心设计的 Verilog 代码）</li>
<li>完全并行实施的资源（DSP 块和 BRAM 的数量）限制</li>
</ul>
<h2 id="目前-CNN-在-FPGA-上的实现"><a href="#目前-CNN-在-FPGA-上的实现" class="headerlink" title="目前 CNN 在 FPGA 上的实现"></a>目前 CNN 在 FPGA 上的实现</h2><p><img src="http://img.thebetterkong.cn/blog/FPGA-Outlook-NewFPGA/CNNImplementation.png" alt="CNNImplementation">   </p>
<p>在 DNN 中压缩数据：</p>
<ul>
<li>量化：将浮点运算转换为定点运算</li>
<li>共享：分组权重</li>
<li>修剪：切掉小重量的树枝</li>
</ul>
<h2 id="适合-FPGA-的目标-AI-应用"><a href="#适合-FPGA-的目标-AI-应用" class="headerlink" title="适合 FPGA 的目标 AI 应用"></a>适合 FPGA 的目标 AI 应用</h2><ul>
<li>尺寸和能量受限的前端：<strong>边缘计算</strong></li>
<li>低功耗和高并行处理所需的数据中心：<strong>云计算</strong>（ 云和嵌入式系统的需求）</li>
</ul>
<h1 id="发展挑战和机遇"><a href="#发展挑战和机遇" class="headerlink" title="发展挑战和机遇"></a>发展挑战和机遇</h1><h2 id="FPGA-技术趋势"><a href="#FPGA-技术趋势" class="headerlink" title="FPGA 技术趋势"></a>FPGA 技术趋势</h2><p>四个时代的 FPGA:</p>
<ul>
<li>1984年-1991年：发明 Invention</li>
<li>1992年-1999年：扩张 Expansion</li>
<li>2000年-2007年：积累 Accumulation</li>
<li>2008年-2017年：融合 Fusion</li>
<li>2018年：可编程计算架构创新？</li>
</ul>
<h2 id="新兴技术驱动的-FPGA"><a href="#新兴技术驱动的-FPGA" class="headerlink" title="新兴技术驱动的 FPGA"></a>新兴技术驱动的 FPGA</h2><ol>
<li>新的可编程 brain inspired computing 体系结构—-现场可编程神经阵列(FPNA)</li>
<li>新的可编程 in-memory computing 体系结构</li>
<li>基于新设备(rRAM)的可编程计算体系结构</li>
</ol>
<h2 id="现在可能得到答案的问题"><a href="#现在可能得到答案的问题" class="headerlink" title="现在可能得到答案的问题"></a>现在可能得到答案的问题</h2><p>[ Steve Trimberger, Fellow, Xilinx Research Labs, 2014 ]：</p>
<ul>
<li>为什么 FPGA 编译时间这么长？FPGA 公司愚蠢吗？还是他们不在乎？</li>
<li>为什么选择 LUT？那是自然法则还是什么？</li>
<li>为什么动态编程的 FPGA 从来没有到过任何地方？现在可以改变吗？<ul>
<li>Tabula 的“时空” 3D FPGA 架构将时间作为第三维度，从而允许以高达 2 GHz 的时钟速率动态地重新配置片上逻辑，存储器和互连资源。</li>
</ul>
</li>
<li>为什么没有规范的 FPGA 架构？</li>
<li>可重构计算发生了什么？</li>
<li>如果处理器是新的 LUT，那么处理器阵列呢？</li>
<li>FPGA 的多芯片分区发生了什么？</li>
<li>模拟 FPGA 呢？那么异步 FPGA 呢？</li>
<li>为什么 FPGA 制造商不提供 ASIC 转换？</li>
<li>FPGA 制造商为什么要坚持拥有自己的位置和路线？他们也会接管逻辑综合吗？那么高级综合呢？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可编程设备的创新以非常快的速度持续进行；</li>
<li>在未来几年中，我们可以预期制造商将利用设计和制造技术两者的优势来继续提高 FPGA 的功能；</li>
<li>摩尔定律的终结可能即将到来，但是 FPGA 的用户可以期待更多代的性能和功能的提高；</li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>《SGX技术的分析和研究》阅读笔记</title>
    <url>/2020/02/14/Literature-reading-notes/SGX-Technology-Analysis-and-Research/</url>
    <content><![CDATA[<p>本文是一篇综述性质的文章，主要介绍了SGX的基础架构，分析其技术原理，也从各个角度阐述了SGX侧信道攻击及其防御。分析对比了一些主要的应用和研究方向，指出了SGX自身的一些优势与不足。</p>
<a id="more"></a> 
<h1 id="SGX的技术背景"><a href="#SGX的技术背景" class="headerlink" title="SGX的技术背景"></a>SGX的技术背景</h1><p>移动环境和云平台的安全对硬件和平台安全机制的需要更加迫切，基于硬件的可信执行环境必不可少，以处理器安全为核心的硬件安全技术竞相发展；   </p>
<p>当前主流的技术：</p>
<ol>
<li><strong>虚拟化技术</strong>：<ul>
<li>例子：Intel VT(Intel virtualization technology)与AMD SVM(AMD secure virtual machine)技术；</li>
<li>虚拟化技术基于<strong>特权软件hypervisor</strong>对系统资源进行分配与监控，极大提升了资源利用率，但hypervisor潜在的软件漏洞可能威胁到整个系统。</li>
</ul>
</li>
<li><strong>基于可信平台模块(trusted platforill module，TPM)的可信计算技术</strong>：<ul>
<li>例子：Intel TXT(Intel trusted execution technology)、嵌入式平台ARM TrustZone安全扩展等；</li>
<li>基于TPM的可信架构在程序加载时进行完整性度量，却难以保障程序运行时的可信执行；</li>
<li>TrustZone为程序提供了两种隔离的执行环境，但需要硬件厂商的签名验证才能运行在安全执行环境，这一特性使得多数软件开发者望而却步。</li>
</ul>
</li>
</ol>
<p>2013年，Intel推出<strong>SGX(software guard extensions)指令集扩展</strong>：</p>
<ul>
<li>旨在以硬件安全为强制性保障，不依赖于固件和软件的安全状态，提供用户空间的可信执行环境</li>
<li>SGX是Intel在原有架构上增加的一组新的指令集和内存访问机制，进而允许用户实现enclave容器（在应用程序地址空间划分出保护区域），来保护代码和数据，免受特权攻击。</li>
<li>要求：处理器、内存管理部件、BIOS、驱动程序、运行时环境等软硬件协同完成。</li>
<li>目标：<ol>
<li>允许应用程序开发者保护敏感数据不被未授权访问或者更高特权级别软件的修改； </li>
<li>使得应用程序能够拥有保护敏感代码和数据的机密性与完整性的能力，而不会中断这些资源被合法程序和系统调度、使用和管理的能力； </li>
<li>使得计算设备的消费者能够控制自己平台，并且具有自由安装和卸载应用与服务的能力； </li>
<li>使得平台能够度量应用程序的可信代码，生成签名验证，并且度量和认证过程的代码都能够在可信赖的环境中正确的初始化； </li>
<li>使得可信应用程序的开发过程中能够使用原来的工具和流程； </li>
<li>允许可信应用程序的性能能够随着处理器的能力增强而得到扩展； </li>
<li>使得软件代理商能够使用它们选择的分发通道来分发、更新可信应用程序； </li>
<li>使得应用程序可以定义一个安全代码和数据区域，这一区域可以维护其机密性，即使攻击者能够物理上控制这个平台以及产生对内存的直接攻击，也能够有效加以抵御；</li>
</ol>
</li>
</ul>
<p>TrustZone 和 SGX 的不同之处在于：</p>
<ul>
<li>TrustZone中，通过CPU将系统划分为两个隔离环境，两者之间通过SMC指令通信，一旦Secure world中存在恶意程序，那么将危害整个系统的安全；</li>
<li>而SGX中，一个CPU可以运行多个安全enclaves，并发执行，即使某个enclave中存在恶意程序，它也不能访问和危害其他enclave的被保护内容。</li>
</ul>
<h1 id="SGX架构及技术分析"><a href="#SGX架构及技术分析" class="headerlink" title="SGX架构及技术分析"></a>SGX架构及技术分析</h1><h2 id="SGX整体架构"><a href="#SGX整体架构" class="headerlink" title="SGX整体架构"></a>SGX整体架构</h2><p>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/SGX-overall-architecture.png" alt="SGX整体架构"></p>
<h2 id="处理器保留内存：PRM（processor-reserved-memory）"><a href="#处理器保留内存：PRM（processor-reserved-memory）" class="headerlink" title="处理器保留内存：PRM（processor reserved memory）"></a>处理器保留内存：PRM（processor reserved memory）</h2><p>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/PRM-layout.png" alt="PRM布局示例"></p>
<ul>
<li>所有的Enclave都驻留在<strong>EPC(enclave page cache)</strong>，这是系统内一块被保护的物理内存区域，用来存放Enclave和SGX数据结构。</li>
<li>如果CPU支持SGX架构并在加密保护的DRAM中实现EPC，那么它也支持BIOS保留一段叫<strong>PRM的内存范围</strong>；   </li>
<li>BIOS通过配置一组范围寄存器分配PRM。具体的PRM和EPC布局和平台有关，并取决于BIOS设置；</li>
</ul>
<h2 id="Enclave容器"><a href="#Enclave容器" class="headerlink" title="Enclave容器"></a>Enclave容器</h2><p>一个被保护的内容容器：用于存放应用程序敏感数据和代码，在创建enclave之前，不必对这些代码和数据进行检查或分析，但加载到enclave中去的代码和数据必须被度量；  </p>
<ul>
<li>Enclave可以向远程认证者证明自己的身份，并提供必需的功能结构用于安全地提供密钥；</li>
<li>用户也可以请求独有的密钥，这个密钥通过结合enclave身份和平台的身份做到独一无二，可以用来保护存储在enclave之外的密钥或数据；</li>
</ul>
<p>特征：</p>
<ul>
<li>具有自己的代码和数据； </li>
<li>提供机密性和完整性保护； </li>
<li>具有可控的入口点； </li>
<li>支持多线程； </li>
<li>对应用程序内存具有最高访问权限；</li>
</ul>
<p>结构：<br>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/Enclave-structure.png" alt="Enclave结构"></p>
<ul>
<li><strong>TCS(thread control structure)</strong>：保存着进入或退出Enclave时恢复Enclave线程的特殊信息。<ul>
<li>每一个Enclave中的执行线程都和一个TCS相关联；</li>
<li>它需要4K字节对齐；</li>
<li>由多个部分组成，例如：保留位(RESERVED)、标志位(FLAGS)、状态保存区偏移量(state save area offset，简称OSSA)等</li>
</ul>
</li>
</ul>
<h2 id="Enclave保护机制"><a href="#Enclave保护机制" class="headerlink" title="Enclave保护机制"></a>Enclave保护机制</h2><p>由Enclave<strong>内存访问语义</strong>的变化、应用程序<strong>地址映射关系的保护</strong>，这两项功能共同完成对Enclave的机密性和完整性的保护。</p>
<h3 id="内存访问语义"><a href="#内存访问语义" class="headerlink" title="内存访问语义"></a>内存访问语义</h3><p>作用：</p>
<ul>
<li>保证内存保护机制在物理上锁住EPC内存区域，将外部的访问请求视为引用了不存在的内存，使得外部的实体(直接存储器访问、图像引擎等)无法访问。</li>
</ul>
<p>对于使用MOV等指令访问Enclave内部的页面的情况，硬件将执行下列的检查：</p>
<ul>
<li>处理器当前运行在Enclave mode中； </li>
<li>访问地址在Enclave地址空间； </li>
<li>物理地址在EPC内存中； </li>
<li>EPCM(enclave page cache map)检查，请求访问的页属于正在运行的Enclave(只有Enclave内的代码才能访问该Enclave的内容)；</li>
</ul>
<p>SGX所提供的内存保护机制，是在保护模式所提供的段保护、页保护机制基础上进行进一步的内存保护，访问地址由虚拟地址转换为物理地址进行访问。   </p>
<p>对内存的访问可分为如下5种类型：<br>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/SGX-memory-access-control.png" alt="SGX内存访问控制"></p>
<ol>
<li>运行于非Enclave模式的处理器访问PRM之外的内存，按照保护模式下的机制进行访问； </li>
<li>运行于非Enclave模式的处理器访问PRM内部内存，将被视为引用了不存在的内存； </li>
<li>处理器运行于Enclave模式，访问的页面不在Enclave的虚拟地址空间，但是处于EPC的区域范围内，则CPU将这次访问视为引用了不存在的内存： </li>
<li>处理器运行于Enclave模式，硬件允许Enclave代码访问处理器保留内存(PRM)外部的地址； </li>
<li>如果页面在Enclave的虚拟地址空间外，且指向PRM页面，硬件将阻止访问并且发出异常。</li>
</ol>
<h3 id="地址映射保护EPCM-enclave-page-cache-map"><a href="#地址映射保护EPCM-enclave-page-cache-map" class="headerlink" title="地址映射保护EPCM(enclave page cache map)"></a>地址映射保护EPCM(enclave page cache map)</h3><p>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/EPCM-logical-structure.png" alt="EPCM逻辑结构">   </p>
<ul>
<li>EPC内存，以<em>页为单位</em>进行管理，<em>页的控制信息保存在硬件结构EPCM里</em>，一个页面对应一个EPCM表项；类似于操作系统内的页表，管理着EPC页面的基本信息：包括页面是否已被使用、该页的拥有者、页面类型、地址映射和权限属性等。</li>
<li>EPCM结构，<em>在CPU地址映射过程中用于执行Enclave页面的访问控制</em>，逻辑上而言， 它在保护模式的段保护和页保护机制的基础上，增加了一层安全的访问控制。</li>
<li>EPCM结构，由 <strong>PMH(page miss handler)</strong> 硬件模块访问，这个模块通过查询页表(系统软件维护的)、范围寄存器、EPCM来进行内存访问。</li>
</ul>
<h3 id="Enclave机密性和完整性保护"><a href="#Enclave机密性和完整性保护" class="headerlink" title="Enclave机密性和完整性保护"></a>Enclave机密性和完整性保护</h3><p>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/Enclave-build-protection.png" alt="Enclave建立保护过程"><br>过程描述：（较粗箭头表示请求的操作，细箭头表示具体步骤）</p>
<ul>
<li>应用程序在申请创建一个Enclave时：需要进行页面分配、复制程序代码与数据、和度量操作，创建过程的最后一步需要对Enclave的完整性进行验证（判断特权软件在创建过程中是否篡改了程序数据，如分配了多余的页、将恶意代码复制进来，或是篡改了复制的数据等）。通过对每个添加的页面内容进行度量，最终得到一个创建序列的度量结果，保存在enclave的控制结构中。</li>
<li>然后，SGX通过一条初始化指令将这个结果与Enclave所有者签名的证书中的完整性值进行比较：<ul>
<li>如果匹配，则将证书中的所有者公钥进行哈希，作为密封身份保存在Enclave控制结构中；</li>
<li>如果不匹配，则说明创建过程存在问题，指令返回失败结果． </li>
</ul>
</li>
<li>成功进行了初始化指令之后，才能进入Enclave执行程序，此后SGX提供的内存保护和地址映射保护使得外界无法访问Enclave内存，从而保证了Enclave的机密性和完整性，远程的认证者可以通过Enclave的完整性度量值和其密封身份，确保其正确地创建。</li>
</ul>
<h2 id="SGX认证"><a href="#SGX认证" class="headerlink" title="SGX认证"></a>SGX认证</h2><p>SGX两种类型的身份认证方式：</p>
<ul>
<li>平台内部enclave间的认证：用来认证进行报告的Enclave和自己是否运行在同一个平台上；</li>
<li>平台间的远程认证：用于远程的认证者认证Enclave的身份信息；</li>
</ul>
<h3 id="平台内部enclave间的认证"><a href="#平台内部enclave间的认证" class="headerlink" title="平台内部enclave间的认证"></a>平台内部enclave间的认证</h3><p>验证使用的是对称密钥；<br>过程：</p>
<ul>
<li>当Enclave向平台上其他Enclave报告身份时，先获取当前的Enclave的身份信息和属性、平台硬件TCB信息，附加上用户希望交互的数据，生成报告结构；</li>
<li>然后获取目标Enclave的报告密钥，对报告结构生成一个MAC标签，形成最终的报告结构，传递给目标Enclave，由目标Enclave验证请求报告身份的Enclave跟自己是否运行于同一平台。</li>
</ul>
<h3 id="平台间的远程认证"><a href="#平台间的远程认证" class="headerlink" title="平台间的远程认证"></a>平台间的远程认证</h3><p>对称密钥不再适用于远程认证，平台间的认证采用非对称密钥机制；<br>需要引入一个特殊的<strong>引用(quoting)Enclave</strong>：</p>
<ul>
<li>由引用Enclave创建平台认证的签名密钥 EPID(enhanced privacy identification)，这个密钥不仅代表平台，还代表着底层硬件的可信度，并且绑定处理器固件的版本。</li>
<li>当enclave系统运行时，只有引用enclave才能访问到EPID密钥。</li>
</ul>
<p>远程认证的过程（假设远程认证方B 要认证EnclaveA）：<br>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/Remote-authentication.png" alt="远程认证过程"></p>
<ul>
<li>A 先执行 EREPORT 指令，将 A 的身份和附加信息组合生成 REPORT 结构，利用引用Enclave (称其为Q) 的报告密钥生成一个MAC，连同报告结构一起发给Q，Q通过该结构验证 A 是否运行于同一平台，然后将它封装为一个引用结构体 QUOTE ，并使用 EPID 进行签名，将 QUOTE 和签名一同发给远程认证者。</li>
<li>报告结构还需提供额外的用户数据域，可用来传递用户自定义的信息，以支持更复杂的交互方式。</li>
</ul>
<h2 id="SGX程序机密性"><a href="#SGX程序机密性" class="headerlink" title="SGX程序机密性"></a>SGX程序机密性</h2><p>《Moat：Verifying confidentiality of enclave programs》：基于自动定理证明和信息流分析，提出了一套 SGX 的使用规范，设计了 Moat 这一检测工具，通过在汇编语言层面对程序进行分析，从而检测应用程序是否存在泄露 SGX 区域中秘密信息的可能。</p>
<h1 id="SGX的漏洞及防御"><a href="#SGX的漏洞及防御" class="headerlink" title="SGX的漏洞及防御"></a>SGX的漏洞及防御</h1><h2 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h2><p>侧信道攻击主要目标：攻击 Enclave 数据的机密性：</p>
<ul>
<li>攻击者来自non-enclave部分，包括应用程序和系统软件。</li>
<li>系统软件：包括OS，hypervisor，SMM(system management mode)，BIOS 等特权级软件。</li>
</ul>
<p>三个假设：</p>
<ul>
<li>侧信道攻击一般假设攻击者知道Enclave初始化时候的代码和数据，并且知道内存布局（虚拟地址、物理地址以及他们之间的映射关系）。</li>
<li>有些侧信道攻击假设攻击者知道Enclave的输入数据，并且可以反复触发Enclave，进行多次观察记录。</li>
<li>侧信道攻击还假设攻击者知道运行Enelave平台的硬件配置、特性和性能，比如：CPU、TLB(translation lookaside buffer)、Cache、DRAM、页表、中断以及异常等各种系统底层机制。</li>
</ul>
<h2 id="侧信道攻击面"><a href="#侧信道攻击面" class="headerlink" title="侧信道攻击面"></a>侧信道攻击面</h2><p>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/SGX-side-channel-attack-surface.png" alt="SGX侧信道攻击面"> </p>
<p>Enclave的运行过程中会用到： </p>
<ul>
<li><strong>CPU内部结构</strong>：比如pipeline，BPB(branch prediction buffer)等等．这些结构不能够直接访问，但是如果可以间接利用，仍然可能泄露enclave的控制流或数据流； </li>
<li><strong>TLB</strong>：TLB包括iTLB，dTLB和L2 TLB．如果Hyper-Threading打开，两个逻辑核共享一个物理核，这个时候会大大增加侧信道攻击的可能； </li>
<li><strong>Cache</strong>：Cache包括LI instruction Cache，LI data Cache，L2 Cache和L3 Cache(又叫LLC Cache)； </li>
<li><strong>DRAM</strong>：DRAM包括channels，DIMMs(dual inline memory module)，ranks，banks．每个 banks 又包括 rows，columns和row buffer； </li>
<li><strong>页表(page table)</strong>：页表可以通过权限控制来触发缺页异常，也可以通过页表的状态位来表明CPU的某些操作；</li>
</ul>
<p>为了进行切实灵活的攻击，攻击者需掌握 intel 的相关手册；</p>
<h2 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h2><p>侧信道攻击的主要手段：是通过攻击面获取数据，推导获得控制流和数据流信息，最终获取 enclave 的代码和数据的信息</p>
<h3 id="基于页表"><a href="#基于页表" class="headerlink" title="基于页表"></a>基于页表</h3><p>攻击基本原理：</p>
<ul>
<li>利用页表对enclave页面的访问控制权，设置Enclave页面为不可访问。这个时候任何访问都会触发缺页异常，从而能够区分Enclave访问了哪些页面。按照时间顺序把这些信息组合，就能够反推出Enclave的某些状态和保护的数据。</li>
</ul>
<p>典型攻击：</p>
<ul>
<li>controlled channel 攻击和 pigeonhole 攻击。</li>
</ul>
<p>缺点：</p>
<ul>
<li>精度只能达到页粒度，无法区分更细粒度的信息．但是在某些场景下，这类攻击已经能够获得大量有用信息</li>
</ul>
<p>变种攻击原理：</p>
<ul>
<li>利用页表的状态位；</li>
<li>页表项的位：<ul>
<li>访问控制：P，RW，US，XD；</li>
<li>标识状态：比如，D(dirty bit)和A(access bit)</li>
<li>如果 Abit 被设置，则表明该页表指向的页面已经被访问：</li>
<li>如果D bit被设置，则表明该页表指向的页面发生了写操作。</li>
</ul>
</li>
<li>通过监控观察这些状态位，攻击者就可以获取和controlled.channel／pigeonhole攻击类似的信息。</li>
</ul>
<p>相关研究：</p>
<ul>
<li>《Controlled-Channel attacks：Deterministic side channels for untrusted operating systems》</li>
<li>《Preventing page faults from telling your secrets》</li>
</ul>
<h3 id="基于TLB"><a href="#基于TLB" class="headerlink" title="基于TLB"></a>基于TLB</h3><ul>
<li>没有完全基于TLB的攻击，但是已经出现TLB作为辅助手段的侧信道攻击（混合）。</li>
<li>TLB的层次结构。目前，SkyLake的机器分为Ll和L2两层，不同层次出现TLB miss的时间代价不同； </li>
<li>TLB对代码和数据的区分。Ll区分代码(iTLB)和数据(dTLB)，两者直接有Cache coherence的保证．L2 不区分代码和数据。</li>
</ul>
<h3 id="基于cache"><a href="#基于cache" class="headerlink" title="基于cache"></a>基于cache</h3><p>在SGX的环境里面，大部分侧信道技术仍然适用，而且可以做得更好：</p>
<ul>
<li>在SGX环境里面仅依赖CPU，因此当操作系统，甚至是BIOS都是恶意的情况下，攻击者可以控制整个系统的资源。</li>
</ul>
<p>SGX易受Cache.timing攻击：</p>
<ul>
<li>一种基于Cache的 Prime&amp;Probe 算法，能够识别Cache行粒度上的enclave代码访问的内存位置，并在相同的Hyper—threading核心上运行enclave和攻击线程，使得攻击线程和enclave共享内存。通过这种方法，能够在不到10秒的时间获得加密程序的AES密钥。</li>
</ul>
<p>SGX能很好地防御利用 Flush+Reload 的Cache攻击：</p>
<ul>
<li>因为EPC页面一次只属于一个enclave，这就导致攻击者和enclave程序不能共享代码，也就使得Flush+Reload变得不可能。</li>
</ul>
<p>在攻击者能控制整个系统资源的情况下，可以有针对地调度资源，减少侧信道的噪音，增加侧信道的成功率。降低噪音的策略大体可以有以下几种：</p>
<ul>
<li><strong>核隔离(core Isolation)</strong>：这个方法的主要目标就是让enclave独自占有一个核(不允许其他程序运行在该核上面)； </li>
<li><strong>缓存隔离(cache Isolation)</strong>：尽量使用L1或者L2级别的Cache进行侧信道攻击．L3的Cache被所有的核共用，会引入不必要的噪音： </li>
<li><strong>不间断运行(uninterrupted execution)</strong>：也就是不触发或尽量少触发AEX(asynchronous enclave exit)，因为AEX和后续的ISR(interrupt service routines)都会使用Cache，从而引入不必要噪音。少触发AEX就是要使用中断绑定(interrupt affinity)和时钟频率；不触发AEX基本上就是让系统软件(比如os)屏蔽所有中断。</li>
</ul>
<p>除了降低噪音，攻击者还可以提高攻击的精度，大体策略有： </p>
<ul>
<li><strong>高精度时钟</strong>：可以采用APIC(advanced programmable interrupt controller)提供的高精度时钟和硬件 TSC(time stamp counter)； </li>
<li><strong>放大时间差异</strong>：比如，攻击者可以配置侧信道攻击代码所在的CPU以最高频率运行，而对enclave所在的CPU进行降频处理． </li>
</ul>
<p>可以进行细粒度的监控．最小粒度可以做到一个Cache line，即64个字节。可以获得更多的信息。</p>
<p>相关研究：</p>
<ul>
<li>《Last-Level cache side—channel aaacks are practical》</li>
<li>《FLUSH+RELoAD：A high resolution，low noise，L3 cache side—channel attack》</li>
<li>《ARMageddon：Cache attacks on mobile devices》</li>
<li>《Flush+Flush：A fast and stealthy cache attack》</li>
<li>《Cache template attacks：Automating attacks on inclusive last—level caches》</li>
</ul>
<h3 id="基于DRAM的攻击"><a href="#基于DRAM的攻击" class="headerlink" title="基于DRAM的攻击"></a>基于DRAM的攻击</h3><p>DRAM的结构：<br>&emsp;&emsp;<img src="http://img.thebetterkong.cn/blog/SGX-Technology-Analysis-and-Research/Typical-DRAM-structure.png" alt="典型DRAM结构">  </p>
<ul>
<li>row buffer：用来缓存最近访问过的一个row；</li>
<li>访问情况：在访问DRAM的时候，如果访问地址已经被缓存在row buffer当中(情况A)，就直接从 buffer里面读取；否则，需要把访问地址对应的整个row都加载到row buffer当中(情况B)．当然，如果row buffer 之前缓存了其他row的内容，还需要先换出row buffer的内容再加载新的row(情况C）。</li>
<li>A，B，C对应的3种情况，访问速度依次递减(情况A最快，情况C最慢)。 </li>
</ul>
<p>通过时间上的差异，攻击者就可以了解当前访问的内存地址是否在row buffer里面以及是否有被换出。   </p>
<p>不足：</p>
<ul>
<li>enclave使用的内存通常都在缓存里面，只有少部分需要从DRAM里面去取： </li>
<li>DRAM的精度不够。例如，一个页面(4KB)通常分布在4个DRAM row上面，这样，基于DRAM的侧信道攻击的精度就是1KB，仅比基于页表的侧信道攻击好一些，远远不及基于Cache的侧信道攻击的精度； </li>
<li>DRAM里面存在很难避免的噪音干扰。因为一个DRAM row被很多页面使用，同时，同一个bank不同 ，row的数据读取也会对时间测量造成干扰，使得误报时常发生。</li>
</ul>
<p>相关研究：</p>
<ul>
<li>《Malware guard extension：Using SGX to conceal cache attacks》用到了基于DRAM的侧信道信息。</li>
<li>《DRAMA：Exploiting DRAM addressing for cross-CPU attacks》介绍了更多基于DRAM的攻击细节，不过，该文献不是在SGX环境下的攻击。 </li>
</ul>
<h3 id="基于CPU内部结构"><a href="#基于CPU内部结构" class="headerlink" title="基于CPU内部结构"></a>基于CPU内部结构</h3><p>CPU内部有大量的结构是在 Enclave 和 non.Enclave 之间共用的。给侧信道攻击提供了大量的攻击面素材。   </p>
<p>相关研究：</p>
<ul>
<li>《Inferring fine-grained control flow inside SGX enclaves with branch shadowing》：<ul>
<li>提出使用<strong>BPB</strong>来实现侧信道攻击。</li>
<li><strong>原理</strong>：在 Enclave 和 non-Enclave 切换的时候，BPB里面存留的跳转预测记录并没有被清除。这样使得 non-Enclave 可以构造一个程序，测试这些跳转预测记录。如果预测成功，则执行时问较短；反之，如果预测失败，则执行时间较长。通过时间上的差异，攻击者就可以推测 Enclave 之前运行的跳转分支，进而获得 Enclave 运行的控制流图。通过控制流图，攻击者又可以进一步推测隐私数据，比如加密密钥等。</li>
<li><strong>强大之处</strong>：它几乎可以还原整个控制流。这样细粒度的信息使得该攻击可以泄露很多信息．该文献也进行了大量实验，充分展示了这个攻击的强大．实验表明，这个攻击可以泄露字符串信息、RSA私钥以及网络数据等等． </li>
</ul>
</li>
</ul>
<p>SGX可以避免这类侧信道攻击：</p>
<ul>
<li>在Enclave到non-Enclave的切换过程中，CPU清除这些共用的内部结构体。这样，non-Enclave就不会得到任何残留的记录。</li>
<li>注意细节：比如清除的时间也必须是稳定不变的。如果Enclave运行的差异会导致清除操作的时间差异，攻击者很可能据此推导出Enclave的某些运行状态。</li>
</ul>
<h3 id="混合侧信道攻击"><a href="#混合侧信道攻击" class="headerlink" title="混合侧信道攻击"></a>混合侧信道攻击</h3><p>典型的做法： </p>
<ul>
<li><strong>TLB和页表混合攻击</strong>。比如：TLB miss的时候会加载页表，这个时候CPU会设置页表的Access bit。<ul>
<li>《Leaky cauldron on the dark land： Understanding memory side—channel hazards in SGX》：在Hyper-Threading的情况下触发大量的TLB miss，再通过观察页表的A bit进行侧信道攻击； </li>
</ul>
</li>
<li><strong>Cache和DRAM混合攻击</strong>。基于DRAM的攻击只能精确到row（一个row通常8KB）的粒度。<ul>
<li>为了增强这类攻击的效果，《Leaky cauldron on the dark land： Understanding memory side—channel hazards in SGX》：提出了Cache-DRAM攻击来增加空间精度，把精度提高到了一个Cache line(64B)。</li>
</ul>
</li>
</ul>
<p>3个攻击面(i…e TLB、页表和Cache) 的混合：《Prefetch side—channel attacks：Bypassing SMAP and kernel ASLR》</p>
<h2 id="SGX侧信道防御"><a href="#SGX侧信道防御" class="headerlink" title="SGX侧信道防御"></a>SGX侧信道防御</h2><p>源码层次解决方案：</p>
<ul>
<li>主要思想：通过修改源码，编写出能够防御侧信道的代码实现。</li>
<li>核心思想：隐藏控制流和数据流． </li>
<li>运用：<ul>
<li>密码算法：<ul>
<li>利用exponent blindingt来增强RSA算法，</li>
<li>利用bit slicing增强DES和AES算法</li>
</ul>
</li>
<li>机器学习：<ul>
<li>blivious ML修改了机器学习的算法，使用oblivious assignments and comparisons来隐藏控制流，使用oblivious array access(即：k-anonymity)来隐藏数据流．</li>
</ul>
</li>
<li>《Raccoon：Closing digital side·channels through obfuscated execution》：使用oblivious store隐藏if-else控制流，使用ORAM(oblivious random access memory)来隐藏数据流，从而抵御侧信道攻击</li>
</ul>
</li>
<li>问题：这些技术还很难在一个通用的计算环境下实现，比如loop tripcount，longjump以及break等问题． </li>
</ul>
<p>系统层次解决方案：</p>
<ul>
<li>主要是利用一些系统特性来防御或检测SGX侧信道攻击。</li>
<li>思路：<ul>
<li>随机化技术(randomization)：<ul>
<li>随机化技术可以应用在控制流和数据流上面，这将大大增加侧信道攻击的代价，防御效果与随机化粒度以及随机化频率有关； </li>
</ul>
</li>
<li>检测可疑异常和中断：<ul>
<li>《T—SGX：Eradicating controlled—channel attacks against enclave programs》利用TSX技术来检测中断和缺页异常，从而抵御最原始的controlled-channel攻击。但是现在已经出现不需要触发AEX的侧信道攻击； </li>
</ul>
</li>
<li>检测时间异常：<ul>
<li>目前，《Detecting privileged side—channel attacks in shielded execution with Deja Vu》：Deja Vu系统也使用了TSX技术来保护Enclave自己的时钟。如果攻击者中断或减缓Enclave的运行，Enclave就可以通过自己的时钟检测出时间上的异常。目前，绝大多数侧信道攻击都会引起Enclave的性能显著下降。因此，检测时间异常还是一个比较有效的方案： </li>
</ul>
</li>
<li>Cache隔离：<ul>
<li>目前，Intel推出了CAT技术，允许对Cache进行粗粒度的隔离。这个技术已经被使用在云计算平台上面防御侧信道攻击。但是还没有看到在SGX环境里面的应用。把CAT应用到SGX的一个很大的障碍是Enclave在用户空间无法有效地检测或验证CAT的配置。</li>
<li>《CATalyst：Debating last-level cache side channel attacks in cloud computing》</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>硬件层次解决方案：</p>
<ul>
<li>硬件层次的解决方案还处于探索阶段。</li>
<li>加入侧信道防御，将会显著增加硬件复杂度，影响功耗和性能。这也可能是Intel在最初推出SGX的时候没有加入侧信道防御的一个原因。</li>
<li>硬件解决方案可能有以下两种：<ul>
<li>硬件分割(partition)：类似于ARM里面的TrustZone，有自己的Cache，memory等一系列硬件资源，物理上与non-enclave分离；</li>
<li>硬件隔离(isolation)：类似于Intel CAT技术，可以单独为每一个enclave提供一个动态隔离出的Cache。 当enclave销毁的时候，隔离出的Cache可以被收回。这里一个很重要的要求：enclave必须可以验证这个功能的有效性。</li>
</ul>
</li>
<li>Sanctum已经做了一些尝试，但是还不够彻底，还会遭受攻击。<ul>
<li>《Sanctum：Minimal hardware extensions for strong software isolation》</li>
<li>《Software grand exposure：SGX cache attacks arepractical》</li>
</ul>
</li>
</ul>
<h2 id="SGX多线程同步漏洞"><a href="#SGX多线程同步漏洞" class="headerlink" title="SGX多线程同步漏洞"></a>SGX多线程同步漏洞</h2><p>《AsyncShock：Exploiting synchronisation bugs in Intel SGX enclaves》：</p>
<ul>
<li>展示了在使用SGX后以往被视为无害的同步漏洞可能会变为严重的安全漏洞。通过在enclave代码中利用UAF(use．after-free)和TOCTTOU(time．of-check．to．time．of-use)漏洞，一个攻击者可以劫持它的控制流或者绕过访问控制。</li>
<li>提出AsyncShock，一个利用运行于SGX的多线程代码的同步漏洞的工具。AsyncShock只能通过操作用于执行enclave代码的线程调度来达到这一的目标．它允许一个攻击者通过在enclave页强制分割错误来中断线程。</li>
</ul>
<h1 id="SGX在云安全中的应用进展"><a href="#SGX在云安全中的应用进展" class="headerlink" title="SGX在云安全中的应用进展"></a>SGX在云安全中的应用进展</h1><p>（这里是对当前的一些研究进行概述总结，想进一步了解可以再去详细阅读列举的论文）</p>
<h2 id="基于SGX构建云端应用安全隔离执行环境"><a href="#基于SGX构建云端应用安全隔离执行环境" class="headerlink" title="基于SGX构建云端应用安全隔离执行环境"></a>基于SGX构建云端应用安全隔离执行环境</h2><p>云环境采用传统分层安全模型来保护特权程序免受不可信用户程序的攻击，但却无法保证其不被特权软件访问和篡改。于是云环境下的用户只能被动地相信云服务供应商的硬件和软件的可靠性，以及管理人员不会去窃取自己的私密数据。   </p>
<p>目前，保护云计算环境安全的三种方法：</p>
<ol>
<li>基于特定的硬件保护关键的秘密信息：如密钥的安全。该方法难以保证整个应用程序的安全，且密钥通常会以明文的形式在不可信节点上使用；</li>
<li>基于可信的VMM(virtual machine manager)来保护应用程序：该方法需要整个VMM可信，并且无法防止特权用户窃取用户隐私数据；</li>
<li>基于密文数据的计算：如密文检索，但该方法在性能方面存在局限性． </li>
</ol>
<p>《Shielding applications from all untrusted cloud with haven》利用SGX的方案：</p>
<ul>
<li>方案基于<strong>Drawbridge沙箱机制</strong>，为用户程序的运行提供了一个<strong>Picoprocess容器</strong>，从而保证运行在里面的用户程序无法对外界系统造成破坏；再在容器中创建一个Enclave。 </li>
<li>将<strong>用户程序、System Library和Shield module</strong>放进Enclave中，以防止这些数据和代码被外界的特权软件或恶意程序访问和篡改。<ul>
<li>System Library：通过Downcalls和Upcalls的方式与Drawbridge主机进行交互，用来完成用户程序需要的系统功能。（由于操作系统自身可能是不可信的，因此方案中设计了一个SystemLibrary库，用来将操作系统的系统调用进行封装，并在应用程序运行时将其一起放到enclave中供应用程序使用，System Library自身实现了全部的系统调用 ）</li>
<li>Shield module：为了保护用户程序和System Library的代码和数据不被enclave外的恶意软件攻击。（该模块通过仔细地检查参数和函数调用的返回值来进行保护。Shield module自身包含了一些典型的内核函数： 内存管理、进程调度、文件系统操作等）</li>
</ul>
</li>
</ul>
<h2 id="基于SGX构建安全容器"><a href="#基于SGX构建安全容器" class="headerlink" title="基于SGX构建安全容器"></a>基于SGX构建安全容器</h2><p>现有的容器隔离机制专注于保护其免受不可信容器的访问，然而租户需要保护应用程序数据的机密性和完整性，以防止未经授权的其他容器，或更高级的系统软件(如操作系统内核和管理程序等)访问。这便需要有硬件机制能够保护用户级软件免受特权级系统软件的影响。   </p>
<p>用SGX来构建安全容器面临着两个挑战：</p>
<ul>
<li>尽量减少enclave中可信计算基的大小；</li>
<li>尽量减少性能开销．</li>
</ul>
<p>《SCONE：Secure Linux containers with Intel SGX》提出SCONE：</p>
<ul>
<li>一种用于Docker的安全容器环境，其利用Inter CPU提供的SGX机制来保护Docker容器内进程免受外部攻击。</li>
<li>SCONE的设计主要实现了： <ol>
<li>一个较小的可信计算基； </li>
<li>更低的性能消耗：SCONE提供了一个安全C语言静态库接口用于透明的加解密I／O数据；降低了因线程同步和系统调用导致的高性能消耗；支持用户级线程和异步系统调用。</li>
</ol>
</li>
<li>实验评估表明：SCONE能够通过SGX保护未被修改的应用程序。并实现0．6～1．2倍的吞吐量． </li>
</ul>
<h2 id="基于SGX构建云端大数据安全可信计算环境"><a href="#基于SGX构建云端大数据安全可信计算环境" class="headerlink" title="基于SGX构建云端大数据安全可信计算环境"></a>基于SGX构建云端大数据安全可信计算环境</h2><ul>
<li>目前大数据处理最成功的计算技术：MapReduce</li>
<li>大数据计算通常会租用公共计算设施，如：公有云</li>
</ul>
<p>目前的大数据安全方法：</p>
<ul>
<li>目前，对于大数据安全通常采用的是基于密码的保护机制，如全同态加密机制、安全多方计算或零知识证明的机制，然而这些方式目前都因受到性能的制约而没有大规模实用。</li>
<li>另外一些方法，如数据库加密机制，如：CtrptDB和Cipherbase，只能对数据库进行保护，却不能保护计算中的代码和数据。</li>
</ul>
<p>《VC3: Trustworthy Data Analytics in the Cloud using SGX》基于SGX技术提出方案，其中关键问题：</p>
<ul>
<li>利用SGX构建最小可信计算基：<ul>
<li>为增加方案的实用性，本方法需要运行在未修改过的Hadoop上，因此系统的可信计算基不包括Hadoop，OS 和hypervisor．用户编写map和reduce代码，并且将它们进行加密，之后上传到云端．在每一个工作节点上，云操作系统将这些代码加载进一个隔离的enclave中之后，enclave内的代码会执行密钥交换协议，解密出map和reduce 函数，从而运行分布式计算处理用户数据． </li>
</ul>
</li>
<li>保证整个分布式计算的完整性：<ul>
<li>SGX只能在本地计算节点上为程序和数据构建安全执行环境，如何在分布式大数据处理过程中确保代码和数据的安全可信是需要解决的关键问题．本方案提出了一个<strong>高效的分布式作业执行协议</strong>来保证MapReduce作业的正确性和机密性．每个计算节点为正在运行的程序产生一个安全的摘要信息，之后再将这些摘要进行收集整合，通过验证最后结果中的最终摘要信息，用户可以检查云服务提供商是否干扰了计算的执行． </li>
</ul>
</li>
<li>保护用户程序免受非法内存访问攻击： <ul>
<li>SGX技术允许用户程序访问系统的全部地址空间，因此，不安全的内存访问可能会泄露数据或者带来其他的安全威胁．如何限制enclave内部程序的内存访问，减轻由于应用程序本身的缺陷而导致其遭受非法内存访问攻击，是需要解决的一个问题．该项目<strong>基于GCC开发了安全增强的编译器</strong>，在代码编译过程中增加额外参数，将其地址空间限定在有效范围内，从而有效地将需要保证完整性的代码放到一个独立的区域中，并且对该区域中变量的读写访问都将进行检查．只有通过检查，才能真正访问到用户数据． </li>
</ul>
</li>
</ul>
<h2 id="基于SGX技术实现NFV的状态保护"><a href="#基于SGX技术实现NFV的状态保护" class="headerlink" title="基于SGX技术实现NFV的状态保护"></a>基于SGX技术实现NFV的状态保护</h2><ul>
<li><strong>网络功能虚拟化(network function virtualization，简称NFV)</strong>：通过软硬件解耦及功能抽象，使网络设备功能不再依赖于专用硬件，资源可以充分灵活共享，实现新业务的快速开发和部署，并基于实际业务需求进行自动部署、弹性伸缩、故障隔离和自愈等。</li>
<li><strong>NFV网元</strong>是有状态的，例如，内容分发网络从远程服务器缓存浏览器内容并且把它们发送至客户端．类似地，入侵检测系统和入侵防御系统都有逐流或者多流(共享)状态来应对入侵．在现今NFV的部署方式中，攻击者可以通过访问共享的物理资源来窃取网络应用的状态信息。</li>
<li>《S-NFV：Securing NFV states by using SGX》提出一种保护方案(S．NFV)，即是利用SGX对NFV产生的状态进行安全隔离保护．但该方案较简单，仅在模拟环境 OpenSGX中验证了保护Snort[26】应用程序流状态安全的方案． </li>
</ul>
<h1 id="Intel-SGX的优势与不足"><a href="#Intel-SGX的优势与不足" class="headerlink" title="Intel SGX的优势与不足"></a>Intel SGX的优势与不足</h1><p>主要有3大优势：</p>
<ul>
<li>通过内存加密技术保护程序运行态的安全，使得通过内存泄漏攻击获取关键信息的难度增大；</li>
<li>将系统的可信计算基缩小到CPU，相比以往将整个操作系统或特权软件(如hypervisor等)视为可信计算基，可以避免更多的系统攻击带来的危害；</li>
<li>支持虚拟化技术、容器技术，可用性更强；</li>
</ul>
<p>不足之处：</p>
<ul>
<li>由于enclave处于用户态，其自身无法执行系统调用，需要与不可信区域进行交互(运行库的支持有限，接口的安全性)。在执行系统调用前需要退出enclave，执行完成后将结果返回到enclave中，增大了安全风险和系统开销；</li>
<li>Enclave中的数据和处理过程，如果依赖于外部数据，则存在一定的安全隐患。例如：通过一些不合法输入，可以发起对可信区的缓冲区溢出攻击，这些攻击可能会改变可信区中程序的执行流程、获取可信区中的敏感信息；</li>
<li>SGX本身无法抵御侧信道攻击； </li>
<li>SGX提供的enclave可使用内存太小，当程序数量和规模增大时，需要换进换出页面．为了保证安全性， 需要对页面进行完整性和机密性保障，导致系统开销大； </li>
<li>使用SGX提供的enclave时需要对程序进行改造，当程序规模大时，带来的编程成本高；</li>
</ul>
<h1 id="SGX研究和应用需求展望："><a href="#SGX研究和应用需求展望：" class="headerlink" title="SGX研究和应用需求展望："></a>SGX研究和应用需求展望：</h1><ul>
<li>可信计算与SGX技术的结合</li>
<li>利用SGX技术构建可信云安全环境</li>
<li>利用SGX技术构建虚拟网元可信执行环境</li>
<li>利用SGX技术构建面向云的可信外包计算<ul>
<li>传统的密文检索方法目前只能在密文数据上实现简单的计算，性能制约</li>
</ul>
</li>
<li>SGX与ORAM（不经意随机存储，效率低）的结合</li>
</ul>
]]></content>
      <categories>
        <category>文献阅读笔记</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>SGX</tag>
      </tags>
  </entry>
  <entry>
    <title>FPGA-DesignFlow</title>
    <url>/2020/03/22/FPGA-technology/FPGA-DesignFlow/</url>
    <content><![CDATA[<p>从总体上介绍 FPGA 设计的整体流程，大致了解。</p>
<a id="more"></a> 
<p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/DesignFlow.png" alt="DesignFlow"></p>
<ul>
<li>ASDB: A Simulation Database</li>
<li>VCD: a file containing simulation waveforms</li>
<li>SDF: Simulation Delay File</li>
</ul>
<h1 id="FPGA-编程过程"><a href="#FPGA-编程过程" class="headerlink" title="FPGA 编程过程"></a>FPGA 编程过程</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/ProgrammingProcess.png" alt="ProgrammingProcess"></p>
<ul>
<li>FPGA的设计具有层次结构，它使用HDL（硬件描述语言）进行不同层次的仿真；</li>
<li>在布局布线后进行时序仿真；</li>
<li>可使用图形用户界面（GUI）进行仿真，或者使用脚本自动进行仿真；</li>
<li>FPGA设计应始终包括一个testbench测试平台，该testbench可提供包括时钟和数据在内的输入，并接受FPGA的输出—-这就是常说的FPGA pins（引脚）；</li>
<li>FPGA中的HDL代码必须映射到FPGA中的真实逻辑门，因此，它必须是可综合的；</li>
<li>当编写用于仿真的测试平台时，经常使用不可综合的代码结构会使测试平台更好，并能更轻松的实现：<ul>
<li>最基本的不可综合代码是延迟语句：FPGA没有时间概念，因此不可能告诉FPGA等待10纳秒；</li>
</ul>
</li>
</ul>
<h1 id="FPGA-编程工具套件"><a href="#FPGA-编程工具套件" class="headerlink" title="FPGA 编程工具套件"></a>FPGA 编程工具套件</h1><p>通常使用类似于专用集成电路（ASIC）的硬件描述语言（HDL）来指定 FPGA 配置。    </p>
<p>集成开发环境（IDE）可以执行设计输入，综合，布局，布线和比特流生成/下载操作。   </p>
<p>例如：</p>
<ol>
<li>集成开发环境（IDE）：vivado</li>
<li>HDL仿真软件：ModelSim<ul>
<li>ModelSim 是 Mentor Graphics 的多语言 HDL 仿真环境，用于仿真硬件描述语言（例如VHDL，Verilog 和 SystemC），并包括内置的 C 调试器；</li>
<li>ModelSim 可以单独使用，也可以与 Intel Quartus Prime，Xilinx ISE或Xilinx Vivado 结合使用；</li>
</ul>
</li>
</ol>
<h1 id="FPGA-CAD-Flow"><a href="#FPGA-CAD-Flow" class="headerlink" title="FPGA CAD Flow"></a>FPGA CAD Flow</h1><p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/FPGACADFlow.png" alt="FPGACADFlow"></p>
<ul>
<li>CAD：计算机辅助设计；</li>
<li>商业FPGA CAD系统，例如：Quartus（由Intel / Altera 提供），ISE / Vivado（由 Xilinx 提供）</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/FPGACADFlowProcess.png" alt="FPGACADFlowProcess"></p>
<h2 id="HDL-设计与仿真"><a href="#HDL-设计与仿真" class="headerlink" title="HDL 设计与仿真"></a>HDL 设计与仿真</h2><p>在电子产品中，硬件描述语言（HDL）是一种专用的计算机语言，用于描述电子电路（最常见的是数字逻辑电路）的结构和行为。 硬件描述语言可以对电子电路进行精确的形式化描述，从而可以对电子电路进行自动分析和仿真。   </p>
<p>主要做法：</p>
<ul>
<li>用 HDL（如：verilog）对电路功能进行描述设计，然后在 HDL 仿真环境（如：ModelSim）里仿真，验证自己的设计；<br><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/HDLDesignSimulation.png" alt="HDLDesignSimulation"></li>
</ul>
<h2 id="逻辑综合"><a href="#逻辑综合" class="headerlink" title="逻辑综合"></a>逻辑综合</h2><p>该过程可以对通常在寄存器传输级别（RTL）处，所需电路行为的抽象形式进行优化，并根据逻辑（通常通过计算机程序：综合工具）将其转换为设计实现；<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/LogicSynthesis.png" alt="LogicSynthesis"></p>
<ul>
<li>该过程通常包括 HDL（例如 VHDL 和 Verilog）的综合；</li>
</ul>
<h2 id="工艺映射"><a href="#工艺映射" class="headerlink" title="工艺映射"></a>工艺映射</h2><p>将通用布尔逻辑网络（从设计规范中通过较早的转换获得）转换为功能等效的 K-LUT 网络，该网络可以由目标 FPGA 器件实现；<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/TechnologyMapping.png" alt="TechnologyMapping"></p>
<ul>
<li>目的：减少面积，延迟或其组合；</li>
</ul>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>将基本逻辑元素（BLE-basic logic elements）LUT 转换为群集逻辑块（CLB-cluster<br>logic blocks）；(装盒)<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/Packing.png" alt="Packing"></p>
<p>它是 FPGA 分层设计的关键过程，它会对电路面积、时序和可布线性产生影响，因此就需要我们尽可能的去寻找最优的 packing 策略；<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/OptimizedPackingAlgorithms.png" alt="OptimizedPackingAlgorithms"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>是一种算法过程，可以为用户 CLB，BRAM，DSP 等在 FPGA 中定位到可能的位置；（放置）<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/Placement.png" alt="Placement"></p>
<p>目的:为设计中的所有块找到最佳的位置布置，以便可以实现最佳性能;</p>
<ul>
<li>一个好的 placement 应该是从<mark>区域、可布线性以及电气特性</mark>这三个方面来综合考虑，达到<mark>低延迟、低功耗、小面积、高的可布线性以及高的资源利用率</mark>；</li>
</ul>
<h2 id="布线"><a href="#布线" class="headerlink" title="布线"></a>布线</h2><p>也一种算法过程，通过配置 switch matrix 来连线，可将 FPGA 中的路由资源分配给所有用户网络；<br>  <img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/Routing.png" alt="Routing"></p>
<p>目的：在一定的时序约束条件下为设计中的所有互连找到最佳的通道安排   </p>
<p>路由资源：通用路由通道、Switch Matrixes   </p>
<p>FPGA 路由问题可以简化为“有向图上的路径查找问题”，引入 <strong>Pathfinder 算法</strong>：</p>
<ul>
<li>引入协商拥塞</li>
<li>在每次路由迭代期间，使用最短路径路由网络<ul>
<li>允许过度使用（拥塞）路由资源</li>
</ul>
</li>
<li>如果存在拥塞（非法路由）<ul>
<li>根据过度使用的数量更新拥塞资源的成本</li>
<li>整理所有路由并重新路由所有网络</li>
</ul>
</li>
<li>示例：<br><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/Pathfinder.png" alt="Pathfinder"></li>
</ul>
<p><mark>时序驱动的路由</mark>：最大限度地减少关键路径的延迟，同时保持其余电路的可路由性；   </p>
<p><mark>关键路径</mark>：在同步电路中，组合逻辑中的最长路径决定了电路的性能；</p>
<h2 id="时序分析"><a href="#时序分析" class="headerlink" title="时序分析"></a>时序分析</h2><p><mark>时序收敛-Timing closure</mark>：修改 FPGA 或 VLSI 设计以满足其时序要求的过程   </p>
<p>使用特定的时序模型来计算和检查实现的电路是否满足用户分配的时序约束：Setup/Hold Time Analysis、Clock to Output Time Analysis、Synchronous Performance Analysis(Maximum Clock Speed)   </p>
<h3 id="tSU、tH、tCO"><a href="#tSU、tH、tCO" class="headerlink" title="tSU、tH、tCO"></a>tSU、tH、tCO</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/Time.png" alt="Time"></p>
<ol>
<li>Setup Time（tSU）：在时钟沿之前保持数据稳定所需的时间</li>
<li>Hold Time（tH）：时钟沿之后保持数据稳定所需的时间</li>
<li>Clock To Output（tCO）：时钟沿后更改输出所需的时间</li>
</ol>
<h3 id="Maximum-Clock-Frequency"><a href="#Maximum-Clock-Frequency" class="headerlink" title="Maximum Clock Frequency"></a>Maximum Clock Frequency</h3><p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/MaximumClockFrequency.png" alt="MaximumClockFrequency"> </p>
<p><mark>Critical Path Delay</mark>: Tmin = tco + tsu + Longest Logic &amp; Routing Delay<br>降低关键路径的延迟，提高时钟频率，是优化时序的常用手段；</p>
<h2 id="Bit-Stream-Generation"><a href="#Bit-Stream-Generation" class="headerlink" title="Bit Stream Generation"></a>Bit Stream Generation</h2><p>SRAM配置过程：</p>
<ul>
<li>访问所有 CLB，BRAM，DSP 模块，PLL，互连网络等中的 CRAM（配置 RAM）单元；</li>
<li>为网络启用布线路径段并分配查找表值；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/SRAMConfiguration.png" alt="SRAMConfiguration"></p>
<p>SRAM 配置系统和码流下载：</p>
<ul>
<li>阅读网表，布局和布线结果文件;</li>
<li>根据目标设备规范生成比特流文件;</li>
<li>可以通过JTAG扫描链下载比特流，由此实现用户逻辑；</li>
</ul>
<p>片上配置数据流：</p>
<ul>
<li>串行数据被加载到一系列寄存器中</li>
<li>并行数据被一一写入一行 CRAM<br><img src="http://img.thebetterkong.cn/blog/FPGA-DesignFlow/On-chipConfigurationData.png" alt="On-chipConfigurationData"></li>
</ul>
]]></content>
      <categories>
        <category>可编程逻辑系统设计与 FPGA 技术</category>
      </categories>
      <tags>
        <tag>国科大研究生课程笔记</tag>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学笔记</title>
    <url>/2020/04/18/Math-Basic-Notes/Combinatorial-Mathematics/</url>
    <content><![CDATA[<p>本人本科期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p>
<p><strong><center><mark>多图警告！</mark></center></strong></p>
<a id="more"></a> 
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="https://img-blog.csdnimg.cn/20200418214637641.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">         </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214657106.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214737863.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">           </p>
<h1 id="鸽巢原理和Ramsey定理"><a href="#鸽巢原理和Ramsey定理" class="headerlink" title="鸽巢原理和Ramsey定理"></a>鸽巢原理和Ramsey定理</h1><p><img src="https://img-blog.csdnimg.cn/20200418214802665.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">          </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214817446.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p>
<h1 id="基本计数方法及应用"><a href="#基本计数方法及应用" class="headerlink" title="基本计数方法及应用"></a>基本计数方法及应用</h1><p><img src="https://img-blog.csdnimg.cn/20200418214844586.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214855391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214904651.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214912269.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214922510.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214940289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214951654.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214958321.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">           </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821500551.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215011734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215019151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="11">                 </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215026429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="12">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215039811.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="13">            </p>
<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><p><img src="https://img-blog.csdnimg.cn/20200418215100774.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215106961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215115206.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">              </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215125786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">               </p>
<h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p><img src="https://img-blog.csdnimg.cn/20200418215149542.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">              </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215156353.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">               </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215204785.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">                 </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215213149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">                </p>
<h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p><img src="https://img-blog.csdnimg.cn/20200418215231769.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215242201.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">             </p>
<h1 id="Polya定理"><a href="#Polya定理" class="headerlink" title="Polya定理"></a>Polya定理</h1><p><img src="https://img-blog.csdnimg.cn/20200418215258585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215306162.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">         </p>
<p><img src="https://img-blog.csdnimg.cn/20200418215314153.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">               </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821532359.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">                    </p>
]]></content>
      <categories>
        <category>数学基础笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>《云环境中跨虚拟机的Cache侧信道攻击技术研究》阅读笔记</title>
    <url>/2020/03/07/Literature-reading-notes/Research-CacheSideChannelAttack-Across-VM-inCloudEnvironment/</url>
    <content><![CDATA[<p>本文是一篇综述性质的文章，主要介绍了cache侧信道和它所带来的信息泄露问题（秘钥），介绍了跨虚拟机的cache侧信道攻击，并与传统cache侧信道攻击进行对比，给出了跨虚拟机访问驱动cache侧信道攻击的通用模型。介绍了虚拟机同驻的相关问题，分析其检测的各种方法和评价原则。最后，也重点介绍了当前用于跨虚拟机cache侧信道信息探测的主要方法。</p>
<a id="more"></a> 
<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><strong>虚拟机同驻</strong>：云计算环境中，不同租户的虚拟机可能运行于同一台物理主机之上。同驻的虚拟机之间共享物理主机的计算资源，并依赖于虚拟机监控器进行系统资源的分配与调度</li>
<li><strong>跨虚拟机的侧信道攻击</strong>：恶意租户通过探测共享资源的状态信息，建立泄漏模型，便可绕过虚拟化提供的隔离性，窃取其它同驻虚拟机的隐私信息</li>
<li><strong>侧信道信息(Side—Channel Information，SCI)</strong>：通过非直接传输途径泄露出来的物理状态信息被研究人员称为侧信道信息    </li>
<li><strong>侧信道攻击</strong>：攻击者通过测量采集密码算法执行期间产生的侧信道信息，再结合密码算法的具体实现，来进行密钥的分析与破解</li>
</ul>
<h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>云计算通过网络以按需、易扩展的方式为用户提供各种虚拟的IT资源和应用服务，支持用户在任意位置、使用多种终端进行访问。   </p>
<p>然而，在已经实现的云计算服务中，安全和隐私问题已经成为阻碍云计算推广和普及的主要因素之一。    </p>
<p>基于虚拟化环境提供的逻辑隔离，采用访问控制、入侵检测等方法可以增强云计算环境的安全性；但是，隐私泄露问题依然存在，因为底层共享的硬件资源容易引发侧信道攻击(Side—Channel—Attacks，SCA)的威胁。   </p>
<p>同驻虚拟机之间对于CPU、Cache及内存等底层物理资源的共享和争用则天然地为Cache侧信道信息泄露提供了泄露通道。跨虚拟机Cache侧信道攻击已成为云计算环境中威胁用户隐私安全的重要挑战。   </p>
<p>云计算包含3种不同的服务类型：</p>
<ul>
<li>基础设施即服务(Infrastructure as a Service，IaaS)</li>
<li>平台即服务(Platform as a Service，PaaS)</li>
<li>软件即服务 (Software as a Service，SaaS)</li>
</ul>
<p>目前，云环境中有关跨虚拟机Cache侧信道攻击的研究工作，基本都是围绕IaaS云平台展开。因此，将Cache侧信道攻击扩展到IaaS层之上的PaaS或SaaS，甚至轻量级虚拟化方案Docker中，也具有重要意义。</p>
<h2 id="现有举措"><a href="#现有举措" class="headerlink" title="现有举措"></a>现有举措</h2><ul>
<li>2010年，Intel公司发布了第1款支持AES—NI指令集的处理器，用于防御针对AES的Cache侧信道攻击．<ul>
<li>AES—NI指令集在处理器芯片的定制硬件上执行AES加密／解密操作，由于不需要在内存中建立查找表，其指令在运行时都不会访问内存，因此，可有效防御针对AES的Cache侧信道攻击． </li>
</ul>
</li>
<li>公有云平台Amazon EC2提供的Virtual Private Cloud (VPC)服务允许租户额外付费的选择“专用硬件模式”创建虚拟机实例，并承诺租户可以独占使用某个物理平台上的硬件资源</li>
<li>SecludlT公司的云基础设施自动检测软件Elastic Detector则宣称可以检测发现云环境中访问驱动的侧信道攻击。</li>
</ul>
<h1 id="Cache侧信道信息泄露分析"><a href="#Cache侧信道信息泄露分析" class="headerlink" title="Cache侧信道信息泄露分析"></a>Cache侧信道信息泄露分析</h1><p>Cache 是攻击者构建侧信道时最常用的一类共享资源，因为：</p>
<ul>
<li>CPU Cache 是最常用的共享资源，只要程序运行，就离不开 CPU ，也就离不开 CPU Cache ；</li>
<li>Cache 在系统中位于较低的层级，且缺乏有效的访问控制机制，利用其构建侧信道可<br>以绕过许多高层的隔离机制，比如虚拟化环境提供的逻辑隔离等；</li>
<li>Cache 拥有一个系统上数据访问和计算操作最细粒度且详细的状态信息，可以为攻击者提供丰富的信息；</li>
<li>不同的 Cache 行为(命中或失效)具有不同的时间特征，可以通过采集 Cache 时间特征得到 Cache 侧信道信息，而 Cache 时间特征的采集方法比较简单；</li>
<li>Cache 的操作和刷新频率较高，可以提供细粒度的观察结果；</li>
</ul>
<h2 id="Cache侧信道信息"><a href="#Cache侧信道信息" class="headerlink" title="Cache侧信道信息"></a>Cache侧信道信息</h2><p>Cache 侧信道信息：是指系统中由 Cache 行为产生的物理状态信息，包括访问时间、功率、电磁辐射等。</p>
<p>攻击运用原理：</p>
<ul>
<li>通常，CPU访问内存中的数据或指令时，根据涉及到的目标数据或指令当前是否位于Cache中，将导致不同的Cache行为，包括Cache命中和Cache失效。</li>
<li>而不同Cache行为产生的Cache侧信道信息是可区分的（访问时间、功耗不同等）。</li>
<li>因此，如果能够观察或测量到算法执行期问产生的Cache侧信道信息，攻击者就可以推断对应的Cache行为（程序执行期间的内存访问信息，包括访问了哪些内存位置的数据，使用了哪些内存页面，或者执行了哪些指令序列等），并进一步得到内存访问的一些关键信息。</li>
</ul>
<p>能获取的信息类型：</p>
<ol>
<li><p>内存访问的部分地址信息：</p>
<ul>
<li>Cache是物理标记的，数据在Cache中的位置由其物理内存地址决定。</li>
<li>因此，Cache可能泄露内存访问的部分地址信息。</li>
<li>例如：目标程序执行期间，攻击者根据访问指定的Cache组产生的侧信道信息，可以推断目标程序是否使用了该Cache组；如果使用了，再根据Cache与内存地址之间的映射关系，就可以得到目标程序执行期间内存访问的部分地址信息。</li>
</ul>
</li>
<li><p>历史内存访问的数据信息或指令信息：</p>
<ul>
<li>CPU访问指定的数据或指令时，根据其当前是否被缓存于Cache中，将产生不同的侧信道信息：<ul>
<li>具体地，当访问一个数据块或指令块时，如果其已经被缓存于Cache中，将发生Cache命中；那么，相对Cache失效来说，将产生较短的访问时间．因此，一个数据块或指令块的访问时问将泄露其是否已被缓存于Cache中这一信息；</li>
</ul>
</li>
<li>进一步地，这将泄露历史内存访问的数据信息或指令信息：<ul>
<li>例如，目标程序执行期间，攻击者访问指定的数据块或指令块，根据访问时间就可以判断它们是否已被缓存，进一步地可以推断目标程序执行期间是否访问过这些数据或指令。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Cache侧信道信息与密钥之间的相关性"><a href="#Cache侧信道信息与密钥之间的相关性" class="headerlink" title="Cache侧信道信息与密钥之间的相关性"></a>Cache侧信道信息与密钥之间的相关性</h2><p>研究理论基础：算法执行具有数据依赖性    </p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Algorithm-exe-data-dependent.png" alt="算法执行具有数据依赖性"></li>
<li>(a)输入依赖的指令执行:如果A和B的运行时间存在可观察的差异，攻击者就可以根据采集到的时间信息判断执行了哪一分支，进而确定z的取值。</li>
<li>(b)输入依赖的数据访问:如果攻击者能够确认用户访问了m 还是11，就可以确定Y的取值。</li>
<li>(c)输入依赖的执行时间:由于循环次数由输入参数决定，而循环次数又直接影响算法的执行时间，因此，算法执行时间将泄露输入参数z的取值信息。</li>
</ul>
<p>密码算法的执行通常具有密钥依赖特性，主要包括：</p>
<ul>
<li>密钥依赖的数据访问模式</li>
<li>密钥依赖的指令执行序列</li>
</ul>
<p>因此，攻击者可以利用密码算法执行中产生的侧信道信息推断其执行特征，再根据执行特征以及具体的依赖关系来反向推测密码算法使用的密钥。  </p>
<p>举例：</p>
<ul>
<li>现代分组密码算法：<ul>
<li>在实现中通常使用查找表来提高性能，且查表索引通常是密钥相关的，因此，分组密码算法的执行通常具有密钥依赖的数据访问模式。</li>
<li>如果攻击者能够获取密码算法查表访问的Cache组地址集合，并将其转换为查表索引，再结合 明文或密文就可以进行密钥分析，推断出密码算法使用的部分或全部密钥。</li>
</ul>
</li>
<li>现代公钥密码算法：<ul>
<li>在加密／解密过程中所要执行的指令序列，由于密钥各二进制位取值不同一般具有很大区别，因此，公钥密码算法的执行通常具有密钥依赖的指令执行序列。</li>
<li>比如：模幂运算是RSA加解密的核心算法，其中一种简单的实现方式为平方一乘算法，即将模幂运算分解为一系列平方、乘法以及取模运算。</li>
<li>如下图所示，采用平方一乘算法，当指数e的二进制表示中的某一位为1时将比为0时多执行两步运算。那么，如果攻击者能够确定算法运行期间执行的指令序列，就可以推测指数e的取值，并进一步破解密钥。</li>
<li><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Square-multiplication-algorithm.png" alt="平方-乘算法"></li>
</ul>
</li>
</ul>
<h2 id="Cache侧信道信息泄露来源"><a href="#Cache侧信道信息泄露来源" class="headerlink" title="Cache侧信道信息泄露来源"></a>Cache侧信道信息泄露来源</h2><p>主要是由于共享Cache导致的信息泄露（主要分为两类）：</p>
<ul>
<li>在云计算环境中，被分配到同一个物理 CPU 上运行的多个虚拟机之间共享硬件Cache，虽然 Cache 中的数据是受存储器保护的，攻击者无法直接获取。</li>
<li>但是，这些虚拟机在Cache中的数据可能被映射到同一个或多个Cache组甚至Cache行中，这为攻击者提供了一个观察被攻击虚拟机Cache行为的侧信道：<ul>
<li>攻击者访问其私有数据或执行私有指令时产生的侧信道信息，可以用来推测其它虚拟机的Cache行为。</li>
</ul>
</li>
</ul>
<h3 id="Cache争用产生的信息泄露"><a href="#Cache争用产生的信息泄露" class="headerlink" title="Cache争用产生的信息泄露"></a>Cache争用产生的信息泄露</h3><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Information-disclosure-cache%20contention.png" alt="cache争用产生的信息泄露"></p>
<blockquote>
<p>每个小方块:表示Cache行大小的数据块，是Cache与内存之间进行数据传输与分配的基本单位；<br>图中左边:表示Cache，每行表示一个Cache组，每个Cache组有w个Cache行，总共有S个Cache组；<br>右边:表示内存，每行表示映射到同一Cache组中的所有内存块，即对应于左边同一高度的Cache组。</p>
</blockquote>
<ul>
<li>通常，Cache失效表明发生了Cache争用。如图所示，虚拟机VMl的内存数据A1，A2与虚拟机VM2的内存数据B1，B2，B3被映射到同一个Cache组中。</li>
<li>假设VM2在较短的时间内连续两次访问B1、B2和B3，如果第2次访问B1时发生了Cache失效，则可以判断在VM2的两次访问之间有其它的虚拟机(VMl)使用了相同的Cache组，导致VM2的B1已被驱逐出Cache。</li>
</ul>
<p>运用实例：</p>
<ul>
<li>《Hey，you，get off of my cloud：Exploring information leakage in third—party compute clouds》</li>
<li>《Cross-VM side channels and their use to extract private keys》</li>
<li>《Last—level cache side—channel attacks are practical》<ul>
<li>Prime-Probe攻击：是Cache争用产生信息泄露的一个典型应用．Prime—Probe攻击中，攻击者利用进程或虚拟机之间的外部Cache访问冲突，在密码进程运行前后分别访问同样的数据来填充Cache。并根据第2次访问各个Cache组时发生了Cache命中(没有争用)还是Cache失效(存在争用)，来推测密码进程运行期间访问的Cache组地址集合，再在此基础之上进行密钥分析。</li>
</ul>
</li>
</ul>
<h3 id="数据重用产生的信息泄露"><a href="#数据重用产生的信息泄露" class="headerlink" title="数据重用产生的信息泄露"></a>数据重用产生的信息泄露</h3><p>Cache命中信息能够记录CPU对Cache的历史访问情况．Cache命中表明存在相同数据的重复使用，即CPU曾经访问过相同的数据:<br><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Information-leakage-data-reuse.png" alt="数据重用产生的信息泄露"> </p>
<ul>
<li>如图所示:假设虚拟机VMl和VM2共享部分内存页面，VM2访问页面A1、A2时,发现Al，A2已经位于Cache中，则可以推断有其它的虚拟机(VMl)在之前使用了A1、A2。</li>
</ul>
<p>实例：</p>
<ul>
<li>《Flush+Reload：A high resolution， low noise，L3 cache side—channel attack》<ul>
<li>Yarom等人提出的Flush—Reload攻击方法：是数据重用产生信息泄露的一个典型例子，其假设攻击者和攻击目标共享内存页面。在密码进程执行前将指定地址的一个或多个共享内存块驱逐出 Cache，并在加密完成后立即访问这些内存块。然后根据访问时是否发生了Cache命中来推测密码进程执行期间是否使用了其中的一些内存块，进一步地可以推测密码进程执行了哪些加密指令等。</li>
</ul>
</li>
</ul>
<h2 id="Cache侧信道信息泄露方式"><a href="#Cache侧信道信息泄露方式" class="headerlink" title="Cache侧信道信息泄露方式"></a>Cache侧信道信息泄露方式</h2><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/share-cache-between-vm.png" alt="虚拟机间共享cache的方式"></p>
<h3 id="分时共享"><a href="#分时共享" class="headerlink" title="分时共享"></a>分时共享</h3><ul>
<li>当攻击虚拟机和目标虚拟机被分配到同一个CPU核心上运行时。它们之间分时复用该物理CPU核心，并由虚拟机监控器(Virtual Machine Monitor，VMM)负责调度、切换运行的虚拟机。</li>
<li>这种情况下，攻击虚拟机和目标虚拟机可以共享该CPU的全部多级Cache，但是只能分时共享．并不能同时对Cache进行访问。</li>
<li>VMM每次切换运行的虚拟机时，并不会清空该CPU Cache中的数据，因此，下一个运行的虚拟机可以探测得到上一个运行的虚拟机的Cache访问信息。</li>
<li>通常，攻击者需要寻找并利用虚拟机调度算法的漏洞，来抢占目标虚拟机的调度，才能保证攻击虚拟机能够紧随目标虚拟机之后被调度运行；这样．才能在虚拟机切换后探测目标虚拟机之前的Cache访问信息。 </li>
<li>《Cross-VM side channels and their use to extract private keys》</li>
</ul>
<h3 id="同时共享"><a href="#同时共享" class="headerlink" title="同时共享"></a>同时共享</h3><ul>
<li>当攻击虚拟机和目标虚拟机被分配到同一个CPU的不同核心上运行时，它们之间可以并行运行。</li>
<li>攻击虚拟机和目标虚拟机只能共享该CPU的末级Cache(Iast Ievel Cache，LCC)，并不能共享各个核心私有的L1 Cache 或L2 Cache。但是，由于它们之间可以同时对LLC 进行访问。因此，攻击者可以同步地在目标虚拟机运行期间探LLC来得到其Cache访问信息。</li>
<li>《Last—level cache side—channel attacks are practical》</li>
<li>《S$A：A shared cache attack that works across cores and defies VM sandboxing— and its application to AES》</li>
</ul>
<h3 id="通过Cache一致性协议共享Cache数据"><a href="#通过Cache一致性协议共享Cache数据" class="headerlink" title="通过Cache一致性协议共享Cache数据"></a>通过Cache一致性协议共享Cache数据</h3><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Cache-data-sharing-Cache-Consistency-Protocol.png" alt="通过Cache一致性协议共享Cache数据"></p>
<ul>
<li>在多处理器系统中，如果多个CPU访问了同样的一块内存数据，那么，这块内存数据可能在不同CPU的多个Cache中都存有副本。Cache一致性协议就是用来解决内存数据与它的多个Cache副本之间的内容一致性问题。即使攻击虚拟机和目标虚拟机被分配到不同的CPU之上运行时。虽然它们之间并不物理上共享Cache；但是．由于Cache一致性协议，它们也可能会共享一部分Cache数据(同一内存数据在不同Cache中的副本)，因此，Cache一致性协议也可以看作逻辑上共享Cache的一种方式。</li>
<li>当一个处理器发生Cache失效时，失效的数据是否缓存于另一个处理器Cache中，将产生从另一个处理器Cache读取数据和直接从内存读取数据两种可能，这将导致可区分的Cache访问时间差异．因此，攻击者也可以利用Cache一致性协议来探测目标虚拟机是否使用了指定的内存数据。</li>
<li>《Cross proeessor cache attacks》</li>
</ul>
<h1 id="跨虚拟机Cache侧信道攻击概述"><a href="#跨虚拟机Cache侧信道攻击概述" class="headerlink" title="跨虚拟机Cache侧信道攻击概述"></a>跨虚拟机Cache侧信道攻击概述</h1><h2 id="传统缓存侧信道攻击"><a href="#传统缓存侧信道攻击" class="headerlink" title="传统缓存侧信道攻击"></a>传统缓存侧信道攻击</h2><p>最初，Cache侧信道攻击的相关研究工作都是围绕单机环境展开，以数据缓存、指令缓存等作为研究对象；   </p>
<p>根据采集信息不同，可将传统Cache侧信道攻击分为</p>
<ul>
<li>时序驱动攻击：需要采集密码算法一次加密／解密的<strong>整体时间</strong>，并利用统计分析方法推测密钥．</li>
<li>访问驱动攻击：需要通过间谍进程采集密码算法一次加密／解密过程中<strong>访问的Cache组地址集合</strong>，再利用直接分析或排除分析方法推测密钥．</li>
<li>踪迹驱动攻击：需要采集密码算法一次加密／解密过程中所有Cache访问的命中和失效序列，再结合明文或密文推测密钥．</li>
</ul>
<p>传统Cache侧信道攻击方法大多存在先决成立的假设条件：</p>
<ul>
<li>时序驱动攻击：需要能够获得目标系统的详细配置参数并重建相同的本地对照环境； </li>
<li>访问驱动攻击：需要能够侵入目标机器并植入间谍进程；</li>
<li>踪迹驱动攻击：通过计时手段很难实现，需要物理上接触目标机器并精确采集其功率消耗或电磁辐射信息等。</li>
</ul>
<h2 id="跨虚拟机Cache侧信道攻击的起源"><a href="#跨虚拟机Cache侧信道攻击的起源" class="headerlink" title="跨虚拟机Cache侧信道攻击的起源"></a>跨虚拟机Cache侧信道攻击的起源</h2><p>跨虚拟机时序驱动攻击：</p>
<ul>
<li>传统时序驱动攻击可以分为远程攻击和本地攻击两种：<ul>
<li>远程攻击：属于非入侵式攻击，攻击者通过网络远程采集计时信息，由于网络传输时延和抖动时延的存在，很难采集到精确的计时信息，而不精确的计时信息对攻击成功率影响较大，因此，远程攻击在真实网络环境下的适用性不强．</li>
<li>本地攻击：属于入侵式攻击，攻击者需要在攻击目标的操作系统中植入间谍进程来采集计时信息，虽然可以完全消除网络传输时延和抖动时延带来的影响，但是也降低了本地攻击在现实环境中的可行性． </li>
</ul>
</li>
<li>由于发生在两个虚拟机操作系统之问，跨虚拟机时序驱动攻击本质上仍属于远程攻击：<ul>
<li>当攻击者的虚拟机和攻击目标的虚拟机不同驻时，攻击场景与传统远程时序驱动攻击完全一样，因此，跨虚拟机时序驱动攻击通常发生在同驻的虚拟机之间。</li>
<li>由于同驻虚拟机之间一般通过宿主机的本地通信信道进行数据交换，因此，跨虚拟机时序驱动攻击采集的计时信息比较精确。</li>
</ul>
</li>
<li>跨虚拟机时序驱动攻击与传统时序驱动攻击并无明显区别． </li>
</ul>
<p>跨虚拟机访问驱动攻击：</p>
<ul>
<li>与传统访问驱动攻击方法类似，跨虚拟机访问驱动攻击通过监测宿主机的Cache或共享内存，并利用计时手段采集目标进程运行期间通过Cache泄露出来的侧信道信息，再结合其具体实现进行分析，即可能推测得到其它同驻虚拟机的隐私信息。</li>
<li>跨虚拟机访问驱动攻击与传统访问驱动攻击的不同： </li>
<li><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Diff-tradprocesses-crossvirtualmachineaccess.png" alt="传统进程与跨虚拟机访问驱动的区别"></li>
</ul>
<h2 id="跨虚拟机Cache侧信道攻击的研究进展"><a href="#跨虚拟机Cache侧信道攻击的研究进展" class="headerlink" title="跨虚拟机Cache侧信道攻击的研究进展"></a>跨虚拟机Cache侧信道攻击的研究进展</h2><p>跨虚拟机时序驱动攻击研究进展:</p>
<ul>
<li>只是将传统时序驱动攻击方法直接应用于跨虚拟机攻击场景中． </li>
</ul>
<p>跨虚拟机访问驱动攻击研究进展:   </p>
<ul>
<li>迁移传统攻击方法：<ul>
<li>2009年，Ristenpart等人：利用Prime-Probe《Cache attacks and countermeasures：The case of AES》方法在Amazon EC2云平台中探测得到同驻虚拟机的Cache负载状态信息以及用户击键间隔时间信息等。</li>
<li>2012年，Zhang等人：基于Prime—Probe 方法设计了HomeAlone工具，租户可利用Home—Alone来检测是否有其他租户的虚拟机与其同驻．</li>
<li>随后，Zhang等人利用Prime—Probe方法对L1指令Cache进行探测，并设计了一个隐马尔科夫模型过滤探测噪声，成功恢复了其它同驻虚拟机上使用的E1Gamal加密密钥．</li>
<li>2015年，Younis等人将虚拟机的虚拟地址转换为物理地址，再利用Prime—Probe方法监控这些物理地址是否被其它虚拟机访问过．</li>
<li>Liu等人和Irazoqui等人利用大页映射得到的额外物理地址知识来保留LLC和物理内存之间的映射关系，绕过了LLC与内存地址映射不透明的问题，使得Prime—Probe方法可用于探测LLC．在此之前，Prime-Probe方法只能用于探测容 量较小的L1 Cache．</li>
<li>随后，Inci等人和Kayaalp等人对LLC的索引哈希机制进行逆向工程，得到了内存地址与LLC各分片之间的映射关系，解决了LLC与内存地址映射不透明的问题． </li>
</ul>
</li>
<li>设计新的攻击方法： <ul>
<li>2014年，Yarom等人假设攻击虚拟机和目标虚拟机共享内存页面，并利用Cache的包容性特点，将Gullasch攻击∞刈扩展之后用于探测LLC，提出了第1个可以跨内核进行攻击的Cache侧信道攻 击方法(Flush—Reload攻击)． </li>
<li>2015年，Gruss等人发现缓存刷新指令的执行时间取决于被刷新的内存块是否位于Cache中，他们利用这一点对Flush—Reload攻击进行了改进，提出了Flush—Flush攻击，在缩短了攻击执行时间的同时提高了攻击的隐匿性． </li>
<li>2016年，Irazoqui等人基于Cache一致性协议，提出并实现了第1个跨CPU的Cache侧信道攻击方法(Invalidate—Transfer攻击)，成功恢复了另一个CPU上运行的加密软件库中使用的AES密钥和ElGamal密钥．</li>
</ul>
</li>
</ul>
<p>跨虚拟机访问驱动攻击的攻击方法更为多样化，随着攻击媒介从L1数据Cache和L1指令Cache，到LLC，再到双路CPU上Cache的变化，攻击的限制条件越来越现实：从要求攻击虚拟机和目标虚拟机同驻一个CPU核心，到同驻一个CPU，再到跨CPU，威胁范围也越来越广。</p>
<h1 id="跨虚拟机访问驱动Cache侧信道攻击的通用模型"><a href="#跨虚拟机访问驱动Cache侧信道攻击的通用模型" class="headerlink" title="跨虚拟机访问驱动Cache侧信道攻击的通用模型"></a>跨虚拟机访问驱动Cache侧信道攻击的通用模型</h1><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/model-CrossVirtualMachine-CacheSideChannelAttacks.png" alt="跨虚拟机访问驱动Cache侧信道攻击的通用模型"></p>
<h2 id="相关假设"><a href="#相关假设" class="headerlink" title="相关假设"></a>相关假设</h2><ul>
<li>云服务供应商及其提供的底层基础设施都是可信的，而使用云平台的各个租户之间是互不信任的。</li>
<li>攻击者为使用云平台的恶意租户，其拥有目标用户所运行应用的相关背景知识，但不具有任何特殊权限，期望利用侧信道攻击来获取目标用户的隐私信息。</li>
<li>攻击目标为使用云平台的正常租户，他们利用虚拟机运行某些机密性相关的应用，并对外提供公开的服务访问接口。 </li>
</ul>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>跨虚拟机Cache侧信道攻击本质上是一种基于统计分析的攻击方法.</p>
<ol>
<li>实现同驻:<ul>
<li>基于一定策略，攻击者创建并运行多个虚拟机实例，并利用虚拟机同驻检测方法逐一判断这些虚拟机是否和目标虚拟机同驻；重复这一过程，直到实现至少一个攻击虚拟机和目标虚拟机同驻为止。 </li>
</ul>
</li>
<li>探测Cache侧信道信息:<ul>
<li>攻击虚拟机首先根据具体攻击场景（包括攻击虚拟机和目标虚拟机共享Cache的方式，目标虚拟机所运行应用的具体实现特征等）的不同，设计选取合适的Cache侧信道信息探测方法；</li>
<li>然后，将Cache设置为一个已知状态，并访问部署在目标虚拟机中的应用；</li>
<li>最后，探测并收集目标虚拟机运行过程中产生的Cache侧信道信息． </li>
</ul>
</li>
<li>分析Cache侧信道信息: <ul>
<li>将攻击者想要获取的隐私信息标记为 $K = \{ K_1，K_2，K_3，…，K_n \}$。目标虚拟机中的应用为了响应攻击者的服务请求，将执行一些操作 $OP = \{ OP_1，OP_2，…，OP_n \}$，而操作OP与隐私信息K之间通常具有依赖关系，即由隐私信息K决定执行哪些操作，可以表示为函数$f：K-&gt;OP$，即 $OP=f(K)$；</li>
<li>在执行OP时，目标虚拟机访问共享Cache，这将产生一些Cache侧信道信息 $L = \{ L_1，L_2，…，L_n \}$；当 Cache 初始状态相同时，不同的操作OP将产生不同的Cache行为，从而产生不同的Cache侧信道信息，即操作OP与执行操作OP产生的Cache侧信道信息L之间具有强相关性，可以表示为函数 $g：OP-&gt;L$，即 $L = g(OP)$。 </li>
</ul>
</li>
</ol>
<p>通过上述分析：</p>
<ul>
<li>攻击虚拟机可以通过分析探测到的Cache侧信道信息L来推测得到目标虚拟机中的应用具体执行了哪些操作，再结合这些操作(OP)与隐私信息(K)之间的关系，减小K的取值范围或直接推测K的取值。</li>
<li>具体地：通过对目标应用的具体实现进行分析，可以建立函数f，并得到其逆函数：$K=f^{-1}(OP)$；对具体Cache行为与其产生的 Cache侧信道信息进行关联，可以建立函数g，并得到其逆函数：$OP=g^{-1}(L)$；在此基础之上，建立泄露模型：$K=f^{-1}(g^{-1}(L))$，即可通过对Cache侧信道信息L进行分析，推测得到目标虚拟机的隐私信息K。</li>
</ul>
<h1 id="虚拟机同驻"><a href="#虚拟机同驻" class="headerlink" title="虚拟机同驻"></a>虚拟机同驻</h1><p>现状：服务中心的物理机器越来越多，攻击者可能需要花费大量的时间和精力才能实现和特定的目标虚拟机的同驻</p>
<h2 id="虚拟机资源调度策略"><a href="#虚拟机资源调度策略" class="headerlink" title="虚拟机资源调度策略"></a>虚拟机资源调度策略</h2><p>主要解决：虚拟机与物理主机的映射问题，包括虚拟机的创建、迁移以及管理等   </p>
<ul>
<li>作为云计算底层的核心技术之一，虚拟机资源调度策略的好坏将直接影响到云平台的整体性能、运营成本以及服务质量等</li>
</ul>
<p>目前，公有云平台的虚拟机资源调度策略还未形成统一的标准和规范，各大云服务供应商都是根据自身资源的特点以及调度目标等采用不同的调度策略，例如：</p>
<ul>
<li>IBM云平台采用性能优先的调度策略，</li>
<li>HP云平台采用成本优先的调度策略</li>
<li>Amazon EC2的调度策略综合考虑了成本优先、负载均衡、高可靠性、满足用户不同租用请求等优化目标． </li>
</ul>
<p>公有云平台目前采用的虚拟机资源调度策略多是从降低能耗、减少成本、提高资源利用率以及实现负载均衡等角度出发进行优化，而大多忽略了安全上的考虑。<br>因此，攻击者可以分析并利用虚拟机资源调度策略的脆弱性，更有针对性地创建或启动虚拟机来实现与目标虚拟机的同驻。例如：</p>
<ul>
<li>为了降低能耗，并提高资源利用率， 虚拟机资源调度策略可能将同一时刻提交启动申请的多个虚拟机分配到一台物理主机上运行</li>
<li>为了便于管理，虚拟机资源调度策略可能将业务分类、可用区域、实例类型等启动信息相同的虚拟机分配到一台物理主机上运行</li>
</ul>
<h2 id="虚拟机同驻检测方法"><a href="#虚拟机同驻检测方法" class="headerlink" title="虚拟机同驻检测方法"></a>虚拟机同驻检测方法</h2><h3 id="基于网络信息的虚拟机同驻检测"><a href="#基于网络信息的虚拟机同驻检测" class="headerlink" title="基于网络信息的虚拟机同驻检测"></a>基于网络信息的虚拟机同驻检测</h3><ul>
<li>利用两个虚拟机的网络信息来判断它们之间是否同驻．</li>
<li>优点：是实现简单，检测效率较高，且不会对目标虚拟机的运行造成任何影响；</li>
<li>缺点：是检测准确率不高，且云平台可以很容易地阻止此类检测方法<ul>
<li>例如：利用VPC对不同虚拟机的网络进行隔离等． </li>
</ul>
</li>
</ul>
<h3 id="基于资源干扰的虚拟机同驻检测"><a href="#基于资源干扰的虚拟机同驻检测" class="headerlink" title="基于资源干扰的虚拟机同驻检测"></a>基于资源干扰的虚拟机同驻检测</h3><ul>
<li>利用两个虚拟机竞争使用共享资源时是否相互干扰来判断它们是否同驻．</li>
<li>优点：是检测准确率较高；</li>
<li>缺点：是实现相对复杂，容易受到同一宿主机上其它虚拟机的干扰，并且可能破坏宿主机的资源可用性．<ul>
<li>Inci等人发现云平台通过优化资源管理机制和虚拟机隔离机制，可以有效降低同驻虚拟机之间的相互干扰；</li>
<li>同时，随着硬件技术的不断发展，云平台中使用的硬件也更加复杂，例如固态硬盘允许多个读／写操作同时进行，在Amazon EC2云平台中已经很难观察到硬件性能上的衰减． </li>
</ul>
</li>
</ul>
<h3 id="基于隐蔽信道的虚拟机同驻检测"><a href="#基于隐蔽信道的虚拟机同驻检测" class="headerlink" title="基于隐蔽信道的虚拟机同驻检测"></a>基于隐蔽信道的虚拟机同驻检测</h3><ul>
<li>隐蔽信道：是指两个合谋的恶意进程通过预先约定的方式操作系统中的共享资源而实现的一种信息传输方式．云计算环境中，合谋的两个虚拟机利用宿主机的共享资源创建隐蔽信道，就可以绕过VMM，以一种隐秘地方式进行通信．</li>
<li>基于隐蔽信道的虚拟机同驻检测基于两个虚拟机是否能够合谋操作同一宿主机的共享资源，来判断它们是否同驻．</li>
<li>优点：是误检率低，检测结果比较准确；</li>
<li>存在一个致命的缺点：即只能应用于检测与被检测双方均为受控虚拟机的情况，并不适用于现实应用场景中只有攻击虚拟机受控的情况．<ul>
<li>因此，基于隐蔽信道的同驻检测方法一般用于研究人员在实验环境中确定其创建的两个虚拟机同驻这一事实，并在此基础上，分析同驻虚拟机之间的一些特性． </li>
</ul>
</li>
</ul>
<h2 id="虚拟机同驻检测方法评估"><a href="#虚拟机同驻检测方法评估" class="headerlink" title="虚拟机同驻检测方法评估"></a>虚拟机同驻检测方法评估</h2><h3 id="虚拟机同驻检测方法的测评原则"><a href="#虚拟机同驻检测方法的测评原则" class="headerlink" title="虚拟机同驻检测方法的测评原则"></a>虚拟机同驻检测方法的测评原则</h3><p>需要在保证检测效果的同时兼顾检测效率与检测能力，另外，一个好的同驻检测方法应该在现实环境中可行。</p>
<ol>
<li>检测效果：<ul>
<li><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/ConfusionMatrix-dichotomy-problem-co-resident-detection.png" alt="同驻检测的二分问题的混淆矩阵"><ul>
<li>正确接受：表示两个虚拟机实际同驻，检测结果也为同驻； </li>
<li>正确拒绝：表示两个虚拟机实际不同驻，检测结果也为不同驻； </li>
<li>错误拒绝：表示两个虚拟机实际同驻，但检测结果为不同驻； </li>
<li>错误接受：表示两个虚拟机实际不同驻，但检测结果为同驻。 </li>
</ul>
</li>
<li>根据混淆矩阵，可以使用分类器的评价指标，包括真正类率、漏报率、误报率、假负类率、正确率、精确度、准确率、召回率以及F-measure等。来对同驻检测方法的检测效果进行度量。</li>
</ul>
</li>
<li>检测效率 ：<ul>
<li>可以利用完成一次同驻检测所需的时间来对检测效率进行评估。 </li>
</ul>
</li>
<li>检测能力：<ul>
<li>主要用于反映同驻检测方法能够检测的同驻级别。</li>
<li>由于虚拟机之间对于CPU的共享情况直接决定它们之间的Cache共享关系，根据虚拟机之间共享CPU的情况，将它们之间的同驻级别分为： <ul>
<li>内核级同驻：两个虚拟机被分配到同一个CPU的同一个内核之上交替运行； </li>
<li>CPU级同驻：两个虚拟机被分配到同一个CPU之上运行，包括交替地运行于同一个内核之上(内核级同驻)以及并行地运行于不同内核之上两种情况； </li>
<li>宿主机级同驻：两个虚拟机被分配到同一个物理主机之上运行，它们之间可能被分配到同一个CPU之上运行(CPU级同驻)，也可能被分配到不同的CPU上运行． </li>
</ul>
</li>
</ul>
</li>
<li>局限性：<ul>
<li>主要用于衡量同驻检测方法在现实应用环境下的可行性，可以使用限制条件来描述同驻检测算法的局限性。</li>
<li>通常来说，限制条件越严格，算法的局限性越强、可行性越低． </li>
</ul>
</li>
<li>实用性：<ul>
<li>主要用于衡量同驻检测方法在现实应用场景下的实用价值．</li>
</ul>
</li>
</ol>
<h3 id="虚拟机同驻检测方法的比较"><a href="#虚拟机同驻检测方法的比较" class="headerlink" title="虚拟机同驻检测方法的比较"></a>虚拟机同驻检测方法的比较</h3><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Comparison-vm-coexistence-detection-methods.png" alt="虚拟机同驻检测方法的比较"></p>
<ul>
<li>基于隐蔽信道的同驻检测方法误检率低、检测效果最好，但其限制条件较为严格，在现实攻击场景中很难实现，实用性低；</li>
<li>基于网络信息的同驻检测方法实现简单，检测效率较高，但其检测准确率低、检测效果一般，而且由于大多数云平台已经支持使用VPC来加强网络隔离，导致其实用性严重降低；</li>
<li>基于资源干扰的同驻检测方法相对来说实用性最高，是目前虚拟机同驻检测的主流方法． </li>
</ul>
<h1 id="Cache侧信道信息探测方法"><a href="#Cache侧信道信息探测方法" class="headerlink" title="Cache侧信道信息探测方法"></a>Cache侧信道信息探测方法</h1><p>当前跨虚拟机Cache侧信道信息探测方法主要有四种：<strong>Prime-Probe方法</strong>、<strong>Flush-Reload方法</strong>、<strong>Flush-Flush方法</strong>以及<strong>Invalidate-Transfer方法</strong>。</p>
<ul>
<li>其中，Flush-Flush方法和Invalidate-Transfer方法与Flush—Reload方法的探测原理类似。</li>
</ul>
<h2 id="Prime-Probe（PP）方法"><a href="#Prime-Probe（PP）方法" class="headerlink" title="Prime-Probe（PP）方法"></a>Prime-Probe（PP）方法</h2><h3 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h3><p>利用PP探测Cache侧信道信息时，攻击虚拟机重复下面的步骤： </p>
<ol>
<li><strong>Prime</strong>：用预先准备的数据填充一个或多个 Cache 组 </li>
<li><strong>Trigger</strong>：访问部署在目标虚拟机中的应用，并且等待一段预设的 Prime-Probe 间隔时间；在这个过程中，由于要响应服务请求，目标虚拟机执行应用并使用 Cache </li>
<li><strong>Probe</strong>：重新读取 Prime 阶段加载的数据，测量并记录各个 Cache 组的读取时间</li>
</ol>
<p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Prime-Probe-method.png" alt="Prime-Probe方法"></p>
<ul>
<li>如图所示，如果目标虚拟机在Trigger阶段使用了一些攻击虚拟机在Prime阶段填充的Cache组，攻击虚拟机位于这些Cache组中的数据将被驱逐出Cache，导致攻击虚拟机在Probe阶段重新读取数据时发生Cache失效，从而产生一个较长的读取时间。因此，根据Probe阶段探测到的各个Cache组的重载时间，可以判断目标虚拟机在应用执行中使用了哪些Cache组。</li>
</ul>
<p>实际探测过程中，为了避免硬件预取导致的时延隐藏问题，通常采用<strong>Pointer-Chasing技术</strong>对预先准备的数据进行组织和操作。   </p>
<p>PP算法基于以下关键因素实现：</p>
<ul>
<li>攻击者能够识别出与目标用户内存访问活动相关的Cache访问．即需要确定目标应用中安全性关键的数据或代码缓存于Cache中的哪一个或哪几个Cache组中； </li>
<li>攻击虚拟机能够填充指定Cache组中的全部Cache行．即要求攻击者知道Cache与内存地址之间的映射关系；</li>
<li>高分辨率的时钟；</li>
</ul>
<h3 id="应用PP方法探测L1-Cache"><a href="#应用PP方法探测L1-Cache" class="headerlink" title="应用PP方法探测L1 Cache"></a>应用PP方法探测L1 Cache</h3><p>大致过程：通常针对整个L1 Cache进行探测，然后再使用机器学习方法识别出与目标用户内存访问活动相关的Cache使用。   </p>
<ul>
<li><strong>虚拟定址</strong>：攻击者可以利用数据或代码的虚拟地址确定其在L1 Cache中的具体位置。</li>
<li><strong>物理定址</strong>：Cache是物理标记的，即使用物理地址来确定数据或代码在Cache中的存储位置。</li>
</ul>
<p>虚拟机系统中共包含3种地址：   </p>
<ul>
<li><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/3-types-addresses-vm-systems.png" alt="虚拟机系统3种地址"></li>
<li><strong>虚拟地址</strong>：是指客户机操作系统提供给其应用程序使用的线性地址空间．对应于传统计算机系统中的虚拟地址；</li>
<li><strong>物理地址</strong>：是指虚拟机能够看到的经过VMM抽象的伪物理地址；</li>
<li><strong>机器地址</strong>：是指真实硬件的机器地址．即地址总线上应该出现的地址信号，对应于传统计算机系统中的物理地址。</li>
</ul>
<p>PP方法最初只能应用于探测 L1 Cache：</p>
<ul>
<li>系统在进行虚拟地址到物理地址再到机器地址的转换过程中：只对页号部分进行映射，页内地址偏移部分则保留不变；</li>
<li>因此，当Cache容量小于等于内存页面大小时，虚拟地址的页内地址偏移部分将保留Cache与物理内存之间进行映射所需的全部地址信息，使Cache由物理定址变为虚拟定址；</li>
<li>但是，当Cache容量大于内存页面大小时，Cache只能物理定址。此时，攻击者只能控制其数据或代码的虚拟地址，不知道也无法控制其物理地址和机器地址，也就无法控制其私有数据填充指定的Cache组． </li>
</ul>
<h3 id="应用PP方法探测LLC"><a href="#应用PP方法探测LLC" class="headerlink" title="应用PP方法探测LLC"></a>应用PP方法探测LLC</h3><p>除了物理定址问题，使用PP探测LLC的挑战还在于：</p>
<ul>
<li>非公开哈希索引机制：<ul>
<li>LLC各分片与物理内存地址之间的映射关系由一个非公开的哈希函数确定，即使攻击者可以判断一个Cache组中包含有哪些Cache行。也不知道这些Cache行分别对应于LLC的哪个分片；</li>
</ul>
</li>
<li>安全性关键访问相关的Cache组：<ul>
<li>对于容量较大的LLC(通常大于2MB)来说，对整个LLC进行一次Prime或Probe 的时间较长，如果每次都探测整个LLC，将无法以足够的分辨率探测得到有用的信息。导致使用PP探测LLC时，只能监控那些与目标应用安全性关键访问相关的cache组，因此也就需要确定目标应用中安全性关键的数据或代码缓存与LLC中的哪一个或那几个cache组。</li>
</ul>
</li>
</ul>
<p>针对上述问题：</p>
<ul>
<li>《Last—level cache side—channel attacks are practical》：通过在攻击虚拟机中使用大内存页，利用大页映射产生的额外页内地址偏移来保留LLC与虚拟地址之间的映射关系；同时，利用Cache组内各Cache行之间的驱逐关系来按照分片进行Cache行划分．绕过了LLC地址映射不透明的问题；最后，通过对LLC进行扫描．一次监控一个cache组在探测周期内的时态访问模式，并判断是否与目标应用的安全性关键访问一致，直到确定目标应用中安全性关键的数据或代码对应的Cache组．</li>
<li>《S$A：A shared cache attack that works across cores and defies VM sandboxing— and its application to AES》：也利用大页映射解决LLC的地址映射问题，并通过将探测数据从除LLC之外的多级Cache中驱逐的方法来降低其它高级别Cache对于探测结果的影响．</li>
<li>也有通过对LLC的索引哈希机制进行逆向工程，恢复了物理内存地址与LLC的地址映射关系，从根本上解决了LLC与物理内存地址映射不透明的问题．</li>
<li>Kayaalp等人则通过访问一个cache组时是否对目标应用造成影响来判断该cache组是否对应于目标应用的安全性关键访问。</li>
</ul>
<h2 id="Flush-Reload方法"><a href="#Flush-Reload方法" class="headerlink" title="Flush-Reload方法"></a>Flush-Reload方法</h2><p>Flush-Reload基于共享内存实现，是虚拟化环境中第1个跨内核、跨虚拟机的Cache探测方法．</p>
<h3 id="方法简介-1"><a href="#方法简介-1" class="headerlink" title="方法简介"></a>方法简介</h3><p>利用FR探测Cache侧信道信息时，攻击虚拟机重复下面的操作：</p>
<ol>
<li><strong>Flush</strong>：将共享内存中指定位置的内存块驱逐出Cache；</li>
<li><strong>Trigger</strong>：访问部署在目标虚拟机中的应用，并且等待一个预先设定的Flush-Reload间隔；在这个过程中，由于要响应服务请求，目标虚拟机执行应用并使用Cache；</li>
<li><strong>Reload</strong>：重新加载这些指定位置的内存块，测量并记录各个数据块的重载时间。</li>
</ol>
<p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Flush-Reload-method.png" alt="Flush-Reload方法"></p>
<ul>
<li>Flush阶段，攻击虚拟机将指定位置的内存块驱逐出Cache，</li>
<li>如果在Trigger阶段目标虚拟机访问了其中的一些内存块，这些数据将被重新加载到Cache，</li>
<li>那么，Reload阶段对这些内存块的重载将发生缓存命中，从而得到一个显著降低的重载时间．</li>
<li>因此，根据Reload阶段的重载时间，可以判断目标虚拟机是否访问了共享内存中指定位置的数据块、并进一步判断目标拟机访问了哪些数据或执行了哪些指令。</li>
</ul>
<p>FR算法实现基于以下关键因素：</p>
<ul>
<li>攻击虚拟机和目标虚拟机共享内存页面；</li>
<li>攻击虚拟机可以无限制地使用Cache刷新指令；</li>
<li>攻击虚拟机知道目标应用中安全性关键的数据或代码的内存位置;</li>
<li>Cache多级架构具有包容性的特点；</li>
<li>高分辨率的时钟．</li>
</ul>
<h3 id="Flush-Reload方法的应用"><a href="#Flush-Reload方法的应用" class="headerlink" title="Flush-Reload方法的应用"></a>Flush-Reload方法的应用</h3><ul>
<li>实际中，为了得到目标应用中安全性关键的数据或代码的内存位置，攻击者通常需要对被攻击的目标应用进行逆向工程，来定位这些安全性关键的内存块的具体位置。</li>
<li>Flush-reload攻击基于假设：<ul>
<li>攻击虚拟机和目标虚拟机共享内存页面实现，这种共享可以基于页面的来源（比如：共享的代码库或加密库），或者基于合并内容相同的页面。</li>
</ul>
</li>
<li>共享内存页面可以为攻击者提供丰富的信息。</li>
</ul>
<h3 id="Flush-Reload方法的扩展—-Flush-Flush方法"><a href="#Flush-Reload方法的扩展—-Flush-Flush方法" class="headerlink" title="Flush-Reload方法的扩展—-Flush-Flush方法"></a>Flush-Reload方法的扩展—-Flush-Flush方法</h3><p>《Flush+Flush：A stealthier last—level cache attack》：</p>
<ul>
<li>发现Cache刷新指令Clflush的 执行时间可以用来判断被刷新的内存块是否位于 Cache中：<ul>
<li>被刷新的内存块不在Cache中时，Clflush指令将提前终止，从而产生较短的执行时间；</li>
<li>被刷新的内存块在Cache中时，Clflush指令需要将其从全部多级Cache中驱逐，导致执行时间较长．</li>
</ul>
</li>
<li>基于此， Gruss等人去掉了Flush—Reload方法中的Reload步骤，提出了Flush—Flush攻击方法。</li>
<li>Flush—Flush方法连续两次使用Clflush指令将指定位置的内存块驱逐出Cache，并根据第2次Clflush指令的执行时间来判断在这期间目标虚拟机是否使用了这些内存块．由于去掉了Reload步骤，Flush—Flush方法缩短了一轮探测所需时间，可以提供更高的探测分辨率，同时也增加了攻击的隐匿性．</li>
<li>但是，与Cache命中和失效产生的Cache访问时间差异信息相比，Clflush指令执行时间的差异信息较小，导致Flush-Flush方法的探测准确率没有Flush-Reload方法高． </li>
</ul>
<h3 id="Flush-Reload方法的扩展—-Invalidate-Transfer方法"><a href="#Flush-Reload方法的扩展—-Invalidate-Transfer方法" class="headerlink" title="Flush-Reload方法的扩展—-Invalidate-Transfer方法"></a>Flush-Reload方法的扩展—-Invalidate-Transfer方法</h3><p>《cross processor cache attacks》：</p>
<ul>
<li>发现在多处理器配置下，由于需要保持多处理器间Cache内容的一致性，当一个处理器发生Cache失效时，失效的数据是否缓存于另一个处理器Cache中，将产生从另一个处理器Cache读取数据和直接从内存读取数据两种可能，这将导致Cache访问时间差异(大约50个时钟周期)．</li>
<li>基于上述事实，Irazoqui等人首次提出并实现了跨处理器的Invalidate-Transfer攻击方法，并恢复了另一个处理器上运行的加密软件库中使用的AES密钥和ElGamal密钥．</li>
<li>Invalidate-Transfer方法:先将指定的共享内存块在Cache中的副本标记为无效，然后等待一段时间后，再重新访问上述指定的内存块，并根据重载时间来判断在此期间攻击目标是否使用了这些内存块。进一步地，根据重载时间的差异还可以判断攻击者和攻击目标是否运行于同一个CPU之上。</li>
</ul>
<h2 id="Cache侧信道信息探测方法的比较"><a href="#Cache侧信道信息探测方法的比较" class="headerlink" title="Cache侧信道信息探测方法的比较"></a>Cache侧信道信息探测方法的比较</h2><p><img src="http://img.thebetterkong.cn/blog/CacheSideChannelAttackVM-Cloud/Comparison-Prime-Probe-Flush-Reload.png" alt="Prime-Probe与Flush-Reload的比较"></p>
<ul>
<li>Prime-Probe方法和Flush-Reload方法针对不同的应用需求，有各自的优缺点及应用挑战，具体方法的选取取决于应用场景和攻击者具备的能力等。<ul>
<li>当攻击虚拟机和目标虚拟机之间共享内存时，采用Flush-Reload方法，攻击者可以得到更细粒度且更为丰富的信息；</li>
<li>当攻击虚拟机和目标虚拟机没有共享内存时，攻击者只能采用Prime-Probe方法</li>
</ul>
</li>
<li>因此，Flush—Reload方法的适用范围受到了严格的限制，Prime—Probe方法则更为通用</li>
</ul>
]]></content>
      <categories>
        <category>文献阅读笔记</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
        <tag>Cache侧信道攻击</tag>
        <tag>云计算</tag>
        <tag>跨虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数笔记</title>
    <url>/2020/04/18/Math-Basic-Notes/Linear-Algebra/</url>
    <content><![CDATA[<p>本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p>
<p><strong><center><mark>多图警告！</mark></center></strong></p>
<a id="more"></a> 
<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><img src="https://img-blog.csdnimg.cn/20200118153653460.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200118153735522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200118153737836.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">       </p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><img src="https://img-blog.csdnimg.cn/20200118154130390.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">              </p>
<p><img src="https://img-blog.csdnimg.cn/20200118154140421.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200118154148137.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200118154414376.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">             </p>
<p><img src="https://img-blog.csdnimg.cn/2020011815444798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">      </p>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p><img src="https://img-blog.csdnimg.cn/20200118154744775.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200118154815931.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200118155522138.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200118155603663.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">         </p>
<h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p><img src="https://img-blog.csdnimg.cn/20200118160231836.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200118160243488.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">          </p>
<p><img src="https://img-blog.csdnimg.cn/20200118160307150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200118160335631.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">          </p>
<p><img src="https://img-blog.csdnimg.cn/20200118160358899.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">       </p>
<h1 id="特征值、特征向量、相似矩阵"><a href="#特征值、特征向量、相似矩阵" class="headerlink" title="特征值、特征向量、相似矩阵"></a>特征值、特征向量、相似矩阵</h1><p><img src="https://img-blog.csdnimg.cn/20200118160824125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">         </p>
<p><img src="https://img-blog.csdnimg.cn/2020011816292558.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200118163113577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">           </p>
<p><img src="https://img-blog.csdnimg.cn/2020011816314912.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">      </p>
<h1 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h1><p><img src="https://img-blog.csdnimg.cn/20200118163350775.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200118163436524.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">            </p>
<p><img src="https://img-blog.csdnimg.cn/202001181634527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200118163549294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">        </p>
<p><img src="https://img-blog.csdnimg.cn/20200118163607383.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5">      </p>
]]></content>
      <categories>
        <category>数学基础笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>干货分享 | 网页文档不让复制？带你一起破解网页限制</title>
    <url>/2020/05/30/Skills/ResolveCopyProhibition/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/header.png" width="100%" alt="header.png" /> </div>    

<p>受疫情影响，现在基本都是远程上课，眼看学期末就要到了，各个课程也纷纷结课。往常的结课考试，自然也就行不通，所以大部分课程开始改为递交课程报告的形式。于是乎，现在天天就是看论文，找资料，写报告……头都大了！特别有时候，好不容易在网上找到一些资料，结果还不让我使用传统的 <kbd>Crtl C+V</kbd> 大法，有的是让你登录，更狠的直接给你禁了，你都找不到这个选项。现在版权意识越来越重，要说不让随意下载转发，尚还接受，可是，有时候我就想用一下那么几句话，亦或者做下阅读笔记，还得一字一句的打，效率太低了。然后，就开始了各种捣鼓，这里总结出了所有我知道的办法，欢迎评论补充！</p>
<a id="more"></a> 
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>介绍具体破解方法前，我们还是有必要先弄清楚这种「复制禁用」到底是怎么实现的，只有知其然亦知其所以然，才能不变应万变；（如果你只是简单的想找个破解方法，可以跳过此章节）     </p>
<p>目前，绝大多数网页禁用复制功能，都可以囊括到如下三类：</p>
<p><strong>JavaScript 脚本的方式</strong>：</p>
<ul>
<li>也是目前最常用的方式，常用的实现方式如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'右键'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止文字选择。</span></span><br><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'文字选择'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'copy'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止剪切</span></span><br><span class="line"><span class="built_in">document</span>.body.oncut = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'cut'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e, <span class="string">'paste'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用e.preventDefault()也可以禁用，但建议使用 return false 这样就不用去访问 e 和 e 的方法了;</span></span><br><span class="line"><span class="comment">// 示例中 document.body 全局都禁用了，也可以对 dom （某些区域）进行禁用。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>CSS 的方式</strong>：<br><a id="mao"></a></p>
<ul>
<li>使用 CSS 能够保证在用户禁用 JavaScript 脚本的情况下，复制功能也会被禁止；<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>:none; <span class="comment">/* Firefox私有属性 */</span></span><br><span class="line">  <span class="attribute">-webkit-user-select</span>:none; <span class="comment">/* WebKit内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-ms-user-select</span>:none; <span class="comment">/* IE私有属性(IE10及以后) */</span></span><br><span class="line">  <span class="attribute">-khtml-user-select</span>:none; <span class="comment">/* KHTML内核私有属性 */</span></span><br><span class="line">  <span class="attribute">-o-user-select</span>:none; <span class="comment">/* Opera私有属性 */</span></span><br><span class="line">  <span class="attribute">user-select</span>:none; <span class="comment">/* CSS3属性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>HTML 属性的方式</strong>：</p>
<ul>
<li>这种方式就用的不多了；<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">oncopy</span>=<span class="string">"return false"</span> <span class="attr">oncut</span>=<span class="string">"return false;"</span> <span class="attr">onselectstart</span>=<span class="string">"return false"</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后，还必须提一下，有些爱捣鼓的网站（很少很少）会想办法禁用开发者模式，但是这种禁用通常是不可能 100% 禁用的；   </p>
<p>有的只是单纯通过禁用 <kbd>F12</kbd> 按键，又或者高级一些的：  </p>
<blockquote>
<p>“利用 console.log 打印一个对象然后覆盖这个对象的 toString 方法，一旦开发者工具存在，toString 方法就会被调用。”</p>
</blockquote>
<h1 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h1><p>首先最简单最笨的办法，当然就是，百度搜索这篇文章，看看有没有别的地方可以直接复制或者下载的。这不符合本文主题，pass！</p>
<h2 id="利用网页打印"><a href="#利用网页打印" class="headerlink" title="利用网页打印"></a>利用网页打印</h2><p>这里说的打印，不是让你真的打印（当然，不嫌麻烦话当我没说）；    </p>
<p>具体做法就是：</p>
<ul>
<li>在文档上：<kbd>右键</kbd> -&gt; <kbd>打印</kbd></li>
<li>然后，就可以直接在弹出的打印预览页面的，愉快的复制粘贴了；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/print.png" alt="print"></p>
<h2 id="拖拽法"><a href="#拖拽法" class="headerlink" title="拖拽法"></a>拖拽法</h2><p>选中所需要的文字，鼠标点击拖入到文本文件中；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/drag.jpg" alt="drag"></p>
<h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><p><kbd>F12</kbd> 进入开发者模式，在 hmtl 源码里就可以找到你所需要的文字；<br><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/html.jpg" alt="html"></p>
<p>这种方法很明显有个弊端就是，我们复制的文字量比较大时，会复制到一些不必要的 <code>&lt;p&gt;</code>、<code>&lt;div&gt;</code> 这种标签，这就需要自己去手动修改了，比较麻烦；</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>前面我们知道了，网站禁用复制的实现原理，那么，只需要按照对应的原理进行破解就 OK 了；</p>
<h2 id="0-命令"><a href="#0-命令" class="headerlink" title="$=0 命令"></a>$=0 命令</h2><p>许多网站在复制时会弹窗，提示让你登录，或者其它信息，这些网站通常是让你复制时触发 js 代码实现；   </p>
<p>而在 js 中，由于受到 prototype.js（老外写的框架，用于将一些常用的函数封装，方便操作）的影响，现在很多人都<strong>用 <code>$</code> 来表示一个查找对象的函数</strong>，于是也就有了命令： <code>$=0</code>，这样就能破坏 js 代码的执行；</p>
<p>具体操作：</p>
<ul>
<li><kbd>F12</kbd> 进入开发者模式，点击 <kbd>Console</kbd>；</li>
<li>输入：<code>$=0</code>，回车执行，再返回去复制即可；</li>
</ul>
<p><img src="http://img.thebetterkong.cn/blog/ResolveCopyProhibition/jscode.jpg" alt="jscode"></p>
<h2 id="禁用-js-代码"><a href="#禁用-js-代码" class="headerlink" title="禁用 js 代码"></a>禁用 js 代码</h2><p>上面提到的办法，不能保证 100% 的让 js 失效，所以接下来，我们直接设置禁用 js 代码；</p>
<p>以 Google 浏览器为例（其它浏览器大同小异）：</p>
<ul>
<li>进入 <kbd>设置</kbd> -&gt; <kbd>隐私设置和安全性</kbd> -&gt; <kbd>网站设置</kbd> -&gt; <kbd>JavaScript</kbd></li>
<li>将 <kbd>允许</kbd> 关闭，或者，将文档那个网站加入到禁止名单即可；</li>
<li>回去，刷新网站，就可以复制了；</li>
</ul>
<p>使用完后，别忘了将设置还原！</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果，你尝试完上述所有方法依旧不管用，那就是我们之前提到过得，网站使用了 <code>user-select: none;</code> 设置 css 样式进而停用用户选择，它是不受 js 影响的。所以，此方法处理起来比较复杂；</p>
<p>通常，<kbd>F12</kbd> 进入开发者模式，进入 Elements 选项卡，然后取消选中 body 下面的 CSS 规则：</p>
<ul>
<li>具体规则见前文：<a href="#mao">规则查看</a></li>
<li>主要是：<code>user-select: none;</code> 和 <code>webkit-user-select：none;</code></li>
</ul>
<p>或者说，可以使用用户脚本来覆盖设置（<a href="https://qastack.cn/superuser/1282718/how-do-websites-block-selecting-text-and-how-do-i-unblock-that" target="_blank" rel="noopener">方法来源</a>）：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Force Select</span></span><br><span class="line"><span class="comment">// @version      1.0</span></span><br><span class="line"><span class="comment">// @description  Stop sites from disabling selection of text</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        *://*/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>);</span><br><span class="line">  style.innerHTML = <span class="string">'*&#123; user-select: auto !important; &#125;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果启用此功能，则将适用于每个页面，这在所有情况下都不是理想的；</li>
<li>因此，可以使用 Violentmonkey，Tampermonkey 或 Greasemonkey 之类的用户脚本管理器来安装脚本，并轻松打开/关闭该脚本；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果你能熟练掌握上述所有方法，那么基本所有的文档都能任由你复制了；    </p>
<p>但是，如果还非要说上面那些方法不会使用，想要更加轻松的方式，那就直接使用第三方插件吧！   </p>
<p>推荐几款谷歌插件：</p>
<ul>
<li>『<a href="https://chrome.google.com/webstore/detail/enable-copy/lmnganadkecefnhncokdlaohlkneihio" target="_blank" rel="noopener">Enable Copy</a>』：安装完后会在 chrome 插件栏上增加一个对勾形状按钮，以后碰到不能直接复制的网页，每次复制网页内容之前，先点此勾形按钮即可；</li>
<li>『<a href="https://chrome.google.com/webstore/detail/simple-allow-copy/aefehdhdciieocakfobpaaolhipkcpgc?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">simple allow copy</a>』：使用方法，和 Enable Copy 基本相同；</li>
</ul>
<p>再就是前面提到过的脚本管理器：『<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Tampermonkey</a>』</p>
<ul>
<li>你可以用该脚本管理器添加，前面提及的脚本，也可以自己在上面查找一些相关脚本；</li>
<li>再提供一款脚本『<a href="https://greasyfork.org/zh-CN/scripts/28497-remove-web-limits-modified" target="_blank" rel="noopener">网页限制解除（改）</a>』供选择；</li>
</ul>
<p>最后，送佛送到西，再安利一个文档下载器：</p>
<ul>
<li>『<a href="http://www.bingdian001.com/?p=30" target="_blank" rel="noopener">冰点文库下载器</a>』：可以解决常见的像百度文库这种，大部分的文档下载；</li>
</ul>
<p>最最最后，只要不嫌麻烦，<strong>包治百病的终极大法</strong>：</p>
<ul>
<li>截图 + 文字识别</li>
<li>至于这两个工具，直接百度，那就是一大堆了；</li>
</ul>
<p>那就再附加一个，网页内容选择性打印的脚本：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到你所需要打印的部分的 div，这里是利用 ID 识别</span></span><br><span class="line"><span class="comment">// 你也可以利用 JSP 的 DOM（Document Object Model）的其他方式</span></span><br><span class="line"><span class="comment">// 常用的三种方法：getElementById、getElementsByName、getElementsByTagName</span></span><br><span class="line"><span class="comment">// Element.innerHTML 属性用于设置或返回指定标签之间的 HTML 内容</span></span><br><span class="line"><span class="keyword">var</span> printData = <span class="built_in">document</span>.getElementById(<span class="string">"article_content"</span>).innerHTML;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把 html 里的数据复制给 body 的 html 数据 ，相当于重置了整个页面的内容</span></span><br><span class="line"><span class="built_in">window</span>.document.body.innerHTML = printData; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始打印</span></span><br><span class="line"><span class="built_in">window</span>.print();</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5b66993ee51d451924734c35#heading-6" target="_blank" rel="noopener">前端er怎样操作剪切复制以及禁止复制+破解等</a></li>
</ul>
]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论笔记</title>
    <url>/2020/04/18/Math-Basic-Notes/Random-Mathematics/</url>
    <content><![CDATA[<p>本人考研期间的数学笔记，虽然以后不怎么用的上，但是还是给自己做了个归纳整理，方便查看吧。         </p>
<p><strong><center><mark>多图警告！</mark></center></strong></p>
<a id="more"></a> 
<h1 id="随机事件和概率"><a href="#随机事件和概率" class="headerlink" title="随机事件和概率"></a>随机事件和概率</h1><p><img src="https://img-blog.csdnimg.cn/20200418213404670.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="1">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213415807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="2">              </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213429830.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="3">                </p>
<h1 id="随机变量及分布"><a href="#随机变量及分布" class="headerlink" title="随机变量及分布"></a>随机变量及分布</h1><p><img src="https://img-blog.csdnimg.cn/20200418213622252.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="4">               </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213641746.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="5"></p>
<p><img src="https://img-blog.csdnimg.cn/20200418213652529.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="6">               </p>
<h1 id="二维随机变量及分布"><a href="#二维随机变量及分布" class="headerlink" title="二维随机变量及分布"></a>二维随机变量及分布</h1><p><img src="https://img-blog.csdnimg.cn/20200418213709177.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="7">             </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821373253.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="8">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213742872.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="9">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418213754850.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="10">                </p>
<h1 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h1><p><img src="https://img-blog.csdnimg.cn/20200418214045105.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="11">              </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214054877.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="12">               </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214104936.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="13">               </p>
<p><img src="https://img-blog.csdnimg.cn/2020041821411550.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="14">               </p>
<h1 id="大数定理与中心极限定理"><a href="#大数定理与中心极限定理" class="headerlink" title="大数定理与中心极限定理"></a>大数定理与中心极限定理</h1><p><img src="https://img-blog.csdnimg.cn/20200418214137934.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="15">                 </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214148904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="16">                 </p>
<h1 id="数理统计的基本概念"><a href="#数理统计的基本概念" class="headerlink" title="数理统计的基本概念"></a>数理统计的基本概念</h1><p><img src="https://img-blog.csdnimg.cn/20200418214210620.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="17">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214221273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="18">                  </p>
<h1 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h1><p><img src="https://img-blog.csdnimg.cn/202004182142432.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="19">                 </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214252542.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="20">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214301744.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="21">               </p>
<h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><p><img src="https://img-blog.csdnimg.cn/20200418214331831.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="22">             </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214342642.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="23">                </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214406528.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="24">            </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214415447.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="25">           </p>
<p><img src="https://img-blog.csdnimg.cn/20200418214424734.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg0OTQwMw==,size_16,color_FFFFFF,t_70" alt="26">             </p>
]]></content>
      <categories>
        <category>数学基础笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 offer 67题</title>
    <url>/2020/04/05/DataStructure-Algorithm/Finger-offer67/</url>
    <content><![CDATA[<div align="center"> <img src="http://img.thebetterkong.cn/blog/Finger-offer67/header.png" width="100%" alt="header.png" /> </div>     

<p>为了提高自己算法能力，从今天起，这篇 Blog 持续更新，预计在 35 天后完成所有题目的一刷，立下 flag 保证每日更新两题！主要用 <code>Java</code> 完成，偶尔为了练习 <code>Python</code> 也会穿插一些 <code>Python</code> 算法。</p>
<a id="more"></a> 
<hr>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code> <code>数组</code></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在目标二维数组中，找目标数。很显然，这是一个典型的寻找问题，题目给出了数组元素的一个递增关系，那么很明显，我们就不能直接把整个数组都遍历一遍，那样实在是太笨了。     </p>
<p>所以，现在问题的关键就是在于：制定一种遍历策略，保证当目标 <code>target &gt; a[i][j]</code> 或 <code>target &lt; a[i][j]</code> 时，算法只有一种遍历方向，并且不会出现漏找的情况。   </p>
<p>下面，研究一下这个二维数组：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/search-two-dimensional-array.png" alt="二维数组">      </p>
<blockquote>
<p>不难发现，任意画一条从上到下再从左往右的折线箭头（①、②、③），该箭头所穿过的数组元素都满足递增的顺序，而数组便是由许许多多这种所谓的箭头构成。<br>数组左上角元素最小，右下角元素最大；   </p>
</blockquote>
<p>基于上述发现，一个大致的思路就已经出来了：</p>
<ul>
<li>初始时，选择数组最左下角的元素参与比较</li>
<li>若 <code>target &gt; a[i][j]</code>，下一个选取 <code>a[i][j+1]</code> 与 <code>target</code> 比较；</li>
<li>若 <code>target &lt; a[i][j]</code>，下一个选取 <code>a[i+1][j]</code> 与 <code>target</code> 比较；</li>
</ul>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>Java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = array.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt; array[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == array[row][col])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">                    col++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    row--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于<code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        row = len(array)<span class="number">-1</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span> <span class="keyword">and</span> col &lt; len(array[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; array[row][col]:</span><br><span class="line">                row = row - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                col = col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价"><a href="#算法评价" class="headerlink" title="算法评价"></a>算法评价</h2><ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>最坏情况下的时间复杂度： <code>2n</code></li>
</ul>
<hr>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个函数，将一个字符串中的每个 <code>空格</code> 替换成 <code>“%20”</code>。<br>例如：当字符串为： <code>We Are Happy.</code> ，则经过替换之后的字符串为： <code>We%20Are%20Happy.</code>     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点：<code>字符串</code></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，如果不考虑额外的空间开销，最简单的思路就是：</p>
<ol>
<li>开辟一个新的字符串数组，然后对原字符串数组从头到尾进行遍历；</li>
<li>字符如果不是空格就复制到新字符串中，如果是空格就不复制，并且在新字符串中插入%20；</li>
<li>循环进行，直至遍历完原字符串；</li>
</ol>
<p>那问题就来了：<code>『能不能在不开辟新的内存空间的情况下，完成此操作呢？』</code>   </p>
<ul>
<li>当然可以，我们可以直接遍历字符串，假设在索引 <code>i</code> 处遇到 <code>空格</code>，就将位于 <code>i</code> 位置后的所有字符后移两位，然后将 <code>%</code>、<code>2</code>、<code>0</code>，插入到 <code>i</code>、<code>i+1</code>、<code>i+2</code> 这三个位置即可，然后，再从第 <code>i+2</code> 出开始遍历，直至字符串遍历完毕。   </li>
<li>因为后移操作也需要进行循环遍历，所以此算法的时间复杂度无疑是很高的，为 <code>O(n^2)</code>。    </li>
</ul>
<p>那还有没有更加高效的方法，让时间复杂度变为 <code>O(n)</code> 呢？   </p>
<ul>
<li>上面的思路，带来过高的时间开销的原因是：<code>每次遍历到空格时，都需要再次循环移动字符串字符</code>。如果能解决这个问题，我们的时间复杂度就能变成 <code>O(n)</code> 了。</li>
<li>转换一下思考方向：如果我们能知道，各个字符需要往后移动的位数，那么，我们就可以通过一次从后往前的循环遍历，直接将所有字符移动到位了！</li>
</ul>
<p>为了实现上面的想法，我们将替换前后的字符串拿出来对比一下：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Spaces-Replace.png" alt="替换空格">       </p>
<blockquote>
<p><code>Happy</code> 整体向后移动四个单位；<code>Are</code> 整体向后移动两个单位；<code>We</code> 没变；<br>也就是说，每遇到一个空格，后面的字符就需要多移动两个单位；<br>关键的问题也就是：需要我们确定各个字符前的空格总数。</p>
</blockquote>
<p>规律找到了，我们算法的思路也就知道了：</p>
<ul>
<li>第一次遍历，确定字符串中的空格数量，并用 <code>count</code> 记录；</li>
<li>第二次 『<strong>从后往前</strong>』 遍历：<ul>
<li>不是空格就往后移动 <code>2 x count</code> 个单位；</li>
<li>是空格，<code>count - 1</code>，并且将 <code>%</code>、<code>2</code>、<code>0</code>，插入到当前 <code>i+2*count-2</code>、<code>i+2*count-1</code>、<code>i+2*count</code> 这三个位置；然后继续从 <code>i-1</code> 处遍历；</li>
<li>直至整个字符遍历完毕。（Ps：结束条件可改为 『count==0』 ，这样可以进一步提高性能。</li>
</ul>
</li>
</ul>
<h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>Java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldlength = str.length(); </span><br><span class="line">        <span class="keyword">int</span> newlength = str.length() + count*<span class="number">2</span>;</span><br><span class="line">        str.setLength(newlength);<span class="comment">//扩大str的长度,防止下标越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = oldlength-<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; count&gt;<span class="number">0</span>;i--)&#123; </span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count, <span class="string">'0'</span>);</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count-<span class="number">1</span>, <span class="string">'2'</span>);</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count-<span class="number">2</span>, <span class="string">'%'</span>);</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    str.setCharAt(i+<span class="number">2</span>*count, str.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>Python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        changed = s.replace(<span class="string">" "</span>,<span class="string">"%20"</span>)</span><br><span class="line">        <span class="keyword">return</span> changed</span><br></pre></td></tr></table></figure></p>
<p>语法知识点：</p>
<ul>
<li><code>python</code>：字符串有replace方法，直接替换即可；</li>
<li><code>java</code>：<ul>
<li>也有 <code>replace</code>、<code>replaceALL</code> 等方法，但是这里为了表达算法思路，就没有直接使用；</li>
<li>字符串按位置索引需要用：<code>CharAt</code></li>
<li>字符串按位置赋值需要用：<code>setCharAt</code></li>
<li>字符串取出某字符位置：<code>indexOf</code></li>
<li>要注意，字符串长度 <code>setLength</code>，防止下标越界</li>
</ul>
</li>
</ul>
<h2 id="算法评价-1"><a href="#算法评价-1" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度： <code>O(n)</code></p>
<hr>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个 <code>ArrayList</code>。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题，第一反应就是利用 <code>栈</code> 来实现，直接将其顺序入栈，然后出栈，就能很轻松的实现 <code>反顺序</code>，但是这种方法带来的问题就是：栈的引入，带来了额外的空间开销；     </p>
<p>这个时候，我就想：直接将链表元素存入数组，然后将数组进行一下反转。<br>数组反转时，大致有三种思路：</p>
<ol>
<li>使用工具类： <code>Collections.reverse(ArrayList)</code> 将数组进行反转;</li>
<li>新建一个 <code>arrayList</code>，新数组的头等于原数组的尾；<ul>
<li>这种方法和基于堆栈的方法比较起来，没有什么优势，而且个人认为此更加麻烦；</li>
</ul>
</li>
</ol>
<p>上面使用工具类的方法，相对来说最为简单，但是问题就是，这个工具类的内部实现是怎样的？它在内部实现的时候是否也像其他方法一样，开辟了新的内存空间，带着这个问题，我查看了它的内部实现源代码『<code>摘自于jdk 1.8.0_181</code>』，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverses the order of the elements in the specified list.&lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method runs in linear time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  list the list whose elements are to be reversed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the specified list or</span></span><br><span class="line"><span class="comment">     *         its list-iterator does not support the &lt;tt&gt;set&lt;/tt&gt; operation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">                swap(list, i, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// instead of using a raw type here, it's possible to capture</span></span><br><span class="line">            <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">            <span class="comment">// private method</span></span><br><span class="line">            ListIterator fwd = list.listIterator();</span><br><span class="line">            ListIterator rev = list.listIterator(size);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">                Object tmp = fwd.next();</span><br><span class="line">                fwd.set(rev.previous());</span><br><span class="line">                rev.set(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Swaps the elements at the specified positions in the specified list.</span></span><br><span class="line"><span class="comment">     * (If the specified positions are equal, invoking this method leaves</span></span><br><span class="line"><span class="comment">     * the list unchanged.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list The list in which to swap elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index of one element to be swapped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j the index of the other element to be swapped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException if either &lt;tt&gt;i&lt;/tt&gt; or &lt;tt&gt;j&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     *         is out of range (i &amp;lt; 0 || i &amp;gt;= list.size()</span></span><br><span class="line"><span class="comment">     *         || j &amp;lt; 0 || j &amp;gt;= list.size()).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// instead of using a raw type here, it's possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="keyword">final</span> List l = list;</span><br><span class="line">        l.set(i, l.set(j, l.get(i)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，它分为了两种情况来实现：    </p>
<ol>
<li>『集合大小小于 REVERSE_THRESHOLD』或者『支持随机访问』：直接使用 <code>swap函数</code> 实现，注意：<mark>这里 <code>swap函数</code> 的具体实现也非常值得我们深挖；</mark></li>
<li>采用两个迭代器，一个从前往后，一个从后往前，实现数组元素的交换</li>
</ol>
</blockquote>
<p>所以可以看到，使用 <code>Collections.reverse(ArrayList)</code> 方法的这个思路更加简单，而且，在空间效率上也不会比『开辟新栈的方法』差。所以，这里我更加推荐这种方法实现。</p>
<h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：  </p>
<ol>
<li><p>堆栈实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            list.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>Collections.reverse(ArrayList)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>基于 <code>python</code>：   </p>
<ul>
<li>python可直接用insert方法实现<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        array = []</span><br><span class="line">        node = listNode</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            array.insert(<span class="number">0</span>, node.val)</span><br><span class="line">            node = node.next</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="算法评价-2"><a href="#算法评价-2" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度为：<code>O(n)</code><br>空间复杂度为：<code>3n</code>，此参数仅供参考，还不够准确</p>
<hr>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。    </p>
<p>例如：输入前序遍历序列 $\{1,2,4,7,3,5,6,8\}$ 和中序遍历序列 $\{4,7,2,1,5,3,8,6\}$，则重建二叉树并返回。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一道十分基础的和 <code>树</code> 有关的题，在学习的时候，我们就知道树的遍历一般都是用递归实现的，本题自然也不例外。     </p>
<p>其实只需要将平常解这种题的过程用算法描述出来即可。<br>![例子][<img src="http://img.thebetterkong.cn/blog/Finger-offer67/Rebuild-Binary-Tree.jpeg" alt="mark">]</p>
<h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存数组长度，也是递归调用的出口</span></span><br><span class="line">        <span class="keyword">int</span> length = pre.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = pre[<span class="number">0</span>];</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在中序遍历中，找根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[<span class="number">0</span>] == in[i])&#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重构左右子树的前序和中序遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> [] left_pre = <span class="keyword">new</span> <span class="keyword">int</span> [mid];</span><br><span class="line">        <span class="keyword">int</span> [] left_in = <span class="keyword">new</span> <span class="keyword">int</span> [mid];</span><br><span class="line">        <span class="keyword">int</span> [] right_pre = <span class="keyword">new</span> <span class="keyword">int</span> [length-<span class="number">1</span>-mid];</span><br><span class="line">        <span class="keyword">int</span> [] right_in = <span class="keyword">new</span> <span class="keyword">int</span> [length-<span class="number">1</span>-mid];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mid;i++)&#123;</span><br><span class="line">            left_pre[i] = pre[i+<span class="number">1</span>];</span><br><span class="line">            left_in[i] = in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            right_pre[i-mid-<span class="number">1</span>] = pre[i];</span><br><span class="line">            right_in[i-mid-<span class="number">1</span>] = in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        head.left = reConstructBinaryTree(left_pre,left_in);</span><br><span class="line">        head.right = reConstructBinaryTree(right_pre,right_in);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        mid = tin.index(root.val)</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:mid+<span class="number">1</span>], tin[:mid])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[mid + <span class="number">1</span>:], tin[mid + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-3"><a href="#算法评价-3" class="headerlink" title="算法评价"></a>算法评价</h2><p>基于递归的算法，不管是在时间复杂度还是空间复杂度上都是很高的；     </p>
<p>后续，二刷时，考虑下非递归实现。目前感觉，即使是采用非递归算法，其时间复杂度和空间复杂度也应该是比较高的。</p>
<hr>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> 和 <code>栈</code></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先得认清 <code>栈</code> 和 <code>队列</code> 的特点：</p>
<ul>
<li>栈：先进后出</li>
<li>队列：先进先出</li>
</ul>
<p>利用栈实现队列，需要两个栈（一个负责入队，一个负责出队）：</p>
<ul>
<li>入队操作：将元素压入栈 1</li>
<li>出队操作：将栈 1 的元素出栈并依次压入栈 2，这样栈 1 的栈底也就成了栈 2 的栈顶，再对栈 2 出栈即可。</li>
</ul>
<p>Note：出队的逻辑，在将栈 1 的元素倒入栈 2 之前，一定要先保证栈 2 空。</p>
<h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>『数组的旋转』：把一个数组最开始的若干个元素搬到数组的末尾；    </p>
<p>现要求：输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。   </p>
<p>例如：数组 $\{3,4,5,1,2\}$ 为 $\{1,2,3,4,5\}$ 的一个旋转，该数组的最小值为 1。    </p>
<p>注意：给出的所有元素都大于 0，若数组大小为 0，请返回 0。    </p>
<p>时间限制：C/C++ 3秒，其他语言6秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code></p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一思路：直接从头往后遍历数组，如果出现 <code>array[i]&gt;array[i+1]</code>，那么 <code>array[i+1]</code> 一定就是最小元素，如果一直遍历结束也没出现这种结果，那么最小元素就是 <code>array[0]</code>；   </p>
<ul>
<li>该思路，时间复杂性为 <code>O(n)</code>；最坏情况下，需要将整个数组遍历一次，效率比较低。所以，下面探讨采用 <code>二分查找</code> 的方法来实现该算法，将时间复杂度降为：$O(log_2n)$</li>
</ul>
<p>二分查找思路：类似普通二分法，但是需要注意的是：当 <code>mid==high</code> 时，例如 $(1,1,1,1,1,1)$，此时是无法判断最小元素是在 $[low,mid]$ 还是 $[mid,high]$ 区间的，此时需要再从头至尾逐个查找，但发生这种情况概率还是较低的。对算法效率影响不大。</p>
<h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>思路一：    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路二：   </p>
<p>基于<code>java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = lenth-<span class="number">1</span>,mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high -<span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;<span class="comment">//array[mid]可能就是最小元素，比较时，不能直接将其剔除</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        lenth = len(rotateArray)</span><br><span class="line">        high = lenth - <span class="number">1</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        mid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[mid] &gt; rotateArray[high]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> rotateArray[mid] == rotateArray[high]:</span><br><span class="line">                high = high - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> rotateArray[low]</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-4"><a href="#算法评价-4" class="headerlink" title="算法评价"></a>算法评价</h2><p>见解题思路部分；</p>
<hr>
<h1 id="斐波拉契数列"><a href="#斐波拉契数列" class="headerlink" title="斐波拉契数列"></a>斐波拉契数列</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。（n&lt;=39）</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p><code>斐波那契数列</code>：$0、1、1、2、3、5、8、13、21、34…$     </p>
<p>从斐波那契数列的定义来看，我们就知道容易用递归实现，其递归算法：</p>
<ul>
<li>当 $n&gt;2$ 时：$Fibonacci（n）=Fibonacci（n-1）+ Fibonacci（n-2）$</li>
</ul>
<p>但是递归对程序员来说，修养要求极高，容易出现：无穷递归、栈溢出等各种问题，安全性也比较难把握，所以我们应该尽量避免递归的使用。<br>有关递归的效率问题，具体参考：『<a href="http://www.nowamagic.net/librarys/veda/detail/2321" target="_blank" rel="noopener">漫谈递归：递归的效率问题</a>』     </p>
<p>接下来的算法主要采用循环实现；</p>
<h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p><a id="FibonacciSequence"></a></p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            c=a+b;</span><br><span class="line">            a=b;</span><br><span class="line">            b=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = []</span><br><span class="line">            c.append(<span class="number">1</span>)</span><br><span class="line">            c.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">                c.append(c[i<span class="number">-1</span>]+c[i<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> c[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="跳台阶问题"><a href="#跳台阶问题" class="headerlink" title="跳台阶问题"></a>跳台阶问题</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题需要转换思路，直接分析比较麻烦，尝试分析其数列关系：</p>
<ul>
<li>要想知道跳到 n 级台阶多少种跳法，那么包含两种情况：① 从 n-1 级台阶跳一级到 n 级；② 从 n-2 级台阶跳 2 级到 n 级台阶。这样，递归关系就出来了；</li>
</ul>
<p>得到递归关系：</p>
<ul>
<li>$f（n）=f（n−1）+f（n−2）$，说白了，也就是斐波拉契数列；</li>
</ul>
<h2 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h2><p>参考：『<a href="#FibonacciSequence">斐波拉契数列</a>』</p>
<hr>
<h1 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>贪心</code></p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>青蛙可以跳任意级数的台阶，所以类似上一题那种找递归关系的办法在这里肯定是行不通了。那么，既然局部分析已经失效，那就再换个思路，从总体上分析：     </p>
<p>青蛙从初始 0 处开始，任意跳，最终落到位置 n 处。这时候，建立一个模型：</p>
<ul>
<li>首先，将步长定为 1，再将青蛙每次的落脚点作为集合中的一个元素，这样就能得到 <code>集合 a[n]</code>；</li>
<li>然后，青蛙的步长为任意值，此时集合 $a[n]$ 中的 n 个元素都有 $0/1$ 两种取值（0：青蛙没在该位置停留；1：青蛙又在该位置停留）；</li>
<li>青蛙最终停在位置 n 处，那么 $a[n]=1$；</li>
</ul>
<p>有了这个模型后，问题就转换成：<code>集合 a[n]</code> 中的前 n-1 个元素一共有多少种不同的取值情况，答案也就是：$2^{n-1}$；</p>
<h2 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target;i++)&#123;</span><br><span class="line">            b=a*<span class="number">2</span>;</span><br><span class="line">            a=b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">2</span>,number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 $2<em>1$ 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 $2</em>1$ 的小矩形无重叠地覆盖一个 $2*n$ 的大矩形，总共有多少种方法？    </p>
<p>比如：n=3 时，$2*3$ 的矩形块有3种覆盖方法：   </p>
<ul>
<li>三竖；</li>
<li>一竖两横；</li>
<li>两横一竖；</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>递归</code></p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样是一个找递推关系的题：    </p>
<ul>
<li>首先，假设我们已知：$2*n$ 的矩形有 $f(n)$ 种覆盖方式；</li>
<li>使用 $2*1$ 的矩形去填充，也就是需要找： $f(n)、f(n+1)、f(n+2)$ 这三者的关系；</li>
</ul>
<p>从 $f(n+1)$ 到 $f(n+2)$ 只有一种填充方式：    </p>
<ul>
<li>在原基础上竖着往后加入一个小矩形；    </li>
</ul>
<p>从 $f(n)$ 到 $f(n+2)$，且不经过 $f(n+1)$ 的结构，也只有一种填充方式：    </p>
<ul>
<li>在原基础上横着并入两个小矩形；</li>
</ul>
<p>于是，递推关系就是：$f(n+2)=f(n+1)+f(n)$，同样也是斐波拉契数列；</p>
<h2 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h2><p>参考：『<a href="#FibonacciSequence">斐波拉契数列</a>』，注意一下数列项的对于关系；</p>
<hr>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code>、<code>补码反码原码</code></p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们都知道，求一个正整数二进制中 1 的个数很简单，只需要不断除 2，余 1 时，count+1 就可以了。但是本题主要难点就在于输入的整数可能为负，而负数在计算机中采用补码表示，其 1 的个数计算起来就比较麻烦，咋眼一看，很让人没有头绪。    </p>
<p>上面说到的，正整数处理方法的核心就在于移位：</p>
<ol>
<li>而负数的补码在右移时，最高位填 1，这就会影响我们计算 1 的结果。<ul>
<li>当然了，你也可以说我把移位的次数保留下来最后再减掉就好了，这种思路我也尝试过，真正实现起来比较复杂，有兴趣可以再试一下。</li>
</ul>
</li>
<li>既然补码右移麻烦，那就考虑左移。在最高上与 1 计数，然后不断左移。<ul>
<li>我们知道，一个 int 类型的变量在计算机里是 32 位，那么最高位为 1 的数应该就是：$-2^{31}$，这个数具体是多少，我是不会算了，真要实现就得调 math 里的 pow 方法，所以，我还是把这个思路放弃了。</li>
</ul>
</li>
</ol>
<p>好了，两种处理数的办法都行不通，看来对数本身进行处理是不太可能了，那就另辟蹊径，把用来进行与操作的 flag 进行移位：</p>
<ul>
<li>初始时，<code>flag = 1</code>（二进制表示：0000 0000 0000 0000 0000 0000 0000 0001）；</li>
<li><code>n &amp; flag</code>，就能知道 n 最低位是否为 1；</li>
<li>flag 左移 1 位，<code>flag=flag&lt;&lt;1</code>（二进制表示：0000 0000 0000 0000 0000 0000 0000 0010），再 <code>n &amp; flag</code>，就能知道 n 倒数第二位是否为 1；</li>
<li>循环下去，直至 flag 32 次左移后，1 溢出，<code>flag = 0</code>；</li>
<li>注意：<code>n &amp; flag</code> 是否需要 <code>count++</code> 的判别标准是 <code>(n &amp; flag)!=0</code>，原因仔细琢磨一下就知道了。</li>
</ul>
<h2 id="算法描述-10"><a href="#算法描述-10" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag)!=<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> bin(n).count(<span class="string">"1"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin(<span class="number">2</span>**<span class="number">32</span>+n).count(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure><br>还可以更简单，表达：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        nbin = bin(n &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">        <span class="keyword">return</span> nbin.count(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-5"><a href="#算法评价-5" class="headerlink" title="算法评价"></a>算法评价</h2><p>上面的思路中，我们知道不管数字 n 中 1 的个数为多少，我们都需要循环 32 次，有时候会造成大量的浪费；    </p>
<p>发现了网上广为流传的一个更加巧妙的思路：   </p>
<ul>
<li>先一个简单的例子，整数 12 的二进制表示为：1100，将其减一变为 1011，将得到的结果和原数进行按位与，得到 1000。</li>
<li>这样就可以发现一个<mark>规律</mark>：把一个整数减去 1 之后再和原来的整数做按位与，得到的结果相当于是把整数的二进制表示中最右边的一个 1 变成 0 。</li>
</ul>
<p>按照这个规律进行遍历，则函数的循环次数为二进制中一的个数次。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!= <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的exponent 次方。<br>保证：base 和 exponent 不同时为 0；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数学</code></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>求浮点数的整数次方，无非就是要分情况讨论：</p>
<ol>
<li>base=0，exponent=0，抛出异常；<ol>
<li>base=0，exponent != 0，返回0；</li>
<li>base != 0：<ol>
<li>exponent为正，直接求$base^{exponent}$；</li>
<li>exponent为负，先求,$base^{-exponent}$，再求$\frac{1}{base^{-exponent}}$；</li>
<li>exponent=0，直接返回1；</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>特别关注一下这里的<mark>快速幂算法</mark>；</p>
<h2 id="算法描述-11"><a href="#算法描述-11" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//用来标记最后返回情况</span></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Invalid input!"</span>);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//快速幂算法：</span></span><br><span class="line">            <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                flag = -<span class="number">1</span>;</span><br><span class="line">                exponent = -exponent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(exponent != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                    ans *= base;</span><br><span class="line">                base *= base;<span class="comment">// 翻倍</span></span><br><span class="line">                exponent&gt;&gt;=<span class="number">1</span>;<span class="comment">// 右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag&gt;=<span class="number">0</span>?ans:(<span class="number">1</span>/ans);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> base == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">"Invalid input!"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">                flag = <span class="number">-1</span>;</span><br><span class="line">                exponent = -exponent;</span><br><span class="line">            <span class="keyword">while</span> exponent != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> (exponent &amp; <span class="number">1</span>) == <span class="number">1</span>:</span><br><span class="line">                    ans *= base</span><br><span class="line">                base *= base</span><br><span class="line">                exponent&gt;&gt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans <span class="keyword">if</span> flag&gt;=<span class="number">0</span> <span class="keyword">else</span> (<span class="number">1</span>/ans)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="调整数组顺序使奇数位于偶数前"><a href="#调整数组顺序使奇数位于偶数前" class="headerlink" title="调整数组顺序使奇数位于偶数前"></a>调整数组顺序使奇数位于偶数前</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>典型的 <code>数组排序</code> 问题。    </p>
<p>第一种思路：新开辟一个数组，第一次遍历，把所有的奇数按顺序放入新数组；第二次遍历，把所有的偶数放入新数组。但是这样，带来了额外的空间开销，这在排序算法里是十分低效的，这里不再具体描述。    </p>
<p>第二种思路：利用常见的排序算法，插入排序、冒泡排序等，这里我选用冒泡排序；</p>
<h2 id="算法描述-12"><a href="#算法描述-12" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i]%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>]%<span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        odd = collections.deque()</span><br><span class="line">        x = len(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x):</span><br><span class="line">            <span class="keyword">if</span> array[x-i<span class="number">-1</span>]%<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                odd.appendleft(array[x-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> array[i]%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                odd.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> list(odd)</span><br></pre></td></tr></table></figure><br>主要是为了，学习 python 里，<code>collections.deque()</code>；</p>
<h2 id="算法评价-6"><a href="#算法评价-6" class="headerlink" title="算法评价"></a>算法评价</h2><p>上述，冒泡排序算法的时间复杂度为：$O(n^2)$    </p>
<p>但是对于上述冒泡排序算法，还可以进行进一步的改进：往第一层循环里插入旗标，一旦发现某次循环不再进行元素交换，就直接终止算法，这样，使该算法在最好情况下的时间复杂度变为：$O(n)$     </p>
<p>具体 <code>java</code> 算法描述：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reOrderArray(<span class="keyword">int</span> [] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//旗标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i]%<span class="number">2</span>!=<span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>]%<span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> array;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我有一个疑问：从循环次数的角度上来看，算法在最好情况下的时间复杂度下降了一个级别。但是，从编译器的角度来看，新变量的引入、循环赋值、以及每次循环都得进行的条件判断，又带来新的开销，这在性能上会不会出现得不偿失的情况？</p>
<hr>
<h1 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p><a id="LastKthNode"></a></p>
<p>链表的特点是只能从头到尾进行遍历，而现在要求的是输出链表的倒数第 k 个结点，所以我们迫切需要知道的就是链表的 length 了；    </p>
<p>一个简单的思路自然就是，先遍历一遍链表并记录结点数，这样就知道了链表 length，下次再遍历链表至第 length-k+1 个结点即可。<br>这种方法，两次遍历链表，两次循环，每次循环带来的时间复杂度都是 $O(n)$；<br>那进一步改进，考虑将循环减为一次。     </p>
<p>结合上面的思路，将两次循环合并：在链表遍历时定义两个指针。</p>
<ul>
<li>指针 1 从头至尾遍历，也就相当于length；</li>
<li>指针 2 在指针 1 遍历到第 k 个节点时，再跟着一起遍历；</li>
<li>这样，在指针 1 遍历至链表末尾时，刚好指针 2 所指向的结点就是链表的倒数第 k 个结点了。</li>
</ul>
<h2 id="算法描述-13"><a href="#算法描述-13" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode fir = <span class="keyword">null</span>;</span><br><span class="line">        ListNode las = <span class="keyword">null</span>;</span><br><span class="line">        fir = head;</span><br><span class="line">        las = head;</span><br><span class="line">        <span class="keyword">int</span> a=k;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fir!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fir = fir.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>)&#123;</span><br><span class="line">                las = las.next;</span><br><span class="line">            &#125;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> las;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head==<span class="literal">None</span> <span class="keyword">or</span> k&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p2=head</span><br><span class="line">        p1=head</span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> p2.next!=<span class="literal">None</span>:</span><br><span class="line">                p2=p2.next</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p2.next!=<span class="literal">None</span>:</span><br><span class="line">            p1=p1.next</span><br><span class="line">            p2=p2.next</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-7"><a href="#算法评价-7" class="headerlink" title="算法评价"></a>算法评价</h2><p>见解题思路部分；</p>
<hr>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题是链表里一个十分常见的操作，想要将链表反向，最重要的就是捋清各个指针的相互关系，循环实现每个结点的反转。具体的关系，直接参考代码，画图过一遍就能很清楚了。</p>
<h2 id="算法描述-14"><a href="#算法描述-14" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode p2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = head.next;</span><br><span class="line">            head.next = p1;</span><br><span class="line">            p1 = head;</span><br><span class="line">            head = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        p1 = <span class="literal">None</span></span><br><span class="line">        p2 = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            p2 = pHead.next</span><br><span class="line">            pHead.next = p1</span><br><span class="line">            p1 = pHead</span><br><span class="line">            pHead = p2</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-8"><a href="#算法评价-8" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度为：$O(n)$</p>
<hr>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题也是链表中十分常见的操作，我最开始想的是，合并的时候，直接把 List2 向List1 上合并，以此来节省再次开辟新链表的内存空间。<br>具体思路：先找到 List1 和 List2 的较小者，假设为 List1，然后循环遍历 List2，将 List2 的各个节点插入到 List1 中的合适位置。    </p>
<p>但是会存在一些问题：</p>
<ol>
<li>初始时，并不能确定 List1 和 List2 的大小关系，需要分情况讨论；</li>
<li>上述的想法中对 List2 的每个节点，都需要遍历 List1 来找合适位置，本身来说比较麻烦，而且算法在最坏情况下的时间复杂度$n*（n-1）$，太高。</li>
</ol>
<p>所以，我还是用最原始的方法，合并到一个新链表。以空间换时间。</p>
<h2 id="算法描述-15"><a href="#算法描述-15" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list = <span class="keyword">null</span>;<span class="comment">//合并链表的头指针</span></span><br><span class="line">        ListNode p = <span class="keyword">null</span>; <span class="comment">//合并链表过程中的中间指针</span></span><br><span class="line">        <span class="comment">//初始化合并链表的头指针</span></span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            list = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        p = list;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt;= list2.val)&#123;</span><br><span class="line">                p.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">                p = p.next;<span class="comment">//p指针始终指向合并链表的链尾，向尾部插入节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//某一个链表合并完后，直接将另一个链表的剩余部分，链接到合并链表的链尾</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        Head = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = Head</span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &gt;= pHead2.val:</span><br><span class="line">                Head.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                Head.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next       </span><br><span class="line">            Head = Head.next</span><br><span class="line">        <span class="keyword">if</span> pHead1:</span><br><span class="line">            Head.next = pHead1</span><br><span class="line">        <span class="keyword">elif</span> pHead2:</span><br><span class="line">            Head.next = pHead2</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure><br>下面是我参考的别人的代码，对比两个代码，思路基本相同，但是我认为，下面的更加巧妙，它的条件判断语句更少，可以好好领会一下。</p>
<h2 id="算法评价-9"><a href="#算法评价-9" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。<br>ps：我们约定空树不是任意一个树的子结构。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>二叉树</code></p>
<h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><p>又涉及到树的遍历，说实话，每次看到看到树相关的操作，莫名就有些抵触，因为太需要花脑细胞去分析递归关系了。<br>抵触归抵触，题目还得做。   </p>
<p>首先，弄清题目所谓的『子结构』:两个层次的含义，即要求每个结点的值相等，也要求树的结构相同；    </p>
<p>程序返回值，肯定就是 <code>false or true</code>，那就用一个标志 <code>flag</code> 表示。再然后就是，递归呗！关键问题：怎么递？分情况讨论；   </p>
<ol>
<li>比较两个树的根节点，若 <code>root1.val == root2.val</code>，再比较 <code>root1</code> 和 <code>root2</code> 的左右子树结构是否相同。<ul>
<li>这里就又有一个问题了，这里描述的操作和我们原函数不同，就需要再考虑编写一个递归函数：</li>
<li>递归比较：<code>root1.left.val == root2.left.val ?</code> 以及 <code>root1.right.val == root2.right.val ?</code>，只要有一次不等于就 <code>return false</code>；如果一直递归下去，tree1 先遍历完，<code>return false</code>，tree2 先遍历完，<code>return false</code>；</li>
</ul>
</li>
<li>若 <code>root1.val != root2.val</code>，接下来就递归的找：<code>root1</code> 的左子树是否包含 <code>root2</code> 以及 <code>root1</code> 的右子树是否包含 <code>root2</code>；</li>
</ol>
<p>思路捋清楚了，接下来，代码更加直观的描述；</p>
<h2 id="算法描述-16"><a href="#算法描述-16" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                flag = rootTree1EqualTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                flag = HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">rootTree1EqualTree2</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意下面这两个条件判断递归出口的顺序</span></span><br><span class="line">        <span class="comment">//特殊情况：有可能tree1和tree2同时遍历完毕，node1=node2=null，此时应该返回true；</span></span><br><span class="line">        <span class="comment">//因此要优先考虑node2；</span></span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node1.val != node2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootTree1EqualTree2(node1.left,node2.left) &amp;&amp; rootTree1EqualTree2(node1.right,node2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_subtree</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.is_subtree(A.left,B.left) <span class="keyword">and</span> self.is_subtree(A.right, B.right)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>Ps：源二叉树的镜像：将二叉树的所有结点的左右子结点交换得到的二叉树；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>算得上是树里面十分常见的操作了，主要思路就是循环递归交换左右子树。    </p>
<p>以这题为例子，实现一下树里面一些操作的非递归实现，主要利用 <code>栈</code> 和 <code>队列</code>；</p>
<h2 id="算法描述-17"><a href="#算法描述-17" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：递归算法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//结点交换</span></span><br><span class="line">        TreeNode p = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = p;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>java</code>，非递归算法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode p = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span> || p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = p.left;</span><br><span class="line">                p.left = p.right;</span><br><span class="line">                p.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root!=<span class="literal">None</span>:</span><br><span class="line">            root.left,root.right=root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字；<br>例如：</p>
<ul>
<li>如果输入如下 $4 \times 4$ 矩阵：<ul>
<li>$[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]$；</li>
</ul>
</li>
<li>则依次打印出数字： <ul>
<li>$1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10$。</li>
</ul>
</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题目，很明显就是画图找规律，既然如此，上图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Print-matrix-clockwise.jpeg" alt="顺时针打印矩阵"></p>
<p>规律：</p>
<ol>
<li>circle 由 row 和 col 的较小者决定，为：<code>circle = (row&lt;col?row:col)/2</code>；</li>
<li>当 row 和 col 的较小者为偶数时，按一层层的 circle 遍历完矩阵即可；</li>
<li>当 row 和 col 的较小者为奇数时，按一层层的 circle 遍历完矩阵后，矩阵中间会残留有小行或者小列（由矩阵的形状决定）没有遍历到的情况；</li>
</ol>
<h2 id="算法描述-18"><a href="#算法描述-18" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() ;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length; <span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length; <span class="comment">//列数</span></span><br><span class="line">        <span class="keyword">int</span> circle = (row&lt;col?row:col)/<span class="number">2</span>; <span class="comment">//圈数</span></span><br><span class="line">        <span class="comment">//处理所有的外圈情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circle;i++)&#123;</span><br><span class="line">            <span class="comment">//从左向右打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;col-i;j++)</span><br><span class="line">                result.add(matrix[i][j]);</span><br><span class="line">            <span class="comment">//从上往下打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;row-i;k++)</span><br><span class="line">                result.add(matrix[k][col-<span class="number">1</span>-i]);</span><br><span class="line">            <span class="comment">//从右向左的每行数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=col-i-<span class="number">2</span>;m&gt;=i;m--)</span><br><span class="line">                result.add(matrix[row-i-<span class="number">1</span>][m]);</span><br><span class="line">            <span class="comment">//从下往上的每一列数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=row-i-<span class="number">2</span>;n&gt;i;n--)</span><br><span class="line">                result.add(matrix[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行列的较小者为偶数，则不会存在需特殊处理的情况</span></span><br><span class="line">        <span class="keyword">if</span>((row&lt;col?row:col)%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//处理竖矩阵</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(row &gt; col)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=circle;i&lt;row-circle;i++)</span><br><span class="line">                result.add(matrix[i][circle]);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=circle;i&lt;col-circle;i++)</span><br><span class="line">                result.add(matrix[circle][i]);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        res=[]</span><br><span class="line">        row=len(matrix)</span><br><span class="line">        col=len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> row==<span class="number">1</span> <span class="keyword">and</span> col==<span class="number">1</span>:</span><br><span class="line">            res=[matrix[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange((min(col,row)+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">            [res.append(matrix[k][i]) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k,col-k)]</span><br><span class="line">            [res.append(matrix[j][col<span class="number">-1</span>-k]) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k,row-k) <span class="keyword">if</span> matrix[j][col<span class="number">-1</span>-k] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">            [res.append(matrix[row<span class="number">-1</span>-k][m]) <span class="keyword">for</span> m <span class="keyword">in</span> xrange(col<span class="number">-1</span>-k,k<span class="number">-1</span>,<span class="number">-1</span>) <span class="keyword">if</span> matrix[row<span class="number">-1</span>-k][m] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">            [res.append(matrix[n][k]) <span class="keyword">for</span> n <span class="keyword">in</span> xrange(row<span class="number">-1</span>-k,k<span class="number">-1</span>,<span class="number">-1</span>) <span class="keyword">if</span> matrix[n][k] <span class="keyword">not</span> <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 $O(1)$）。    </p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用 pop() 或者 min() 或者 top() 方法。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code></p>
<h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义一个动态数组 minlist，随时保存当前栈中的最小值，并用一个变量 min 记录当前最小值（其实，动态数组的最后一个元素就是最小值）。</p>
<ul>
<li>每次 <code>push</code> 时，比当前元素小，就将该值加入 minlist 末尾，并更新 min；<ul>
<li>注意：初始化，以及重复压入相同最小值至 minlist 的情况；</li>
</ul>
</li>
<li>每次 <code>pop</code> 时，直接考虑 pop 的元素值是否是当前最小值，“是”：更新；“否”：不用更新；</li>
</ul>
<h2 id="算法描述-19"><a href="#算法描述-19" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    ArrayList&lt;Integer&gt; minlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;() ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minlist.isEmpty())&#123;</span><br><span class="line">            min = node;</span><br><span class="line">            minlist.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node &lt;= min)&#123;</span><br><span class="line">            min = node;</span><br><span class="line">            minlist.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lenth = minlist.size();</span><br><span class="line">        k = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(k == min)&#123;</span><br><span class="line">            min = minlist.get(lenth-<span class="number">2</span>);</span><br><span class="line">            minlist.remove(lenth-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-10"><a href="#算法评价-10" class="headerlink" title="算法评价"></a>算法评价</h2><p>尽量避免循环的使用，从 <code>pop</code> 和 <code>push</code> 操作入手，保证时间复杂性在 $O(1)$ 级别。</p>
<hr>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出序列。假设压入栈的所有数字均不相等。（注意：这两个序列的长度是相等的）<br>例如：</p>
<ul>
<li>序列 $\{1,2,3,4,5\}$ 是某栈的压入顺序；</li>
<li>序列 $\{4,5,3,2,1\}$ 是该压栈序列对应的一个弹出序列；</li>
<li>但 $\{4,3,5,1,2\}$ 就不可能是该压栈序列的弹出序列。</li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code></p>
<h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据某入栈序列判断出栈序列，关键就是分析给出的出栈序列中，每个元素出栈时的位置，只要其所有元素的出栈位置合法（所谓合法：就是看是否满足栈的先进后出特点），那么该出栈序列就是一个合法的出栈序列；    </p>
<p>举个例子：</p>
<ul>
<li>给定入栈序列 <code>pushA = {1,2,3,4,5}</code>，判断序列 <code>popA = {4,5,3,2,1}</code> 是否合法：</li>
<li>第一个出栈元素是：4，那么我们就检查是在什么时候出栈的这个 4。<ul>
<li>遍历 pushA 并入栈（保留状态）；</li>
<li>比较栈顶元素值，直到栈顶为 4 时，即说明该位置为 4 出栈时刻；</li>
</ul>
</li>
<li>第二个出栈元素是：5<ul>
<li>首先比较当前栈顶元素是否为5，是：找到，并出栈5；否，继续遍历 pushA，寻找合适时刻；</li>
</ul>
</li>
<li>循环下去…</li>
<li>如果 popA 所有元素都能在合法时刻出栈，最终栈会为空；</li>
</ul>
<p>基于上述思路，将其归纳一下：就是遍历 pushA 依次入栈，在此期间，不停地将栈顶元素和 popA 元素比较（找到，就出栈，找不到就继续遍历 pushA 并入栈），最终，pushA 遍历完毕时，如果 popA 序列合法，栈应该为空。</p>
<h2 id="算法描述-20"><a href="#算法描述-20" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span> || pushA.length != popA.length) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;(); <span class="comment">//保存状态的辅助栈</span></span><br><span class="line">        <span class="keyword">int</span> lenth = pushA.length;</span><br><span class="line">        <span class="keyword">int</span> pA = <span class="number">0</span>; <span class="comment">//索引 popA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="comment">//比较 popA 的过程</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[pA])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                pA++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> 和 <code>树</code></p>
<h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题说白了就是二叉树的广度优先遍历。这里做一个扩展：</p>
<ul>
<li>广度优先遍历：利用队列实现</li>
<li>深度优先遍历：利用栈实现</li>
</ul>
<h2 id="算法描述-21"><a href="#算法描述-21" class="headerlink" title="算法描述"></a>算法描述</h2><p><strong>广度优先遍历：</strong>    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">//利用队列遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>深度优先遍历：</strong>    </p>
<p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">depthOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="comment">//利用栈遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。<br>假设输入的数组的任意两个数字都互不相同。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code> 和 <code>树</code></p>
<h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先介绍几种树：</p>
<ul>
<li>满二叉树：除叶结点外，所有结点的左右子结点都存在；</li>
<li>完全二叉树：若二叉树的深度为 h，除第 h 层外，其它 1～h-1 层构成一个满二叉树，并且第 h 层所有的结点都连续集中在最左边；</li>
<li>平衡二叉树：空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树也都是平衡树；</li>
<li>二叉搜索树：空树或者二叉树的所有结点，该结点比它的左子结点大，比它的右子结点小；</li>
</ul>
<p>回到题目，判断二叉搜索树的后序遍历，那么寻找二叉搜索树后序遍历序列的规律，可以发现该序列一定满足如下形式：</p>
<ul>
<li><code>[(根节点左子树的后序遍历序列，且该序列中所有元素均小于根节点)，(根节点右子树的后序遍历序列，且该序列中所有元素均大于根节点)，(根节点)]</code></li>
</ul>
<p>然后，基于上述形式，不断的递归判断序列的各个部分是否也满足上述形式即可。</p>
<h2 id="算法描述-22"><a href="#算法描述-22" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> IsSquenceOfBST(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end &lt;= start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找跟结点的左子树</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &gt; sequence[end]) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根结点的右子树的结点应该都比根节点大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j] &lt; sequence[end]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断根节点的左右子树是否构成二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> IsSquenceOfBST(sequence, start, i-<span class="number">1</span>) &amp;&amp; IsSquenceOfBST(sequence, i, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>网上还有一个十分巧妙的非递归算法，该算法的原理其实和递归算法完全相同：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = sequence.size();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==size)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从最后一个结点循环遍历</span></span><br><span class="line">        <span class="keyword">while</span>(--size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//二叉搜索树后序遍历，对于数组中每个元素来说，都可以将该元素前的数组分为两部分：第一部分所有元素都比它大，第二部分所有元素都比它小；</span></span><br><span class="line">            <span class="keyword">while</span>(sequence[i++]&lt;sequence[size]);</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++]&gt;sequence[size]);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(i&lt;size)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>路径：定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>注意: 在返回值的 list 中，数组长度大的数组靠前。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用递归遍历的思路，无非就是在深度优先遍历的基础上，加上每次遍历到叶结点时，判断一下路径和与目标是否相等；     </p>
<p>递归思路：</p>
<ul>
<li>从根节点出发，设置好递归出口；</li>
<li>递归调用：<ul>
<li>FindPath(root.left, target-root.val);</li>
<li>FindPath(root.right, target-root.val);</li>
</ul>
</li>
</ul>
<h2 id="算法描述-23"><a href="#算法描述-23" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：      </p>
<p>以下提供的是一种非递归实现方式，该方式基于二叉树的『非递归深度优先遍历算法』实现，但是有个缺陷：在查找失败回退时，需要查找某结点的父结点。算法的复杂度比较高。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stack;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//用来存储各条路径</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;<span class="keyword">return</span> result;&#125;</span><br><span class="line">        <span class="comment">//用来存储某条路径的节点</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存储当前的累加值</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二叉树深度优先遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            sum = sum + node.val;</span><br><span class="line">            res.add(node);</span><br><span class="line">            <span class="comment">//遍历到了叶结点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span> &amp;&amp; node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                    result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(res));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//不是目标路径，开始回退</span></span><br><span class="line">                    TreeNode next = stack.peek();</span><br><span class="line">                    TreeNode fathernext = getfather(root,next);</span><br><span class="line">                    <span class="keyword">int</span> size = res.size()</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(res.get(i) == fathernext.val)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            sum = sum - res.get(i);</span><br><span class="line">                            res.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非叶结点，继续</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常规解法，递归实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//初始化声明</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//保存当前总和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        path(root,target,result,res,sum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result, ArrayList&lt;Integer&gt; res,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">//遍历到叶结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123; </span><br><span class="line">                res.add(root.val);</span><br><span class="line">                result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(res));</span><br><span class="line">                <span class="comment">//查找完毕，回退一下，不影响后面子结点的查找</span></span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        path(root.left,target,result,res,sum);</span><br><span class="line">        path(root.right,target,result,res,sum);</span><br><span class="line">        <span class="comment">//遍历到了叶子结点，路径上结点值的和不是目标，也需要回退一次</span></span><br><span class="line">        res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。<br>注意：输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空；      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，想先谈一下深拷贝和浅拷贝：</p>
<ul>
<li>深拷贝：<ul>
<li>会拷贝所有的属性，并拷贝属性指向的动态分配的内存；</li>
<li>当对象和它所引用的对象一起拷贝时即发生深拷贝；</li>
<li>深拷贝相比于浅拷贝速度较慢并且花销较大；</li>
</ul>
</li>
<li>浅拷贝：<ul>
<li>按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝；</li>
<li>如果属性是基本类型，拷贝的就是基本类型的值；</li>
<li>如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象；</li>
</ul>
</li>
</ul>
<p>回到此题，题目想要我们做的就是一个深拷贝例子。回想一下在最初接触到链表时，一定也接触过链表的拷贝问题，此题就是在此基础上最了改进，给每个结点加入了一个复杂的 random 指针，如果理解了普通链表的复制过程，那么此题也就只是在原基础上多复制一下链表结点的一个指针罢了。     </p>
<p>两种思路：</p>
<ol>
<li>利用 hashmap 构造出，新旧链表的节点映射关系。通过两次循环，一次新建链表结点；第二次，赋值新链表结点的 next 和 random 指针，使链表结点构成链；</li>
<li>采用类似普通链表复制时的『复制拆分』策略：<ul>
<li>遍历链表，复制每个结点，如：复制结点 A 得到 A1，将结点 A1 插到结点 A 后面；</li>
<li>重新遍历链表，复制老结点的随机指针给新结点，如：A1.random = A.random.next;</li>
<li>拆分链表，将链表拆分为原链表和复制后的链表；</li>
</ul>
</li>
</ol>
<h2 id="算法描述-24"><a href="#算法描述-24" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：     </p>
<p>思路一：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode p1 = pHead;<span class="comment">//在hashmap中新建结点时，第一次循环遍历原链表的指针</span></span><br><span class="line">        RandomListNode p2 = pHead;<span class="comment">//修改hashmap中新结点的next和random时，第二次循环遍历原链表的指针</span></span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//通过原链表，在hashmap中建立新链表的每个结点，并构造出了新旧链表的映射关系</span></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(p1,<span class="keyword">new</span> RandomListNode(p1.label));</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给新链表各结点的next和random赋值</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.get(p2).next = map.get(p2.next);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(p2).next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(p2).random = map.get(p2.random);</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路二：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制原链表的结点，并将复制得到的新节点插入到原结点后；</span></span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode currentnext = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = currentnext;</span><br><span class="line">            currentNode = currentnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新遍历链表，复制原结点的random；</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//currentNode.next.random，新链表结点的random指针</span></span><br><span class="line">            <span class="keyword">if</span>(currentNode.random == <span class="keyword">null</span>)</span><br><span class="line">                currentNode.next.random = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                currentNode.next.random = currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;<span class="comment">//跨度为2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分链表出复制的链表</span></span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==<span class="keyword">null</span>?<span class="keyword">null</span>:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code> <code>树</code></p>
<h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题最常见的思路就是中序遍历二叉搜索树，然后用一个动态数组保存遍历结果，之后再通过该动态数组来修改二叉树的指针。这种方法需要新开辟内存空间，且也需要完整遍历二叉树，显然不是最佳方式。     </p>
<p>再之后，看到树，自然而然的就想到了递归算法，这个递归过程想起来也不算难，但是真的让我烧了不少脑细胞（里面的坑比较多），大致思路：</p>
<ul>
<li>先初始化一个链表的头尾指针为 null；</li>
<li>递归生成当前 root 结点的树，使之成为双向链表：<ul>
<li>将其左子树生成为双向链表，并更新 head 和 end 指针；</li>
<li>将当前 root 结点插入到双向链表，并更新 end 指针；</li>
<li>在现在的链表的基础上，继续生成其右子树的双向链表；</li>
</ul>
</li>
</ul>
<p>我们知道，递归算法效率很低，这里又想到树里面常用的队列和栈，于是提出第三种基于栈的算法实现，其主要原理和思路二的递归算法一样。（分析这个思路更加有利于递归算法的理解）     </p>
<h2 id="算法描述-25"><a href="#算法描述-25" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：     </p>
<p>思路一：基于 ArrayList 的实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrderTraverse1(pRootOfTree, list);</span><br><span class="line">        <span class="keyword">return</span> Convertlist(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历，将树的节点排好序，保存在 ArrayList 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode pRootOfTree, ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderTraverse1(pRootOfTree.left, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(pRootOfTree);</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrderTraverse1(pRootOfTree.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历list，修改指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convertlist</span><span class="params">(ArrayList&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            list.get(i).right = list.get(i + <span class="number">1</span>);</span><br><span class="line">            list.get(i + <span class="number">1</span>).left = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路二：递归实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode end = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        ConvertSub(pRootOfTree);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConvertSub</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>)&#123;    <span class="comment">//相当于初始链表为空，初始化链表</span></span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//将当前根节点加入到链表</span></span><br><span class="line">            end.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = end;</span><br><span class="line">            end = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>思路三：基于栈<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode end = <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将根节点在内其所有左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//弹出栈顶，相当于在树中回退出父节点</span></span><br><span class="line">            pRootOfTree = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;   <span class="comment">//链表初始化</span></span><br><span class="line">                head = pRootOfTree;</span><br><span class="line">                end = pRootOfTree;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//将当前节点插入链表</span></span><br><span class="line">                end.right = pRootOfTree;</span><br><span class="line">                pRootOfTree.left = end;</span><br><span class="line">                end = pRootOfTree;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找其右子节点</span></span><br><span class="line">            pRootOfTree = pRootOfTree.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-11"><a href="#算法评价-11" class="headerlink" title="算法评价"></a>算法评价</h2><p>这个题真的是烧了我不少的脑细胞，一开始想到用递归实现，可是递归的逻辑捋了半天也没捋明白，后来看了不少大神的算法，将其总结。<br>最后想说的，涉及树的算法，还是 <code>栈</code> 牛逼！</p>
<hr>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。<br>例如：输入字符串 $abc$，则打印出由字符 $a,b,c$ 所能排列出来的所有字符串 $abc, acb, bac, bca, cab 和 cba$。      </p>
<p>输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code> <code>动态规划</code> <code>递归</code></p>
<h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设求：$fun(a,b,c)$</p>
<ul>
<li>求：$a \times fun(b,c)$，$b \times fun(a,c)$，$c \times fun(a,b)$</li>
<li>$fun(b,c)=b \times fun(c)+c \times fun(b)$</li>
<li>$fun(c)=\{c\}$</li>
</ul>
<p>采用递归的思想：</p>
<ul>
<li>循环提取字符串的字符，作为新字符串的首字符，递归排序新字符串除首字符外的子字符串，然后合并出结果，最后对结果进行排序；</li>
</ul>
<p>有几个关键点：</p>
<ol>
<li>避免重复操作；</li>
<li>每次递归得到结果后，记得恢复字符串为原始状态；</li>
<li>最终的排序不要忘了；</li>
</ol>
<h2 id="算法描述-26"><a href="#算法描述-26" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder strbuilder = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//用来存放所有排序结果</span></span><br><span class="line">        result = PermutationSub(strbuilder);</span><br><span class="line">        Collections.sort(result);  <span class="comment">//按字典顺序排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">PermutationSub</span><span class="params">(StringBuilder str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//用来存放所有排序结果</span></span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(str.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//递归处理：循环将字符串中的字符都提到最前面来进行递归</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="comment">//和字符开头字符相同的字符，交换后是同一种排列，因此这里不做处理</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || str.charAt(i) != str.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="comment">//开始交换</span></span><br><span class="line">                    swap(str,<span class="number">0</span>,i);</span><br><span class="line">                    <span class="comment">//递归给出，str除首字符外其他字符的排序情况</span></span><br><span class="line">                    ArrayList&lt;String&gt; subresult = PermutationSub(<span class="keyword">new</span> StringBuilder(str.substring(<span class="number">1</span>)));</span><br><span class="line">                    <span class="comment">//将子结果与首字符合并后，加入result</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;subresult.size();j++)</span><br><span class="line">                        result.add(str.substring(<span class="number">0</span>,<span class="number">1</span>)+subresult.get(j));</span><br><span class="line">                    <span class="comment">//完成后，回到原始状态</span></span><br><span class="line">                    swap(str,i,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于字符交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(StringBuilder str, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str.charAt(b);</span><br><span class="line">        str.setCharAt(b, str.charAt(a));</span><br><span class="line">        str.setCharAt(a, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-12"><a href="#算法评价-12" class="headerlink" title="算法评价"></a>算法评价</h2><p>本题采用递归实现，每层递归都输出一个排列结果，没有造成额外的时间浪费；<br>每次提出字符串首字符，然后给出剩余字符串的排序结果，再与字符串的首字符合并，时间复杂度较高： $time(n)=n \times (time(n-1)+(n-1)+time(排序))$，为$O(n!)$</p>
<hr>
<h1 id="数组中出现次数超过一半的数组"><a href="#数组中出现次数超过一半的数组" class="headerlink" title="数组中出现次数超过一半的数组"></a>数组中出现次数超过一半的数组</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如：输入一个长度为 9 的数组 $\{1,2,3,2,2,2,5,4,2\}$。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h2><p>采用『数量削减』方式寻找数组中出现次数最多的元素：</p>
<ul>
<li>具体思路：假象一块区域（该区域只允许相同的数存在），然后循环遍历数组，将数组元素加到该区域，如果「加入数」与「区域内数」相同，则「区域内该数」的数量加一，否则数量减一，当区域内没有数存在时，更换区域内的数值为「加入数」。</li>
</ul>
<p>利用上述方法，找到数组中出现次数最多的元素后，再判断该数出现的次数是否超过数组长度一半。</p>
<h2 id="算法描述-27"><a href="#算法描述-27" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找数组中出现次数最多的元素</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123; <span class="comment">//区域内没有了数</span></span><br><span class="line">                current = array[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i] == current)</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到数组中出现次数最多的元素为 current，判断其出现次数是否超过数组长度一半</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] == current)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; (array.length/<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-13"><a href="#算法评价-13" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 n 个整数，找出其中最小的 K 个数。<br>例如：输入 $4,5,1,6,2,7,3,8$ 这 8 个数字，则最小的 4 个数字是 $1,2,3,4$    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code> <code>高级算法</code></p>
<h2 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h2><p>说白了，本题主要就是考查的各种排序算法，这里我选择时间复杂度为：$O(nlogn)$ 的快速排序算法。</p>
<h2 id="算法描述-28"><a href="#算法描述-28" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最小的k个数</span></span><br><span class="line">        ArrayList&lt;Integer&gt; kminlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> lenth = input.length; <span class="comment">//数组长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k&gt;lenth || k==<span class="number">0</span> || lenth==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> kminlist;</span><br><span class="line">       &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对input进行快排</span></span><br><span class="line">        sort(input,<span class="number">0</span>,lenth-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将低位的k个数放入kminlist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            kminlist.add(input[i]);</span><br><span class="line">        <span class="keyword">return</span> kminlist;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, index;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; hight) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        index = a[i]; <span class="comment">// 用子表的第一个记录做基准</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= index)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                a[i++] = a[j];<span class="comment">// 用比基准小的记录替换低位记录</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="comment">// 用比基准大的记录替换高位记录</span></span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = index;<span class="comment">// 将基准数值替换回 a[i]</span></span><br><span class="line">        sort(a, low, i - <span class="number">1</span>); <span class="comment">// 对低子表进行递归排序</span></span><br><span class="line">        sort(a, i + <span class="number">1</span>, hight); <span class="comment">// 对高子表进行递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>在古老的一维模式识别中，常常需要计算连续子向量的最大和，当向量全为正数的时候，问题很好解决。<br>但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？<br>例如：$\{6,-3,-2,7,-15,1,2,2\}$，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。<br>给一个数组，返回它的最大连续子序列的和。(子向量的长度至少是1)       </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题是一个简单的动态规划问题，并且只有保存值，不用保存路径：</p>
<ul>
<li>imax 为某处位置的最大连续子序列和：<ul>
<li>$imax = max(imax+array[i],array[i])$</li>
</ul>
</li>
<li>result：取最大的 imax；</li>
</ul>
<h2 id="算法描述-29"><a href="#算法描述-29" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];  <span class="comment">//当前最大连续子序列和</span></span><br><span class="line">        <span class="keyword">int</span> imax = array[<span class="number">0</span>];     <span class="comment">//包含了array[i]的最大连续子序列和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            imax = Math.max(imax+array[i], array[i]);</span><br><span class="line">            result = Math.max(imax, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="从-1-到-n-的整数中-1-出现的次数"><a href="#从-1-到-n-的整数中-1-出现的次数" class="headerlink" title="从 1 到 n 的整数中 1 出现的次数"></a>从 1 到 n 的整数中 1 出现的次数</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出任意非负整数区间中 1 出现的次数；<br>例如：$[1,13]$ 中包含 1 的数字有：$\{1,10,11,12,13\}$；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>查找</code> <code>数学</code></p>
<h2 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h2><p>谈到这个题目，真是困扰了我很长一段时间，最开始解题失误，我以为是求 1 到 n 位的整数中，「1」出现的次数，我也不知道我怎么会想成这样，既然都想了，也与本题思考方式大同小异，这里先把这个思路记录一下：</p>
<ul>
<li>首先，一位数，即：0 ~ 9<ul>
<li>没啥好说的，「1」出现了 1 次；</li>
</ul>
</li>
<li>两位数，即：0 ~ 99，分为两部分：0 ~ 9 ，10 ~ 99<ul>
<li>第一部分也就是刚刚计算的，我们用 $c_1$ 表示；</li>
<li>首位为 1 的数，$[10,11,…,19]$，「1」出现了 $10+c_1$ 次；</li>
<li>其余数中，有 1 出现的：$[21,31,…,91]$，「1」出现了 $8 \times c_1$ 次；</li>
<li>合计：<mark>$c_2=c_1+10+c_1+8 \times c_1=10+10 \times c_1$</mark></li>
</ul>
</li>
<li>三位数，即：0 ~ 999，同样分为两部分：0 ~ 99 ，100 ~ 999<ul>
<li>第一部分也就是刚刚计算的，我们用 $C_2$ 表示；</li>
<li>首位为 1 的数，$[100,101,…,199]$，「1」出现了 $100+c_2$ 次；</li>
<li>其余数，即：$[201,…,299,300,…,399,…,999]$，「1」出现了 $8 \times c_2$ 次；</li>
<li>合计：<mark>$c_3=c_2+100+c_2+8 \times c_2=100+10 \times c_2$</mark></li>
</ul>
</li>
<li>继续采用同样的思路分析：<ul>
<li>k 位数时，合计：<mark>$c_k=10^{k-1}+10 \times c_{k-1}$</mark></li>
</ul>
</li>
<li>现在递推关系式出来了，用递归实现？那当然是不存在的，高中数学，求数列通项公式（两边同时除以 $10^{k-1}$ 就可以了，最后求得：<mark>$c_n=10^{n-1} \times n$</mark></li>
</ul>
<p>好了，上面的思路虽然不是解决本题的，但是仔细分析和本题的关系也是十分紧密的，这里我实在是在这题上耽误了太多时间，这次就直接引用网上一个分析过程：</p>
<blockquote>
<p>个位：</p>
<ul>
<li>每 10 个数一轮回，每个轮回中，个位上出现一次 1；</li>
<li>对于任意整数，其最后不足一个轮回的部分，我们称为「露出」。这里，如果最后这个露出来的部分小于 1，则不可能出现 1;</li>
<li>归纳，个位上 1 出现的个数为：<code>(n/10)*1 + (n%10 != 0 ? 1:0)</code></li>
</ul>
<p>十位：</p>
<ul>
<li>十位数上出现 1 的情况是 10-19，每 100 个数为一轮回，每轮回 1 出现 10 次；</li>
<li>露出部分：<code>k = n%100</code><ul>
<li>如果露出来的数大于 19，那么直接算 10 个 1，因为 10-19 肯定会出现；</li>
<li>如果小于 10，那么肯定不会出现十位数的 1；</li>
<li>如果在 10-19 之间的，计算结果为：k-10+1（k为露出部分的数字）；</li>
</ul>
</li>
<li>归纳：<code>(n/100)*10 + (if(k&gt;19) 10 else if(k&lt;10) 0 else k-10+1)</code></li>
</ul>
<p>百位：<code>k = n%1000</code></p>
<ul>
<li>十位数上出现 1 的情况是 100-199，每一千个数一轮回，每轮回 1 出现 100 次；</li>
<li>露出部分：<ul>
<li>若：k &gt; 199，则有 100 个百位 1；</li>
<li>若：100 &lt;= k &lt;= 199，则有 k-100+1 个百位 1；</li>
<li>否则，露出部分 1；</li>
</ul>
</li>
<li>归纳：<code>(n/1000)*100 + (if(k&gt;199) 100 else if(k&lt;100) 0 else k-100+1)</code></li>
</ul>
<p>最终归纳：</p>
<ul>
<li>设 i 为所计算的位数（i=1：计算个位，i=10：计算十位），<code>k = n%(i*10)</code></li>
<li><strong><code>count(i) = (n/(i*10))*i + (if(k &gt; i*2-1) i else if (k &lt; i) 0 else k-i+1)</code></strong></li>
<li>将后半部分的条件判断再改变一下写法：</li>
<li><code>min( max( (n mod (i*10))−i+1 , 0), i)</code></li>
</ul>
</blockquote>
<h2 id="代码描述"><a href="#代码描述" class="headerlink" title="代码描述"></a>代码描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>)&#123;</span><br><span class="line">             <span class="keyword">long</span> diviver = i * <span class="number">10</span>;          </span><br><span class="line">             count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + <span class="number">1</span>, <span class="number">0</span>), i);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如：输入数组 ${3,32,321}$，则打印出这三个数字能排成的最小数字为 321323。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一个类似数组排序的问题，但是，排序的规则不再是数组里每个元素的大小，而是需要某种规则，使得最后连接而成的数字最小；    </p>
<p>最简单的思路：把数组所有可能的组合情况都记录到一个新数组，然后对新数组进行排序，求最小。也就是我们常说的暴力破解，这种方式时间复杂度有多高不言而喻，所以，我们需要一种新的思路。     </p>
<p>递归的思想就来了，既然要求数组 a 中的最小组合情况，我们可以把先求数组前 n-1 个元素的最小组合情况，然后与 a[n] 归并。递归？再 pass 掉；</p>
<p>其实，就像一开始说的，问题关键在于找数组排序规则。那么假设：如果我们找两元素 a1、a2 的排序，有两种拼接方式 a1+a2 或 a2+a1。若 a1+a2 &gt; a2+a1，则排序为 {a1，a2}，否则为 {a2，a1}；那么，基于这个规则，对数组进行排序即可解决问题，这里采用选择排序策略；</p>
<h2 id="算法描述-30"><a href="#算法描述-30" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//选择排序策略</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;numbers.length; j++)&#123;</span><br><span class="line">                <span class="comment">//将int型数组转换为字符串拼接，再转换成int型</span></span><br><span class="line">                <span class="keyword">int</span> sum1 = Integer.valueOf(numbers[i]+<span class="string">""</span>+numbers[j]);</span><br><span class="line">                <span class="keyword">int</span> sum2 = Integer.valueOf(numbers[j]+<span class="string">""</span>+numbers[i]);</span><br><span class="line">                <span class="comment">//排序规则</span></span><br><span class="line">                <span class="keyword">if</span>(sum1 &gt; sum2)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = numbers[j];</span><br><span class="line">                    numbers[j] = numbers[i];</span><br><span class="line">                    numbers[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序后的数组，拼接位字符串</span></span><br><span class="line">        String result = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">            result = result + numbers[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）；<br>例如：6、8 都是丑数，但 14 不是，因为它包含质因子 7；<br>习惯上我们把 1 当做是第一个丑数；<br>求按从小到大的顺序的第N个丑数。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>穷举</code></p>
<h2 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先，我们将丑数的定义抽象为数学公式就是 $m=2^x \times 3^y \times 5^z$；<br>所以，任意一个丑数本质上都是在它的前面数的基础上乘 2/3/5 所得到的，我们将这个过程手工模拟一遍来找规律：</p>
<ul>
<li>首先，假定一个 list 用来存放按从小到大顺序排列的丑数，初始时，里面包含第一个丑数 1；</li>
<li>接下来将求： $1 \times2$，$1 \times 3$，$1 \times 5$，在里面找最小的数为 2，将 2 存入队列，list=[1,2]；</li>
<li>然后就是求：$2 \times2$，$2 \times 3$，$2 \times 5$，接下来就是从：$1 \times 3$，$1 \times 5$，$2 \times2$，$2 \times 3$，$2 \times 5$，里面找最小数，但是这里 $2 \times 3$，$2 \times 5$ 很显然是要大于 $1 \times 3$，$1 \times 5$ 的，因此就是从：$1 \times 3$，$1 \times 5$，$2 \times2$ 里面找最小值。</li>
<li>发现规律没有？</li>
</ul>
<p>这么说可能还不够明显，画张图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/UglyNumber.png" alt="丑数">     </p>
<p>从图中，我们可以看出，假想有三个队列，分别代表 x2，x3，x4 的队列，队列中第一个元素被选中加入到 list 后，就将该元素出列，并把选中的元素 x2，x3，x4 并加入到相应的队列中去。这样实现起来，很清晰，可是，新引入的三个队列，造成了很大的空间浪费。   </p>
<p>再继续观察这个图，我们真正意义用到的永远只有三个数（x2，x3，x4 三个队列的队头），所以后面的元素根本用不上，引入队列的目的无非就是记录一下，当前进行到什么位置了。再观察其结构，既然是要记录位置，那我们直接在 list 上引入三个变量记录位置信息就可以了。</p>
<h2 id="算法描述-31"><a href="#算法描述-31" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index2=<span class="number">0</span>,index3=<span class="number">0</span>,index5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &lt; index)&#123;</span><br><span class="line">            <span class="keyword">int</span> m2=list.get(index2)*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m3=list.get(index3)*<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> m5=list.get(index5)*<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">int</span> min=Math.min(m2,Math.min(m3,m5));</span><br><span class="line">            list.add(min);</span><br><span class="line">            <span class="keyword">if</span>(min == m2) index2++;</span><br><span class="line">            <span class="keyword">if</span>(min == m3) index3++;</span><br><span class="line">            <span class="keyword">if</span>(min == m5) index5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个字符串（0 &lt;= 字符串长度 &lt;= 10000，全部由字母组成）中找到第一个只出现一次的字符，并返回它的位置,，如果没有则返回 -1（需要区分大小写）。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h2><p>一眼看去，就想到了 hashmap，先遍历整个字符串，将每种字符的情况以 [“字符首次出现位置”,”字符出现次数”] 的形式存入 hashmap。然后再次遍历 hashmap，直到找出出现次数为 1 的字符，并返回。   </p>
<p>强迫症，总觉得引入 hashmap 带来了额外的空间开销，是否还有其它解法，二刷的时候在仔细研究一下。</p>
<h2 id="算法描述-32"><a href="#算法描述-32" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length() == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.keySet().contains(str.charAt(i)))</span><br><span class="line">                map.put(str.charAt(i),<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(str.charAt(i),map.get(str.charAt(i))+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>python</code>：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s.count(s[i]) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 P。并将 P 对 1000000007 取模的结果输出。即输出：P%1000000007</p>
<ul>
<li>输入描述：<ul>
<li>题目保证输入的数组中没有相同的数字；</li>
<li>数据范围：<ul>
<li>对于 %50 的数据，size&lt;=10^4</li>
<li>对于 %75 的数据，size&lt;=10^5</li>
<li>对于 %100 的数据，size&lt;=2*10^5</li>
</ul>
</li>
</ul>
</li>
<li>例如：<ul>
<li>输入：1,2,3,4,5,6,7,0</li>
<li>输出：7</li>
</ul>
</li>
</ul>
<p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h2><p>求逆序对的数目，说白了就是在数组排序时，需要交换的元素次数。想到了「冒泡排序」，然后按照冒泡排序思路写了个算法去测试，结果报超时异常了，看来 $O(n^2)$ 的复杂度太高了。     </p>
<figure class="highlight java"><figcaption><span>[冒泡排序]</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lenth;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=lenth-<span class="number">1</span>;i&gt;k;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    m = array[i];</span><br><span class="line">                    array[i] = array[i-<span class="number">1</span>];</span><br><span class="line">                    array[i-<span class="number">1</span>] = m;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是想着改用其他排序算法，先考虑了「快排」，但是我们知道快排加速的基本原理就是减少比较和交换次数，那既然这样，利用快排找逆序对势必会少于真正逆序对的数目；</p>
<p>那又不想开辟过多的内存空间，唯一能想到的就是「归并排序」了。在归并排序的归并操作时，遇到交换就计数。</p>
<h2 id="算法描述-33"><a href="#算法描述-33" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并排序递归</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">        MergeSort(array, start, mid);</span><br><span class="line">        MergeSort(array, mid+<span class="number">1</span>, end);</span><br><span class="line">        Merge(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = start; <span class="comment">//代表第一个子序列头</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//第二个子序列头</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j]) <span class="comment">//第一个子序列元素小，不构成逆序对</span></span><br><span class="line">                temp[k++] = array[i++]; <span class="comment">//注意这个写法：先有temp[k]=array[i]，然后k++，i++</span></span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">//array[i]&gt;array[j]，由于子序列已经是排好序，则array[i，mid]都会与array[j]构成逆序对</span></span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">                count = (count + (mid-i+<span class="number">1</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end)</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;k; l++)&#123;</span><br><span class="line">            array[start+l] = temp[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        MergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。<br>注意：因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的；     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个链表的第一个公共结点，像不像找两个数组第一个相同的元素？<br>暴力解答：套用两层循环逐个遍历，时间复杂度 $O(n^2)$；</p>
<p>想其他更优办法：</p>
<ul>
<li>首先，必须想到的一点是：两个链表存在公共结点，而每个结点又只有一个后续结点，那么，从该公共结点开始，后续的所有结点都是被两个链表公用的；</li>
<li>例如：<ul>
<li>链表 1：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; <strong>5 -&gt; 6 -&gt; 7 -&gt; null</strong></li>
<li>链表 2：8 -&gt; 9 -&gt; <strong>5 -&gt; 6 -&gt; 7 -&gt; null</strong></li>
<li>公共结点为：5</li>
<li>链表 1 长度：4+3</li>
<li>链表 2 长度：2+3</li>
</ul>
</li>
</ul>
<p>发现没有，如果有某种办法，能将两个链表从尾向头遍历，那么就是找最后一个不相同的结点，当然了，这种方法是不可能的。<br>但是，有没有联想到我们之前做过的一个题：『<a href="#LastKthNode">链表中倒数第k个结点</a>』，当时就是通过两个指针“绕”，解决的。那么这里，是不是也可以这么绕？</p>
<ul>
<li>我们观察，链表 1 比链表 2 长 2，那么让链表 1 先遍历两个结点，链表再开始和链表 1 同时遍历，那么只要它们有公共结点，就一定能找到；</li>
<li>现在问题就是，怎么知道链表长度差？这里就需要绕一下了<ul>
<li>同样思路，先用两指针同时遍历链表，某个指针先遍历到链表（短的那个）末尾，然后将其换成头指针，换成哪个链表的头指针呢？<ul>
<li>如果换成短链表自己的头指针，那链表 2 比链表 1 领先，这肯定不是我们想要的；</li>
</ul>
</li>
<li>所以就换成长链表的头指针，然后再继续同时遍历，长链表的指针遍历的末尾，再换成短链表的头指针，OK，长度差就合理构造出来了；</li>
<li>有点绕，可以自己画图模拟一下，关系就能出来了。</li>
</ul>
</li>
</ul>
<h2 id="算法描述-34"><a href="#算法描述-34" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1 = (p1==<span class="keyword">null</span> ? pHead2 : p1.next);</span><br><span class="line">            p2 = (p2==<span class="keyword">null</span> ? pHead1 : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题主要分为两部分：</p>
<ol>
<li>在排序数组中找到这个数字；</li>
<li>统计这个数字出现的次数；</li>
</ol>
<p>问题还是相对简单的，关键在于降低时间复杂度，选用时间复杂度为：$O(logn)$ 的折半查找；</p>
<h2 id="算法描述-35"><a href="#算法描述-35" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(array.length==<span class="number">0</span> || k&lt;array[<span class="number">0</span>] || k&gt;array[array.length-<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; k)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; k)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到后进一步统计数字出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i&lt;array.length &amp;&amp; array[i]==k; i++)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; array[i]==k; i--)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注： java 中自带的二叉搜索函数：<code>binatySearch</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来源：https://www.nowcoder.com/questionTerminal/70610bf967994b22bb1c26f9ae901fa2?answerType=1&amp;f=discussion</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(array, k);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>; i &lt; array.length &amp;&amp; array[i]==k;i++)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; array[i]==k;i--)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p><a id="cengcishuchuerchashu"></a></p>
<h2 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一种简单思路，就是递归实现；   </p>
<p>第二种：非递归实现。   </p>
<ul>
<li>我们知道，求树的深度，其实就相当于对二叉树进行层次遍历，然后求层次遍历所经过的层数；</li>
<li>在广度优先的非递归算法中，我们采用的是队列实现：<ul>
<li>初始：先将根节点入队；</li>
<li>队头取出元素，然后将其左右孩子节点入队；</li>
<li>循环进行，直至队列为空；</li>
</ul>
</li>
<li>任意一棵二叉树广度优先遍历的结果，就是将二叉树每层的节点，从根节点开始，一层一层的存入数组中，所以，如果能知道二叉树每层的节点数，这个问题就很好解决了；</li>
<li>回到广度优先遍历算法的实现过程，其实每次「将其左右孩子节点入队」入的就是下一层结点，我们只需要将这个操作的次数记录下来，就能知道下一层的节点数了；</li>
<li>大致思路是这样，但是还有一些细节上的问题，详情见代码；</li>
</ul>
<h2 id="算法描述-36"><a href="#算法描述-36" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<p>递归实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">return</span> Math.max( <span class="number">1</span>+TreeDepth(root.left), <span class="number">1</span>+TreeDepth(root.right) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归算法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录每层的节点个数</span></span><br><span class="line">        <span class="comment">//遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            num = queue.size();<span class="comment">//每层结点出队完毕后，记录下一层结点的个数</span></span><br><span class="line">            <span class="comment">//每层的节点逐个出队，并将其左右孩子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            high++; <span class="comment">//遍历完了二叉树的一层，记录+1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h2><p>「平衡二叉树」：空树或者它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树也都是平衡树；</p>
<p>直接递归求各个节点的高度，只要发现某个结点的左孩子与右孩子高度差大于 1，就返回 false；</p>
<h2 id="算法描述-37"><a href="#算法描述-37" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        getHigh(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getHigh(root.left);;</span><br><span class="line">        <span class="keyword">int</span> right = getHigh(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>) flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> right &gt; left ? right+<span class="number">1</span>:left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题，第一思路就是 HashMap，第一次遍历数组：将数组的各数字及其出现的次数存入 hashmap，第二次遍历 hashmap，返回出现次数为 1 的数字；</p>
<p>思路二：</p>
<blockquote>
<p><strong>异或</strong>，对数组的所有元素进行异或处理，那么数组中出现两次的数都会被清除掉，最终只剩下只出现一次的两个数的异或结果。<br>但是这里，就有个问题，我知道了 A B 异或的结果，但是我要求的是 A 和 B 的值：    </p>
<ul>
<li>知道了 A、B 异或的结果，这个结果的二进制中的 1，表现的是 A 和 B 的不同的位。</li>
<li>我们就取第一个 1 所在的位数，假设是第 3 位，接着把原数组分成两组，分组标准是第 3 位是否为 1。<ul>
<li>一组：包含数字 A，另一组：包含数字 B<ul>
<li>这两个数组中，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。</li>
</ul>
</li>
<li>然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="算法描述-38"><a href="#算法描述-38" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：   </p>
<p>思路一：hashmap<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(array[i]))</span><br><span class="line">                map.put(array[i],<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                map.put(array[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth &amp;&amp; count&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(array[i]) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    num1[<span class="number">0</span>] = array[i];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    num2[<span class="number">0</span>] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路二：异或<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span>[] num1, <span class="keyword">int</span>[] num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">2</span>)&#123;</span><br><span class="line">            num1[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">            num2[<span class="number">0</span>] = array[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A B 异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> bitResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            bitResult ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A 异或 B 结果中第一个 1 的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = findFirst1(bitResult);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="comment">//分为两组异或</span></span><br><span class="line">            <span class="keyword">if</span>(isBit1(array[i], index))&#123;</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst1</span><span class="params">(<span class="keyword">int</span> bitResult)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((bitResult &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; index &lt; <span class="number">32</span>)&#123;</span><br><span class="line">            bitResult &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照 index 的位是否为 1，将原数组分组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((target &gt;&gt; index) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="和位-S-的连续正数序列"><a href="#和位-S-的连续正数序列" class="headerlink" title="和位 S 的连续正数序列"></a>和位 S 的连续正数序列</h1><h2 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h2><p>小明很喜欢数学，有一天他在做数学作业时，要求计算出 9~16 的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100(至少包括两个数)。没多久，他就得到另一组连续正数和为 100 的序列:18,19,20,21,22。现在把问题交给你，你能不能也很快的找出所有和为S的连续正数序列? Good Luck!    </p>
<p>输出描述:<br>输出所有和为 S 的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>穷举</code></p>
<h2 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到本题的知识点是「穷举」，那自然就知道思路是啥了，一个一个列举呗！<br>那问题关键就是怎样穷举，来保证一个不漏。<br>在看输出描述，要求序列内按从小至大的顺序，序列间按开始数字从小到大，很显然，本题的穷举也就自然应该分为两层循环：</p>
<ol>
<li>找所有序列：<ul>
<li><code>for(int i=0; i&lt;s; i++)</code></li>
</ul>
</li>
<li>找满足条件的序列:<ul>
<li><code>for(int j=i+1; j&lt;s; k++)</code></li>
</ul>
</li>
</ol>
<p>把它们合并起来看，像不像一个大小可变的「窗口」，要在整个数轴上滑动，找到所有和为 s 的窗口！     </p>
<p>窗口，就需要定义一个窗口左右边界，左边界就是上面循环中的 <code>i</code>，右边界就是上面循环中的 <code>j</code>；利用滑动窗口的思想，接下来就好办了，详情见代码。</p>
<h2 id="算法描述-39"><a href="#算法描述-39" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//开始滑</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)&#123;</span><br><span class="line">            <span class="comment">//当前窗口内数字总和，等差数列求和</span></span><br><span class="line">            <span class="keyword">int</span> val = (left+right)*(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//找到满足条件的窗口</span></span><br><span class="line">            <span class="keyword">if</span>(val == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                left++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，扩大窗口，右边界右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &lt; sum)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，当前窗口不再可能满足条件，滑动窗口到新的位置寻找，左边界右移</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="和为-s-的两个数字"><a href="#和为-s-的两个数字" class="headerlink" title="和为 s 的两个数字"></a>和为 s 的两个数字</h1><h2 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。      </p>
<p>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数学</code></p>
<h2 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h2><p>求递增数组中和为 s 的两个数，也是一个穷举问题，这里有两种穷举思路：从数组同一侧进行、从数组两端进行，但是题目要求输出两个数的乘积最小的，那自然就是从数组两端进行了，因为“相差越远乘积越小”；<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/TwoNumberSum.png" alt="TowNumberSum"></p>
<ul>
<li>若 <code>left + right == sum</code>，找到；</li>
<li>若 <code>left + right &gt; sum</code>，<code>right--</code>，right 右边的数据都过大而不可能满足条件；</li>
<li>若 <code>left + right &lt; sum</code>，<code>left++</code>，left 左边的数都过小不可能满足条件；</li>
</ul>
<h2 id="算法描述-40"><a href="#算法描述-40" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> lenth = array.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = lenth-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]+array[right] == sum)&#123;</span><br><span class="line">                list.add(array[left]);</span><br><span class="line">                list.add(array[right]);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[left]+array[right] &gt; sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-14"><a href="#算法评价-14" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$</p>
<hr>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。<br>例如，字符序列 <code>S=”abcXYZdef”</code>，要求输出循环左移 3 位后的结果，即 <code>“XYZdefabc”</code>。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题很简单，主要就是字符串的操作，先将原字符串分为两个字字符串，然后再将它们拼接在一起，但是需要注意的是，要考虑 <code>n&gt;length</code> 的情况。</p>
<h2 id="算法描述-41"><a href="#算法描述-41" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = str.length();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || lenth==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        n = n % lenth;</span><br><span class="line">        <span class="keyword">return</span> str.substring(n) + str.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h1><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是 “I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用两个栈实现，首先将整个句子全部反转（栈1）实现，但是我们知道，这样虽然将每个字句的顺序调整对了，但是字句里面的字符也被反转了，所以这个时候，再以空格为单位利用（栈2），将所有的子句再反转会来即可。    </p>
<p>也可以直接用StringBuffer.reverse（）实现，但是注意一下：</p>
<ul>
<li>String 没有 reverse（）用法；</li>
<li>StringBuffer.reverse（）返回的是 String；</li>
</ul>
<h2 id="算法描述-42"><a href="#算法描述-42" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)  <span class="keyword">return</span> str;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer(); <span class="comment">//存放结果</span></span><br><span class="line">        Stack&lt;String&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//用来反转句子</span></span><br><span class="line">        Stack&lt;String&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//反转子字符串</span></span><br><span class="line">        <span class="keyword">int</span> lenth = str.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始时，将整个句子入栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)</span><br><span class="line">            stack1.push(String.valueOf(str.charAt(i)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出栈，开始反转</span></span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不是空格，往新栈捣鼓，</span></span><br><span class="line">            <span class="keyword">if</span>(!stack1.peek().trim().isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//遇到空格，清空栈2，完成子字符串反转</span></span><br><span class="line">                <span class="keyword">while</span>(!stack2.isEmpty())</span><br><span class="line">                    result.append(stack2.pop());</span><br><span class="line">                result.append(stack1.pop());<span class="comment">//把stack1里面的空格加进来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty())</span><br><span class="line">            result = result.append(stack2.pop());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里为了写这个算法，有几个注意点：</p>
<ol>
<li>java 里的 stack 是没有 char 类型的，所以得将 char 类型用  <code>String.valueof()</code> 方法转换为字符串再进行处理；</li>
<li>判断字符串是否为空：<ul>
<li><code>String str1 = null;</code> 类型为空，表示这个字符串不指向任何的东西，如果这时候你调用它的方法，那么就会出现空指针异常；</li>
<li><code>String str2 = &quot;&quot;;</code> 表示它指向一个长度为 0 的字符串，这时候调用它的方法是安全的；</li>
<li>正确的写法是 <code>if(str1==null||str1.equals(&quot;&quot;)){...}</code> ，所以在判断字符串是否为空时，先判断是不是对象，如果是，再判断是不是空字符串 }</li>
</ul>
</li>
<li>在第 18 行处，直接写 <code>stack1.peek() != &quot; &quot;</code>，即使栈顶为空格，它也会一直返回 <code>true</code>：<ul>
<li>空格可以直接输入，例如：System.out.println(“ “)；</li>
<li>而如果用 String 表示那些符号的话，空格应该是 <code>\t</code>； </li>
</ul>
</li>
</ol>
<hr>
<h1 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h1><h2 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h2><p>LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王(一副牌原本是 54 张^_^)…他随机从中抽出了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票，嘿嘿！！<br>“红心 A，黑桃 3，小王，大王，方片 5”，“Oh My God!” 不是顺子…..LL 不高兴了，他想了想，决定大\小王可以看成任何数字，并且 A 看作 1，J 为 11，Q 为 12，K 为 13。上面的 5 张牌就可以变成 “1,2,3,4,5” (大小王分别看作 2 和 4)，“So Lucky!”。LL 决定去买体育彩票啦。<br>现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何，如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见，你可以认为大小王是 0。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题题目看着贼麻烦，属实让人头大。但是，仔细分析一下，就可以发现其实思路很简单，要检索手上的五张牌能否组成顺子，研究一下顺子的特点就能发现：“顺子最大值与最小值的差为 4”，那么是不是满足这个就行了呢？     </p>
<p>由于题目引入了大小王，将其定为 0，并且可以替代为任意数字，所以说这里组成顺子应该满足：“顺子最大值与最小值的差小于 5”，另外，肯定得保证顺子无对子出现（每个数字只出现一次）。   </p>
<p>归纳起来：</p>
<ol>
<li>max - min &lt; 5；//注意，min 不包括 0 </li>
<li>除 0 外没有重复的数字(牌)；</li>
<li>数组长度为 5 （五张牌）；</li>
</ol>
<h2 id="算法描述-43"><a href="#算法描述-43" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = numbers.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>]; <span class="comment">//统计出现的元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lenth; i++)&#123;</span><br><span class="line">            count[numbers[i]] = count[numbers[i]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] !=<span class="number">0</span> &amp;&amp; count[numbers[i]]&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt; max) max = numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; min &amp;&amp; numbers[i] != <span class="number">0</span>) min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt; <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="圆圈中最后剩下的数"><a href="#圆圈中最后剩下的数" class="headerlink" title="圆圈中最后剩下的数"></a>圆圈中最后剩下的数</h1><h2 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h2><p>每年六一儿童节，牛客都会准备一些小礼物去看望孤儿院的小朋友，今年亦是如此。HF 作为牛客的资深元老，自然也准备了一些小游戏。其中，有个游戏是这样的：首先，让小朋友们围成一个大圈。然后，他随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数，….，这样下去….，直到剩下最后一个小朋友，可以不用表演，并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下，哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 n-1 )<br>如果没有小朋友，请返回 -1；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code> <code>数学</code></p>
<h2 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h2><p>最简单粗暴的方法，就是用数组来模拟圆进行相关操作；然后，我比较懒，总觉得这种题肯定有某种数学规律，就画了数组，手动模拟了一下，发现这个过程是存在一个递推规律的：</p>
<ul>
<li>首先，我们初始所求为 <code>find(n,m)</code>，在进行一轮后，将 <code>(m-1)%n</code> 这个人出列，剩下的就是 <code>find(n-1,m)</code> 问题；</li>
<li>那么，就是将这两个关系式连接起来，问题的关键就是其序号的变化情况。<ul>
<li>原先，一个孩子出列后的序号为：<code>0,1,2,...,(m-1)%n,(m-1)%n+1,...,n-1</code>，为表述方便取 <code>k=m%n</code>，此时，新的一轮开始；</li>
<li>先将上述序号重排为 x：$k,k+1,…,n-1,0,1,…,k-3,k-2$，然后重新编号为 y：$0,1,2,…,n-3,n-2$；</li>
</ul>
</li>
<li>就能找到新编号 y 和旧编号 x 的关联：<code>x=(y+k) % n</code>；</li>
<li>现在递推关系就出来了：<code>f(n)=(f(n-1)+m) % n</code>，然后将其描述为非递归算法即可；</li>
</ul>
<h2 id="算法描述-44"><a href="#算法描述-44" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">            s=(s+m)%i;</span><br><span class="line">       <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>数组模拟圆的方法（weizier）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLastNumber</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>,step = <span class="number">0</span>, count = n;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;   <span class="comment">//跳出循环时将最后一个元素也设置为了-1</span></span><br><span class="line">            i++;          <span class="comment">//指向上一个被删除对象的下一个元素。</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=n) i=<span class="number">0</span>;  <span class="comment">//模拟环。</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] == -<span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//跳过被删除的对象。</span></span><br><span class="line">            step++;                     <span class="comment">//记录已走过的。</span></span><br><span class="line">            <span class="keyword">if</span>(step==m) &#123;               <span class="comment">//找到待删除的对象。</span></span><br><span class="line">                array[i]=-<span class="number">1</span>;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">//返回跳出循环时的i,即最后一个被设置为-1的元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<h1 id="求-1-2-…-n"><a href="#求-1-2-…-n" class="headerlink" title="求 1+2+…+n"></a>求 1+2+…+n</h1><h2 id="问题描述-10"><a href="#问题描述-10" class="headerlink" title="问题描述"></a>问题描述</h2><p>求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code></p>
<h2 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h2><p>相信大家都知道，这种数列就是所谓的高斯求和，求和公式为：$\frac{(n+1)\times n}{2}$，这里在拓展一下等差数列的求和公式：$\frac{(a_1+a_n)\times n}{2}$。    </p>
<p>可能本题的难点就是不让你用乘除法吧，那上面公式变形一下：$\frac{n+n^2}{2}$，现在，乘法运算改为指数运算，除法运算改为移位运算即可。</p>
<h2 id="算法描述-45"><a href="#算法描述-45" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n + (<span class="keyword">int</span>)Math.pow(n,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：<code>Math.pow()</code> 方法返回的是一个 <code>double</code> 类型的值，需要做一下强制转换；   </p>
<p>后来看了题解，发现有个很有意思的做法，叫 “<strong>短路求值</strong>”：</p>
<blockquote>
<p>来源：<a href="https://www.nowcoder.com/profile/248824047" target="_blank" rel="noopener">Iron欣</a></p>
<ul>
<li>expr1 &amp;&amp; expr2，若 expr=0，expr2 将不会进行求值，整个逻辑表达式的值已经确定为 0</li>
<li>expr1 || expr2，若 expr=1，expr2 将不会进行求值，整个逻辑表达式的值已经确定为 1<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n;</span><br><span class="line">            <span class="keyword">boolean</span> ans = (n&gt;<span class="number">0</span>)&amp;&amp;((sum+=Sum(n-<span class="number">1</span>))&gt;<span class="number">0</span>); </span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<hr>
<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><h2 id="问题描述-11"><a href="#问题描述-11" class="headerlink" title="问题描述"></a>问题描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点：<code>进制转化</code></p>
<h2 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h2><p>做体系结构的人看到这个题目对会有一种亲切感，说白了，就是要你实现一个加法器；<br>在加法器的实现过程中，我们知道应该分为两部分：①进位（通过与运算求）；②输出（通过异或运算求）；但是，在微结构中，我们可以直接对二进制数的每个位进行操作，而在 JAVA 中肯定就不行了。那就是需要找个办法来模拟这个过程：</p>
<ul>
<li>首先，我们知道，没有进位的加法很容易实现：<code>num1^num2</code>，但是这肯定不够还得加上数的进位部分才行；</li>
<li>某一位是否产生进位，是通过与门实现的，并且这一位产生的进位是加到高一位去的。所以，数的进位求法：<code>(num1&amp;num2)&lt;&lt;1</code></li>
<li>接下来，就是再将原值与进位相加，但是这个过程又可能有新进位运算产生，那么就需要继续递归调用上面的过程，直至没有新的进位产生，递归算法就出来了；    </li>
</ul>
<p>这里可能有人会有疑问，上述思想，递归算法结束的条件是不再有新的进位产生，即：<code>(num1&amp;num2)&lt;&lt;1 == 0</code>，那么这个运算最后一定会为 0 吗？    </p>
<ul>
<li>答案是肯定的，其实，只需要手动模拟一下，下一次的进位求解公式为；<code>((num1^num2)&amp;((num1&amp;num2)&lt;&lt;1))&lt;&lt;1</code>，只需要看 <code>(num1^num2)&amp;((num1&amp;num2)&lt;&lt;1)</code> 这个部分，发现没有，右边的数始终要比左边的数多一个左移操作，也就是说最低位始终添 0，与操作后，新的进位值最低位始终为 0。下一轮迭代时，这个 0 被左移移位，并且又在最低位产生一个 0，如此反复下去，进位值最终肯定会变为 0。</li>
</ul>
<h2 id="算法描述-46"><a href="#算法描述-46" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：   </p>
<p>递归实现，只需要一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num2 != <span class="number">0</span> ? Add(num1^num2,(num1&amp;num2)&lt;&lt;<span class="number">1</span>):num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本着能不递归就不递归的原则：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            sum = num1^num2;</span><br><span class="line">            carry = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><h2 id="问题描述-12"><a href="#问题描述-12" class="headerlink" title="问题描述"></a>问题描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数；<br>数值为 0 或者字符串不是一个合法的数值则返回 0；   </p>
<p>输入描述:</p>
<ul>
<li>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:</li>
<li>如果是合法的数值表达则返回该数字，否则返回0</li>
</ul>
<p>示例：</p>
<blockquote>
<p>输入：</p>
<ul>
<li>+2147483647</li>
<li>1a33</li>
</ul>
<p>输出：</p>
<ul>
<li>2147483647</li>
<li>0</li>
</ul>
</blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题看着的时候，属实有点头大感觉没啥思绪，特别是看到这个输入输出示例，更懵了，所以，这题一点一点来怼吧。    </p>
<p>首先，涉及字符串和整数的转换，那么必须知道的就是所对应的常见的 $128(0,2^7-1)$ 个「<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin&amp;fromid=99077&amp;fromtitle=ascii%E7%A0%81" target="_blank" rel="noopener">ASCII</a>」码，其中比较常见的几个：</p>
<ul>
<li>数字 ‘0-9’：对应 ASCII 码 ‘48-57’；</li>
<li>大写字母 ‘A-Z’：对应 ASCII 码 ‘65-90’；</li>
<li>小写字母 ‘a-z’：对应 ASCII 码 ‘97-122’； </li>
<li>空字符 NULL：对应 ASCII 码为 0；</li>
<li>在上述中间穿插各种特殊符号，具体讲上面的百度百科链接；</li>
</ul>
<p>然后，看了这题的题解，恍然大悟，其实就是要把这个按「字符串类型存的整数」转换成「整数类型存储」，瞬间觉得自己的理解能力属实有点差了。希望下次再看到这题的时候不会这么懵了…</p>
<p>注意一下，int 类型一共 32 位，在转换时需要做溢出判断：</p>
<ul>
<li><code>int MIN_VALUE = 0x80000000;</code>，int 类型数的最小值：$-2^31 = -2147483648$；</li>
<li><code>int MAX_VALUE = 0x7fffffff;</code>，int 类型数的最大值：$2^31-1 = 2147483647$;</li>
</ul>
<h2 id="算法描述-47"><a href="#算法描述-47" class="headerlink" title="算法描述"></a>算法描述</h2><p>『<a href="https://www.nowcoder.com/profile/236738700" target="_blank" rel="noopener">来源牛客网：pmzcc</a>』    </p>
<p><strong>解法 1</strong>：捕捉异常（有些钻空子嫌疑，但是很好用）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       Integer res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             res = <span class="keyword">new</span> Integer(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解法 2</strong>：正则表达式判断格式 + 结果溢出判断，<strong>效率低，很慢</strong></p>
<ul>
<li>不符合规则就返回 0；符合规则，得出结果后判断是否溢出；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// \d代表[0-9] 但是要写成\\d才行。</span></span><br><span class="line">        <span class="keyword">if</span>(!str.matches(<span class="string">"[+,-]?\\d+"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;  <span class="comment">//long类型，避免溢出。不能用int</span></span><br><span class="line">        <span class="comment">//按十进制数原理开始转换</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            res += Math.pow(<span class="number">10</span>,len-<span class="number">1</span>-i)*(str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (str.charAt(<span class="number">0</span>) == <span class="string">'-'</span> ? -res : res);</span><br><span class="line">        <span class="comment">//溢出就返回0，用long类型的res来比较，</span></span><br><span class="line">        <span class="comment">//如果定义为int res,那再比较就没有意义了，int范围为[-2147483648,2147483647]</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE || res&lt;Integer.MIN_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法 3</strong>：最优解<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || <span class="string">""</span>.equals(str.trim())) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断数字的正负性</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( arr[i] == <span class="string">'+'</span> || arr[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始转换</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;arr.length )&#123;</span><br><span class="line">            <span class="keyword">if</span>(isNum(arr[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = arr[i] - <span class="string">'0'</span>; <span class="comment">//当前位置字符对应的整数值，将 ASCII 类似的数字，转换成 int类型的数字</span></span><br><span class="line">                <span class="comment">//正数的溢出判断，实际上只有在最后一个迭代时才进行了比较，最大正数的末尾为7</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; (res &gt; Integer.MAX_VALUE/<span class="number">10</span> || res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; cur &gt;<span class="number">7</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//负数的溢出判断，负数的最大末位为8</span></span><br><span class="line">                <span class="keyword">if</span>(flag == -<span class="number">1</span> &amp;&amp; (res &gt; Integer.MAX_VALUE/<span class="number">10</span> || res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; cur &gt;<span class="number">8</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始转换</span></span><br><span class="line">                res = res*<span class="number">10</span> +cur;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不是数字</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符在 ascii 中对应的是否为数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c&gt;=<span class="string">'0'</span>&amp;&amp; c&lt;=<span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以，其实不用去记 ASCII 码的；</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>java 中字符串与整数装换的常用函数：</p>
<ol>
<li>String 转换成 int 类型：<ul>
<li><code>int i = Integer.parseInt([String]);</code><ul>
<li>//直接使用静态方法，不会产生多余的对象，但会抛出异常</li>
</ul>
</li>
<li><code>int i = Integer.valueOf(my_str).intValue();</code><ul>
<li>//<code>Integer.valueOf(s)</code> 相当于 <code>new Integer(Integer.parseInt(my_str))</code>，也会抛异常，但会多产生一个对象</li>
</ul>
</li>
<li>举例：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = Integer.parseInt(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = Integer.valueOf(str).intValue();</span><br><span class="line">&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>int 类型转换成 String 类：<ul>
<li>通过 <code>Integer.toString(i)</code> 方法转换：利用 <code>String s = Integer.toString(i);</code></li>
<li>通过 <code>String.valueOf(i)</code> 方法转换为字符串：利用 <code>String s = String.valueOf(i);//直接使用String类的静态方法，只产生一个对象</code></li>
<li>通过 ‘+’ 链接，将整型强制转换一下字符串：利用 <code>String s = &quot;&quot; + i;//会产生两个String对象</code></li>
</ul>
</li>
</ol>
<p>『<a href="https://blog.csdn.net/yangxingpa/article/details/79900732" target="_blank" rel="noopener">来源链接</a>』</p>
<hr>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="问题描述-13"><a href="#问题描述-13" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个长度为 n 的数组里的所有数字都在  0 到 n-1 的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中任意一个重复的数字。    </p>
<p>例如：如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路一：先排序，查找相邻位置；     </p>
<p>思路二：hashmap 存次数；   </p>
<p>思路三：对数组做标记</p>
<ul>
<li>我们知道，比较重复最常见的思路就是，存访问过的数据值进行比较，但是这样势必引入新的空间开销；</li>
<li>同样是采用做标志的方法，本题汇总规定了数组的所有元素数值不超过 n，这就给了我们很好的做标志方法；</li>
<li>每次访问一个值，我们就将其 +n，这样下次再访问这个位置时，只要是重复出现了，就会发现其值 &gt;n；</li>
</ul>
<h2 id="算法描述-48"><a href="#算法描述-48" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//开始打标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="comment">//位置被标记过</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= length)&#123;</span><br><span class="line">                numbers[i] = numbers[i]-length; <span class="comment">//回到原始值去访问相应位置</span></span><br><span class="line">                <span class="comment">//因为先做了-length的操作，避免自己访问自己的情况时把标记减掉了</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == i)&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断 numbers[i] 做索引访问对应的位置（那个位置被访问过话，那个位置的值就大于length），也就间接说明数组里有相同的元素</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[numbers[i]] &gt;= length) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[numbers[i]] = numbers[numbers[i]] + length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><h2 id="问题描述-14"><a href="#问题描述-14" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组 $A[0,1,…,n-1]$，请构建一个数组 $B[0,1,…,n-1]$，其中 B 中的元素 $B[i]=A[0] \ast A[1] \ast … \ast A[i-1] \ast A[i+1] \ast … \ast A[n-1]$。<br>不能使用除法。<br>注意：规定 $B[0] = A[1] \ast A[2] \ast … \ast A[n-1]$，$B[n-1] = A[0] \ast A[1] \ast … \ast A[n-2]$;     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h2><p>见到这题时，一开始，我想着先求 A[i] 的各个叠乘值，这样就能得到：</p>
<ul>
<li>A[0];</li>
<li>A[0] * A[1];</li>
<li>A[0] <em> A[1] </em> A[2];</li>
<li>……</li>
<li>A[0] <em> A[1] </em> A[2] <em> … </em> A[n-1];</li>
</ul>
<p>然后，再将题目所求的 B[i] 表示出来：</p>
<ul>
<li>B[0]   =   1  <em> A[1] </em> A[2] <em> … </em> A[n-1]</li>
<li>B[1]   = A[0] <em>   1  </em> A[2] <em> … </em> A[n-1]</li>
<li>B[2]   = A[0] <em> A[1] </em>   1  <em> … </em> A[n-1]</li>
<li>……</li>
<li>B[n-1] = A[0] <em> A[1] </em> A[2] <em> … </em> 1</li>
</ul>
<p>对比一下，我们只需要再将 A[i] 倒过来再求一次叠乘值：</p>
<ul>
<li>A[n-1]</li>
<li>A[n-1] * A[n-2]</li>
<li>……</li>
<li>A[n-1] <em> A[n-2] </em> A[n-3] <em> … </em> A[1];</li>
<li>A[n-1] <em> A[n-2] </em> A[n-3] <em> … </em> A[1] * A[0];</li>
</ul>
<p>接下来观察上面三个矩阵就知道，只需要将第 1 个和第 3 个合适的项乘到一起就能求得 B[i]；   </p>
<p>画个图：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/ProductArray.png" alt="ProductArray"><br>这样更加直观了，是不是好像也不用重新来定义两个新的数组，直接在 B[i] 上操作也可以，见代码。</p>
<h2 id="算法描述-49"><a href="#算法描述-49" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            mul = mul*A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] = B[i]*mul;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><h2 id="问题描述-15"><a href="#问题描述-15" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数用来匹配包括 <code>.</code> 和 <code>*</code> 的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含 0 次）；<br>在本题中，匹配是指字符串的所有字符匹配整个模式；<br>例如，字符串 <code>aaa</code> 与模式 <code>a.a</code> 和 <code>ab*ac*a</code> 匹配，但是与 <code>aa.a</code> 和 <code>ab*a</code> 均不匹配；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题主要是分类讨论，不要出现漏算的情况。    </p>
<p>就不再论述了，看了网上的分析觉得写的很详细，鉴于许多人的题解都出现了一模一样的分析，我也不知道谁是原作者，这里就没加链接了。</p>
<blockquote>
<p>首先，考虑特殊情况：</p>
<ul>
<li>两个字符串都为空，返回 true；</li>
<li>当第一个字符串不空，而第二个字符串空了，返回 false；<ul>
<li>而如果第一个字符串空了，第二个字符串非空，还是可能匹配成功的，比如第二个字符串是 <code>a*a*a*a*</code>，由于 <code>*</code> 之前的元素可以出现 0 次，所以有可能匹配成功；</li>
</ul>
</li>
</ul>
<p>之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。<br>但考虑到 pattern 下一个字符可能是 <code>*</code>， 这里我们分两种情况讨论：pattern 下一个字符为 <code>*</code> 或不为 <code>*</code>：</p>
<ul>
<li>pattern 下一个字符不为 <code>*</code>：<ul>
<li>这种情况比较简单，直接匹配当前字符。</li>
<li>如果匹配成功，继续匹配下一个；如果匹配失败，直接返回 false。</li>
<li>注意这里的“匹配成功”，除了两个字符相同的情况外，还有一种情况，就是 pattern 的当前字符为 <code>.</code>，同时 str 的当前字符不为 ‘\0’；</li>
</ul>
</li>
<li>pattern 下一个字符为 <code>*</code> 时，稍微复杂一些，因为 <code>*</code> 可以代表 0 个或多个。<ul>
<li>当 <code>*</code> 匹配 0 个字符时，str 当前字符不变，pattern 当前字符后移两位，跳过这个 <code>*</code> 符号；</li>
<li>当 <code>*</code> 匹配 1 个或多个时，str 当前字符移向下一个，pattern 当前字符不变。<ul>
<li>这里匹配 1 个或多个可以看成一种情况，因为：当匹配一个时，由于 str 移到了下一个字符，而 pattern 字符不变，就回到了上边的情况；</li>
<li>当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>本题其实更适合用 C/C++ 写，因为 C/C++ 的指针可以直接进行 +1 操作，相对方便，而 java 不行，虽然可以用 index 来替代，但是随时都需要判断数组溢出的情况。</p>
<h2 id="算法描述-50"><a href="#算法描述-50" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>C++</code> （<a href="https://www.nowcoder.com/profile/2189472" target="_blank" rel="noopener">来源：跪求offer养家糊口</a>）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//if the next character in pattern is not '*'</span></span><br><span class="line">        <span class="keyword">if</span> (*(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if the next character is '*'</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>) || match(str+<span class="number">1</span>, pattern);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>基于 <code>java</code>（基于上述思路修改）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchhelp(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchhelp</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span> (i == str.length &amp;&amp; j == pattern.length) <span class="comment">// 字符串和模式串都为空</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == pattern.length)<span class="comment">// 模式串为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if the next character in pattern is '*'</span></span><br><span class="line">        <span class="comment">//时时刻刻都要保证 i&lt;str.length，j&lt;pattern.length 否则越界</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (j+<span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[j+<span class="number">1</span>] == <span class="string">'*'</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j]))</span><br><span class="line">                <span class="keyword">return</span> matchhelp(str, i, pattern, j+<span class="number">2</span>) || matchhelp(str, i+<span class="number">1</span>, pattern, j);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> matchhelp(str, i, pattern, j+<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//if the next character is not '*'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j]))</span><br><span class="line">                 <span class="keyword">return</span> matchhelp(str, i + <span class="number">1</span>, pattern, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h1><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。<br>例如，字符串 <code>+100</code>,<code>5e2</code>,<code>-123</code>,<code>3.1416</code> 和 <code>-1E-16</code> 都表示数值。但是 <code>12e</code>,<code>1a3.14</code>,<code>1.2.3</code>,<code>+-5</code> 和 <code>12e+4.3</code> 都不是。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单明了的办法，就是正则表达式：<br><code>[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?</code></p>
<p>其中：</p>
<ul>
<li><code>[+-]?</code>：正负符号是否出现；</li>
<li><code>[0-9]*</code>：数字出现 0 或者任意次；</li>
<li><code>(\\.[0-9]*)?</code>：小数部分，出不出现都可以；</li>
<li><code>([eE][+-]?[0-9]+)?</code>：指数部分，出不出现都可以<ul>
<li><code>[eE]</code>：必须要有指数符号；</li>
<li><code>[+-]?</code>：正负符号出不出现都可以；</li>
<li><code>[0-9]+</code>：数字部分至少出现一次；</li>
</ul>
</li>
</ul>
<h2 id="算法描述-51"><a href="#算法描述-51" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String str1 = String.valueOf(str);</span><br><span class="line">        <span class="keyword">return</span> str1.matches(<span class="string">"[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h1><h2 id="问题描述-16"><a href="#问题描述-16" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>例如：当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g” 。当从该字符流中读出前六个字符 “google” 时，第一个只出现一次的字符是 “l”。   </p>
<p>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>字符串</code></p>
<h2 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h2><p>在此之前已经遇到过几次关于查找重复的问题了，之前我们基本都是采用 hashmap 来记录元素出现次数，然后比较来判断的。本题当然也可以。    </p>
<p>但是注意到本题判断的是字符流，和之前的数组中元素有点不太，这里是没有索引的（当然了，你也可以按照字符出现的顺序来建立索引，但是这样似乎太占内存空间了）。其实，可以直接用一个数组来存就行了：</p>
<ul>
<li>ASCII 一共 128 个字符，也就是说，字符流中出现的字符可能有 128 种情况；</li>
<li>因此，建立一个 128 大小的数组，利用字符的 ASCII码 的十进制作为数组索引，元素值代表该字符出现的次数；</li>
<li>说白了，就是相当于用数组做了一个 hashmap；</li>
</ul>
<p>现在，解决了出现次数的问题，但是题目还有一个要求就是让我们返回第一个只出现一次的字符，所以相当于还得对这些字符出现的顺序做一个记录，根据这里的规则：先进先出，很容易就想到了队列，那怎样来完成这个逻辑呢：</p>
<ul>
<li>元素首次出现，就入队；</li>
<li>当字符流中出现队头字符，该字符出队，但是这个时候，不能直接返回新的队头（因为，按照前面的逻辑，在字符流字符的判断时，只关心了队头，但是队列中的其他元素可能出现过，所以，这里还需要做一下判断），在数组检查新队头字符出现次数，为 1，则返回；否则，将该队头出队，继续检查新的队头；</li>
</ul>
<h2 id="算法描述-52"><a href="#算法描述-52" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numcount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numcount[ch] == <span class="number">0</span>)</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        numcount[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            res = queue.peek();</span><br><span class="line">            <span class="keyword">if</span> (numcount[res] == <span class="number">1</span>) <span class="comment">//判断是否脱单了，没脱单则输出</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span> queue.remove(); <span class="comment">//脱单了就移出队列，它不会再回来了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h1><h2 id="问题描述-17"><a href="#问题描述-17" class="headerlink" title="问题描述"></a>问题描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一眼看到这个题，脑海里只有一个思路：构造辅助存储空间，但是这题要是只有这种解法，自然也就没意思了。       </p>
<p>想了一会也没什么思路，就去看了题解（『<a href="https://leetcode.com/problems/linked-list-cycle-ii/discuss/44774/Java-O(1" target="_blank" rel="noopener">原文链接</a>-space-solution-with-detailed-explanation)』，这里做一个搬运工），捋一遍思路：</p>
<ul>
<li>主打方法：<strong>双指针法</strong><ul>
<li>一快一慢指针。快指针每次跑两个结点，慢指针每次跑一个结点；</li>
<li>如果存在一个圈，最终快指针是能追上慢指针的；</li>
</ul>
</li>
<li>假设一个模型（可以自己画个图）：<ul>
<li>快慢指针相遇的点：p；</li>
<li>环的入口在点：q；</li>
<li>从链表头节点到点 q 距离为 A；</li>
<li>q、p 两点间距离为 B，p、q 两点间距离为 C；</li>
<li>快指针的速度是慢指针的两倍，因此得到关系式：$2 \times (A+B) = A+B+C+B$，因此，求得：$C=A$</li>
</ul>
</li>
<li>找入口节点：<ul>
<li>新建一个另外的指针 slow2，让他从头节点开始走，每次只走下一个；原 slow 指针继续保持原来的走法，和 slow2 同样，每次只走下一个；</li>
<li>由于 $A=C$，在遍历完 A/C 个节点后，这两个指针最终一定会在入口处相遇，返回此时的节点即可；</li>
</ul>
</li>
</ul>
<p>刷题，刷到这，发现凡是涉及链表的操作，都可以将其思路归结如下：</p>
<ol>
<li>链表嘛，自然离不开指针，所以首先来个指针遍历一定不会有错；</li>
<li>因为链表遍历的特点，<strong>走过之后不留痕迹</strong>（遍历过后，是没法回退的），而这往往会成为链表考点。<ul>
<li>最简单粗暴的方法就是开辟新的空间存 “痕迹”；但是这一般不推荐。</li>
</ul>
</li>
<li>存痕迹的方法很多，不能仅仅局限在数组、hashmap 等这种数据结构上，不知道你有没有发现，链表要用到所谓的痕迹，很多时候都只需要用到前面一个或者几个（很少）的节点信息，直接用变量（指针）存就行了；<ul>
<li>常用的思路就是，用一个指针正常遍历，另外定义一个指针按照 “某种规则” 跟着遍历；</li>
<li>常用的 “规则”：从速度差，时间差上去考虑；</li>
</ul>
</li>
</ol>
<h2 id="算法描述-53"><a href="#算法描述-53" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode slow2 = pHead;</span><br><span class="line">                <span class="keyword">while</span>(slow2 != slow)&#123;</span><br><span class="line">                    slow2 = slow2.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个小思考：我们将快结点的速度定义为慢结点的两倍，那如果是：“三倍”、“四倍”、……呢？算法的时间复杂度会不会更低一些？</p>
<ul>
<li>这个具体怎样规定速度最合适，是需要根据链表结构来确定的，是受环的大小以及链表头结点到环入口长度这两点的影响。</li>
</ul>
<hr>
<h1 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h1><h2 id="问题描述-18"><a href="#问题描述-18" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如：链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>链表</code></p>
<h2 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚刚总结完思路，这里正好用的上：</p>
<ul>
<li>删除链表重复元素，考查的就是链表遍历过程中无法保留历史信息特点；</li>
<li>思路一：构造辅助存储，这里不再阐述；</li>
<li>思路二：构造双指针存历史记录；<ul>
<li>pre：正常遍历指针</li>
<li>cur：遍历重复结点的指针</li>
<li>删除：<code>pre = cur.next</code></li>
<li>关键点：边界处理（仔细查看代码的处理逻辑）</li>
</ul>
</li>
</ul>
<h2 id="算法描述-54"><a href="#算法描述-54" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给链表手工构建一个头结点，用于头结点重复被删除的情况</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        <span class="comment">//初始化指针</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val)&#123; <span class="comment">//遇到重复结点</span></span><br><span class="line">                <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.val == cur.val) <span class="comment">//循环使cur指向最后一个重复的结点</span></span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                <span class="comment">// pre 连接新结点</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法评价-15"><a href="#算法评价-15" class="headerlink" title="算法评价"></a>算法评价</h2><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>
<hr>
<h1 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h1><h2 id="问题描述-19"><a href="#问题描述-19" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<br>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M 热度指数：290756<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h2><p>中序遍历的下一个结点，所以需要对树进行分类讨论，我本来写了一段，但是感觉绕来绕去，不太清晰，刚好发现了一个十分简洁清晰的版本，这里引入一下（来源：<a href="https://www.nowcoder.com/profile/773262" target="_blank" rel="noopener">小河沟大河沟</a>）。</p>
<p><img src="./image/../../../_images/Algorithm/Finger-offer67/BinaryTreeNextNode.png" alt="BinaryTreeNextNode"></p>
<blockquote>
<p>结合图，我们可发现分成两大类：</p>
<ol>
<li>有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） </li>
<li>没有右子树的，也可以分成两类:<ul>
<li>a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； </li>
<li>b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点…直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="算法描述-55"><a href="#算法描述-55" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//有右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从右子树找最左边的结点</span></span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无右子树，看父结点</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找当前结点是其父结点的左孩子的结点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//回退到了根节点，pNode 就是最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><h2 id="问题描述-20"><a href="#问题描述-20" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>树</code></p>
<h2 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h2><p>涉及到树，这里利用递归进行左右子树的比较很容易实现，同样本着能不递归就不递归的原则，利用栈的思想实现。实现起来的主要思路和递归一样，要注意的就是，每次入栈出栈操作都应该保证镜像结点成对同时进行操作。</p>
<h2 id="算法描述-56"><a href="#算法描述-56" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pRoot.left);</span><br><span class="line">        stack.push(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//成对出栈比较镜像结点</span></span><br><span class="line">            TreeNode right = stack.pop();</span><br><span class="line">            TreeNode left = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//不构成镜像</span></span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//左右应保持对称的结点成对进栈</span></span><br><span class="line">            stack.push(left.left);</span><br><span class="line">            stack.push(right.right);</span><br><span class="line">            stack.push(left.right);</span><br><span class="line">            stack.push(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h1><h2 id="问题描述-21"><a href="#问题描述-21" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。      </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code>  <code>树</code></p>
<h2 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先应该联想起来的就是二叉树的广度优先遍历，这两个有着异曲同工之妙。<br>两种办法，一般用队列实现，但是这里会涉及反转，比较麻烦，采用 reverse() 方法效率太低。所以，不如直接采用栈来实现。毕竟，栈和反转、树都是经常关联在一起的。   </p>
<p>本题分析思路：</p>
<ul>
<li>既然是层次遍历，那每次对栈进行进栈出栈都应该是以层为单位来循环的；</li>
<li>涉及到反转，应该是用两个栈以每层为单位来进行两个栈的互相捣鼓；</li>
<li>然后就是分析，怎么捣鼓？画图。</li>
</ul>
<p>本题思路：</p>
<ul>
<li>先把根节点入栈 1；</li>
<li>栈 1 栈顶元素出栈并记录，把根节点的<strong>左右</strong>孩子结点入栈 2；栈 1 空；</li>
<li>栈 2 栈顶元素出栈并记录，注意：因为要反转，这里孩子节点应该是按<strong>右左</strong>的顺序入栈 1，循环，直至栈 2 空，第二层遍历完毕；</li>
<li>循环进行……</li>
</ul>
<h2 id="算法描述-57"><a href="#算法描述-57" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//标记对哪个栈进行操作，就就是我们所谓的奇偶行</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">//最终结果</span></span><br><span class="line">        Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//没层的遍历结果</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop = s1.pop();</span><br><span class="line">                    res.add(pop.val);</span><br><span class="line">                    <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>) s2.add(pop.left);</span><br><span class="line">                    <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>) s2.add(pop.right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res); <span class="comment">//把本层的结果放入结果中</span></span><br><span class="line">                flag = <span class="number">2</span>; <span class="comment">//下一次就是对 s2 操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">                    TreeNode pop = s2.pop();</span><br><span class="line">                    res.add(pop.val);</span><br><span class="line">                    <span class="keyword">if</span>(pop.right != <span class="keyword">null</span>) s1.add(pop.right);</span><br><span class="line">                    <span class="keyword">if</span>(pop.left != <span class="keyword">null</span>) s1.add(pop.left);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(res); <span class="comment">//把本层的结果放入结果中</span></span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//下一次就是对 s2 操作</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h1><h2 id="问题描述-22"><a href="#问题描述-22" class="headerlink" title="问题描述"></a>问题描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。   </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> <code>树</code></p>
<h2 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题和上一题是同一类型的，而且在之前也有讨论过类似的（<a href="#cengcishuchuerchashu">返回到该题</a>），只需要使用个队列，然后用变量记录一下每层的结点数就可以。当然也可以像上一题，在这里用两个队列实现。</p>
<h2 id="算法描述-58"><a href="#算法描述-58" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录每层的节点个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历二叉树</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            num = queue.size();<span class="comment">//每层结点出队完毕后，记录下一层结点的个数</span></span><br><span class="line">            <span class="comment">//每层的节点逐个出队，并将其左右孩子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="问题描述-23"><a href="#问题描述-23" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树；</p>
<ul>
<li>二叉树的序列化：<ul>
<li>把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存；</li>
<li>序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</li>
</ul>
</li>
<li>二叉树的反序列化：<ul>
<li>根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树；</li>
</ul>
</li>
</ul>
<p>例如，我们可以把一个只有根节点为 1 的二叉树序列化为 “1,”，然后通过自己的函数来解析回这个二叉树；    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>队列</code> <code>树</code></p>
<h2 id="解题思路-60"><a href="#解题思路-60" class="headerlink" title="解题思路"></a>解题思路</h2><p>关键在于捋清递归的思路；</p>
<h2 id="算法描述-59"><a href="#算法描述-59" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + <span class="string">"!"</span> + Serialize(root.left) + <span class="string">"!"</span> + Serialize(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] s = str.split(<span class="string">"!"</span>); <span class="comment">//将序列化之后的字符串用!分隔符转化为字符串数组</span></span><br><span class="line">        index++; <span class="comment">//索引每次加一</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!s[index].equals(<span class="string">"#"</span>)) &#123;  <span class="comment">//不是叶子节点</span></span><br><span class="line">            treeNode = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">            treeNode.left = Deserialize(str);</span><br><span class="line">            treeNode.right = Deserialize(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="二叉搜索树的第-k-个节点"><a href="#二叉搜索树的第-k-个节点" class="headerlink" title="二叉搜索树的第 k 个节点"></a>二叉搜索树的第 k 个节点</h1><h2 id="问题描述-24"><a href="#问题描述-24" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一棵二叉搜索树，请找出其中的第 k 小的结点；    </p>
<p>例如：（5，3，7，2，4，6，8）中，按结点数值大小顺序第 3 小结点的值为 4；</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>栈</code> <code>树</code></p>
<h2 id="解题思路-61"><a href="#解题思路-61" class="headerlink" title="解题思路"></a>解题思路</h2><p>找二叉搜索树的第 k 小节点，相当于需要先对二叉树节点进行排序，才能知道第 k 小的节点是哪个。<br>而二叉搜索树的中序遍历结果，即将二叉搜索树的各个节点从小到大的排列，我们用栈来完成其中序遍历，而栈 pop 的序列就是二叉搜索树从小到大的输出序列。所以，只需要记录栈 pop 的次数，第 k 次 pop 时就是我们要找的数。</p>
<h2 id="算法描述-60"><a href="#算法描述-60" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = pRoot;</span><br><span class="line">        <span class="comment">//利用栈实现中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123; <span class="comment">//只要当前节点不为空就找左孩子</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//当前节点为空，出栈其父节点，然后找右节点</span></span><br><span class="line">                node = stack.pop(); <span class="comment">//出栈的顺序就是中序遍历的结果，也即从小到大的排列</span></span><br><span class="line">                <span class="keyword">if</span>(--k &lt;= <span class="number">0</span>)&#123;  <span class="comment">//计数第 k 小的数</span></span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="数据流中的位数"><a href="#数据流中的位数" class="headerlink" title="数据流中的位数"></a>数据流中的位数</h1><h2 id="问题描述-25"><a href="#问题描述-25" class="headerlink" title="问题描述"></a>问题描述</h2><p>如何得到一个数据流中的中位数？</p>
<ul>
<li>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值；</li>
<li>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值；</li>
</ul>
<p>使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。     </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>进制转化</code></p>
<h2 id="解题思路-62"><a href="#解题思路-62" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题目一开始没明白它具体的意思，不太懂使用 Insert() 方法读取数据流是要干嘛，后来参看题解才知道，Insert() 方法主要是为了让我们能够构建一个数据结构，便于后面求解中位数。       </p>
<p>知道题目意思后，最先想到的思路就是把 Insert() 方法写成类似插入排序的算法，从而构建一个排好序的动态数组，但是这样有个问题就是每次插入的时候可能都需要移动整个数组，时间复杂度太高。    </p>
<p>然后又想到了 Insert() 方法只负责将数据存入数组，在使用 GetMedian() 方法时，就先对数组进行排序，但是这样时间复杂度依旧很高。时间关系，来不及再思考别的方法，等二刷的时候在仔细思考一下，直接参考了题解，用 <code>优先队列 PriorityQueue（堆）</code> 实现。</p>
<h2 id="算法描述-61"><a href="#算法描述-61" class="headerlink" title="算法描述"></a>算法描述</h2><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆，用该堆记录位于中位数后面的部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大顶堆，用该堆记录位于中位数前面的部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="comment">//优先队列中的常用方法有：增加元素，删除栈顶，获得栈顶元素，和队列中的几个函数应该是一样的</span></span><br><span class="line">    <span class="comment">//offer peek poll,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可，所以我们要保证小顶堆中的元素的个数。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><h2 id="问题描述-26"><a href="#问题描述-26" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<br>例如：如果输入数组 <code>{2,3,4,2,6,2,5,1}</code> 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 <code>{4,4,6,6,6,5}</code>；</p>
<ul>
<li>针对数组 <code>{2,3,4,2,6,2,5,1}</code> 的滑动窗口有以下 6 个： </li>
<li><code>{[2,3,4],2,6,2,5,1}</code>，<code>{2,[3,4,2],6,2,5,1}</code>，<code>{2,3,[4,2,6],2,5,1}</code>，<code>{2,3,4,[2,6,2],5,1}</code>，<code>{2,3,4,2,[6,2,5],1}</code>，<code>{2,3,4,2,6,[2,5,1]}</code>；    </li>
</ul>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code></p>
<h2 id="解题思路-63"><a href="#解题思路-63" class="headerlink" title="解题思路"></a>解题思路</h2><p>滑动窗口类型的题目接触的不多，但是我比较习惯直接用指针来遍历数组，对比网上流传的好多采用双端队列或者其他数据结构的，还是感觉用在这里有点杀猪用牛刀。（也是我比较菜，对高级数据结构掌握还不够熟练，等一刷结束，打算把这些数据结构，或者常用算法好好总结一番）</p>
<h2 id="算法描述-62"><a href="#算法描述-62" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span>||size == <span class="number">0</span> ||size&gt;num.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = num[<span class="number">0</span>];<span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;  <span class="comment">//记录最大值下标，防止最大值过期</span></span><br><span class="line">        <span class="keyword">int</span> len = num.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size-<span class="number">1</span>;  <span class="comment">//滑动窗口边界</span></span><br><span class="line">        <span class="comment">//开始在数组中滑动窗口</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            <span class="keyword">if</span>((index &gt;= left)&amp;&amp;(index &lt;= right))&#123; <span class="comment">//保证最大值未过期</span></span><br><span class="line">                <span class="keyword">if</span>(max &lt; num[right])&#123;</span><br><span class="line">                    max = num[right];</span><br><span class="line">                    index = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//过期后，重新在窗口内循环遍历，更新最大值</span></span><br><span class="line">                <span class="comment">//初始定在窗口最左边的元素</span></span><br><span class="line">                max = num[left];</span><br><span class="line">                index = left;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i &lt;= right; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(max&lt;num[i])&#123;</span><br><span class="line">                        max = num[i];</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><h2 id="问题描述-27"><a href="#问题描述-27" class="headerlink" title="问题描述"></a>问题描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。   </p>
<p>例如：</p>
<script type="math/tex; mode=display">\begin{bmatrix}a & b & c & e\\\\s & f & c & s\\\\a & d & e & e\end{bmatrix}</script><p>矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M 热度指数：342994<br>本题知识点：<code>回溯法</code></p>
<h2 id="解题思路-64"><a href="#解题思路-64" class="headerlink" title="解题思路"></a>解题思路</h2><p>回溯法；</p>
<h2 id="算法描述-63"><a href="#算法描述-63" class="headerlink" title="算法描述"></a>算法描述</h2><p>找到个思路十分清晰的代码（来源：<a href="https://www.nowcoder.com/profile/7711710" target="_blank" rel="noopener">我去个地方啊</a>）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><h2 id="问题描述-28"><a href="#问题描述-28" class="headerlink" title="问题描述"></a>问题描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0,0) 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的<strong>数位之和</strong>大于 k 的格子。<br>例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 32M，其他语言64M<br>本题知识点： <code>数组</code> <code>回溯法</code></p>
<h2 id="解题思路-65"><a href="#解题思路-65" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题和上题是同一类型的题目，采用相同思路；</p>
<h2 id="算法描述-64"><a href="#算法描述-64" class="headerlink" title="算法描述"></a>算法描述</h2><p>这里也参照了同一人的代码，加上注释（来源：<a href="https://www.nowcoder.com/profile/7711710" target="_blank" rel="noopener">我去个地方啊</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];  <span class="comment">//存储某个位置的格子能否到达，避免递归中重复检查某个位置导致死循环</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断，judge(索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，给定的最大数位和，存储该位置能否进入的矩阵)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> threshold,<span class="keyword">boolean</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || flag[i][j]==<span class="keyword">true</span> || getK(i)+getK(j) &gt; threshold)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上述条件的位置就说明可以到达，置标志位</span></span><br><span class="line">        flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//从当前位置递归继续向其余四个方向查找，并因为当前位置可达，总格子数+1</span></span><br><span class="line">        <span class="keyword">return</span> judge(i+<span class="number">1</span>,j,rows,cols,threshold,flag) +</span><br><span class="line">                 judge(i-<span class="number">1</span>,j,rows,cols,threshold,flag) +</span><br><span class="line">                    judge(i,j+<span class="number">1</span>,rows,cols,threshold,flag) +</span><br><span class="line">                        judge(i,j-<span class="number">1</span>,rows,cols,threshold,flag) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求每个位置行坐标和列坐标的数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>((num=num/<span class="number">10</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><h2 id="问题描述-29"><a href="#问题描述-29" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n 都是整数，n&gt;1 并且 m&gt;1），每段绳子的长度记为 $k[0],k[1],…,k[m]$。请问 $k[0] \times k[1] \times…\times k[m]$ 可能的最大乘积是多少？<br>例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。    </p>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 64M，其他语言128M<br>本题知识点： <code>贪心</code></p>
<h2 id="解题思路-66"><a href="#解题思路-66" class="headerlink" title="解题思路"></a>解题思路</h2><p>最后一题了，看到这题，哈哈，想着就充分的利用下自己的数学优势吧！<br>完全数学分析解法，详细分析过程：<br><img src="http://img.thebetterkong.cn/blog/Finger-offer67/Cutshengzi.png" alt="Cutshengzi"></p>
<p>结论：尽量将绳子剪的只有 2 和 3 这两种长度，并且尽量保证 3 的个数更多。</p>
<h2 id="算法描述-65"><a href="#算法描述-65" class="headerlink" title="算法描述"></a>算法描述</h2><p>基于 <code>java</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> x = target % <span class="number">3</span>; </span><br><span class="line">        <span class="keyword">int</span> y = target / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)  <span class="comment">//刚好能被全部剪成3的长度</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="comment">//全部按照3的长度，最后剩下了一个1，需要把3少算一段，变成两个2长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * <span class="number">2</span> * (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//最后刚好剩一个2长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他解法，基于 <code>python</code>：</p>
<ol>
<li><p>递归解法：</p>
<ul>
<li>我们先定义函数 f(n) 为把绳子剪成若干段之后的各段长度乘积的最大值。在剪第一刀的时候，我们会有 n-1 种可能的选择，也就是说剪出来的第一段绳子的长度可能为 1,2,……n-1。因此就有了递归公式 f(n) = max(f(i)*f(n-i))，其中 0 &lt; i &lt; n 。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###链接：https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion</span></span><br><span class="line"><span class="comment">###来源：牛客网</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#递归写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>       </span><br><span class="line">    <span class="keyword">return</span> self.cutRopeCore(number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRopeCore</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> number</span><br><span class="line">    max_ = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number/<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        max_ = max(self.cutRopeCore(i) * self.cutRopeCore(number - i), max_)</span><br><span class="line">    <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>动态规划：</p>
<ul>
<li>接着上面的递归解法我们可以将其转换成动态规划的写法。由于这是一个从上至下的递归公式，递归会出现很多大量不必要的计算，一个很好的方法就是按照从下而上的顺序计算，即:</li>
<li>我们先得到 f(2),f(3)，再得到 f(4),f(5)，直到 f(n)。</li>
<li>我们可以得知 f(2)=1, f(3)=2<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###链接：https://www.nowcoder.com/questionTerminal/57d85990ba5b440ab888fc72b0751bf8?answerType=1&amp;f=discussion</span></span><br><span class="line"><span class="comment">###来源：牛客网</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="comment"># write code here</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>       </span><br><span class="line">    <span class="comment">#申请辅助空间</span></span><br><span class="line">    products = [<span class="number">0</span>]*(number+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#定义前几个初始变量的值</span></span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">    <span class="comment">#进行动态规划,也就是从下向上的进行求解</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, number+<span class="number">1</span>):</span><br><span class="line">        max_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i/<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">            max_ = max(products[j]*products[i-j], max_)</span><br><span class="line">        products[i] = max_</span><br><span class="line"></span><br><span class="line">    max_ = products[number]</span><br><span class="line">    <span class="keyword">return</span> max_</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>从 2010-04-05 到 2010-05-09 历时三十多天，利用闲暇时间完成了《剑指offer》的一刷，这个过程中明显感觉到自己在一些数据结构和 java 知识点的掌握上有所不足。    </p>
<p>下一阶段，会对这段时间来的刷题进行一波沉淀，准备好好总结算法中的一些数据结构、常用算法和一些解题思路。并再对 java 知识点进行一波查漏补缺。看后面这段时间的课程安排吧，初步打算在两周时间左右完成。    </p>
<p>然后就要进军 LeetCode 了，待 LeetCode 刷完 100 题后，再回来对《剑指offer》进行二刷。这就是目前的计划安排了。    </p>
<div align="center"><span style="background-color:black; color:#FF0000;font-size:24px;"> Let's fight！</span></div>]]></content>
      <categories>
        <category>DataStructure &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Algorithm</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
